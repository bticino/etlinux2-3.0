diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/cgi-bin/printenv apache_1.3.33/cgi-bin/printenv
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/cgi-bin/printenv	Wed Nov 24 19:10:58 1999
+++ apache_1.3.33/cgi-bin/printenv	Mon Jul 18 15:22:19 2005
@@ -1,4 +1,4 @@
-#!/usr/local/bin/perl
+#!/usr/bin/perl
 ##
 ##  printenv -- demo CGI program which just prints its environment
 ##
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/conf/mime.types apache_1.3.33/conf/mime.types
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/conf/mime.types	Thu Jul 15 21:34:07 2004
+++ apache_1.3.33/conf/mime.types	Mon Jul 18 15:22:18 2005
@@ -346,14 +346,12 @@
 application/x-bcpio		bcpio
 application/x-cdlink		vcd
 application/x-chess-pgn		pgn
-application/x-compress
 application/x-cpio		cpio
 application/x-csh		csh
 application/x-director		dcr dir dxr
 application/x-dvi		dvi
 application/x-futuresplash	spl
 application/x-gtar		gtar
-application/x-gzip
 application/x-hdf		hdf
 application/x-javascript	js
 application/x-koan		skp skd skt skm
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/conf/mime.types.orig apache_1.3.33/conf/mime.types.orig
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/conf/mime.types.orig	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/conf/mime.types.orig	Thu Jul 15 21:34:07 2004
@@ -0,0 +1,592 @@
+# This is a comment. I love comments.
+
+# This file controls what Internet media types are sent to the client for
+# given file extension(s).  Sending the correct media type to the client
+# is important so they know how to handle the content of the file.
+# Extra types can either be added here or by using an AddType directive
+# in your config files. For more information about Internet media types,
+# please read RFC 2045, 2046, 2047, 2048, and 2077.  The Internet media type
+# registry is at <http://www.iana.org/assignments/media-types/>.
+
+# MIME type			Extensions
+application/activemessage
+application/andrew-inset	ez
+application/applefile
+application/atom+xml		atom
+application/atomicmail
+application/batch-smtp
+application/beep+xml
+application/cals-1840
+application/cnrp+xml
+application/commonground
+application/cpl+xml
+application/cybercash
+application/dca-rft
+application/dec-dx
+application/dvcs
+application/edi-consent
+application/edifact
+application/edi-x12
+application/eshop
+application/font-tdpfr
+application/http
+application/hyperstudio
+application/iges
+application/index
+application/index.cmd
+application/index.obj
+application/index.response
+application/index.vnd
+application/iotp
+application/ipp
+application/isup
+application/mac-binhex40	hqx
+application/mac-compactpro	cpt
+application/macwriteii
+application/marc
+application/mathematica
+application/mathml+xml		mathml
+application/msword		doc
+application/news-message-id
+application/news-transmission
+application/ocsp-request
+application/ocsp-response
+application/octet-stream	bin dms lha lzh exe class so dll dmg
+application/oda			oda
+application/ogg			ogg
+application/parityfec
+application/pdf			pdf
+application/pgp-encrypted
+application/pgp-keys
+application/pgp-signature
+application/pkcs10
+application/pkcs7-mime
+application/pkcs7-signature
+application/pkix-cert
+application/pkix-crl
+application/pkixcmp
+application/postscript		ai eps ps
+application/prs.alvestrand.titrax-sheet
+application/prs.cww
+application/prs.nprend
+application/prs.plucker
+application/qsig
+application/rdf+xml		rdf
+application/reginfo+xml
+application/remote-printing
+application/riscos
+application/rtf
+application/sdp
+application/set-payment
+application/set-payment-initiation
+application/set-registration
+application/set-registration-initiation
+application/sgml
+application/sgml-open-catalog
+application/sieve
+application/slate
+application/smil		smi smil
+application/srgs		gram
+application/srgs+xml		grxml
+application/timestamp-query
+application/timestamp-reply
+application/tve-trigger
+application/vemmi
+application/vnd.3gpp.pic-bw-large
+application/vnd.3gpp.pic-bw-small
+application/vnd.3gpp.pic-bw-var
+application/vnd.3gpp.sms
+application/vnd.3m.post-it-notes
+application/vnd.accpac.simply.aso
+application/vnd.accpac.simply.imp
+application/vnd.acucobol
+application/vnd.acucorp
+application/vnd.adobe.xfdf
+application/vnd.aether.imp
+application/vnd.amiga.ami
+application/vnd.anser-web-certificate-issue-initiation
+application/vnd.anser-web-funds-transfer-initiation
+application/vnd.audiograph
+application/vnd.blueice.multipass
+application/vnd.bmi
+application/vnd.businessobjects
+application/vnd.canon-cpdl
+application/vnd.canon-lips
+application/vnd.cinderella
+application/vnd.claymore
+application/vnd.commerce-battelle
+application/vnd.commonspace
+application/vnd.contact.cmsg
+application/vnd.cosmocaller
+application/vnd.criticaltools.wbs+xml
+application/vnd.ctc-posml
+application/vnd.cups-postscript
+application/vnd.cups-raster
+application/vnd.cups-raw
+application/vnd.curl
+application/vnd.cybank
+application/vnd.data-vision.rdz
+application/vnd.dna
+application/vnd.dpgraph
+application/vnd.dreamfactory
+application/vnd.dxr
+application/vnd.ecdis-update
+application/vnd.ecowin.chart
+application/vnd.ecowin.filerequest
+application/vnd.ecowin.fileupdate
+application/vnd.ecowin.series
+application/vnd.ecowin.seriesrequest
+application/vnd.ecowin.seriesupdate
+application/vnd.enliven
+application/vnd.epson.esf
+application/vnd.epson.msf
+application/vnd.epson.quickanime
+application/vnd.epson.salt
+application/vnd.epson.ssf
+application/vnd.ericsson.quickcall
+application/vnd.eudora.data
+application/vnd.fdf
+application/vnd.ffsns
+application/vnd.fints
+application/vnd.flographit
+application/vnd.framemaker
+application/vnd.fsc.weblaunch
+application/vnd.fujitsu.oasys
+application/vnd.fujitsu.oasys2
+application/vnd.fujitsu.oasys3
+application/vnd.fujitsu.oasysgp
+application/vnd.fujitsu.oasysprs
+application/vnd.fujixerox.ddd
+application/vnd.fujixerox.docuworks
+application/vnd.fujixerox.docuworks.binder
+application/vnd.fut-misnet
+application/vnd.grafeq
+application/vnd.groove-account
+application/vnd.groove-help
+application/vnd.groove-identity-message
+application/vnd.groove-injector
+application/vnd.groove-tool-message
+application/vnd.groove-tool-template
+application/vnd.groove-vcard
+application/vnd.hbci
+application/vnd.hhe.lesson-player
+application/vnd.hp-hpgl
+application/vnd.hp-hpid
+application/vnd.hp-hps
+application/vnd.hp-pcl
+application/vnd.hp-pclxl
+application/vnd.httphone
+application/vnd.hzn-3d-crossword
+application/vnd.ibm.afplinedata
+application/vnd.ibm.electronic-media
+application/vnd.ibm.minipay
+application/vnd.ibm.modcap
+application/vnd.ibm.rights-management
+application/vnd.ibm.secure-container
+application/vnd.informix-visionary
+application/vnd.intercon.formnet
+application/vnd.intertrust.digibox
+application/vnd.intertrust.nncp
+application/vnd.intu.qbo
+application/vnd.intu.qfx
+application/vnd.irepository.package+xml
+application/vnd.is-xpr
+application/vnd.japannet-directory-service
+application/vnd.japannet-jpnstore-wakeup
+application/vnd.japannet-payment-wakeup
+application/vnd.japannet-registration
+application/vnd.japannet-registration-wakeup
+application/vnd.japannet-setstore-wakeup
+application/vnd.japannet-verification
+application/vnd.japannet-verification-wakeup
+application/vnd.jisp
+application/vnd.kde.karbon
+application/vnd.kde.kchart
+application/vnd.kde.kformula
+application/vnd.kde.kivio
+application/vnd.kde.kontour
+application/vnd.kde.kpresenter
+application/vnd.kde.kspread
+application/vnd.kde.kword
+application/vnd.kenameaapp
+application/vnd.koan
+application/vnd.liberty-request+xml
+application/vnd.llamagraphics.life-balance.desktop
+application/vnd.llamagraphics.life-balance.exchange+xml
+application/vnd.lotus-1-2-3
+application/vnd.lotus-approach
+application/vnd.lotus-freelance
+application/vnd.lotus-notes
+application/vnd.lotus-organizer
+application/vnd.lotus-screencam
+application/vnd.lotus-wordpro
+application/vnd.mcd
+application/vnd.mediastation.cdkey
+application/vnd.meridian-slingshot
+application/vnd.micrografx.flo
+application/vnd.micrografx.igx
+application/vnd.mif		mif
+application/vnd.minisoft-hp3000-save
+application/vnd.mitsubishi.misty-guard.trustweb
+application/vnd.mobius.daf
+application/vnd.mobius.dis
+application/vnd.mobius.mbk
+application/vnd.mobius.mqy
+application/vnd.mobius.msl
+application/vnd.mobius.plc
+application/vnd.mobius.txf
+application/vnd.mophun.application
+application/vnd.mophun.certificate
+application/vnd.motorola.flexsuite
+application/vnd.motorola.flexsuite.adsi
+application/vnd.motorola.flexsuite.fis
+application/vnd.motorola.flexsuite.gotap
+application/vnd.motorola.flexsuite.kmr
+application/vnd.motorola.flexsuite.ttc
+application/vnd.motorola.flexsuite.wem
+application/vnd.mozilla.xul+xml	xul
+application/vnd.ms-artgalry
+application/vnd.ms-asf
+application/vnd.ms-excel	xls
+application/vnd.ms-lrm
+application/vnd.ms-powerpoint	ppt
+application/vnd.ms-project
+application/vnd.ms-tnef
+application/vnd.ms-works
+application/vnd.ms-wpl
+application/vnd.mseq
+application/vnd.msign
+application/vnd.music-niff
+application/vnd.musician
+application/vnd.netfpx
+application/vnd.noblenet-directory
+application/vnd.noblenet-sealer
+application/vnd.noblenet-web
+application/vnd.novadigm.edm
+application/vnd.novadigm.edx
+application/vnd.novadigm.ext
+application/vnd.obn
+application/vnd.osa.netdeploy
+application/vnd.palm
+application/vnd.pg.format
+application/vnd.pg.osasli
+application/vnd.powerbuilder6
+application/vnd.powerbuilder6-s
+application/vnd.powerbuilder7
+application/vnd.powerbuilder7-s
+application/vnd.powerbuilder75
+application/vnd.powerbuilder75-s
+application/vnd.previewsystems.box
+application/vnd.publishare-delta-tree
+application/vnd.pvi.ptid1
+application/vnd.pwg-multiplexed
+application/vnd.pwg-xhtml-print+xml
+application/vnd.quark.quarkxpress
+application/vnd.rapid
+application/vnd.rn-realmedia	rm
+application/vnd.s3sms
+application/vnd.sealed.net
+application/vnd.seemail
+application/vnd.shana.informed.formdata
+application/vnd.shana.informed.formtemplate
+application/vnd.shana.informed.interchange
+application/vnd.shana.informed.package
+application/vnd.smaf
+application/vnd.sss-cod
+application/vnd.sss-dtf
+application/vnd.sss-ntf
+application/vnd.street-stream
+application/vnd.svd
+application/vnd.swiftview-ics
+application/vnd.triscape.mxs
+application/vnd.trueapp
+application/vnd.truedoc
+application/vnd.ufdl
+application/vnd.uplanet.alert
+application/vnd.uplanet.alert-wbxml
+application/vnd.uplanet.bearer-choice
+application/vnd.uplanet.bearer-choice-wbxml
+application/vnd.uplanet.cacheop
+application/vnd.uplanet.cacheop-wbxml
+application/vnd.uplanet.channel
+application/vnd.uplanet.channel-wbxml
+application/vnd.uplanet.list
+application/vnd.uplanet.list-wbxml
+application/vnd.uplanet.listcmd
+application/vnd.uplanet.listcmd-wbxml
+application/vnd.uplanet.signal
+application/vnd.vcx
+application/vnd.vectorworks
+application/vnd.vidsoft.vidconference
+application/vnd.visio
+application/vnd.visionary
+application/vnd.vividence.scriptfile
+application/vnd.vsf
+application/vnd.wap.sic
+application/vnd.wap.slc
+application/vnd.wap.wbxml	wbxml
+application/vnd.wap.wmlc	wmlc
+application/vnd.wap.wmlscriptc	wmlsc
+application/vnd.webturbo
+application/vnd.wrq-hp3000-labelled
+application/vnd.wt.stf
+application/vnd.wv.csp+wbxml
+application/vnd.xara
+application/vnd.xfdl
+application/vnd.yamaha.hv-dic
+application/vnd.yamaha.hv-script
+application/vnd.yamaha.hv-voice
+application/vnd.yellowriver-custom-menu
+application/voicexml+xml	vxml
+application/watcherinfo+xml
+application/whoispp-query
+application/whoispp-response
+application/wita
+application/wordperfect5.1
+application/x-bcpio		bcpio
+application/x-cdlink		vcd
+application/x-chess-pgn		pgn
+application/x-compress
+application/x-cpio		cpio
+application/x-csh		csh
+application/x-director		dcr dir dxr
+application/x-dvi		dvi
+application/x-futuresplash	spl
+application/x-gtar		gtar
+application/x-gzip
+application/x-hdf		hdf
+application/x-javascript	js
+application/x-koan		skp skd skt skm
+application/x-latex		latex
+application/x-netcdf		nc cdf
+application/x-sh		sh
+application/x-shar		shar
+application/x-shockwave-flash	swf
+application/x-stuffit		sit
+application/x-sv4cpio		sv4cpio
+application/x-sv4crc		sv4crc
+application/x-tar		tar
+application/x-tcl		tcl
+application/x-tex		tex
+application/x-texinfo		texinfo texi
+application/x-troff		t tr roff
+application/x-troff-man		man
+application/x-troff-me		me
+application/x-troff-ms		ms
+application/x-ustar		ustar
+application/x-wais-source	src
+application/x400-bp
+application/xhtml+xml		xhtml xht
+application/xslt+xml		xslt
+application/xml			xml xsl
+application/xml-dtd		dtd
+application/xml-external-parsed-entity
+application/zip			zip
+audio/32kadpcm
+audio/amr
+audio/amr-wb
+audio/basic			au snd
+audio/cn
+audio/dat12
+audio/dsr-es201108
+audio/dvi4
+audio/evrc
+audio/evrc0
+audio/g722
+audio/g.722.1
+audio/g723
+audio/g726-16
+audio/g726-24
+audio/g726-32
+audio/g726-40
+audio/g728
+audio/g729
+audio/g729D
+audio/g729E
+audio/gsm
+audio/gsm-efr
+audio/l8
+audio/l16
+audio/l20
+audio/l24
+audio/lpc
+audio/midi			mid midi kar
+audio/mpa
+audio/mpa-robust
+audio/mp4a-latm
+audio/mpeg			mpga mp2 mp3
+audio/parityfec
+audio/pcma
+audio/pcmu
+audio/prs.sid
+audio/qcelp
+audio/red
+audio/smv
+audio/smv0
+audio/telephone-event
+audio/tone
+audio/vdvi
+audio/vnd.3gpp.iufp
+audio/vnd.cisco.nse
+audio/vnd.cns.anp1
+audio/vnd.cns.inf1
+audio/vnd.digital-winds
+audio/vnd.everad.plj
+audio/vnd.lucent.voice
+audio/vnd.nortel.vbk
+audio/vnd.nuera.ecelp4800
+audio/vnd.nuera.ecelp7470
+audio/vnd.nuera.ecelp9600
+audio/vnd.octel.sbc
+audio/vnd.qcelp
+audio/vnd.rhetorex.32kadpcm
+audio/vnd.vmx.cvsd
+audio/x-aiff			aif aiff aifc
+audio/x-alaw-basic
+audio/x-mpegurl			m3u
+audio/x-pn-realaudio		ram ra
+audio/x-pn-realaudio-plugin
+audio/x-wav			wav
+chemical/x-pdb			pdb
+chemical/x-xyz			xyz
+image/bmp			bmp
+image/cgm			cgm
+image/g3fax
+image/gif			gif
+image/ief			ief
+image/jpeg			jpeg jpg jpe
+image/naplps
+image/png			png
+image/prs.btif
+image/prs.pti
+image/svg+xml			svg
+image/t38
+image/tiff			tiff tif
+image/tiff-fx
+image/vnd.cns.inf2
+image/vnd.djvu			djvu djv
+image/vnd.dwg
+image/vnd.dxf
+image/vnd.fastbidsheet
+image/vnd.fpx
+image/vnd.fst
+image/vnd.fujixerox.edmics-mmr
+image/vnd.fujixerox.edmics-rlc
+image/vnd.globalgraphics.pgb
+image/vnd.mix
+image/vnd.ms-modi
+image/vnd.net-fpx
+image/vnd.svf
+image/vnd.wap.wbmp		wbmp
+image/vnd.xiff
+image/x-cmu-raster		ras
+image/x-icon			ico
+image/x-portable-anymap		pnm
+image/x-portable-bitmap		pbm
+image/x-portable-graymap	pgm
+image/x-portable-pixmap		ppm
+image/x-rgb			rgb
+image/x-xbitmap			xbm
+image/x-xpixmap			xpm
+image/x-xwindowdump		xwd
+message/delivery-status
+message/disposition-notification
+message/external-body
+message/http
+message/news
+message/partial
+message/rfc822
+message/s-http
+message/sip
+message/sipfrag
+model/iges			igs iges
+model/mesh			msh mesh silo
+model/vnd.dwf
+model/vnd.flatland.3dml
+model/vnd.gdl
+model/vnd.gs-gdl
+model/vnd.gtw
+model/vnd.mts
+model/vnd.parasolid.transmit.binary
+model/vnd.parasolid.transmit.text
+model/vnd.vtu
+model/vrml			wrl vrml
+multipart/alternative
+multipart/appledouble
+multipart/byteranges
+multipart/digest
+multipart/encrypted
+multipart/form-data
+multipart/header-set
+multipart/mixed
+multipart/parallel
+multipart/related
+multipart/report
+multipart/signed
+multipart/voice-message
+text/calendar			ics ifb
+text/css			css
+text/directory
+text/enriched
+text/html			html htm
+text/parityfec
+text/plain			asc txt
+text/prs.lines.tag
+text/rfc822-headers
+text/richtext			rtx
+text/rtf			rtf
+text/sgml			sgml sgm
+text/t140
+text/tab-separated-values	tsv
+text/uri-list
+text/vnd.abc
+text/vnd.curl
+text/vnd.dmclientscript
+text/vnd.fly
+text/vnd.fmi.flexstor
+text/vnd.in3d.3dml
+text/vnd.in3d.spot
+text/vnd.iptc.nitf
+text/vnd.iptc.newsml
+text/vnd.latex-z
+text/vnd.motorola.reflex
+text/vnd.ms-mediapackage
+text/vnd.net2phone.commcenter.command
+text/vnd.sun.j2me.app-descriptor
+text/vnd.wap.si
+text/vnd.wap.sl
+text/vnd.wap.wml		wml
+text/vnd.wap.wmlscript		wmls
+text/x-setext			etx
+text/xml
+text/xml-external-parsed-entity
+video/bmpeg
+video/bt656
+video/celb
+video/dv
+video/h261
+video/h263
+video/h263-1998
+video/h263-2000
+video/jpeg
+video/mp1s
+video/mp2p
+video/mp2t
+video/mp4v-es
+video/mpv
+video/mpeg			mpeg mpg mpe
+video/nv
+video/parityfec
+video/pointer
+video/quicktime			qt mov
+video/smpte292m
+video/vnd.fvt
+video/vnd.motorola.video
+video/vnd.motorola.videop
+video/vnd.mpegurl		mxu m4u
+video/vnd.nokia.interleaved-multimedia
+video/vnd.objectvideo
+video/vnd.vivo
+video/x-msvideo			avi
+video/x-sgi-movie		movie
+x-conference/x-cooltalk		ice
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/config.layout apache_1.3.33/config.layout
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/config.layout	Thu May 16 18:32:31 2002
+++ apache_1.3.33/config.layout	Mon Jul 18 15:22:19 2005
@@ -304,3 +304,23 @@
     proxycachedir: $localstatedir/cache/apache
 </Layout>
 
+#   Debian GNU policy conforming path layout.
+<Layout Debian>
+    prefix:        /usr
+    exec_prefix:   $prefix
+    bindir:        $prefix/bin
+    sbindir:       $prefix/lib+
+    libexecdir:    $prefix/libexec
+    mandir:        $prefix/share/man
+    sysconfdir:    /etc+
+    datadir:       $prefix/lib
+    iconsdir:      $prefix/share/apache/icons
+    htdocsdir:     $datadir/htdocs
+    cgidir:        $datadir/cgi-bin
+    includedir:    $prefix/include+
+    localstatedir: /var
+    runtimedir:    $localstatedir/run
+    logfiledir:    $localstatedir/log+
+    proxycachedir: $localstatedir/cache+
+</Layout>
+
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/configure apache_1.3.33/configure
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/configure	Fri Feb 20 23:40:50 2004
+++ apache_1.3.33/configure	Mon Jul 18 15:22:52 2005
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!/bin/bash
 #
 # Copyright 1999-2004 The Apache Software Foundation
 #
@@ -77,7 +77,7 @@
 ##  determine platform id
 ##
 PLATFORM="`$aux/GuessOS`"
-
+echo PLATFORM=$PLATFORM
 ##
 ##  display version information
 ##
@@ -1056,7 +1056,7 @@
 ##  target name
 ##
 if [ "x$TARGET" != "x" ]; then
-    thetarget="$TARGET"
+    thetarget=apache
 else
     thetarget=httpd
 fi
@@ -1291,7 +1291,9 @@
 -e "s%@install_support@%$install_support%g" \
 -e "s%@clean_support@%$clean_support%g" \
 -e "s%@distclean_support@%$distclean_support%g" \
--e "s%@SHELL@%$SHELL%g"
+-e "s%@SHELL@%$SHELL%g" \
+-e "s%@HOSTCC@%$HOSTCC%g" \
+-e "s%@HOSTC_FLAGS@%$HOSTC_FLAGS%g"
 
 ##
 ##  override default paths in $src/include/httpd.h
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/ApacheCore.def apache_1.3.33/src/ApacheCore.def
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/ApacheCore.def	Thu Apr 15 17:51:51 2004
+++ apache_1.3.33/src/ApacheCore.def	Mon Jul 18 15:22:25 2005
@@ -448,3 +448,67 @@
         ap_get_chunk_size @440
         ap_escape_logitem @441
         ap_auth_nonce @442
+	
+	; EAPI extended symbols
+	; note; no ID's, so these all bind by name rather than ordinal since 
+	; their ordinals would change with symbol changes in the distribution
+	ap_add_config_define
+	ap_global_ctx  DATA
+	ap_ctx_new
+	ap_ctx_get
+	ap_ctx_overlay
+	ap_ctx_set
+	ap_hook_init
+	ap_hook_kill
+	ap_hook_configure
+	ap_hook_register_I
+	ap_hook_unregister_I
+	ap_hook_status
+	ap_hook_use
+	ap_hook_call
+	ap_set_callback_and_alarm
+	ap_acquire_pool
+	ap_make_shared_sub_pool
+	ap_release_pool
+	ap_mm_useable
+	ap_MM_create
+	ap_MM_permission
+	ap_MM_destroy
+	ap_MM_lock
+	ap_MM_unlock
+	ap_MM_malloc
+	ap_MM_realloc
+	ap_MM_free
+	ap_MM_calloc
+	ap_MM_strdup
+	ap_MM_sizeof
+	ap_MM_maxsize
+	ap_MM_available
+	ap_MM_error
+	ap_mm_create
+	ap_mm_permission
+	ap_mm_destroy
+	ap_mm_lock
+	ap_mm_unlock
+	ap_mm_malloc
+	ap_mm_realloc
+	ap_mm_free
+	ap_mm_calloc
+	ap_mm_strdup
+	ap_mm_sizeof
+	ap_mm_maxsize
+	ap_mm_available
+	ap_mm_error
+	ap_mm_display_info
+	ap_mm_core_create
+	ap_mm_core_permission
+	ap_mm_core_delete
+	ap_mm_core_size
+	ap_mm_core_lock
+	ap_mm_core_unlock
+	ap_mm_core_align2page
+	ap_mm_core_align2word
+	ap_mm_lib_error_set
+	ap_mm_lib_error_get
+	ap_mm_lib_version
+
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/Configuration.tmpl apache_1.3.33/src/Configuration.tmpl
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/Configuration.tmpl	Wed Dec 31 12:58:21 2003
+++ apache_1.3.33/src/Configuration.tmpl	Mon Jul 18 15:22:25 2005
@@ -68,6 +68,24 @@
 #TARGET=
 
 ################################################################
+# Extended API (EAPI) support:
+#
+# EAPI:
+#   The EAPI rule enables more module hooks, a generic low-level hook
+#   mechanism, a generic context mechanism and shared memory based pools. 
+#
+# EAPI_MM:
+#   Set the EAPI_MM variable to either the directory of a MM Shared Memory
+#   Library source tree or the installation tree of MM. Alternatively you can
+#   also use the value 'SYSTEM' which then indicates that MM is installed
+#   under various system locations. When the MM library files cannot be found
+#   the EAPI still can be built, but without shared memory pool support, of
+#   course.
+
+Rule EAPI=no
+#EAPI_MM=SYSTEM
+
+################################################################
 # Dynamic Shared Object (DSO) support
 #
 # There is experimental support for compiling the Apache core and
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/Configure apache_1.3.33/src/Configure
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/Configure	Mon Oct 18 18:39:37 2004
+++ apache_1.3.33/src/Configure	Mon Jul 18 15:22:52 2005
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!/bin/bash
 #
 # Copyright 1999-2004 The Apache Software Foundation
 #
@@ -208,7 +208,7 @@
 ##
 DBM_LIB="-ldbm"
 DB_LIB="-ldb"
-SHELL="/bin/sh"
+SHELL="/bin/bash"
 SUBTARGET="target_static"
 SHLIB_SUFFIX_NAME=""
 SHLIB_SUFFIX_LIST=""
@@ -404,6 +404,14 @@
 	CFLAGS="$CFLAGS -DLINUX=20"
 	LIBS="$LIBS -lm"
 	;;
+    arm-whatever-linux22)
+	# Etlinux
+	# This handles linux 2.2 and above (2.4, ...)
+	DEF_WANTHSREGEX=yes
+	OS='Linux'
+	CFLAGS="$CFLAGS -DLINUX=22"
+	LIBS="$LIBS -lm -lcrypt -lc"
+	;;
     *-linux22)
         # This handles linux 2.2 and above (2.4, ...)
 	DEF_WANTHSREGEX=yes
@@ -1061,13 +1069,24 @@
 	    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
 	    LDFLAGS_SHLIB_EXPORT="-rdynamic"
 	    ;;
+	# Etlinux
+	arm-whatever-linux22)
+	    LD_SHLIB="gcc"
+            CFLAGS_SHLIB="-fPIC"
+            LDFLAGS_SHLIB="-shared"
+            LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+            LDFLAGS_SHLIB_EXPORT="-rdynamic"
+            SHLIB_SUFFIX_DEPTH=0
+	    LIBS_SHLIB="-lm -lcrypt -lc"
+	    ;;
 	*-linux2*)
 		LD_SHLIB="gcc"
-	    CFLAGS_SHLIB="-fpic"
+	    CFLAGS_SHLIB="-fPIC"
 	    LDFLAGS_SHLIB="-shared"
 	    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
 	    LDFLAGS_SHLIB_EXPORT="-rdynamic"
 	    SHLIB_SUFFIX_DEPTH=0
+	    LIBS="$LIBS -lpthread"
 	    ;;
 	*-freebsd2*)
 		LD_SHLIB="gcc"
@@ -1155,6 +1174,7 @@
 	    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
 	    LDFLAGS_SHLIB_EXPORT=""
 	    SHLIB_SUFFIX_DEPTH=0
+	    LIBS_SHLIB="-lm -lcrypt -lc"
 	    ;;
 	*-solaris2*)
 	    if [ "x`$CC -v 2>&1 | grep gcc`" != "x" ]; then
@@ -1865,6 +1885,72 @@
     SUBDIRS="regex $SUBDIRS"
     CFLAGS="$CFLAGS -DUSE_HSREGEX"
 fi
+
+####################################################################
+## Extended API (EAPI) support:
+##
+if [ "x$RULE_EAPI" = "x" ]; then
+    RULE_EAPI=`./helpers/CutRule EAPI $file`
+fi
+if [ "x$RULE_EAPI" = "xyes" ]; then
+    echo " + enabling Extended API (EAPI)"
+    CFLAGS="$CFLAGS -DEAPI"
+    #   some vendor compilers are too restrictive
+    #   for our ap_hook and ap_ctx sources.
+    case "$OS:$CC" in
+        *IRIX-32*:*/cc|*IRIX-32*:cc )
+            CFLAGS="$CFLAGS -woff 1048,1110,1164"
+            ;;
+    esac
+    #   MM Shared Memory Library support for EAPI
+    if [ "x$EAPI_MM" = "x" ]; then
+        EAPI_MM=`egrep '^EAPI_MM=' $file | sed -n -e '$p' | awk -F= '{print $2}'`
+    fi
+    if [ "x$EAPI_MM" != "x" ]; then
+        case $EAPI_MM in
+            SYSTEM|/* ) ;;
+            * ) for p in . .. ../..; do
+                    if [ -d "$p/$EAPI_MM" ]; then
+                        EAPI_MM="`echo $p/$EAPI_MM | sed -e 's;/\./;/;g'`" 
+                        break
+                    fi
+                done
+                ;;
+        esac
+        if [ "x$EAPI_MM" = "xSYSTEM" ]; then
+            echo "   using MM library for EAPI: (system-wide)"
+            CFLAGS="$CFLAGS -DEAPI_MM"
+            __INCLUDES="`mm-config --cflags`"
+            if [ "x$__INCLUDES" != "x-I/usr/include" ]; then
+                INCLUDES="$INCLUDES $__INCLUDES"
+            fi
+            LDFLAGS="$LDFLAGS `mm-config --ldflags`"
+            LIBS="$LIBS `mm-config --libs`"
+        else
+            if [ -f "$EAPI_MM/.libs/libmm.a" -a -f "$EAPI_MM/mm.h" ]; then
+                echo "   using MM library: $EAPI_MM (source-tree only)"
+                case $EAPI_MM in
+                    /* ) ;;
+                    *  ) EAPI_MM="\$(SRCDIR)/$EAPI_MM" ;;
+                esac
+                CFLAGS="$CFLAGS -DEAPI_MM"
+                INCLUDES="$INCLUDES -I$EAPI_MM"
+                LDFLAGS="$LDFLAGS -L$EAPI_MM/.libs"
+                LIBS="$LIBS -lmm"
+            elif [ -f "$EAPI_MM/bin/mm-config" ]; then
+                echo "   using MM library: $EAPI_MM (installed)"
+                CFLAGS="$CFLAGS -DEAPI_MM"
+                INCLUDES="$INCLUDES `$EAPI_MM/bin/mm-config --cflags`"
+                LDFLAGS="$LDFLAGS `$EAPI_MM/bin/mm-config --ldflags`"
+                LIBS="$LIBS `$EAPI_MM/bin/mm-config --libs`"
+            else
+                echo "Configure:Error: Cannot find MM library under $EAPI_MM" 1>&2
+                exit 1
+            fi
+        fi
+    fi
+fi
+
 
 ####################################################################
 ## Add in the Expat library if needed/wanted.
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/Configure.orig apache_1.3.33/src/Configure.orig
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/Configure.orig	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/Configure.orig	Mon Jul 18 15:22:25 2005
@@ -0,0 +1,2670 @@
+#!/bin/bash
+#
+# Copyright 1999-2004 The Apache Software Foundation
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+# Uses 6 supplemental scripts located in ./helpers:
+#	CutRule: Determines the value for a specified Rule
+#	GuessOS: Uses uname to determine OS/platform
+#	PrintPath: generic "type" or "whence" replacement
+#	TestCompile: Can check for libs and if $(CC) is ANSI
+#	 (i.e., a simple "sanity check")
+#	mfhead:
+#	fp2rp:
+#	slo.sh:
+
+LANG=C; export LANG
+exitcode=0
+trap 'rm -f $tmpfile $tmpfile2 $tmpfile3 $tmpconfig $awkfile; exit $exitcode' 0 1 2 3 15
+
+####################################################################
+## Set up some defaults
+##
+file=Configuration
+tmpfile=htconf.$$
+tmpfile2=$tmpfile.2
+tmpfile3=$tmpfile.3
+awkfile=$tmpfile.4
+tmpconfig=$tmpfile.5
+SUBDIRS="ap main"
+APLIBDIRS=""
+
+####################################################################
+## Now handle any arguments, which, for now, is -file
+## to select an alternate Configuration file and -v
+## to turn on verbose mode
+##
+while [ "x$1" != "x" ]; do
+  if [ "x$1" = "x-v" ] ; then
+    shift 1;
+    vflag="-v";
+  fi
+  if [ "x$1" = "x-file" ] ; then
+    shift 1; file=$1; shift 1
+    if [ ! -r $file ]; then
+      echo "$file does not exist or is not readable."
+      exitcode=1
+      exit 1
+    fi
+  else
+    echo "ERROR: Bad command line option '$1'"
+    echo "  Please read the file INSTALL."
+    exit 1
+  fi
+done
+if [ ! -r $file ]; then
+  echo "Can't see or read \"$file\""
+  echo "Please copy Configuration.tmpl to $file, edit it for your platform,"
+  echo "and re-run $0 again."
+  exitcode=1
+  exit 1
+fi
+
+####################################################################
+## Now see if Configuration.tmpl is more recent than $file. If
+## so, then we complain and bail out
+##
+if ls -lt $file Configuration.tmpl | head -1 | \
+  grep 'Configuration.tmpl' > /dev/null
+then
+  echo "Configuration.tmpl is more recent than $file;"
+  echo "Make sure that $file is valid and, if it is, simply"
+  echo "'touch $file' and re-run $0 again."
+  exitcode=1
+  exit 1
+fi
+
+echo "Using config file: $file"
+
+####################################################################
+## From the Configuration file, create a "cleaned-up" version
+## that's easy to scan
+##
+
+# Strip comments and blank lines, remove whitespace around
+# "=" assignments, change Rules to comments and then remove whitespace
+# before Module declarations
+sed 's/#.*//' $file | \
+ sed '/^[ 	]*$/d' | \
+ sed 's/[ 	]*$//' | \
+ sed 's/[ 	]*=[ 	]*/=/' | \
+ sed '/^Rule[ 	]*/d' | \
+ sed 's/^[ 	]*AddModule/AddModule/' | \
+ sed 's/^[ 	]*%AddModule/%AddModule/' | \
+ sed 's/^[ 	]*SharedModule/SharedModule/' | \
+ sed 's/^[ 	]*Module/Module/' | \
+ sed 's/^[ 	]*%Module/%Module/' > $tmpfile
+
+# Determine if shared objects are used
+using_shlib=`grep  '^SharedModule' $tmpfile >/dev/null && echo 1`
+
+# But perhaps later via apxs when just mod_so is compiled in!
+if [ "x$using_shlib" = "x" ]; then
+    using_shlib=`grep  '^AddModule modules/standard/mod_so.o' $tmpfile >/dev/null && echo 1`
+fi
+
+# Only "assignment" ("=") statements and Module lines
+# should be left at this point. If there is other stuff
+# we bail out
+if egrep -v '^%?Module[ 	]+[A-Za-z0-9_]+[ 	]+[^ 	]+$' $tmpfile \
+ | egrep -v '^%?AddModule[ 	]+[^ 	]+$' \
+ | egrep -v '^SharedModule[ 	]+[^ 	]+$' \
+ | grep -v = > /dev/null
+then
+  echo "Syntax error --- The configuration file is used only to"
+  echo "define the list of included modules or to set Makefile"
+  echo "options or Configure rules, and I don't see that at all:"
+  egrep -v '^%?Module[ 	]+[A-Za-z0-9_]+[ 	]+[^ 	]+$' $tmpfile \
+   | egrep -v '^%?AddModule[ 	]+[^ 	]+$'  \
+   | egrep -v '^%?SharedModule[ 	]+[^ 	]+$'  \
+   | grep -v =
+  exitcode=1
+  exit 1
+fi
+
+####################################################################
+## If we find the directory /usr/local/etc/httpd and there is
+## no HTTPD_ROOT flag set in the Configuration file we assume
+## that the user was using the old default root directory
+## and issue a notice about it.
+##
+if [ "x$file" != "xConfiguration.apaci" ]
+then
+  if [ -d /usr/local/etc/httpd/ ]
+  then
+    if egrep '^EXTRA_CFLAGS.*HTTPD_ROOT' $file >/dev/null
+    then
+      :
+    else
+      echo " | Please note that the default httpd root directory has changed"
+      echo " | from '/usr/local/etc/httpd/' to '/usr/local/apache/.'"
+      echo " | You may add '-DHTTPD_ROOT=\\\"/usr/local/etc/httpd\\\"' to EXTRA_CFLAGS"
+      echo " | in your Configuration file (and re-run Configure) or start"
+      echo " | httpd with the option '-d /usr/local/etc/httpd' if you still"
+      echo " | want to use the old root directory for your server."
+    fi
+  fi
+fi
+
+####################################################################
+## Start creating the Makefile. We add some comments and
+## then fold in the modules that were included in Configuration
+##
+echo "Creating Makefile"
+./helpers/mfhead . $file > Makefile
+
+####################################################################
+## Now we create a stub file, called Makefile.config, which
+## just includes those assignments (eg: CC=gcc) in Configuration
+##
+awk >Makefile.config <$tmpfile '
+    BEGIN {
+	print "##"
+	print "##  Inherited Makefile options from Configure script"
+	print "##  (Begin of automatically generated section)"
+	print "##"
+	print "SRCDIR=."
+    } 
+    /\=/ { print } 
+    '
+
+####################################################################
+## Extract the rules.
+##
+RULE_WANTHSREGEX=`./helpers/CutRule WANTHSREGEX $file`
+RULE_STATUS=`./helpers/CutRule STATUS $file`
+RULE_SOCKS4=`./helpers/CutRule SOCKS4 $file`
+RULE_SOCKS5=`./helpers/CutRule SOCKS5 $file`
+RULE_IRIXNIS=`./helpers/CutRule IRIXNIS $file`
+RULE_IRIXN32=`./helpers/CutRule IRIXN32 $file`
+RULE_PARANOID=`./helpers/CutRule PARANOID $file`
+RULE_EXPAT=`./helpers/CutRule EXPAT $file`
+RULE_CYGWIN_WINSOCK=`./helpers/CutRule CYGWIN_WINSOCK $file` 
+RULE_SHARED_CORE=`./helpers/CutRule SHARED_CORE $file`
+RULE_SHARED_CHAIN=`./helpers/CutRule SHARED_CHAIN $file`
+
+####################################################################
+## Rule SHARED_CORE implies required DSO support
+##
+if [ "x$RULE_SHARED_CORE" = "xyes" ]; then
+	using_shlib=1
+fi
+
+####################################################################
+## Preset some "constants";
+## can be overridden on a per-platform basis below.
+##
+DBM_LIB="-ldbm"
+DB_LIB="-ldb"
+SHELL="/bin/bash"
+SUBTARGET="target_static"
+SHLIB_SUFFIX_NAME=""
+SHLIB_SUFFIX_LIST=""
+CAT="cat"
+
+####################################################################
+## Now we determine the OS/Platform automagically, thanks to
+## GuessOS, a home-brewed OS-determiner ala config.guess
+##
+## We adjust CFLAGS, LIBS, LDFLAGS and INCLUDES (and other Makefile
+## options) as required. Setting CC and OPTIM here has no effect
+## if they were set in Configure.
+##
+## Also, we set DEF_WANTHSREGEX and to the appropriate
+## value for each platform.
+##
+## As more PLATFORMs are added to Configuration.tmpl, be sure to
+## add the required lines below.
+##
+PLAT=`./helpers/GuessOS`
+SHELL="/bin/sh"
+OSDIR="os/unix"
+
+case "$PLAT" in
+    *mint)
+	OS="MiNT"
+	CFLAGS="-DMINT"
+	LIBS="$LIBS -lportlib -lsocket"
+	DEF_WANTHSREGEX=yes
+	;;
+    *MPE/iX*)
+	export OS='MPE/iX'
+	OSDIR='os/mpeix'
+	CFLAGS="$CFLAGS -DMPE -D_POSIX_SOURCE -D_SOCKET_SOURCE"
+	LIBS="$LIBS -lsocket -lsvipc -lcurses"
+	LDFLAGS="$LDFLAGS -Xlinker \"-WL,cap=ia,ba,ph;nmstack=1024000\""
+	CAT="/bin/cat" # built-in cat is badly broken for stdin redirection
+	;;
+    *-apple-aux3*)
+	OS='A/UX 3.1.x'
+	CFLAGS="$CFLAGS -DAUX3 -D_POSIX_SOURCE"
+	LIBS="$LIBS -lposix -lbsd"
+	LDFLAGS="$LDFLAGS -s"
+	DEF_WANTHSREGEX=no
+	;;
+    i386-ibm-aix*)
+	OS='IBM AIX PS/2'
+	CFLAGS="$CFLAGS -DAIX=100 -U__STR__ -DUSEBCOPY"
+	DEF_WANTHSREGEX=no
+	;;
+    ia64-ibm-aix*)
+       OS='IBM AIX IA64'
+       CFLAGS="$CFLAGS -DAIXIA64 -U__STR__"
+       LDFLAGS="$LDFLAGS -lm"
+       RULE_SHARED_CORE=no
+       DEF_SHARED_CORE=no
+       ;;
+    *-ibm-aix[1-2].*)
+	OS='IBM AIX 1.x/2.x'
+	CFLAGS="$CFLAGS -DAIX=100 -DNEED_RLIM_T -U__STR__"
+	;;
+    *-ibm-aix3.*)
+	OS='IBM AIX 3.x'
+	CFLAGS="$CFLAGS -DAIX=300 -DNEED_RLIM_T -U__STR__"
+	;;
+    *-ibm-aix[45678].*)
+        PLATOSVERS=`echo $PLAT | sed 's/^.*ibm-aix//'`
+        OS="AIX $PLATOSVERS"
+        PLATOSVERSNUM=`echo $PLATOSVERS | sed 's/\.//'`
+        if test $PLATOSVERSNUM -ge 43; then
+            PLATOSVERSNUM=`oslevel | sed 's/\.//g' | sed 's/.$//'`
+        else
+            PLATOSVERSNUM="$PLATOSVERSNUM"0
+        fi
+        # PLATOSVERSNUM is a three digit number at this point
+        CFLAGS="$CFLAGS -DAIX=$PLATOSVERSNUM -U__STR__"
+        if test $PLATOSVERSNUM -lt 420; then
+            CFLAGS="$CFLAGS -DNEED_RLIM_T"
+        fi
+        if test $PLATOSVERSNUM -ge 420; then
+            LDFLAGS="$LDFLAGS -lm"
+        fi
+        if test $PLATOSVERSNUM -ge 430; then
+            LDFLAGS="$LDFLAGS -lpthread"
+            RULE_SHARED_CORE=no
+            DEF_SHARED_CORE=no
+        fi
+        ;;
+    *-ibm-aix*)
+	OS='IBM AIX'
+	CFLAGS="$CFLAGS -DAIX=100 -U__STR__"
+	LDFLAGS="$LDFLAGS -lm"
+	;;
+    *-apollo-*)
+	OS='Apollo Domain'
+	CFLAGS="$CFLAGS -DAPOLLO"
+	;;
+    *-dg-dgux*)
+	OS='DG/UX 5.4'
+	CFLAGS="$CFLAGS -DDGUX"
+	DEF_WANTHSREGEX=yes
+	;;
+    *OS/2*)
+	OSDIR="os/os2"
+	DEF_WANTHSREGEX=yes
+	OS='EMX OS/2'
+	CFLAGS="$CFLAGS -DOS2 -DTCPIPV4 -g -Zmt"
+	LDFLAGS="$LDFLAGS -Zexe -Zmtd -Zsysv-signals -Zbin-files"
+	LIBS="$LIBS -lsocket -lufc -lbsd"
+	DBM_LIB="-lgdbm"
+	SHELL=sh
+	;;
+    *-hi-hiux)
+	OS='HI-UX'
+	CFLAGS="$CFLAGS -DHIUX"
+	;;
+    *-hp*-hpux11.*)
+	OS='HP-UX 11'
+	CFLAGS="$CFLAGS -DHPUX11"
+	RANLIB="/bin/true"
+	LIBS="$LIBS -lm -lpthread"
+	DEF_WANTHSREGEX=yes
+	;;
+    *-hp*-hpux10.*)
+	OS='HP-UX 10'
+	CFLAGS="$CFLAGS -DHPUX10"
+	RANLIB="/bin/true"
+ 	case "$PLAT" in
+ 	  *-hp-hpux10.01)
+	       # We know this is a problem in 10.01.
+	       # Not a problem in 10.20.  Otherwise, who knows?
+	       CFLAGS="$CFLAGS -DSELECT_NEEDS_CAST"
+	       ;;	     
+ 	esac
+	DEF_WANTHSREGEX=yes
+	;;
+    *-hp*-hpux*)
+	OS='HP-UX'
+	CFLAGS="$CFLAGS -DHPUX"
+	RANLIB="/bin/true"
+	DEF_WANTHSREGEX=yes
+	LIBS="$LIBS -lm"
+	;;
+    *-sgi-irix64)
+	# Note: We'd like to see patches to compile 64-bit, but for now...
+	echo "You are running 64-bit Irix. For now, we will compile 32-bit"
+	echo "but if you would care to port to 64-bit, send us the patches."
+	DEF_WANTHSREGEX=yes
+	DBM_LIB=""
+	if [ "x$RULE_IRIXNIS" = "xyes" ]; then
+	    OS='SGI IRIX-64 w/NIS'
+	    CFLAGS="$CFLAGS -DIRIX"
+	    LIBS="$LIBS -lsun"
+	else
+	    OS='SGI IRIX-64'
+	    CFLAGS="$CFLAGS -DIRIX"
+	fi
+	;;
+    *-sgi-irix32)
+	DEF_WANTHSREGEX=yes
+	DBM_LIB=""
+	if [ "x$RULE_IRIXN32" = "xyes" ]; then
+	    if [ "x$RULE_IRIXNIS" = "xyes" ]; then
+		OS='SGI IRIX-32 w/NIS'
+	    else
+		OS='SGI IRIX-32'
+	    fi
+	else
+	    if [ "x$RULE_IRIXNIS" = "xyes" ]; then
+		OS='SGI IRIX w/NIS'
+	    else
+		OS='SGI IRIX'
+	    fi
+	fi
+	CC='cc'
+	CFLAGS="$CFLAGS -DIRIX"
+	;;
+    *-sgi-irix)
+	DEF_WANTHSREGEX=yes
+	DBM_LIB=""
+	if [ "x$RULE_IRIXNIS" = "xyes" ]; then
+	    OS='SGI IRIX w/NIS'
+	    CFLAGS="$CFLAGS -DIRIX"
+	    LIBS="$LIBS -lsun"
+	else
+	    OS='SGI IRIX'
+	    CFLAGS="$CFLAGS -DIRIX"
+	fi
+	;;
+    *-linux20)
+	DEF_WANTHSREGEX=yes
+	OS='Linux'
+	CFLAGS="$CFLAGS -DLINUX=20"
+	LIBS="$LIBS -lm"
+	;;
+    *-linux22)
+        # This handles linux 2.2 and above (2.4, ...)
+	DEF_WANTHSREGEX=yes
+	OS='Linux'
+	CFLAGS="$CFLAGS -DLINUX=22"
+	LIBS="$LIBS -lm"
+	;;
+    *-GNU*)
+	DEF_WANTHSREGEX=yes
+	OS='GNU/Hurd'
+	CFLAGS="$CFLAGS -DHURD"
+	LIBS="$LIBS -lm -lcrypt"
+	;;
+    *-linux1)
+	DEF_WANTHSREGEX=yes
+	OS='Linux'
+	CFLAGS="$CFLAGS -DLINUX=1"
+	;;
+    *-lynx-lynxos)
+	OS='LynxOS 2.x'
+	CFLAGS="$CFLAGS -D__NO_INCLUDE_WARN__ -DLYNXOS"
+	LIBS="$LIBS -lbsd -lcrypt"
+	DEF_WANTHSREGEX=yes
+	;;
+    *486-*-bsdi*)
+	OS='BSDI w/486'
+	CFLAGS="$CFLAGS -m486"
+	DBM_LIB=""
+	DB_LIB=""
+	;;
+    *-bsdi3)
+        if [ "x$using_shlib" = "x1" ] ; then
+            CC="shlicc2"
+        fi
+        ;;
+    *-bsdi*)
+	OS='BSDI'
+	DBM_LIB=""
+	DB_LIB=""
+	;;
+    *-netbsd*)
+	OS='NetBSD'
+	CFLAGS="$CFLAGS -DNETBSD"
+	LIBS="$LIBS -lcrypt"
+	DBM_LIB=""
+	DB_LIB=""
+	DEF_WANTHSREGEX=no
+	;;
+    *-freebsd*)
+    	PLATOSVERS=`echo $PLAT | sed 's/^.*freebsd//'`
+	OS="FreeBSD $PLATOSVERS"
+	case "$PLATOSVERS" in
+	    [2345]*)
+		DEF_WANTHSREGEX=no
+		CFLAGS="$CFLAGS -funsigned-char"
+		;;
+	esac
+	LIBS="$LIBS -lcrypt"
+	DBM_LIB=""
+	DB_LIB=""
+	;;
+    *-openbsd*)
+	OS='OpenBSD'
+	DBM_LIB=""
+	DB_LIB=""
+	DEF_WANTHSREGEX=no
+	;;
+    *-next-nextstep*)
+	OS='NeXTStep'
+	OPTIM='-O'
+	CFLAGS="$CFLAGS -DNEXT"
+	DEF_WANTHSREGEX=yes
+	;;
+    *-next-openstep*)
+	OS='OpenStep/Mach'
+	CC='cc'
+	OPTIM='-O'
+	CFLAGS="$CFLAGS -DNEXT"
+	DEF_WANTHSREGEX=yes
+	;;
+    *-apple-rhapsody*)
+	OS='Mac OS X Server'
+	CFLAGS="$CFLAGS -DDARWIN -DMAC_OS_X_SERVER"
+	DEF_WANTHSREGEX=yes
+	;;
+    *-apple-darwin*)
+	OS='Darwin'
+	CFLAGS="$CFLAGS -DDARWIN"
+	DEF_WANTHSREGEX=yes
+	;;
+    *-dec-osf*)
+	OS='DEC OSF/1'
+	CFLAGS="$CFLAGS -DOSF1"
+	LIBS="$LIBS -lm"
+	;;
+    *-qnx)
+	OS='QNX'
+	CFLAGS="$CFLAGS -DQNX"
+	LIBS="$LIBS -N128k -lsocket -lunix"
+	DEF_WANTHSREGEX=yes
+	;;
+    *-qnx32)
+        CC='cc -F'
+	OS='QNX32'
+	CFLAGS="$CFLAGS -DQNX -mf -3"
+	LIBS="$LIBS -N128k -lsocket -lunix"
+	DEF_WANTHSREGEX=yes
+	;;
+    *-isc4*)
+	OS='ISC 4'
+	CC='gcc'
+	CFLAGS="$CFLAGS -posix -DISC"
+	LDFLAGS="$LDFLAGS -posix"
+	LIBS="$LIBS -linet"
+	DEF_WANTHSREGEX=yes
+	;;
+    *-sco3*)
+	OS='SCO 3'
+	CFLAGS="$CFLAGS -DSCO -Oacgiltz"
+	LIBS="$LIBS -lPW -lsocket -lmalloc -lcrypt_i"
+	DEF_WANTHSREGEX=yes
+	;;
+    *-sco5*)
+	OS='SCO 5'
+	CFLAGS="$CFLAGS -DSCO5"
+	LIBS="$LIBS -lsocket -lmalloc -lprot -ltinfo -lx -lm"
+	DEF_WANTHSREGEX=no
+	;;
+    *-sco_sv*|*-SCO_SV*)
+	OS='SCO SV'
+	CFLAGS="$CFLAGS -DSCO"
+	LIBS="$LIBS -lPW -lsocket -lmalloc -lcrypt_i"
+	DEF_WANTHSREGEX=yes
+	;;
+    *-solaris2*)
+    	PLATOSVERS=`echo $PLAT | sed 's/^.*solaris2.//'`
+	OS="Solaris $PLATOSVERS"
+	CFLAGS="$CFLAGS -DSOLARIS2=$PLATOSVERS"
+	LIBS="$LIBS -lsocket -lnsl -lpthread"
+	DBM_LIB=""
+	case "$PLATOSVERS" in
+	    2[01234]*)
+		DEF_WANTHSREGEX=yes
+		;;
+	    *)
+		DEF_WANTHSREGEX=no
+		;;
+	esac
+	;;
+    *-sunos4*)
+	OS='SunOS 4'
+	CFLAGS="$CFLAGS -DSUNOS4 -DUSEBCOPY"
+	DEF_WANTHSREGEX=yes
+	;;
+    *-unixware1)
+	DEF_WANTHSREGEX=yes
+	OS='UnixWare 1.x'
+	CFLAGS="$CFLAGS -DUW=100"
+	LIBS="$LIBS -lsocket -lnsl -lcrypt"
+	;;
+    *-unixware2)
+	DEF_WANTHSREGEX=yes
+	OS='UnixWare 2.x'
+	CFLAGS="$CFLAGS -DUW=200"
+	LIBS="$LIBS -lsocket -lnsl -lcrypt -lgen"
+	;;
+    *-unixware211)
+	OS='UnixWare 2.1.1'
+	CFLAGS="$CFLAGS -DUW=211"
+	LIBS="$LIBS -lsocket -lnsl -lcrypt -lgen"
+	;;
+    *-unixware212)
+	OS='UnixWare 2.1.2'
+	CFLAGS="$CFLAGS -DUW=212"
+	LIBS="$LIBS -lsocket -lnsl -lcrypt -lgen"
+	DBM_LIB=""
+	;;
+    *-unixware7)
+	OS='UnixWare 7'
+	CFLAGS="$CFLAGS -DUW=700"
+	LIBS="$LIBS -lsocket -lnsl -lcrypt -lgen -lresolv"
+	DBM_LIB=""
+	;;
+    *-OpenUNIX)
+	OS='OpenUNIX'
+	CFLAGS="$CFLAGS -DUW=800"
+	LIBS="$LIBS -lsocket -lnsl -lcrypt -lgen -lresolv"
+	DBM_LIB=""
+	;;
+    maxion-*-sysv4*)
+    	OS='SVR4'
+	CFLAGS="$CFLAGS -DSVR4"
+	DEF_WANTHSREGEX=yes
+	LIBS="$LIBS -lsocket -lnsl -lc -lgen"
+	;;
+    *-*-powermax*)
+	OS='SVR4'
+	CFLAGS="$CFLAGS -DSVR4"
+	DEF_WANTHSREGEX=yes
+	LIBS="$LIBS -lsocket -lnsl -lgen"
+	LD_SHLIB='cc'
+	LDFLAGS_SHLIB="-Zlink=so"
+	LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+	LDFLAGS_SHLIB_EXPORT="-Zlink=dynamic -Wl,-Bexport"
+	CFLAGS_SHLIB='-Zpic'
+	;;
+    TPF)
+	OS='TPF'
+	OSDIR='os/tpf'
+	CC='c89'
+	CFLAGS="$CFLAGS -DTPF -DCHARSET_EBCDIC -D_POSIX_SOURCE"
+	if [ "x$TPF64BIT" = "xYES" ] ; then
+		DEF_WANTHSREGEX=no
+	else
+		DEF_WANTHSREGEX=yes
+	fi
+	LIBS="$LIBS"
+	SUBTARGET="target_compile_only"
+	;;
+    BS2000*-siemens-sysv4*)
+	OS='BS2000'
+	OSDIR='os/bs2000'
+	# If you are using a CPP before V3.0, delete the -Kno_integer_overflow flag
+	CC='c89 -XLLML -XLLMK -XL -Kno_integer_overflow'
+	CFLAGS="$CFLAGS -DCHARSET_EBCDIC -DSVR4 -D_XPG_IV"
+	DEF_WANTHSREGEX=yes
+	DBM_LIB=""
+	;;
+    *-siemens-sysv4*)
+	OS='SVR4'
+	CFLAGS="$CFLAGS -DSVR4 -D_XPG_IV -DHAS_DLFCN -DUSE_MMAP_FILES -DNEED_UNION_SEMUN"
+	DEF_WANTHSREGEX=yes
+	LIBS="$LIBS -lsocket -lnsl -lc"
+	DBM_LIB=""
+	;;
+    pyramid-pyramid-svr4)
+	OS='SVR4'
+	CFLAGS="$CFLAGS -DSVR4 -DNO_LONG_DOUBLE"
+	DEF_WANTHSREGEX=yes
+	LIBS="$LIBS -lsocket -lnsl -lc"
+	;;
+    DS/90\ 7000-*-sysv4*)
+	OS='UXP/DS'
+	CFLAGS="$CFLAGS -DUXPDS"
+	LIBS="$LIBS -lsocket -lnsl"
+	DEF_WANTHSREGEX=yes
+	;;
+    *-tandem-sysv4*)
+	OS='SVR4'
+	CFLAGS="$CFLAGS -DSVR4"
+	LIBS="$LIBS -lsocket -lnsl"
+	DEF_WANTHSREGEX=yes
+	;;
+    *-ncr-sysv4)
+	OS='NCR MP/RAS'
+	CFLAGS="$CFLAGS -DSVR4 -DMPRAS"
+	LIBS="$LIBS -lsocket -lnsl -lc -L/usr/ucblib -lucb"
+	DEF_WANTHSREGEX=yes
+	;;
+    *-sysv4*)
+	OS='SVR4'
+	CFLAGS="$CFLAGS -DSVR4"
+	LIBS="$LIBS -lsocket -lnsl -lc"
+	;;
+    88k-encore-sysv4)
+	OS='Encore UMAX V'
+	CFLAGS="$CFLAGS -DSVR4 -DENCORE"
+	DEF_WANTHSREGEX=yes
+	LIBS="$LIBS -lPW"
+	;;
+    *-uts*)
+	PLATOSVERS=`echo $PLAT | sed 's/^.*,//'`
+	OS='Amdahl UTS $PLATOSVERS'
+	case "$PLATOSVERS" in
+	    2*) CFLAGS="$CFLAGS -Xa -eft -DUTS21 -DUSEBCOPY"
+	        LIBS="$LIBS -lsocket -lbsd -la"
+	        DEF_WANTHSREGEX=yes
+	        ;;
+	    *)  CFLAGS="$CFLAGS -Xa -DSVR4"
+	        LIBS="$LIBS -lsocket -lnsl"
+	        ;;
+	esac
+	;;
+    *-ultrix)
+	OS='ULTRIX'
+	CFLAGS="-DULTRIX"
+	DEF_WANTHSREGEX=yes
+	SHELL="/bin/sh5"
+	;;
+    *powerpc-tenon-machten*)
+	OS='MachTen PPC'
+	LDFLAGS="$LDFLAGS -Xlstack=0x14000 -Xldelcsect"
+	;;
+    *-machten*)
+	OS='MachTen 68K'
+	LDFLAGS="$LDFLAGS -stack 0x14000"
+	DEF_WANTHSREGEX=yes
+	;;
+    *convex-v11*)
+	OS='CONVEXOS11'
+	CFLAGS="$CFLAGS -ext -DCONVEXOS11"
+	OPTIM="-O1" # scalar optimization only
+	CC='cc'
+	DEF_WANTHSREGEX=yes
+	;;
+    i860-intel-osf1)
+	DEF_WANTHSREGEX=yes
+	OS='Paragon OSF/1'
+	CFLAGS="$CFLAGS -DPARAGON"
+	;;
+    *-sequent-ptx2.*.*)
+	DEF_WANTHSREGEX=yes
+	OS='SEQUENT DYNIX/ptx v2.*.*'
+	CFLAGS="$CFLAGS -DSEQUENT=20 -Wc,-pw"
+	LIBS="$LIBS -lsocket -linet -lnsl -lc -lseq"
+	;;
+    *-sequent-ptx4.0.*)
+	DEF_WANTHSREGEX=yes
+	OS='SEQUENT DYNIX/ptx v4.0.*'
+	CFLAGS="$CFLAGS -DSEQUENT=40 -Wc,-pw"
+	LIBS="$LIBS -lsocket -linet -lnsl -lc"
+	;;
+    *-sequent-ptx4.[123].*)
+	DEF_WANTHSREGEX=yes
+	OS='SEQUENT DYNIX/ptx v4.1.*/v4.2.*'
+	CFLAGS="$CFLAGS -DSEQUENT=41 -Wc,-pw"
+	LIBS="$LIBS -lsocket -lnsl -lc"
+	;;
+    *-sequent-ptx4.4.*)
+	DEF_WANTHSREGEX=yes
+	OS='SEQUENT DYNIX/ptx v4.4.*'
+	CFLAGS="$CFLAGS -DSEQUENT=44 -Wc,-pw"
+	LIBS="$LIBS -lsocket -lnsl -lc"
+	;;
+    *-sequent-ptx4.5.*)
+	DEF_WANTHSREGEX=yes
+	OS='SEQUENT DYNIX/ptx v4.5.*'
+	CFLAGS="$CFLAGS -DSEQUENT=45 -Wc,-pw"
+	LIBS="$LIBS -lsocket -lnsl -lc"
+	;;
+    *-sequent-ptx5.0.*)
+	DEF_WANTHSREGEX=yes
+	OS='SEQUENT DYNIX/ptx v5.0.*'
+	CFLAGS="$CFLAGS -DSEQUENT=50 -Wc,-pw"
+	LIBS="$LIBS -lsocket -lnsl -lc"
+	;;
+    *NEWS-OS*)
+	DEF_WANTHSREGEX=yes
+	OS='SONY NEWS-OS'
+	CFLAGS="$CFLAGS -DNEWSOS"
+	;;
+    *-riscix)
+	OS='Acorn RISCix'
+	CFLAGS="$CFLAGS -DRISCIX"
+	OPTIM="-O"
+	MAKE="make"
+	DEF_WANTHSREGEX=yes
+	;;
+    *-BeOS*)
+	PLATOSVER=`uname -r`
+        case "$PLATOSVER" in
+            5.0.4*)
+                OS="BeOS BONE"
+                LIBS="-lbind -lsocket -lbe -lroot"
+                CFLAGS="$CFLAGS -DBONE"
+                ;;
+            *)
+                OS='BeOS';
+	        CFLAGS="$CFLAGS -DBEOS"
+                ;;
+        esac
+	DEF_WANTHSREGEX=yes
+	;;
+    4850-*.*)
+	OS='NCR MP/RAS'
+	CFLAGS="$CFLAGS -DSVR4 -DMPRAS"
+	DEF_WANTHSREGEX=yes
+	LIBS="$LIBS -lsocket -lnsl -lc -L/usr/ucblib -lucb"
+	;;
+    drs6000*)
+	OS='DRS6000'
+	CFLAGS="$CFLAGS -DSVR4"
+	DEF_WANTHSREGEX=yes
+	LIBS="$LIBS -lsocket -lnsl -lc -L/usr/ucblib -lucb"
+	;;
+    m88k-*-CX/SX|CYBER)
+	OS='Cyberguard CX/SX'
+	CFLAGS="$CFLAGS -D_CX_SX -Xa"
+	DEF_WANTHSREGEX=yes
+	CC='cc'
+	RANLIB='true'
+	;;
+    *-tandem-oss)
+	OS='Tandem OSS'
+	CFLAGS="-D_TANDEM_SOURCE -D_XOPEN_SOURCE_EXTENDED=1"
+	CC='c89'
+	;;
+    *-IBM-OS390*)
+       OS='OS390'
+       OSDIR='os/os390'
+       CC='c89'
+       CFLAGS="$CFLAGS -DOS390 -DCHARSET_EBCDIC -D_ALL_SOURCE"
+       DEF_WANTHSREGEX=yes
+       LIBS="$LIBS"
+       ;;
+    *-cygwin*)
+	OS='Cygwin'
+	OSDIR="os/cygwin"
+	CFLAGS="$CFLAGS -DCYGWIN"
+	DEF_WANTHSREGEX=yes
+	DBM_LIB="-lgdbm"
+	LIBS="$LIBS -lcrypt $DBM_LIB"
+	if [ "x$RULE_CYGWIN_WINSOCK" = "xyes" ]; then 
+	    CFLAGS="$CFLAGS -DCYGWIN_WINSOCK" 
+	    LIBS="$LIBS -lwsock32" 
+	fi 
+
+	;;
+    *atheos*)
+	DEF_WANTSREGEX=yes
+	OS='AtheOS'
+	CFLAGS="$CFLAGS -DATHEOS"
+	LIBS="$LIBS -lcrypt"
+	;;
+    *) # default: Catch systems we don't know about
+	OS='Unknown and unsupported OS'
+    	echo Sorry, but we cannot grok \"$PLAT\"
+	echo uname -m
+	uname -m
+	echo uname -r
+	uname -r
+	echo uname -s
+	uname -s
+	echo uname -v
+	uname -v
+	echo uname -X
+	uname -X
+	echo Ideally, read the file PORTING, do what it says, and send the
+	echo resulting patches to The Apache Group by filling out a report
+	echo form at http://bugs.apache.org/.  If you don\'t 
+	echo wish to do the port yourself, please submit this output rather 
+	echo than the patches. Thank you.
+	echo
+	echo Pressing on with the build process, but all bets are off.
+	echo Do not be surprised if it fails. If it works, and even
+	echo if it does not, please contact the above address.
+	echo
+	;;
+esac
+
+####################################################################
+## set this if we haven't
+##
+if [ "x${MAKE}" = "x" ]; then
+    MAKE='make'; export MAKE
+fi
+
+####################################################################
+## Show user what OS we came up with
+##
+echo " + configured for $OS platform"
+SUBDIRS="$OSDIR $SUBDIRS"
+
+####################################################################
+# Continue building the stub file
+# Set variables as soon as possible so that TestCompile can use them
+##
+echo >>Makefile.config "OSDIR=\$(SRCDIR)/$OSDIR"
+echo >>Makefile.config "INCDIR=\$(SRCDIR)/include"
+echo >>Makefile.config "INCLUDES0=-I\$(OSDIR) -I\$(INCDIR)"
+echo >>Makefile.config "SHELL=$SHELL"
+echo >>Makefile.config "OS=$OS"
+
+####################################################################
+## And adjust/override WANTHSREGEX as needed
+##
+if [ "x$RULE_WANTHSREGEX" = "xdefault" ]; then
+	if [ "x$DEF_WANTHSREGEX" = "x" ]; then
+		RULE_WANTHSREGEX=yes
+	else
+		RULE_WANTHSREGEX=$DEF_WANTHSREGEX
+	fi
+fi
+
+####################################################################
+## Now we determine the C-compiler and optimization level
+## to use. Settings of CC and OPTIM in Configuration have
+## the highest precedence; next comes any settings from
+## the above "OS-specific" section. If still unset,
+## then we look for a known compiler somewhere in PATH
+##
+
+# First, look for a CC=<whatever> setting in Configuration (recall, we
+# copied these to Makefile.config)
+#
+# If $TCC is null, then no such line exists in Configuration
+#
+TCC=`egrep '^CC=' Makefile.config | tail -1 | awk -F= '{print $2}'`
+if [ "x$TCC" = "x" ]; then
+    if [ "x$CC" = "x" ]; then
+	# At this point, CC is not set in Configuration or above, so we
+	# try to find one
+	for compilers in "gcc" "cc" "acc" "c89"
+	do
+	    lookedfor="$lookedfor $compilers"
+	    if ./helpers/PrintPath -s $compilers; then
+		COMPILER="$compilers"
+		break
+	    fi
+	done
+	if [ "x$COMPILER" = "x" ]; then
+	    echo "Error: could not find any of these C compilers"
+	    echo " anywhere in your PATH: $lookedfor"
+	    echo "Configure terminated"
+	    exitcode=1
+	    exit 1
+	fi
+	CC=$COMPILER
+    fi
+    echo " + setting C compiler to $CC"
+fi
+
+####################################################################
+## Write the value of $CC to Makefile.config... We only do this
+## is not done already (ie: a 'CC=' line was in Configuration).
+## If there was an entry for it, then set $CC for our own internal
+## use.
+##
+if [ "x$TCC" = "x" ]; then
+    echo "CC=$CC" >> Makefile.config
+else
+    CC=$TCC
+fi
+
+####################################################################
+## Now check how we can _directly_ run the C pre-processor
+##
+TCPP=`egrep '^CPP=' Makefile.config | tail -1 | awk -F= '{print $2}'`
+if [ "x$TCPP" != "x" ]; then
+    CPP=`CPP="$TCPP"; export CPP CC; ./helpers/findcpp.sh`
+else
+    CPP=`export CC; ./helpers/findcpp.sh`
+fi
+if [ "x$TCPP" = "x" ]; then
+    echo "CPP=$CPP" >> Makefile.config
+fi 
+echo " + setting C pre-processor to $CPP"
+
+####################################################################
+## Now check for existance of non-standard system header files
+## and start generation of the ap_config_auto.h header
+##
+AP_CONFIG_AUTO_H="include/ap_config_auto.h"
+echo "/*" >$AP_CONFIG_AUTO_H
+echo " *  ap_config_auto.h -- Automatically determined configuration stuff" >>$AP_CONFIG_AUTO_H
+echo " *  THIS FILE WAS AUTOMATICALLY GENERATED - DO NOT EDIT!" >>$AP_CONFIG_AUTO_H
+echo " */" >>$AP_CONFIG_AUTO_H
+echo "" >>$AP_CONFIG_AUTO_H
+echo "#ifndef AP_CONFIG_AUTO_H" >>$AP_CONFIG_AUTO_H
+echo "#define AP_CONFIG_AUTO_H" >>$AP_CONFIG_AUTO_H
+
+for uppercase in "tr [a-z] [A-Z]" "tr [:lower:] [:upper:]" "sed y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/"
+do
+  case `echo Apache | $uppercase` in
+    APACHE) break;;
+  esac
+done
+echo " + using \"$uppercase\" to uppercase"
+echo " + checking for system header files"
+CHECK_FOR_HEADERS="dlfcn.h dl.h bstring.h crypt.h unistd.h sys/resource.h sys/select.h sys/processor.h sys/param.h"
+(
+export CPP
+for header in $CHECK_FOR_HEADERS; do
+    echo "" >>$AP_CONFIG_AUTO_H
+    echo "/* check: #include <$header> */" >>$AP_CONFIG_AUTO_H
+    name="`echo $header | sed -e 's:/:_:g' -e 's:\.:_:g' | $uppercase`"
+    ./helpers/checkheader.sh $header
+    if [ $? -eq 0 ]; then
+	echo "#ifndef HAVE_${name}" >>$AP_CONFIG_AUTO_H
+	echo "#define HAVE_${name} 1" >>$AP_CONFIG_AUTO_H
+	echo "#endif" >>$AP_CONFIG_AUTO_H
+    else
+	echo "#ifdef HAVE_${name}" >>$AP_CONFIG_AUTO_H
+	echo "#undef HAVE_${name}" >>$AP_CONFIG_AUTO_H
+	echo "#endif" >>$AP_CONFIG_AUTO_H
+    fi
+done
+)
+
+####################################################################
+# Special AIX 4.x support: need to check for sys/processor.h
+# to decide whether the Processor Binding can be used or not
+case "$PLAT" in
+    *-ibm-aix*)
+	CPP=$CPP ./helpers/checkheader.sh sys/processor.h
+	if [ $? -eq 0 ]; then
+	    CFLAGS="$CFLAGS -DAIX_BIND_PROCESSOR"
+	fi
+	;;
+esac
+
+####################################################################
+## Look for OPTIM and save for later
+##
+TOPTIM=`egrep '^OPTIM=' Makefile.config | tail -1 | awk -F= '{print $2}'`
+TRANLIB=`egrep '^RANLIB=' Makefile.config | tail -1 | awk -F= '{print $2}'`
+TTARGET=`egrep '^TARGET=' Makefile.config | tail -1 | awk -F= '{print $2}'`
+
+####################################################################
+## Check for user provided flags for shared object support
+##
+TLD_SHLIB=`egrep '^LD_SHLIB=' Makefile.config | tail -1 | awk -F= '{print $2}'`
+TLDFLAGS_SHLIB=`egrep '^LDFLAGS_SHLIB=' Makefile.config | tail -1 | awk -F= '{print $2}'`
+TLDFLAGS_MOD_SHLIB=`egrep '^LDFLAGS_MOD_SHLIB=' Makefile.config | tail -1 | awk -F= '{print $2}'`
+TLDFLAGS_SHLIB_EXPORT=`egrep '^LDFLAGS_SHLIB_EXPORT=' Makefile.config | tail -1 | awk -F= '{print $2}'`
+TCFLAGS_SHLIB=`egrep '^CFLAGS_SHLIB=' Makefile.config | tail -1 | awk -F= '{print $2}'`
+
+####################################################################
+## Handle TARGET name
+##
+if [ "x$TTARGET" = "x" ]; then
+    TARGET=httpd
+    echo "TARGET=$TARGET" >> Makefile.config
+else
+    TARGET=$TTARGET
+fi
+if [ "x$TARGET" != "xhttpd" ]; then
+    echo " + using custom target name: $TARGET"
+    CFLAGS="$CFLAGS -DTARGET=\\\"$TARGET\\\""
+fi
+
+####################################################################
+## We adjust now CFLAGS_SHLIB, LDFLAGS_SHLIB and LDFLAGS_SHLIB_EXPORT as
+## required.  For more platforms just add the required lines below.
+##
+if [ "x$using_shlib" = "x1" ] ; then
+    LD_SHLIB="ld"
+    DEF_SHARED_CORE=no
+    DEF_SHARED_CHAIN=no
+    SHLIB_SUFFIX_NAME=so
+    SHMOD_SUFFIX_NAME=so
+    SHLIB_SUFFIX_DEPTH=all
+    SHLIB_EXPORT_FILES=no
+    SHARED_CORE_EP='lib$(TARGET).ep'
+    SHCORE_IMPLIB=''
+    case "$PLAT" in
+	*MPE/iX*)
+	    LD_SHLIB=ld	
+	    LDFLAGS_SHLIB='-b -a archive'
+	    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+	    ;;
+	*-linux1)
+	    CFLAGS_SHLIB="-fpic"
+	    LDFLAGS_SHLIB="-Bshareable"
+	    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+	    LDFLAGS_SHLIB_EXPORT="-rdynamic"
+	    ;;
+	*-linux2*)
+		LD_SHLIB="gcc"
+	    CFLAGS_SHLIB="-fPIC"
+	    LDFLAGS_SHLIB="-shared"
+	    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+	    LDFLAGS_SHLIB_EXPORT="-rdynamic"
+	    SHLIB_SUFFIX_DEPTH=0
+	    LIBS="$LIBS -lpthread"
+	    ;;
+	*-freebsd2*)
+		LD_SHLIB="gcc"
+	    CFLAGS_SHLIB="-fpic"
+	    LDFLAGS_SHLIB="-shared"
+	    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+	    LDFLAGS_SHLIB_EXPORT=""
+	    SHLIB_SUFFIX_DEPTH=2
+	    ;;
+	*-freebsd[3-9]*)
+		LD_SHLIB="gcc"
+	    CFLAGS_SHLIB="-fpic"
+	    LDFLAGS_SHLIB="-shared"
+	    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+	    OBJFORMAT=`test -x /usr/bin/objformat && /usr/bin/objformat || echo aout` 
+	    if [ "x$OBJFORMAT" = "xelf" ]; then
+		LDFLAGS_SHLIB_EXPORT="-Wl,-E"
+		SHLIB_SUFFIX_DEPTH=0
+	    else
+		LDFLAGS_SHLIB_EXPORT=""
+		SHLIB_SUFFIX_DEPTH=2
+	    fi  
+	    ;;
+	*-openbsd*)
+	    PLATOSVERS=`echo $PLAT | sed 's/^.*openbsd//'`
+	    CFLAGS_SHLIB="-fPIC"
+	    LDFLAGS_SHLIB_EXPORT=""
+	    SHLIB_SUFFIX_DEPTH=2
+	    case "$PLATOSVERS" in
+		[01].*|2.[0-7]|2.[0-7].*)
+		   LDFLAGS_SHLIB="-Bshareable"
+		;;
+		*)
+		   LD_SHLIB="gcc"
+		   LDFLAGS_SHLIB="-shared \$(CFLAGS_SHLIB)"
+		   if [ "x`echo __ELF__ | $CC -E - | grep __ELF__`" = "x" ]; then
+		     LDFLAGS_SHLIB_EXPORT="-Wl,-E"
+		   fi
+		;;
+	    esac
+	    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+	    ;;
+	*-netbsd*)
+	    CFLAGS_SHLIB="-fPIC -DPIC"
+	    if echo __ELF__ | ${CC} -E - | grep -q __ELF__; then
+		LDFLAGS_SHLIB="-Bshareable"
+		LDFLAGS_SHLIB_EXPORT=""
+	    else
+		LDFLAGS_SHLIB="-shared"
+		LDFLAGS_SHLIB_EXPORT="-Wl,-E"
+	    fi
+	    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+	    SHLIB_SUFFIX_DEPTH=2
+	    ;;
+	*-bsdi3)
+	    LD_SHLIB="shlicc2"
+	    LDFLAGS_SHLIB="-r"
+	    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+	    ;;
+	*-bsdi)
+	    CFLAGS_SHLIB="-fPIC"
+	    LDFLAGS_SHLIB="-shared"
+	    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+	    LDFLAGS_SHLIB_EXPORT="-rdynamic"
+	    ;;
+ 	*-next-openstep*)
+ 	    LD_SHLIB='cc'
+ 	    CFLAGS_SHLIB='-dynamic -fno-common'
+ 	    LDFLAGS_SHLIB='-bundle -undefined warning'
+	    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+ 	    LDFLAGS_SHLIB_EXPORT=''
+ 	    SHLIB_SUFFIX_DEPTH=0
+ 	    ;;
+	*-apple-rhapsody* | *-apple-darwin* )
+	    LD_SHLIB="cc"
+	    CFLAGS_SHLIB=""
+	    case "$PLAT" in
+		*-apple-rhapsody* | *-apple-darwin1.[0-3]* )
+		    LDFLAGS_SHLIB='$(EXTRA_LDFLAGS) -bundle -undefined suppress'
+		    ;;
+		* )
+		    LDFLAGS_SHLIB='$(EXTRA_LDFLAGS) -bundle -undefined suppress -flat_namespace'
+		    ;;
+	    esac
+	    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+	    LDFLAGS_SHLIB_EXPORT=""
+	    SHLIB_SUFFIX_DEPTH=0
+	    ;;
+	*-solaris2*)
+	    if [ "x`$CC -v 2>&1 | grep gcc`" != "x" ]; then
+	        CFLAGS_SHLIB="-fPIC"
+	    else
+	        CFLAGS_SHLIB="-KPIC"
+	    fi
+	    LDFLAGS_SHLIB="-G"
+	    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+	    LDFLAGS_SHLIB_EXPORT=""
+	    SHLIB_SUFFIX_DEPTH=1
+	    ;;
+	*-sunos4*)
+	    case $CC in
+		*/gcc|gcc ) CFLAGS_SHLIB="-fPIC" ;;
+		*/acc|acc ) CFLAGS_SHLIB="-pic" ;;
+	    esac
+	    LDFLAGS_SHLIB="-assert pure-text"
+	    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+	    LDFLAGS_SHLIB_EXPORT=""
+	    ;;
+	*-sgi-irix32)
+	    case $CC in
+		*/gcc|gcc )
+		    CFLAGS_SHLIB="-fpic"
+		    N32FLAG=""
+		    ;;
+		*/cc|cc )
+		    CFLAGS_SHLIB="-KPIC"
+		    N32FLAG="-n32"
+		    ;;
+	    esac
+	    if [ "x$RULE_IRIXN32" = "xyes" ]; then
+		LDFLAGS_SHLIB="$N32FLAG -shared"
+	    else
+		LDFLAGS_SHLIB="-shared"
+	    fi
+	    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+	    LDFLAGS_SHLIB_EXPORT=""
+	    ;;
+	*-sgi-irix64)
+	    case $CC in
+		*/gcc|gcc )
+		    CFLAGS_SHLIB="-fpic"
+		    N32FLAG=""
+		    ;;
+		*/cc|cc )
+		    CFLAGS_SHLIB="-KPIC"
+		    N32FLAG="-n32"
+		    ;;
+	    esac
+	    if [ "x$RULE_IRIXN32" = "xyes" ]; then
+		LDFLAGS_SHLIB="$N32FLAG -shared"
+	    else
+		LDFLAGS_SHLIB="-shared"
+	    fi
+	    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+	    LDFLAGS_SHLIB_EXPORT=""
+	    ;;
+	*-sgi-irix)
+	    case $CC in
+		*/gcc|gcc ) CFLAGS_SHLIB="-fpic" ;;
+		*/cc|cc   ) CFLAGS_SHLIB="-KPIC" ;;
+	    esac
+	    LDFLAGS_SHLIB="-shared"
+	    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+	    LDFLAGS_SHLIB_EXPORT=""
+	    ;;
+	*-dec-osf*)
+	    case $CC in
+		*/gcc|gcc ) CFLAGS_SHLIB="-fpic" ;;
+		*/cc|cc   ) CFLAGS_SHLIB="" ;;
+	    esac
+	    LDFLAGS_SHLIB='-shared -expect_unresolved "*" -s'
+	    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+	    LDFLAGS_SHLIB_EXPORT=""
+	    ;;
+	*-unixware*)
+	    case $CC in
+		*/gcc|gcc ) CFLAGS_SHLIB="-fpic" ;;
+		*/cc|cc   ) CFLAGS_SHLIB="-KPIC" ;;
+	    esac
+	    LDFLAGS_SHLIB="-Bdynamic -G"
+	    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+	    LDFLAGS_SHLIB_EXPORT="-Wl,-Bexport"
+	    ;;
+	*-OpenUNIX*)
+	    case $CC in
+		*/gcc|gcc ) CFLAGS_SHLIB="-fpic" ;;
+		*/cc|cc   ) CFLAGS_SHLIB="-KPIC" ;;
+	    esac
+	    LDFLAGS_SHLIB="-Bdynamic -G"
+	    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+	    LDFLAGS_SHLIB_EXPORT="-Wl,-Bexport"
+	    LD_SHLIB=$CC
+	    ;;
+	 *-sco5*)
+	     case $CC in
+		 */gcc*|gcc* ) CFLAGS_SHLIB="-fpic" ;;
+		 */cc*|cc*   ) CFLAGS_SHLIB="-KPIC" ;;
+	     esac
+	     LDFLAGS_SHLIB="-G"
+	     LDFLAGS_SHLIB_EXPORT="-Wl,-Bexport"
+	    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+	     SHLIB_SUFFIX_DEPTH=1
+	     ;;
+	*-sequent-ptx*)
+	    case $PLAT in
+	       *-sequent-ptx2*)
+	           ;;
+	       *-sequent-ptx4.0*)
+	           ;;
+	       *-sequent-ptx*)
+	           CFLAGS_SHLIB="-KPIC"
+	           LDFLAGS_SHLIB="-G"
+	           LDFLAGS_SHLIB_EXPORT="-Wl,-Bexport"
+	           LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+	           ;;
+	    esac
+	    ;;
+	RM*-siemens-sysv4*)
+	    # MIPS hosts can take advantage of the LDFLAGS_SHLIB_EXPORT switch
+	    case $CC in
+		*/gcc|gcc ) CFLAGS_SHLIB="-fpic" ;;
+		*/cc|cc   ) CFLAGS_SHLIB="-KPIC" ;;
+	    esac
+	    LDFLAGS_SHLIB="-G"
+	    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+	    LDFLAGS_SHLIB_EXPORT="-Wl,-Blargedynsym"
+	    ;;
+	BS2000-siemens-sysv4*)
+	    CFLAGS_SHLIB="-K PIC"
+	    LDFLAGS_SHLIB="-G"
+	    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+	    LDFLAGS_SHLIB_EXPORT=""
+	    SHLIB_SUFFIX_DEPTH=0
+	    DEF_SHARED_CORE=no
+	    ;;
+	*-siemens-sysv4*)
+	    # Older SINIX machines must be linked as "shared core"-Apache
+	    case $CC in
+		*/gcc|gcc ) CFLAGS_SHLIB="-fpic" ;;
+		*)          CFLAGS_SHLIB="-KPIC" ;;
+	    esac
+	    LDFLAGS_SHLIB="-G"
+	    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+	    LDFLAGS_SHLIB_EXPORT=""
+	    SHLIB_SUFFIX_DEPTH=0
+	    DEF_SHARED_CORE=yes
+	    ;;
+	*-sysv4*)
+	    case $CC in
+		*/gcc|gcc ) CFLAGS_SHLIB="-fpic" ;;
+		*/cc|cc   ) CFLAGS_SHLIB="-KPIC" ;;
+	    esac
+	    LDFLAGS_SHLIB="-G"
+	    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+	    LDFLAGS_SHLIB_EXPORT=""
+	    DEF_SHARED_CORE=yes
+	    ;;
+	*-hp-hpux9.*)
+	    case $CC in
+		*/gcc|gcc ) CFLAGS_SHLIB="-fpic" ;;
+		*/cc|cc   ) CFLAGS_SHLIB="+z" ;;
+	    esac
+	    LDFLAGS_SHLIB="-b"
+	    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+	    LDFLAGS_SHLIB_EXPORT="-Wl,-E -Wl,-B,deferred"
+	    SHLIB_SUFFIX_NAME=sl
+	    ;;
+	*-hp-hpux10.*|*-hp-hpux11.*)
+	    case $CC in
+		*/gcc|gcc ) CFLAGS_SHLIB="-fpic" ;;
+		*/cc|cc   ) CFLAGS_SHLIB="+z" ;;
+	    esac
+	    LDFLAGS_SHLIB="-b"
+	    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+	    LDFLAGS_SHLIB_EXPORT="-Wl,-E -Wl,-B,deferred -Wl,+s"
+	    SHLIB_SUFFIX_NAME=sl
+	    ;;
+       ia64-ibm-aix*)
+           case $CC in
+               */gcc|gcc ) CFLAGS_SHLIB="-fpic" ;;
+               */cc|cc   ) CFLAGS_SHLIB="" ;;
+           esac
+           LDFLAGS_SHLIB=" -L /usr/lib/ia64l32 -G "
+           LDFLAGS_MOD_SHLIB="$LDFLAGS_SHLIB -bI:@libexecdir@/httpd.exp -lc"
+           LDFLAGS_SHLIB="$LDFLAGS_SHLIB -Bexport:\`echo \$@|sed -e 's:\.so\$\$:.exp:'\`"
+           LDFLAGS_SHLIB="$LDFLAGS_SHLIB -lc"
+           LDFLAGS_SHLIB_EXPORT="-Wl,-Bexport:\$(SRCDIR)/support/httpd.exp"
+           SHLIB_EXPORT_FILES=yes
+           ;;
+	*-ibm-aix*)
+	    case $CC in
+		*/gcc|gcc ) CFLAGS_SHLIB="-fpic" ;;
+		*/cc|cc   ) CFLAGS_SHLIB="" ;;
+	    esac
+	    case $PLAT in
+		*-ibm-aix[45678]*)
+		    LDFLAGS_SHLIB="-H512 -T512 -bhalt:4 -bM:SRE -bnoentry"
+		    ;;
+		*-ibm-aix*)
+		    LDFLAGS_SHLIB="-H512 -T512 -bhalt:4 -bM:SRE -e _nostart"
+		    ;;
+	    esac
+	    LDFLAGS_MOD_SHLIB="$LDFLAGS_SHLIB -bI:@libexecdir@/httpd.exp -lc"
+	    LDFLAGS_SHLIB="$LDFLAGS_SHLIB -bI:\$(SRCDIR)/support/httpd.exp "
+	    LDFLAGS_SHLIB="$LDFLAGS_SHLIB -bE:\`echo \$@|sed -e 's:\.so\$\$:.exp:'\`"
+	    LDFLAGS_SHLIB="$LDFLAGS_SHLIB -lc"
+	    LDFLAGS_SHLIB_EXPORT="-Wl,-bE:\$(SRCDIR)/support/httpd.exp"
+	    SHLIB_EXPORT_FILES=yes
+	    ;;
+	*-*-powermax*)
+	    LD_SHLIB='cc'
+	    LDFLAGS_SHLIB="-Zlink=so"
+	    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+	    LDFLAGS_SHLIB_EXPORT="-Zlink=dynamic -Wl,-Bexport"
+	    CFLAGS_SHLIB='-Zpic'
+	    ;;
+	*-OS/2*)
+	    DEF_SHARED_CORE=yes
+	    LDFLAGS_SHLIB="`echo $LDFLAGS|sed -e s/-Zexe//` -Zdll"
+	    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+	    SHLIB_SUFFIX_NAME=dll
+	    SHMOD_SUFFIX_NAME=dll
+	    SHLIB_SUFFIX_DEPTH=0
+	    LD_SHLIB=$CC
+	    LD_SHCORE_DEF="ApacheCoreOS2.def"
+	    LD_SHCORE_LIBS="$LIBS"
+	    LIBS_SHLIB='$(SRCDIR)/ApacheCoreOS2.a -lsocket -lbsd $(EXTRA_LIBS)'
+	    SHARED_CORE_EP=''
+	    SHCORE_IMPLIB='ApacheCoreOS2.a'
+	    OS_MODULE_INCLUDE='Makefile.OS2'
+	    ;;
+	*-dgux)
+	    case $CC in
+		*/gcc|gcc ) CFLAGS_SHLIB="-fpic" ;;
+	    esac
+	    DEF_SHARED_CORE=yes
+	    LDFLAGS_SHLIB="-G"
+	    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+	    LDFLAGS_SHLIB_EXPORT=""
+            ;;
+	*-cygwin*)
+	    DEF_SHARED_CORE=yes
+	    LDFLAGS_SHLIB="--export-all"
+	    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+	    SHLIB_SUFFIX_NAME=dll
+	    SHMOD_SUFFIX_NAME=dll
+	    SHLIB_SUFFIX_DEPTH=0
+	    LD_SHLIB='dllwrap'
+	    LD_SHCORE_DEF=''
+	    LD_SHCORE_LIBS="$LIBS"
+	    LIBS_SHLIB='$(EXTRA_LIBS)'
+	    SHARED_CORE_EP='lib$(TARGET).ep'
+	    SHCORE_IMPLIB='lib$(TARGET).dll'
+	    OS_MODULE_INCLUDE='$(SRCDIR)/modules/standard/Makefile.Cygwin'
+	    ;;
+	*)
+	    ##  ok, no known explict support for shared objects
+	    ##  on this platform, but we give not up immediately.
+	    ##  We take a second chance by guessing the compiler
+	    ##  and linker flags from the Perl installation
+	    ##  if it exists.
+	    PERL=
+	    for dir in `echo $PATH | sed -e 's/:/ /g'`
+	    do
+		if [ -f "$dir/perl5" ]; then
+		    PERL="$dir/perl5"
+		    break
+		fi
+		if [ -f "$dir/perl" ]; then
+		    PERL="$dir/perl"
+		    break
+		fi
+	    done
+	    if [ "x$PERL" != "x" ]; then
+		#   cool, Perl is installed on this platform...
+		if [ "x`$PERL -V:dlsrc 2>/dev/null | grep dlopen`" != "x" ]; then
+		    #   ...and actually uses the dlopen-style interface,
+		    #   so we can guess the flags from its knowledge
+		    CFLAGS_SHLIB="`$PERL -V:cccdlflags | cut -d\' -f2`"
+		    LDFLAGS_SHLIB="`$PERL -V:lddlflags | cut -d\' -f2`"
+		    LDFLAGS_MOD_SHLIB=$LDFLAGS_SHLIB
+		    LDFLAGS_SHLIB_EXPORT="`$PERL -V:ccdlflags | cut -d\' -f2`"
+		    #   but additionally we have to inform the
+		    #   user that we are just guessing the flags
+		    echo ""
+		    echo "** WARNING: We have no explicit knowledge about shared object"
+		    echo "** support for your particular platform. But perhaps you have"
+		    echo "** luck: We were able to guess the compiler and linker flags"
+		    echo "** for creating shared objects from your Perl installation."
+		    echo "** If they actually work, please send the following information"
+		    echo "** for inclusion into later releases to new-httpd@apache.org or make"
+		    echo "** a suggestion report at http://bugs.apache.org/:"
+		    echo "**     PLATFORM=$PLAT"
+		    echo "**     CFLAGS_SHLIB=$CFLAGS_SHLIB"
+		    echo "**     LDFLAGS_SHLIB=$LDFLAGS_SHLIB"
+		    echo "**     LDFLAGS_SHLIB_EXPORT=$LDFLAGS_SHLIB_EXPORT"
+		    echo ""
+		fi
+	    fi
+	    ;;
+    esac
+fi
+
+####################################################################
+## Check if we really have some information to compile
+## the shared objects if SharedModule was used.
+##
+if [ "x$using_shlib" = "x1" ] ; then
+    if [ "x$TCFLAGS_SHLIB"  = "x" -a "x$CFLAGS_SHLIB"  = "x"  -a \
+	 "x$TLDFLAGS_SHLIB" = "x" -a "x$LDFLAGS_SHLIB" = "x" ]; then
+	echo ""
+	echo "** FAILURE: Sorry, no shared object support available."
+	echo "** Either compile all modules statically (use AddModule instead"
+	echo "** of SharedModule in the Configuration file) or at least provide"
+	echo "** us with the appropriate compiler and linker flags via the"
+	echo "** CFLAGS_SHLIB, LDFLAGS_SHLIB and LDFLAGS_SHLIB_EXPORT entries"
+	echo "** in the Configuration file."
+	echo ""
+	exit 1
+    fi
+fi
+
+####################################################################
+## Now we do some OS specific adjustments... for some OSs, we need
+## to adjust CFLAGS and/or OPTIM depending on which compiler we
+## are going to use. This is easy, since this can be gleamed from
+## Makefile.config
+##
+case "$OS" in
+    'ULTRIX')
+	case "$CC" in
+	    */cc|cc ) CFLAGS="$CFLAGS -std" ;;
+	esac
+	;;
+    'SCO 5')
+	case "$CC" in
+	    */cc|cc ) CFLAGS="$CFLAGS -K noinline" ;;
+	esac
+	;;
+    'HI-UX')
+	case "$CC" in
+	    */cc|cc )
+		CFLAGS="$CFLAGS -Aa -Ae -D_HIUX_SOURCE"
+		OPTIM=" "
+		TOPTIM=""
+	    ;;
+	esac
+	;;
+    'HP-UX'|'HP-UX 10'|'HP-UX 11')
+	case "$CC" in
+	    */cc|cc )
+		CFLAGS="$CFLAGS -Aa -Ae -D_HPUX_SOURCE"
+		OPTIM=" "
+		TOPTIM=""
+	    ;;
+	esac
+	;;
+    *IRIX-64*)
+	if [ "x$RULE_IRIXN32" = "xyes" ]; then
+	    case "$CC" in
+		*/cc|cc )
+		    CFLAGS="$CFLAGS -n32"
+		    LDFLAGS="$LDFLAGS -n32"
+		;;
+	    esac
+	fi
+	;;
+    *IRIX-32*)
+	if [ "x$RULE_IRIXN32" = "xyes" ]; then
+	    case "$CC" in
+		*/cc|cc )
+		    CFLAGS="$CFLAGS -n32"
+		    LDFLAGS="$LDFLAGS -n32"
+		;;
+	    esac
+	fi
+	;;
+    IBM?AIX?4.[123])
+	case $CC in
+	    */cc|cc ) 
+		CFLAGS="$CFLAGS -qnogenpcomp -qnousepcomp"
+	    ;;
+	esac
+	;;
+    'IBM AIX IA64')
+       case $CC in
+           */cc|cc )
+               CFLAGS="$CFLAGS -qnogenpcomp -qnousepcomp"
+           ;;
+       esac
+       ;;
+esac
+
+####################################################################
+## OK, now we can write OPTIM
+##
+if [ "x$TOPTIM" = "x" ]; then
+    echo "OPTIM=$OPTIM" >> Makefile.config
+fi
+
+####################################################################
+## OK, now handle RANLIB
+##
+if [ "x$RANLIB" = "x" ]; then
+    if [ "x$TRANLIB" != "x" ]; then
+	RANLIB=$TRANLIB
+    else
+	if ./helpers/PrintPath -s ranlib; then
+	    RANLIB="ranlib"
+	else
+	    RANLIB="true"
+	fi
+    fi
+fi
+
+####################################################################
+## Now we do some general checks and some intelligent Configuration
+## control.
+
+# Use TestCompile to look for various LIBS
+case "$PLAT" in
+    *-linux*)
+	# newer systems using glibc 2.x need -lcrypt
+	if ./helpers/TestCompile lib crypt; then
+	    LIBS="$LIBS -lcrypt"
+	fi
+	# see if prctl(PR_SET_DUMPABLE) is available
+	if TCADDINCL='#include <sys/prctl.h>
+static int required_flag = PR_SET_DUMPABLE;' ./helpers/TestCompile sizeof required_flag ; then
+	    if ./helpers/TestCompile func prctl; then
+	        CFLAGS="$CFLAGS -DHAVE_SET_DUMPABLE"
+	    fi
+	fi
+	;;
+
+    *-dg-dgux*)
+	# R4.11MU02 requires -lsocket -lnsl ... no idea if it's earlier or
+	# later than what we already knew about.  PR#732
+	if ./helpers/TestCompile lib nsl; then
+	    LIBS="$LIBS -lnsl"
+	    TLIB='-lnsl'
+	fi
+	if TLIB=$TLIB ./helpers/TestCompile lib socket; then
+	    LIBS="-lsocket $LIBS"
+	fi
+	;;
+    BS2000*-siemens-sysv4*)
+	# Activate RISC compilation if this is a SR2000 machine
+	# (test written by Thomas Dorner <Thomas.Dorner@start.de>
+	# for perl5 port):
+	ISSR2000="`bs2cmd SHOW-SYSTEM-INFO | grep 'HSI-ATT'`"
+	case "$ISSR2000" in
+	    *TYPE*SR*)
+	        CFLAGS="$CFLAGS -Krisc_4000"
+	        ;;
+	esac
+	# Depending on the BS2000 OS and compiler/crte release,
+	# -lnsl may be available (or may be not).
+	# In standard SVR4 systems, -lsocket relies on some symbols
+	# from -lnsl, so the test for -lnsl must appear first.
+	if ./helpers/TestCompile lib nsl; then
+	    LIBS="$LIBS -lnsl"
+	    TLIB='-lnsl'
+	fi
+	if TLIB=$TLIB ./helpers/TestCompile lib socket; then
+	    LIBS="-lsocket $LIBS"
+	fi
+	# Auto-detect presence of libdl for dynamic loading
+	if ./helpers/TestCompile lib dl; then
+	    if ./helpers/TestCompile func dlopen; then
+		LIBS="$LIBS -ldl"
+		TLIB='-ldl'
+	    fi
+	fi
+	# Test for the presence of the "union semun":
+	if TCADDINCL='#include <sys/types.h>
+#include <sys/ipc.h>
+#include <sys/sem.h>' ./helpers/TestCompile sizeof "union semun"; then
+            : Okay, union semun is defined
+	else
+	    CFLAGS="$CFLAGS -DNEED_UNION_SEMUN"
+	fi
+	# Test for the presence of the _rini_struct typedef:
+	if TCADDINCL='#include <pwd.h>' ./helpers/TestCompile sizeof _rini_struct; then
+	    CFLAGS="$CFLAGS -DHAVE_RINI_STRUCT"
+	fi
+	# Test whether initgroups() must be emulated:
+	if ./helpers/TestCompile func initgroups; then
+	    :
+	else
+	    CFLAGS="$CFLAGS -DNEED_INITGROUPS"
+	fi
+	;;
+esac
+
+# SOCKS4 support:
+# We assume that if they are using SOCKS4, then they've
+# adjusted EXTRA_LIBS and/or EXTRA_LDFLAGS as required,
+# otherwise we assume "-L/usr/local/lib -lsocks"
+if [ "x$RULE_SOCKS4" = "xyes" ]; then
+    echo " + enabling SOCKS4 support"
+    CFLAGS="$CFLAGS -DSOCKS -DSOCKS4"
+    CFLAGS="$CFLAGS -Dconnect=Rconnect -Dselect=Rselect"
+    CFLAGS="$CFLAGS -Dgethostbyname=Rgethostbyname"
+    if [ "x`egrep '^EXTRA_L' Makefile.config | grep lsocks`" = "x" ]; then
+	LIBS="$LIBS -L/usr/local/lib -lsocks"
+    fi
+    case $PLAT in
+	*-solaris2* )
+	    LIBS="$LIBS -lresolv"
+	    ;;
+    esac
+fi
+
+# SOCKS5 support:
+# We assume that if they are using SOCKS5, then they've
+# adjusted EXTRA_LIBS and/or EXTRA_LDFLAGS as required,
+# otherwise we assume "-L/usr/local/lib -lsocks5"
+if [ "x$RULE_SOCKS5" = "xyes" ]; then
+    echo " + enabling SOCKS5 support"
+    CFLAGS="$CFLAGS -DSOCKS -DSOCKS5"
+    CFLAGS="$CFLAGS -Dconnect=SOCKSconnect -Dselect=SOCKSselect"
+    CFLAGS="$CFLAGS -Dgethostbyname=SOCKSgethostbyname -Dclose=SOCKSclose"
+    if [ "x`egrep '^EXTRA_L' Makefile.config | grep lsocks5`" = "x" ]; then
+	LIBS="$LIBS -L/usr/local/lib -lsocks5"
+    fi
+    case $PLAT in
+	*-solaris2* )
+	    LIBS="$LIBS -lresolv"
+	    ;;
+    esac
+fi
+
+####################################################################
+## Find out what modules we want and try and configure things for them
+## Module lines can look like this:
+##
+##  Module  name_module    some/path/mod_name[.[oa]]
+##  AddModule              some/path/mod_name[.[oa]]
+##
+## In both cases, the some/path can either be an arbitrary path (including
+## an absolute path), or a path like "modules/DIR", in which case we _might_
+## auto-generate a Makefile in modules/DIR (see later).
+##
+## The first case is the original style, where we give the module's
+## name as well as it's binary file location - either a .o or .a.
+##
+## The second format is new, and means we do not repeat the module
+## name, which is already part of the module source or definition.
+## The way we find the module name (and other optional information about
+## the module) is like this:
+##
+##  1 If extension is not given or is .c, assume .o was given and goto 3
+##  2 If extension is .module, go to D1
+##  3 If extension is .o, look for a corresponding .c file and if
+##      found, go to C1
+##  4 If no .c file was found, look for a .module file (Apache module
+##      definition file). If found, go to D1
+##  5 Assume module name is the "name" part of "mod_name", as in
+##      name_module.
+##
+## If a C file is found:
+##
+## C1 Look for module name given by an MODULE: line (e.g. MODULE: name_module)
+##      If found assume module contains a definition, and go to D1
+## C2 If not found, look for a module name given on the declaration of the
+##      module structure (e.g. module name_module).
+## C3 If neither given, go to 4 above.
+##
+## If a definition file is found, or a .c file includes a module definition:
+##
+## D1 Get the module name from the MODULE: name= line
+## D2 Get other module options (libraries etc). To be done later.
+##
+##
+## For now, we will convert the AddModule lines into Module format
+## lines, so the rest of Configure can do its stuff without too much
+## additional hackery. It would be nice to reduce the number of times
+## we have to awk the $tmpfile, though.
+
+## MODFILES contains a list of module filenames (could be .c, .o, .so, .a
+##    or .module files) from AddModule lines only
+## MODDIRS contains a list of subdirectories under 'modules' which
+##    contain modules we want to build from both AddModule and Module
+##    lines
+
+echo " + adding selected modules"
+
+MODFILES=`awk <$tmpfile '($1 == "AddModule" || $1 == "SharedModule") { printf "%s ", $2 }'`
+MODDIRS=`awk < $tmpfile '
+	($1 == "Module" && $3 ~ /^modules\//) {
+	    split ($3, pp, "/")
+	    if (! SEEN[pp[2]]) {
+		printf "%s ", pp[2]
+		SEEN[pp[2]] = 1
+	    }
+    	}
+	(($1 == "AddModule" || $1 == "SharedModule") && $2 ~ /^modules\//) { 
+	    split ($2, pp, "/")
+	    if (! SEEN[pp[2]]) {
+		printf "%s ", pp[2]
+		SEEN[pp[2]] = 1
+	    } 
+    	}'`
+MODDIRS_NO_SO=`awk < $tmpfile '
+	($1 == "Module" && $3 ~ /^modules\//) {
+	    split ($3, pp, "/")
+	    if (! SEEN[pp[2]]) {
+		printf "%s ", pp[2]
+		SEEN[pp[2]] = 1
+	    }
+    	}
+	(($1 == "AddModule") && $2 ~ /^modules\//) { 
+	    split ($2, pp, "/")
+	    if (! SEEN[pp[2]]) {
+		printf "%s ", pp[2]
+		SEEN[pp[2]] = 1
+	    } 
+    	}'`
+
+# Now autoconfigure each of the modules specified by AddModule.
+# Use tmpfile2 for the module definition file, and tmpfile3 for the
+# shell commands to be executed for this module.
+
+if [ "x$OS" = "xTPF" -a "x$TPF64BIT" = "xYES" ]; then
+   rm -f apache.modules
+fi
+
+for modfile in $MODFILES ; do
+	rm -f $tmpfile2 $tmpfile3
+	modname=''
+
+	ext=`echo $modfile | sed 's/^.*\.//'`
+	modbase=`echo $modfile | sed 's/\.[^.]*$//'`
+	if [ "x$ext" = "x$modfile" ]; then ext=o; modbase=$modfile; modfile=$modbase.o; fi
+	if [ "x$ext" = "x" ] ; then ext=o; modbase=$modfile; fi
+	if [ "x$ext" = "xc" ] ; then ext=o; fi
+
+	# modbase is the path+filename without extension, ext is the
+	# extension given, or if none, o
+	if [ -r $modbase.module ] ; then
+		$CAT $modbase.module > $tmpfile2
+	else
+	    if [ -f $modbase.c ] ; then
+		# Guess module structure name in case there is no
+		# module definition in this file
+		modname=`egrep '^module .*;' $modbase.c | head -1 |\
+			sed 's/^module.*[ 	][ 	]*//' | \
+			sed 's/[ 	]*;[ 	]*$//'`
+		# Get any module definition part
+		if grep "MODULE-DEFINITION-" $modbase.c > /dev/null; then
+		$CAT $modbase.c | \
+		sed '1,/MODULE-DEFINITION-START/d;/MODULE-DEFINITION-END/,$d' \
+			> $tmpfile2
+		fi
+	    fi
+	fi		
+	if [ -r $tmpfile2 ] ; then
+		# Read a module definition from .module or .c
+		modname=`grep "Name:" $tmpfile2 | sed 's/^.*Name:[ 	]*//'`
+		if grep "ConfigStart" $tmpfile2 > /dev/null \
+		 && grep "ConfigEnd" $tmpfile2 > /dev/null; then
+		    sed '1,/ConfigStart/d;/ConfigEnd/,$d' $tmpfile2 > \
+		     $tmpfile3
+		    echo "    o $modname uses ConfigStart/End"
+		    if [ "x$RULE_PARANOID" = "xyes" ]; then
+			sed 's/^/>> /' $tmpfile3
+		    fi
+		    . ./$tmpfile3
+		fi
+		if grep "Libs:" $tmpfile2 > /dev/null; then
+		    modlibs1=`grep Libs: $tmpfile2 | sed 's/^.*Libs:[ 	]*//'`
+		    echo "    o $modbase adds libraries: $modlibs1"
+		    modlibs="$modlibs $modlibs1"
+		fi
+		rm -f $tmpfile2 $tmpfile3
+		if [ "x$ext" != "x$SHMOD_SUFFIX_NAME" ]; then
+		    ext=o
+		fi
+	fi
+	if [ "x$modname" = "x" ] ; then
+		modname=`echo $modbase | sed 's/^.*\///' | \
+			sed 's/^mod_//' | sed 's/^lib//' | sed 's/$/_module/'`
+	fi
+	if [ "x$ext" != "x$SHMOD_SUFFIX_NAME" ]; then
+		echo "Module $modname $modbase.$ext" >>$tmpfile
+	fi
+	#   optionally generate export file for some linkers 
+	if [ "x$ext" = "x$SHMOD_SUFFIX_NAME" -a "x$SHLIB_EXPORT_FILES" = "xyes" ]; then
+		echo "$modname" >$modbase.exp
+	fi
+	if [ "x$OS" = "xTPF" -a "x$TPF64BIT" = "xYES" ] ; then
+                # output a list of modules for TPF's 64BIT build process
+		`echo $modfile | sed 's/.*\/\([_a-zA-Z]*\.\)o$/\1c/' >> apache.modules`
+	fi
+done
+# $tmpfile now contains Module lines for all the modules we want
+
+####################################################################
+## Now HS's POSIX regex implementation if needed/wanted. We do it
+## now since AddModule may have changed it
+##
+if [ "x$RULE_WANTHSREGEX" = "xyes" ]; then
+    REGLIB="regex/libregex.a"
+    SUBDIRS="regex $SUBDIRS"
+    CFLAGS="$CFLAGS -DUSE_HSREGEX"
+fi
+
+####################################################################
+## Extended API (EAPI) support:
+##
+if [ "x$RULE_EAPI" = "x" ]; then
+    RULE_EAPI=`./helpers/CutRule EAPI $file`
+fi
+if [ "x$RULE_EAPI" = "xyes" ]; then
+    echo " + enabling Extended API (EAPI)"
+    CFLAGS="$CFLAGS -DEAPI"
+    #   some vendor compilers are too restrictive
+    #   for our ap_hook and ap_ctx sources.
+    case "$OS:$CC" in
+        *IRIX-32*:*/cc|*IRIX-32*:cc )
+            CFLAGS="$CFLAGS -woff 1048,1110,1164"
+            ;;
+    esac
+    #   MM Shared Memory Library support for EAPI
+    if [ "x$EAPI_MM" = "x" ]; then
+        EAPI_MM=`egrep '^EAPI_MM=' $file | sed -n -e '$p' | awk -F= '{print $2}'`
+    fi
+    if [ "x$EAPI_MM" != "x" ]; then
+        case $EAPI_MM in
+            SYSTEM|/* ) ;;
+            * ) for p in . .. ../..; do
+                    if [ -d "$p/$EAPI_MM" ]; then
+                        EAPI_MM="`echo $p/$EAPI_MM | sed -e 's;/\./;/;g'`" 
+                        break
+                    fi
+                done
+                ;;
+        esac
+        if [ "x$EAPI_MM" = "xSYSTEM" ]; then
+            echo "   using MM library for EAPI: (system-wide)"
+            CFLAGS="$CFLAGS -DEAPI_MM"
+            __INCLUDES="`mm-config --cflags`"
+            if [ "x$__INCLUDES" != "x-I/usr/include" ]; then
+                INCLUDES="$INCLUDES $__INCLUDES"
+            fi
+            LDFLAGS="$LDFLAGS `mm-config --ldflags`"
+            LIBS="$LIBS `mm-config --libs`"
+        else
+            if [ -f "$EAPI_MM/.libs/libmm.a" -a -f "$EAPI_MM/mm.h" ]; then
+                echo "   using MM library: $EAPI_MM (source-tree only)"
+                case $EAPI_MM in
+                    /* ) ;;
+                    *  ) EAPI_MM="\$(SRCDIR)/$EAPI_MM" ;;
+                esac
+                CFLAGS="$CFLAGS -DEAPI_MM"
+                INCLUDES="$INCLUDES -I$EAPI_MM"
+                LDFLAGS="$LDFLAGS -L$EAPI_MM/.libs"
+                LIBS="$LIBS -lmm"
+            elif [ -f "$EAPI_MM/bin/mm-config" ]; then
+                echo "   using MM library: $EAPI_MM (installed)"
+                CFLAGS="$CFLAGS -DEAPI_MM"
+                INCLUDES="$INCLUDES `$EAPI_MM/bin/mm-config --cflags`"
+                LDFLAGS="$LDFLAGS `$EAPI_MM/bin/mm-config --ldflags`"
+                LIBS="$LIBS `$EAPI_MM/bin/mm-config --libs`"
+            else
+                echo "Configure:Error: Cannot find MM library under $EAPI_MM" 1>&2
+                exit 1
+            fi
+        fi
+    fi
+fi
+
+
+####################################################################
+## Add in the Expat library if needed/wanted.
+##
+
+# set the default, based on whether expat-lite is bundled. if it is present,
+# then we can always include expat.
+if [ "x$RULE_EXPAT" = "xdefault" ]; then
+    if [ -d ./lib/expat-lite/ ]; then
+        RULE_EXPAT=yes
+    else
+        RULE_EXPAT=no
+    fi
+fi
+
+if [ "x$RULE_EXPAT" = "xyes" ]; then
+    if ./helpers/TestCompile lib expat; then
+        echo " + using system Expat"
+        LIBS="$LIBS -lexpat"
+    else
+        if [ ! -d ./lib/expat-lite/ ]; then
+            echo "ERROR: RULE_EXPAT set to \"yes\" but is not available."
+	    exit 1
+        fi
+        echo " + using builtin Expat"
+        EXPATLIB="lib/expat-lite/libexpat.a"
+        APLIBDIRS="expat-lite $APLIBDIRS"
+        CFLAGS="$CFLAGS -DUSE_EXPAT -I\$(SRCDIR)/lib/expat-lite"
+    fi
+fi
+
+####################################################################
+## Now the SHARED_CHAIN stuff
+##
+if [ "x$using_shlib" = "x1" ] ; then
+    if [ "x$RULE_SHARED_CHAIN" = "xdefault" ] ; then
+	RULE_SHARED_CHAIN=$DEF_SHARED_CHAIN
+    fi
+    if [ "x$RULE_SHARED_CHAIN" = "xyes" ]; then
+	echo " + enabling DSO files to be linked against others"
+	#   determine libraries which can be safely linked
+	#   to our DSO files, i.e. PIC libraries and shared libraries
+	extra_ldflags="`grep EXTRA_LDFLAGS= Makefile.config`"
+	extra_libs="`grep EXTRA_LIBS= Makefile.config`"
+	eval "`./helpers/slo.sh $LDFLAGS $LIBS $extra_ldflags $extra_libs`"
+	LIBS_SHLIB="$SLO_DIRS_PIC $SLO_LIBS_PIC $SLO_DIRS_DSO $SLO_LIBS_DSO"
+    fi
+fi
+
+####################################################################
+## Now the SHARED_CORE stuff
+##
+if [ "x$using_shlib" = "x1" ] ; then
+    if [ "x$RULE_SHARED_CORE" = "xdefault" ] ; then
+	RULE_SHARED_CORE=$DEF_SHARED_CORE
+    fi
+    if [ "x$RULE_SHARED_CORE" = "xyes" ]; then
+	DSO_STRING="DSO"
+	if [ "$OS" = "Cygwin" ]; then
+	    DSO_STRING="DLL"
+	fi
+	echo " + enabling generation of Apache core as $DSO_STRING"
+	#    shuffle compiler flags from shlib variant to standard
+	CFLAGS="$CFLAGS $CFLAGS_SHLIB"
+	CFLAGS_SHLIB=""
+	#    indicate that Rule SHARED_CORE is active
+	CFLAGS="$CFLAGS -DSHARED_CORE"
+	#    select the special subtarget for shared core generation
+	SUBTARGET=target_shared
+	#    determine additional suffixes for libhttpd.so
+	V=1 R=3 P=33
+	if [ "x$SHLIB_SUFFIX_DEPTH" = "x0" ]; then
+	    SHLIB_SUFFIX_LIST=""
+	fi
+	if [ "x$SHLIB_SUFFIX_DEPTH" = "x1" ]; then
+	    SHLIB_SUFFIX_LIST="$V"
+	fi
+	if [ "x$SHLIB_SUFFIX_DEPTH" = "x2" ]; then
+	    SHLIB_SUFFIX_LIST="$V.$R"
+	fi
+	if [ "x$SHLIB_SUFFIX_DEPTH" = "x3" ]; then
+	    SHLIB_SUFFIX_LIST="$V.$R.$P"
+	fi
+	if [ "x$SHLIB_SUFFIX_DEPTH" = "xall" ]; then
+	    SHLIB_SUFFIX_LIST="$V $V.$R $V.$R.$P"
+	fi
+    fi
+fi
+
+####################################################################
+## Don't force DL emulation, if not necessary. Currently only used
+## by os/unix/os.c. 
+##
+if [ "x$using_shlib" != "x1" ] ; then
+    CFLAGS="$CFLAGS -DNO_DL_NEEDED"
+fi
+
+####################################################################
+## Set the value of the shared libary flags, if they aren't explicitly
+## set in the configuration file
+##
+if [ "x$using_shlib" = "x1" ] ; then
+    if [ "x$TCFLAGS_SHLIB" = "x" ]; then
+	echo "CFLAGS_SHLIB=$CFLAGS_SHLIB -DSHARED_MODULE" >> Makefile.config
+    fi
+    if [ "x$TLD_SHLIB" = "x" ]; then
+	echo "LD_SHLIB=$LD_SHLIB" >> Makefile.config
+    fi
+    if [ "x$TLDFLAGS_SHLIB" = "x" ]; then
+	echo "EXTRA_LDFLAGS_SHLIB=$EXTRA_LDFLAGS_SHLIB" >> Makefile.config
+	echo "LDFLAGS_SHLIB=$LDFLAGS_SHLIB $EXTRA_LDFLAGS_SHLIB" >> Makefile.config
+    fi
+    if [ "x$TLDFLAGS_SHLIB_EXPORT" = "x" ]; then
+	echo "LDFLAGS_SHLIB_EXPORT=$LDFLAGS_SHLIB_EXPORT" >> Makefile.config
+    fi
+    if [ "x$TLDFLAGS_MOD_SHLIB" = "x" ]; then
+	echo "LDFLAGS_MOD_SHLIB=$LDFLAGS_MOD_SHLIB" >> Makefile.config
+    fi
+    echo "LD_SHCORE_DEF=$LD_SHCORE_DEF" >> Makefile.config
+    echo "LD_SHCORE_LIBS=$LD_SHCORE_LIBS" >> Makefile.config
+    echo "SHARED_CORE_EP=$SHARED_CORE_EP" >> Makefile.config
+    echo "SHCORE_IMPLIB=$SHCORE_IMPLIB" >> Makefile.config
+fi
+
+####################################################################
+## Now create modules.c
+##
+$CAT > $awkfile <<'EOFM'
+    BEGIN {
+	modules[n++] = "core"
+	pmodules[pn++] = "core"
+    } 
+    /^Module/ { modules[n++] = $2 ; pmodules[pn++] = $2 } 
+    /^%Module/ { pmodules[pn++] = $2 } 
+    END {
+	print "/*"
+	print " * modules.c --- automatically generated by Apache"
+	print " * configuration script.  DO NOT HAND EDIT!!!!!"
+	print " */"
+	print ""
+	print "#include \"httpd.h\""
+	print "#include \"http_config.h\""
+	print ""
+	for (i = 0; i < pn; ++i) {
+	    printf ("extern module %s_module;\n", pmodules[i])
+	}
+	print ""
+	print "/*"
+	print " *  Modules which implicitly form the"
+	print " *  list of activated modules on startup,"
+	print " *  i.e. these are the modules which are"
+	print " *  initially linked into the Apache processing"
+	print " *  [extendable under run-time via AddModule]"
+	print " */"
+	print "module *ap_prelinked_modules[] = {"
+	for (i = 0; i < n; ++i) {
+	    printf "  &%s_module,\n", modules[i]
+	}
+	print "  NULL"
+	print "};"
+	print ""
+	print "/*"
+	print " *  Modules which initially form the"
+	print " *  list of available modules on startup,"
+	print " *  i.e. these are the modules which are"
+	print " *  initially loaded into the Apache process"
+	print " *  [extendable under run-time via LoadModule]"
+	print " */"
+	print "module *ap_preloaded_modules[] = {"
+	for (i = 0; i < pn; ++i) {
+	    printf "  &%s_module,\n", pmodules[i]
+	}
+	print "  NULL"
+	print "};"
+	print ""
+    }
+EOFM
+$CAT $tmpfile | sed 's/_module//' | awk -f $awkfile > modules.c 
+
+####################################################################
+## figure out which module dir require use to autocreate a Makefile.
+## for these dirs we must not list the object files from the AddModule
+## lines individually since the auto-generated Makefile will create
+## a library called libMODDIR.a for it (MODDIR is the module dir
+## name). We create two variable here:
+##
+##   AUTODIRS   Space separated list of module directories, relative to
+##              src
+##   AUTOLIBS   Space separated list of auto-generated library files
+##
+for moddir in $MODDIRS 
+do
+	if [ -f modules/$moddir/Makefile.tmpl ] ; then
+		AUTODIRS="$AUTODIRS modules/$moddir"
+	fi
+done
+for moddir in $MODDIRS_NO_SO
+do
+	if [ -f modules/$moddir/Makefile.tmpl ] ; then
+		AUTOLIBS="$AUTOLIBS modules/$moddir/lib$moddir.a"
+	fi
+done
+
+####################################################################
+## Add the module targets to the Makefile. Do not add individual object
+## targets for auto-generated directories.
+##
+$CAT > $awkfile <<EOF1
+    BEGIN {
+	split ("$AUTODIRS", tmp, " ")
+EOF1
+$CAT >> $awkfile <<'EOF2'
+	for ( key in tmp ) {
+	    autodirs[tmp[key]] = 1
+	}
+     }
+    /^Module/ { modules[n++] = $3 }
+    /^%Module/ { modules[n++] = $3 }
+    END {
+	print "MODULES= \\"
+	for (i = 0; i < n; ++i) {
+	    split (modules[i], pp, "/")
+	    dir = pp[1] "/" pp[2] 
+	    inthere = 0
+	    for ( tdir in autodirs ) {
+		if (tdir == dir) 
+		    inthere = 1
+	    }
+	    if (inthere == 1)
+		continue
+	    else
+		printf ("  %s \\\n", modules[i])
+	}
+    }
+EOF2
+awk -f $awkfile >>Makefile <$tmpfile
+
+####################################################################
+## Now add the auto-generated library targets.  Need to use awk so we
+## don't hang a continuation on the last line.
+##
+$CAT > $awkfile <<'EOF4'
+    {
+	z = 0
+	split ($0, libs)
+	for ( lib in libs ) {
+	    if (z != 0)
+		printf (" \\\n")
+	    z++
+	    printf ("  %s", libs[lib])
+	}
+    }
+    END {
+	printf ("\n")
+    }
+EOF4
+echo "$AUTOLIBS" | awk -f $awkfile >>Makefile
+echo "" >>Makefile
+
+####################################################################
+## Now add the target for the main Makefile
+##
+echo "SUBDIRS=$SUBDIRS lib modules" >> Makefile
+echo "SUBTARGET=$SUBTARGET" >> Makefile
+echo "SHLIB_SUFFIX_NAME=$SHLIB_SUFFIX_NAME" >> Makefile
+echo "SHMOD_SUFFIX_NAME=$SHMOD_SUFFIX_NAME" >> Makefile
+echo "SHLIB_SUFFIX_LIST=$SHLIB_SUFFIX_LIST" >> Makefile
+echo "SHLIB_EXPORT_FILES=$SHLIB_EXPORT_FILES" >> Makefile
+echo "" >> Makefile
+
+####################################################################
+## Determine GNU Make variant because
+## it uses ugly looking built-in directory walk messages
+## while we are already using our own messages
+##
+if [ "x`${MAKE} -v 2>/dev/null | grep 'GNU Make'`" = "x" ]; then
+	MFLAGS_STATIC=
+else
+	MFLAGS_STATIC=--no-print-directory
+fi
+
+####################################################################
+## Continue building Makefile.config. Fill in all entries except
+## for $LIBS at this point. This implies that anything below
+## can only alter $LIBS
+##
+echo "CFLAGS1=$CFLAGS" >>Makefile.config
+echo "INCLUDES1=$INCLUDES" >>Makefile.config
+echo "LIBS_SHLIB=$LIBS_SHLIB" >>Makefile.config
+echo "LDFLAGS1=$LDFLAGS" >>Makefile.config
+echo "MFLAGS_STATIC=$MFLAGS_STATIC" >>Makefile.config
+echo "REGLIB=$REGLIB" >>Makefile.config
+echo "EXPATLIB=$EXPATLIB" >>Makefile.config
+echo "RANLIB=$RANLIB" >>Makefile.config
+
+####################################################################
+## Some OS-related stuff for the DSO mechanism:
+## Finding the vendor DSO functions
+##
+if [ "x$using_shlib" = "x1" ] ; then
+    DL_LIB=""
+    case $PLAT in
+       ia64-ibm-aix* )
+           DL_LIB="-ldl"
+           ;;
+	*-ibm-aix* )
+	    DL_LIB="-lld"
+	    ;;
+	*-sequent-ptx* )
+	    case $PLAT in
+	        *-sequent-ptx2*)
+	            ;;
+	        *-sequent-ptx4.0*)
+	            ;;
+	        *-sequent-ptx*)
+	            DL_LIB="-ldl"
+	            ;;
+	    esac
+	    ;;
+	*-hp-hpux*)
+	    if ./helpers/TestCompile func shl_load; then
+		:
+	    else
+		if ./helpers/TestCompile lib dld; then
+		    DL_LIB="-ldld"
+		fi
+	    fi
+	    ;;
+	* )
+	    if ./helpers/TestCompile func dlopen; then
+		:
+	    else
+		if ./helpers/TestCompile lib dl; then
+		    DL_LIB="-ldl"
+		fi
+	    fi
+	    ;;
+    esac
+    if [ "x$DL_LIB" != "x" ]; then
+	LIBS="$LIBS $DL_LIB"
+	echo " + using $DL_LIB for vendor DSO support"
+    fi
+fi
+
+####################################################################
+## More building ap_config_auto.h
+##
+## We check the sizeof various data types
+##
+echo " + checking sizeof various data types"
+AP_TYPE_QUAD=`./helpers/TestCompile -r sizeof 'long long'`
+if [ "x$AP_TYPE_QUAD" = "x" ]; then
+    AP_TYPE_QUAD="unknown_quad"
+    AP_LONGEST_LONG="long"
+else
+    AP_LONGEST_LONG="long long"
+fi
+
+echo "" >>$AP_CONFIG_AUTO_H
+echo "/* determine: longest possible integer type */" >>$AP_CONFIG_AUTO_H
+echo "#ifndef AP_LONGEST_LONG" >>$AP_CONFIG_AUTO_H
+echo "#define AP_LONGEST_LONG $AP_LONGEST_LONG" >>$AP_CONFIG_AUTO_H
+echo "#endif" >>$AP_CONFIG_AUTO_H
+
+####################################################################
+## More building ap_config_auto.h
+##
+## Check for availability of isinf() and isnan()
+##
+if ./helpers/TestCompile func isinf ; then
+    echo "" >>$AP_CONFIG_AUTO_H
+    echo "/* determine: isinf() found in libc */ " >>$AP_CONFIG_AUTO_H
+    echo "#ifndef HAVE_ISINF" >>$AP_CONFIG_AUTO_H
+    echo "#define HAVE_ISINF 1" >>$AP_CONFIG_AUTO_H
+    echo "#endif" >>$AP_CONFIG_AUTO_H
+elif ./helpers/TestCompile lib m isinf ; then
+    echo "" >>$AP_CONFIG_AUTO_H
+    echo "/* determine: isinf() found in libm */ " >>$AP_CONFIG_AUTO_H
+    echo "#ifndef HAVE_ISINF" >>$AP_CONFIG_AUTO_H
+    echo "#define HAVE_ISINF 1" >>$AP_CONFIG_AUTO_H
+    echo "#endif" >>$AP_CONFIG_AUTO_H
+    LIBS="$LIBS -lm"
+    ADDED_LM="yes"
+fi
+
+if ./helpers/TestCompile func isnan ; then
+    echo "" >>$AP_CONFIG_AUTO_H
+    echo "/* determine: isnan() found in libc */ " >>$AP_CONFIG_AUTO_H
+    echo "#ifndef HAVE_ISNAN" >>$AP_CONFIG_AUTO_H
+    echo "#define HAVE_ISNAN 1" >>$AP_CONFIG_AUTO_H
+    echo "#endif" >>$AP_CONFIG_AUTO_H
+elif ./helpers/TestCompile lib m isnan ; then
+    echo "" >>$AP_CONFIG_AUTO_H
+    echo "/* determine: isnan() found in libm */ " >>$AP_CONFIG_AUTO_H
+    echo "#ifndef HAVE_ISNAN" >>$AP_CONFIG_AUTO_H
+    echo "#define HAVE_ISNAN 1" >>$AP_CONFIG_AUTO_H
+    echo "#endif" >>$AP_CONFIG_AUTO_H
+    if [ "x$ADDED_LM" != "xyes" ]; then
+        LIBS="$LIBS -lm"
+    fi
+fi
+
+## We check for the endianess of the machine
+##
+AP_BYTE_ORDER=`./helpers/TestCompile -r byteorder`
+if [ "x$AP_BYTE_ORDER" = "x21" ]; then
+    AP_BYTE_ORDER="21" # big endian
+else
+    AP_BYTE_ORDER="12" # little endian
+fi
+
+echo "" >>$AP_CONFIG_AUTO_H
+echo "/* determine: byte order of machine (12: little endian, 21: big endian) */" >>$AP_CONFIG_AUTO_H
+echo "#ifndef AP_BYTE_ORDER" >>$AP_CONFIG_AUTO_H
+echo "#define AP_BYTE_ORDER $AP_BYTE_ORDER" >>$AP_CONFIG_AUTO_H
+echo "#endif" >>$AP_CONFIG_AUTO_H
+
+##
+## Now compare the sizes of off_t to long
+##
+AP_TYPE_OFF_T=`./helpers/TestCompile -r sizeof off_t`
+if [ "x$AP_TYPE_OFF_T" = "x" ]; then
+    AP_TYPE_OFF_T="unknown_off_t"
+fi
+
+AP_TYPE_LONG=`./helpers/TestCompile -r sizeof long`
+if [ "x$AP_TYPE_LONG" = "x" ]; then
+    AP_TYPE_LONG="unknown_long"
+fi
+
+if [ "x$AP_TYPE_OFF_T" != "x$AP_TYPE_LONG" ]; then
+    echo "" >>$AP_CONFIG_AUTO_H
+    echo "/* determine: is off_t a quad */" >>$AP_CONFIG_AUTO_H
+    echo "#ifndef AP_OFF_T_IS_QUAD" >>$AP_CONFIG_AUTO_H
+    echo "#define AP_OFF_T_IS_QUAD 1" >>$AP_CONFIG_AUTO_H
+    echo "#endif" >>$AP_CONFIG_AUTO_H
+else
+    echo "" >>$AP_CONFIG_AUTO_H
+    echo "/* determine: is off_t a quad */" >>$AP_CONFIG_AUTO_H
+    echo "#ifdef AP_OFF_T_IS_QUAD" >>$AP_CONFIG_AUTO_H
+    echo "#undef AP_OFF_T_IS_QUAD" >>$AP_CONFIG_AUTO_H
+    echo "#endif" >>$AP_CONFIG_AUTO_H
+fi
+
+##
+## Now see of void * is as big as a quad (long long)
+##
+AP_TYPE_VOID_P=`./helpers/TestCompile -r sizeof 'void *'`
+if [ "x$AP_TYPE_VOID_P" = "x" ]; then
+    AP_TYPE_VOID_P="unknown_void_p"
+fi
+
+if [ "x$AP_TYPE_VOID_P" = "x$AP_TYPE_QUAD" ]; then
+    echo "" >>$AP_CONFIG_AUTO_H
+    echo "/* determine: is void * a quad */" >>$AP_CONFIG_AUTO_H
+    echo "#ifndef AP_VOID_P_IS_QUAD" >>$AP_CONFIG_AUTO_H
+    echo "#define AP_VOID_P_IS_QUAD 1" >>$AP_CONFIG_AUTO_H
+    echo "#endif" >>$AP_CONFIG_AUTO_H
+else
+    echo "" >>$AP_CONFIG_AUTO_H
+    echo "/* determine: is void * a quad */" >>$AP_CONFIG_AUTO_H
+    echo "#ifdef AP_VOID_P_IS_QUAD" >>$AP_CONFIG_AUTO_H
+    echo "#undef AP_VOID_P_IS_QUAD" >>$AP_CONFIG_AUTO_H
+    echo "#endif" >>$AP_CONFIG_AUTO_H
+fi
+
+####################################################################
+## Finish building ap_config_auto.h
+##
+## We pick out all -D's from CFLAGS and insert them as defines into
+## ap_config_auto.h so they are available to external modules needing to
+## include Apache header files.
+##
+TEXTRA_CFLAGS=`egrep '^EXTRA_CFLAGS=' Makefile.config | tail -1 |\
+	       sed -e 's;^EXTRA_CFLAGS=;;' -e 's;\`.*\`;;'`
+tmpstr=`echo $CFLAGS $TEXTRA_CFLAGS |\
+	sed -e 's;[ 	]\([+-]\);!\1;g' -e 's/\([^\\\]\)"/\1/g' -e 's/\\\"/\"/g'`
+OIFS="$IFS"
+IFS='!'
+for cflag in $tmpstr; do
+    echo "$cflag" >>$tmpconfig
+done
+IFS="$OIFS"
+awk >>$AP_CONFIG_AUTO_H <$tmpconfig '
+    /^-D.*/ {
+	i = index($0, "=")
+	if (i > 0) {
+	    define = substr($0, 3, i-3)
+	    value  = substr($0, i+1, length($0)-i)
+	}
+	else {
+	    define = substr($0, 3, length($0)-2)
+	    value  = "1";
+	}
+	printf ("\n/* build flag: %s */\n", $0)
+	printf ("#ifndef %s\n#define %s %s\n#endif\n", define, define, value)
+    }
+'
+
+# finish header file
+echo "" >>$AP_CONFIG_AUTO_H
+echo "#endif /* AP_CONFIG_AUTO_H */" >>$AP_CONFIG_AUTO_H
+
+####################################################################
+## Finish creating the Makefile.config file
+##
+echo "LIBS1=$modlibs $LIBS">> Makefile.config
+echo "##" >> Makefile.config
+echo "##  (End of automatically generated section)">> Makefile.config
+echo "##" >> Makefile.config
+echo "" >> Makefile.config
+
+####################################################################
+## Use TestCompile to see if $(CC) is ANSI and as a "final" sanity
+## check
+##
+
+if [ "x$OS" = "xTPF" ] ; then
+    :
+else
+   echo " + doing sanity check on compiler and options"
+   if ./helpers/TestCompile $vflag sanity; then
+      :
+   else
+      if [ "x$vflag" = "x-v" ] ; then
+         WHEREERR="above"
+      else
+         WHEREERR="below"
+      fi
+      echo "** A test compilation with your Makefile configuration"
+      echo "** failed.  The $WHEREERR error output from the compilation"
+      echo "** test will give you an idea what is failing. Note that"
+      echo "** Apache requires an ANSI C Compiler, such as gcc. "
+      echo ""
+      echo "======== Error Output for sanity check ========"
+      (./helpers/TestCompile -v sanity) 2>&1
+      echo "============= End of Error Report ============="
+      echo ""
+      echo " Aborting!"
+      exitcode=1
+      exit 1
+   fi
+fi
+
+####################################################################
+## Now (finish) creating the makefiles
+##
+
+# ./Makefile
+$CAT Makefile.config >> Makefile
+sed -e "s#@@Configuration@@#$file#" "Makefile.tmpl" >>Makefile
+
+# xxx/Makefile
+MAKEDIRS="support $SUBDIRS"
+for dir in $MAKEDIRS ; do
+	echo Creating Makefile in $dir
+	./helpers/mfhead $dir $file > $dir/Makefile
+	$CAT Makefile.config $dir/Makefile.tmpl |\
+	sed -e "s:^SRCDIR=.*:SRCDIR=`./helpers/fp2rp $dir`:" >> $dir/Makefile
+done
+
+####################################################################
+## Now create the lib/Makefile
+##
+./helpers/mfhead modules $file > lib/Makefile
+$CAT Makefile.config | sed -e 's:^SRCDIR=.*:SRCDIR=..:' >> lib/Makefile
+
+$CAT << EOF >> lib/Makefile
+APLIBS=$APLIBDIRS
+CFLAGS=\$(OPTIM) \$(CFLAGS1) \$(EXTRA_CFLAGS)
+
+default: all
+
+all clean distclean depend :: 
+	@for i in \$(APLIBS) ""; do \\
+	  if [ "x\$\$i" != "x" ]; then \\
+	    echo "===> \$(SDP)lib/\$\$i"; \\
+		(cd \$\$i && \$(MAKE) \$(MFLAGS_STATIC) SDP='\$(SDP)' CC='\$(CC)' AUX_CFLAGS='\$(CFLAGS)' RANLIB='\$(RANLIB)' \$@) || exit 1; \\
+		echo "<=== \$(SDP)lib/\$\$i"; \\
+	  fi; \\
+	done
+
+EOF
+
+####################################################################
+## Now create the lib/xxx/Makefile
+##
+
+for dir in $APLIBDIRS ; do
+	echo Creating Makefile in lib/$dir
+	./helpers/mfhead lib/$dir $file > lib/$dir/Makefile
+	$CAT Makefile.config lib/$dir/Makefile.tmpl |\
+	sed -e "s:^SRCDIR=.*:SRCDIR=`./helpers/fp2rp lib/$dir`:" >> lib/$dir/Makefile
+done
+
+####################################################################
+## Now create the modules/Makefile
+##
+./helpers/mfhead modules $file > modules/Makefile
+$CAT Makefile.config | sed -e 's:^SRCDIR=.*:SRCDIR=..:' >> modules/Makefile
+
+$CAT << EOF >> modules/Makefile
+MODULES=$MODDIRS
+CFLAGS=\$(OPTIM) \$(CFLAGS1) \$(EXTRA_CFLAGS)
+
+default: all
+
+all clean distclean depend :: 
+	@for i in \$(MODULES) ""; do \\
+	  if [ "x\$\$i" != "x" ]; then \\
+	    echo "===> \$(SDP)modules/\$\$i"; \\
+		case "x\$(OS)" in \\
+		  xOS390 | xTPF) (cd \$\$i && \$(MAKE) SDP='\$(SDP)' OPTIM='\$(OPTIM)' \$@) || exit 1;; \\
+		              *) (cd \$\$i && \$(MAKE) \$(MFLAGS_STATIC) SDP='\$(SDP)' CC='\$(CC)' AUX_CFLAGS='\$(CFLAGS)' RANLIB='\$(RANLIB)' OPTIM='\$(OPTIM)' \$@) || exit 1;; \\
+		esac; \\
+		echo "<=== \$(SDP)modules/\$\$i"; \\
+	  fi; \\
+	done
+
+EOF
+
+####################################################################
+## Now create modules/xxx/Makefile
+##
+for moddir in $AUTODIRS ; do
+	echo "Creating Makefile in $moddir"
+
+    ./helpers/mfhead $moddir $file > $moddir/Makefile
+	$CAT Makefile.config |\
+	sed -e "s:^SRCDIR=.*:SRCDIR=`./helpers/fp2rp $moddir`:" >> $moddir/Makefile
+	$CAT << 'EOF' >> $moddir/Makefile
+##
+##  Default Makefile options from Configure script
+##  (Begin of automatically generated section)
+##
+CFLAGS=$(OPTIM) $(CFLAGS1) $(EXTRA_CFLAGS)
+LIBS=$(EXTRA_LIBS) $(LIBS1)
+INCLUDES=$(INCLUDES1) $(INCLUDES0) $(EXTRA_INCLUDES)
+LDFLAGS=$(LDFLAGS1) $(EXTRA_LDFLAGS)
+INCDIR=$(SRCDIR)/include
+EOF
+	if [ -f $moddir/Makefile.libdir ]; then
+	    basedir=`echo $moddir | sed 's@^[^/]*/@@g'`
+	    awk >> $moddir/Makefile < $tmpfile '
+		($2 ~ /^modules\/'$basedir'\//) {
+		    split($2, pp, "/");
+		    split(pp[3], parts, ".");
+		    libext=parts[2];
+		}
+		END { 
+		    printf "LIBEXT=%s\n", libext;
+		}'
+	    # it's responsible for the rest of its Makefile...
+	else
+	    basedir=`echo $moddir | sed 's@^[^/]*/@@g'`
+	    OBJS=`awk < $tmpfile '
+		($1 == "Module" && $3 ~ /^modules\/'$basedir'\//) { 
+		    split ($3, pp, "/")
+		    printf "%s ", pp[3] 
+		} 
+		'`
+	    echo "OBJS=$OBJS" >> $moddir/Makefile
+	    if [ "x$OBJS" != "x" ]; then
+		echo "LIB=lib$basedir.a" >> $moddir/Makefile
+	    else
+		#   essential!
+		echo "LIB=" >> $moddir/Makefile
+	    fi
+	    awk >> $moddir/Makefile < $tmpfile '
+	    ($1 == "SharedModule" && $2 ~ /^modules\/'$basedir'\//) {
+		split($2, pp, "/")
+		shlibs=shlibs " " pp[3]
+		so=pp[3]
+		split(pp[3], parts, ".")
+		base=parts[1]
+		objspic=objspic " " base ".lo"
+	    }
+	    END { 
+		printf "SHLIBS=%s\n", shlibs;
+		printf "OBJS_PIC=%s\n", objspic;
+	    }'
+
+	    $CAT << 'EOF' >> $moddir/Makefile
+
+all: lib shlib
+
+lib:	$(LIB) 
+
+shlib:	$(SHLIBS)
+
+dummy $(LIB): $(OBJS)
+	rm -f $@
+	ar cr $@ $(OBJS)
+	$(RANLIB) $@
+
+.SUFFIXES: .o .so .dll
+
+.c.o:
+	$(CC) -c $(INCLUDES) $(CFLAGS) $<
+
+.c.so:
+	$(CC) -c $(INCLUDES) $(CFLAGS) $(CFLAGS_SHLIB) $< && mv $*.o $*.lo
+	$(LD_SHLIB) $(LDFLAGS_SHLIB) -o $@ $*.lo $(LIBS_SHLIB)
+
+clean:
+	rm -f $(LIB) $(OBJS) $(SHLIBS) $(OBJS_PIC)
+
+distclean: clean
+	rm -f Makefile
+
+#   NOT FOR END USERS!
+depend:
+	cp Makefile.tmpl Makefile.tmpl.bak \
+	    && sed -ne '1,/^# DO NOT REMOVE/p' Makefile.tmpl > Makefile.new \
+	    && gcc -MM $(INCLUDES) $(CFLAGS) *.c >> Makefile.new \
+	    && sed -e '1,$$s: $(INCDIR)/: $$(INCDIR)/:g' \
+		   -e '1,$$s: $(OSDIR)/: $$(OSDIR)/:g' Makefile.new \
+		> Makefile.tmpl \
+	    && rm Makefile.new
+
+EOF
+	fi
+
+	if [ "x$OS_MODULE_INCLUDE" != "x" ]; then
+		echo "include $OS_MODULE_INCLUDE" >> $moddir/Makefile
+	fi
+
+	$CAT << 'EOF' >> $moddir/Makefile
+##
+##  (End of automatically generated section)
+##
+EOF
+    $CAT >> $moddir/Makefile < $moddir/Makefile.tmpl
+
+done
+
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/Makefile.tmpl apache_1.3.33/src/Makefile.tmpl
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/Makefile.tmpl	Tue Jan 14 22:21:41 2003
+++ apache_1.3.33/src/Makefile.tmpl	Mon Jul 18 15:22:52 2005
@@ -1,5 +1,6 @@
 
 CFLAGS=$(OPTIM) $(CFLAGS1) $(EXTRA_CFLAGS)
+HOSTC_FLAGS=$(CFLAGS)
 LIBS=$(EXTRA_LIBS) $(LIBS1)
 INCLUDES=$(INCLUDES1) $(INCLUDES0) $(EXTRA_INCLUDES)
 LDFLAGS=$(LDFLAGS1) $(EXTRA_LDFLAGS)
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/ap/Makefile.tmpl apache_1.3.33/src/ap/Makefile.tmpl
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/ap/Makefile.tmpl	Tue Jun 18 02:34:35 2002
+++ apache_1.3.33/src/ap/Makefile.tmpl	Mon Jul 18 15:22:25 2005
@@ -7,7 +7,7 @@
 
 OBJS=ap_cpystrn.o ap_execve.o ap_fnmatch.o ap_getpass.o ap_md5c.o ap_signal.o \
      ap_slack.o ap_snprintf.o ap_sha1.o ap_checkpass.o ap_base64.o ap_ebcdic.o \
-     ap_strtol.o
+     ap_strtol.o ap_hook.o ap_ctx.o ap_mm.o
 
 .c.o:
 	$(CC) -c $(INCLUDES) $(CFLAGS) $<
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/ap/ap.mak apache_1.3.33/src/ap/ap.mak
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/ap/ap.mak	Fri May 23 05:39:01 2003
+++ apache_1.3.33/src/ap/ap.mak	Mon Jul 18 15:22:25 2005
@@ -44,6 +44,9 @@
 	-@erase "$(INTDIR)\ap_cpystrn.obj"
 	-@erase "$(INTDIR)\ap_fnmatch.obj"
 	-@erase "$(INTDIR)\ap_md5c.obj"
+	-@erase "$(INTDIR)\ap_hook.obj"
+	-@erase "$(INTDIR)\ap_ctx.obj"
+	-@erase "$(INTDIR)\ap_mm.obj"
 	-@erase "$(INTDIR)\ap_sha1.obj"
 	-@erase "$(INTDIR)\ap_signal.obj"
 	-@erase "$(INTDIR)\ap_slack.obj"
@@ -99,6 +102,9 @@
 	"$(INTDIR)\ap_cpystrn.obj" \
 	"$(INTDIR)\ap_fnmatch.obj" \
 	"$(INTDIR)\ap_md5c.obj" \
+	"$(INTDIR)\ap_hook.obj" \
+	"$(INTDIR)\ap_ctx.obj" \
+	"$(INTDIR)\ap_mm.obj" \
 	"$(INTDIR)\ap_sha1.obj" \
 	"$(INTDIR)\ap_signal.obj" \
 	"$(INTDIR)\ap_slack.obj" \
@@ -128,6 +134,9 @@
 	-@erase "$(INTDIR)\ap_cpystrn.obj"
 	-@erase "$(INTDIR)\ap_fnmatch.obj"
 	-@erase "$(INTDIR)\ap_md5c.obj"
+	-@erase "$(INTDIR)\ap_hook.obj"
+	-@erase "$(INTDIR)\ap_ctx.obj"
+	-@erase "$(INTDIR)\ap_mm.obj"
 	-@erase "$(INTDIR)\ap_sha1.obj"
 	-@erase "$(INTDIR)\ap_signal.obj"
 	-@erase "$(INTDIR)\ap_slack.obj"
@@ -183,6 +192,9 @@
 	"$(INTDIR)\ap_cpystrn.obj" \
 	"$(INTDIR)\ap_fnmatch.obj" \
 	"$(INTDIR)\ap_md5c.obj" \
+	"$(INTDIR)\ap_hook.obj" \
+	"$(INTDIR)\ap_ctx.obj" \
+	"$(INTDIR)\ap_mm.obj" \
 	"$(INTDIR)\ap_sha1.obj" \
 	"$(INTDIR)\ap_signal.obj" \
 	"$(INTDIR)\ap_slack.obj" \
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/ap/ap_ctx.c apache_1.3.33/src/ap/ap_ctx.c
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/ap/ap_ctx.c	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/ap/ap_ctx.c	Mon Jul 18 15:22:20 2005
@@ -0,0 +1,155 @@
+/* ====================================================================
+ * Copyright (c) 1998-2000 The Apache Group.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the Apache Group
+ *    for use in the Apache HTTP server project (http://www.apache.org/)."
+ *
+ * 4. The names "Apache Server" and "Apache Group" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    apache@apache.org.
+ *
+ * 5. Products derived from this software may not be called "Apache"
+ *    nor may "Apache" appear in their names without prior written
+ *    permission of the Apache Group.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the Apache Group
+ *    for use in the Apache HTTP server project (http://www.apache.org/)."
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE APACHE GROUP ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Group and was originally based
+ * on public domain software written at the National Center for
+ * Supercomputing Applications, University of Illinois, Urbana-Champaign.
+ * For more information on the Apache Group and the Apache HTTP server
+ * project, please see <http://www.apache.org/>.
+ *
+ */
+
+/*
+**  Generic Context Interface for Apache
+**  Written by Ralf S. Engelschall <rse@engelschall.com> 
+*/
+
+#ifdef EAPI
+
+#include "httpd.h"
+#include "ap_config.h"
+#include "ap_ctx.h"
+
+API_EXPORT(ap_ctx *) ap_ctx_new(pool *p)
+{
+    ap_ctx *ctx;
+    int i;
+
+    if (p != NULL) {
+        ctx = (ap_ctx *)ap_palloc(p, sizeof(ap_ctx_rec));
+        ctx->cr_pool = p;
+        ctx->cr_entry = (ap_ctx_entry **)
+            ap_palloc(p, sizeof(ap_ctx_entry *)*(AP_CTX_MAX_ENTRIES+1));
+    }
+    else {
+        ctx = (ap_ctx *)malloc(sizeof(ap_ctx_rec));
+        ctx->cr_pool = NULL;
+        ctx->cr_entry = (ap_ctx_entry **)
+            malloc(sizeof(ap_ctx_entry *)*(AP_CTX_MAX_ENTRIES+1));
+    }
+    for (i = 0; i < AP_CTX_MAX_ENTRIES+1; i++) 
+        ctx->cr_entry[i] = NULL;
+    return ctx;
+}
+
+API_EXPORT(void) ap_ctx_set(ap_ctx *ctx, char *key, void *val)
+{
+    int i;
+    ap_ctx_entry *ce;
+
+    ce = NULL;
+    for (i = 0; ctx->cr_entry[i] != NULL; i++) {
+        if (strcmp(ctx->cr_entry[i]->ce_key, key) == 0) {
+            ce = ctx->cr_entry[i];
+            break;
+        }
+    }
+    if (ce == NULL) {
+        if (i == AP_CTX_MAX_ENTRIES)
+            return;
+        if (ctx->cr_pool != NULL) {
+            ce = (ap_ctx_entry *)ap_palloc(ctx->cr_pool, sizeof(ap_ctx_entry));
+            ce->ce_key = ap_pstrdup(ctx->cr_pool, key);
+        }
+        else {
+            ce = (ap_ctx_entry *)malloc(sizeof(ap_ctx_entry));
+            ce->ce_key = strdup(key);
+        }
+        ctx->cr_entry[i] = ce;
+        ctx->cr_entry[i+1] = NULL;
+    }
+    ce->ce_val = val;
+    return;
+}
+
+API_EXPORT(void *) ap_ctx_get(ap_ctx *ctx, char *key)
+{
+    int i;
+
+    for (i = 0; ctx->cr_entry[i] != NULL; i++)
+        if (strcmp(ctx->cr_entry[i]->ce_key, key) == 0)
+            return ctx->cr_entry[i]->ce_val;
+    return NULL;
+}
+
+API_EXPORT(ap_ctx *) ap_ctx_overlay(pool *p, ap_ctx *over, ap_ctx *base)
+{
+    ap_ctx *new;
+    int i;
+
+#ifdef POOL_DEBUG
+    if (p != NULL) {
+        if (!ap_pool_is_ancestor(over->cr_pool, p))
+            ap_log_assert("ap_ctx_overlay: overlay's pool is not an ancestor of p", 
+                          __FILE__, __LINE__);
+        if (!ap_pool_is_ancestor(base->cr_pool, p))
+            ap_log_assert("ap_ctx_overlay: base's pool is not an ancestor of p",
+                          __FILE__, __LINE__);
+    }
+#endif
+    if ((new = ap_ctx_new(p)) == NULL)
+        return NULL;
+    memcpy(new->cr_entry, base->cr_entry, 
+           sizeof(ap_ctx_entry *)*(AP_CTX_MAX_ENTRIES+1));
+    for (i = 0; over->cr_entry[i] != NULL; i++)
+        ap_ctx_set(new, over->cr_entry[i]->ce_key, over->cr_entry[i]->ce_val);
+    return new;
+}
+
+#endif /* EAPI */
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/ap/ap_hook.c apache_1.3.33/src/ap/ap_hook.c
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/ap/ap_hook.c	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/ap/ap_hook.c	Mon Jul 18 15:22:20 2005
@@ -0,0 +1,930 @@
+#if 0
+=pod
+#endif
+/* ====================================================================
+ * Copyright (c) 1998-2000 The Apache Group.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the Apache Group
+ *    for use in the Apache HTTP server project (http://www.apache.org/)."
+ *
+ * 4. The names "Apache Server" and "Apache Group" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    apache@apache.org.
+ *
+ * 5. Products derived from this software may not be called "Apache"
+ *    nor may "Apache" appear in their names without prior written
+ *    permission of the Apache Group.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the Apache Group
+ *    for use in the Apache HTTP server project (http://www.apache.org/)."
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE APACHE GROUP ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Group and was originally based
+ * on public domain software written at the National Center for
+ * Supercomputing Applications, University of Illinois, Urbana-Champaign.
+ * For more information on the Apache Group and the Apache HTTP server
+ * project, please see <http://www.apache.org/>.
+ *
+ */
+
+/*
+**  Implementation of a Generic Hook Interface for Apache
+**  Written by Ralf S. Engelschall <rse@engelschall.com> 
+**
+**  See POD document at end of ap_hook.h for description.
+**  View it with the command ``pod2man ap_hook.h | nroff -man | more''
+**
+**  Attention: This source file is a little bit tricky.
+**             It's a combination of a C source and an embedded Perl script
+**             (which updates the C source). The purpose of this is to have
+**             both things together at one place. So you can both pass
+**             this file to the C compiler and the Perl interpreter.
+*/
+
+                                      /*
+                                       * Premature optimization is 
+                                       * the root of all evil.
+                                       *       -- D. E. Knuth
+                                       */
+
+#ifdef EAPI
+
+#include "httpd.h"
+#include "http_log.h"
+#include "ap_config.h"
+#include "ap_hook.h"
+
+/* 
+ * the internal hook pool
+ */
+static ap_hook_entry **ap_hook_pool = NULL;
+
+/* 
+ * forward prototypes for internal functions
+ */
+static int            ap_hook_call_func(va_list ap, ap_hook_entry *he, ap_hook_func *hf);
+static ap_hook_entry *ap_hook_create(char *hook);
+static ap_hook_entry *ap_hook_find(char *hook);
+static void           ap_hook_destroy(ap_hook_entry *he);
+
+/*
+ * Initialize the hook mechanism
+ */
+API_EXPORT(void) ap_hook_init(void)
+{
+    int i;
+
+    if (ap_hook_pool != NULL)
+        return;
+    ap_hook_pool = (ap_hook_entry **)malloc(sizeof(ap_hook_entry *)
+                                            *(AP_HOOK_MAX_ENTRIES+1));
+    for (i = 0; i < AP_HOOK_MAX_ENTRIES; i++)
+        ap_hook_pool[i] = NULL;
+    return;
+}
+
+/*
+ * Kill the hook mechanism
+ */
+API_EXPORT(void) ap_hook_kill(void)
+{
+    int i;
+
+    if (ap_hook_pool == NULL)
+        return;
+    for (i = 0; ap_hook_pool[i] != NULL; i++)
+        ap_hook_destroy(ap_hook_pool[i]);
+    free(ap_hook_pool);
+    ap_hook_pool = NULL;
+    return;
+}
+    
+/*
+ * Smart creation of a hook (when it exist this is the same as
+ * ap_hook_find, when it doesn't exists it is created)
+ */
+static ap_hook_entry *ap_hook_create(char *hook)
+{
+    int i;
+    ap_hook_entry *he;
+
+    for (i = 0; ap_hook_pool[i] != NULL; i++)
+        if (strcmp(ap_hook_pool[i]->he_hook, hook) == 0)
+            return ap_hook_pool[i];
+
+    if (i >= AP_HOOK_MAX_ENTRIES)
+        return NULL;
+
+    if ((he = (ap_hook_entry *)malloc(sizeof(ap_hook_entry))) == NULL)
+        return NULL;
+    ap_hook_pool[i] = he;
+
+    he->he_hook          = strdup(hook);
+    he->he_sig           = AP_HOOK_SIG_UNKNOWN;
+    he->he_modeid        = AP_HOOK_MODE_UNKNOWN;
+    he->he_modeval.v_int = 0;
+
+    he->he_func = (ap_hook_func **)malloc(sizeof(ap_hook_func *)
+                                          *(AP_HOOK_MAX_FUNCS+1));
+    if (he->he_func == NULL)
+        return FALSE;
+
+    for (i = 0; i < AP_HOOK_MAX_FUNCS; i++)
+        he->he_func[i] = NULL;
+    return he;
+}
+
+/*
+ * Find a particular hook
+ */
+static ap_hook_entry *ap_hook_find(char *hook)
+{
+    int i;
+
+    for (i = 0; ap_hook_pool[i] != NULL; i++)
+        if (strcmp(ap_hook_pool[i]->he_hook, hook) == 0)
+            return ap_hook_pool[i];
+    return NULL;
+}
+
+/*
+ * Destroy a particular hook
+ */
+static void ap_hook_destroy(ap_hook_entry *he)
+{
+    int i;
+
+    if (he == NULL)
+        return;
+    free(he->he_hook);
+    for (i = 0; he->he_func[i] != NULL; i++)
+        free(he->he_func[i]);
+    free(he->he_func);
+    free(he);
+    return;
+}
+
+/*
+ * Configure a particular hook, 
+ * i.e. remember its signature and return value mode
+ */
+API_EXPORT(int) ap_hook_configure(char *hook, ap_hook_sig sig, ap_hook_mode modeid, ...)
+{
+    ap_hook_entry *he;
+    va_list ap;
+    int rc;
+
+    va_start(ap, modeid);
+    if ((he = ap_hook_create(hook)) == NULL)
+        rc = FALSE;
+    else {
+        he->he_sig = sig;
+        he->he_modeid = modeid;
+        if (modeid == AP_HOOK_MODE_DECLINE || modeid == AP_HOOK_MODE_DECLTMP) {
+            if (AP_HOOK_SIG_HAS(sig, RC, char))
+                he->he_modeval.v_char = va_arg(ap, va_type(char));
+            else if (AP_HOOK_SIG_HAS(sig, RC, int))
+                he->he_modeval.v_int = va_arg(ap, va_type(int));
+            else if (AP_HOOK_SIG_HAS(sig, RC, long))
+                he->he_modeval.v_long = va_arg(ap, va_type(long));
+            else if (AP_HOOK_SIG_HAS(sig, RC, float))
+                he->he_modeval.v_float = va_arg(ap, va_type(float));
+            else if (AP_HOOK_SIG_HAS(sig, RC, double))
+                he->he_modeval.v_double = va_arg(ap, va_type(double));
+            else if (AP_HOOK_SIG_HAS(sig, RC, ptr))
+                he->he_modeval.v_ptr = va_arg(ap, va_type(ptr));
+        }
+        rc = TRUE;
+    }
+    va_end(ap);
+    return rc;
+}
+
+/*
+ * Register a function to call for a hook
+ */
+API_EXPORT(int) ap_hook_register_I(char *hook, void *func, void *ctx)
+{
+    int i, j;
+    ap_hook_entry *he;
+    ap_hook_func *hf;
+
+    if ((he = ap_hook_create(hook)) == NULL)
+        return FALSE;
+
+    for (i = 0; he->he_func[i] != NULL; i++)
+        if (he->he_func[i]->hf_ptr == func)
+            return FALSE;
+
+    if (i == AP_HOOK_MAX_FUNCS)
+        return FALSE;
+
+    if ((hf = (ap_hook_func *)malloc(sizeof(ap_hook_func))) == NULL)
+        return FALSE;
+
+    for (j = i; j >= 0; j--)
+        he->he_func[j+1] = he->he_func[j];
+    he->he_func[0] = hf;
+
+    hf->hf_ptr = func;
+    hf->hf_ctx = ctx;
+
+    return TRUE;
+}
+
+/*
+ * Unregister a function to call for a hook
+ */
+API_EXPORT(int) ap_hook_unregister_I(char *hook, void *func)
+{
+    int i, j;
+    ap_hook_entry *he;
+
+    if ((he = ap_hook_find(hook)) == NULL)
+        return FALSE;
+    for (i = 0; he->he_func[i] != NULL; i++) {
+        if (he->he_func[i]->hf_ptr == func) {
+            free(he->he_func[i]);
+            for (j = i; he->he_func[j] != NULL; j++)
+                he->he_func[j] = he->he_func[j+1];
+            return TRUE;
+        }
+    }
+    return FALSE;
+}
+
+/*
+ * Retrieve the status of a particular hook
+ */
+API_EXPORT(ap_hook_state) ap_hook_status(char *hook)
+{
+    ap_hook_entry *he;
+
+    if ((he = ap_hook_find(hook)) == NULL)
+        return AP_HOOK_STATE_NOTEXISTANT;
+    if (   he->he_func[0] != NULL 
+        && he->he_sig != AP_HOOK_SIG_UNKNOWN
+        && he->he_modeid != AP_HOOK_MODE_UNKNOWN)
+        return AP_HOOK_STATE_REGISTERED;
+    if (   he->he_sig != AP_HOOK_SIG_UNKNOWN 
+        && he->he_modeid != AP_HOOK_MODE_UNKNOWN)
+        return AP_HOOK_STATE_CONFIGURED;
+    return AP_HOOK_STATE_ESTABLISHED;
+}
+
+/*
+ * Use a hook, i.e. optional on-the-fly configure it before calling it
+ */
+API_EXPORT(int) ap_hook_use(char *hook, ap_hook_sig sig, ap_hook_mode modeid, ...)
+{
+    int i;
+    ap_hook_value modeval;
+    ap_hook_entry *he;
+    va_list ap;
+    int rc;
+
+    va_start(ap, modeid);
+
+    if (modeid == AP_HOOK_MODE_DECLINE || modeid == AP_HOOK_MODE_DECLTMP) {
+        if (AP_HOOK_SIG_HAS(sig, RC, char))
+            modeval.v_char = va_arg(ap, va_type(char));
+        else if (AP_HOOK_SIG_HAS(sig, RC, int))
+            modeval.v_int = va_arg(ap, va_type(int));
+        else if (AP_HOOK_SIG_HAS(sig, RC, long))
+            modeval.v_long = va_arg(ap, va_type(long));
+        else if (AP_HOOK_SIG_HAS(sig, RC, float))
+            modeval.v_float = va_arg(ap, va_type(float));
+        else if (AP_HOOK_SIG_HAS(sig, RC, double))
+            modeval.v_double = va_arg(ap, va_type(double));
+        else if (AP_HOOK_SIG_HAS(sig, RC, ptr))
+            modeval.v_ptr = va_arg(ap, va_type(ptr));
+    }
+
+    if ((he = ap_hook_create(hook)) == NULL)
+        return FALSE;
+
+    if (he->he_sig == AP_HOOK_SIG_UNKNOWN)
+        he->he_sig = sig;
+    if (he->he_modeid == AP_HOOK_MODE_UNKNOWN) {
+        he->he_modeid  = modeid;
+        he->he_modeval = modeval;
+    }
+
+    for (i = 0; he->he_func[i] != NULL; i++)
+        if (ap_hook_call_func(ap, he, he->he_func[i]))
+            break;
+
+    if (i > 0 && he->he_modeid == AP_HOOK_MODE_ALL)
+        rc = TRUE;
+    else if (i == AP_HOOK_MAX_FUNCS || he->he_func[i] == NULL)
+        rc = FALSE;
+    else
+        rc = TRUE;
+
+    va_end(ap);
+    return rc;
+}
+
+/*
+ * Call a hook
+ */
+API_EXPORT(int) ap_hook_call(char *hook, ...)
+{
+    int i;
+    ap_hook_entry *he;
+    va_list ap;
+    int rc;
+    
+    va_start(ap, hook);
+
+    if ((he = ap_hook_find(hook)) == NULL) {
+        va_end(ap);
+        return FALSE;
+    }
+    if (   he->he_sig == AP_HOOK_SIG_UNKNOWN
+        || he->he_modeid == AP_HOOK_MODE_UNKNOWN) {
+        va_end(ap);
+        return FALSE;
+    }
+
+    for (i = 0; he->he_func[i] != NULL; i++)
+        if (ap_hook_call_func(ap, he, he->he_func[i]))
+            break;
+
+    if (i > 0 && he->he_modeid == AP_HOOK_MODE_ALL)
+        rc = TRUE;
+    else if (i == AP_HOOK_MAX_FUNCS || he->he_func[i] == NULL)
+        rc = FALSE;
+    else
+        rc = TRUE;
+
+    va_end(ap);
+    return rc;
+}
+
+static int ap_hook_call_func(va_list ap, ap_hook_entry *he, ap_hook_func *hf)
+{
+    void *v_rc;
+    ap_hook_value v_tmp;
+    int rc;
+
+    /*
+     * Now we dispatch the various function calls. We support function
+     * signatures with up to 9 types (1 return type, 8 argument types) where
+     * each argument can have 7 different types (ctx, char, int, long, float,
+     * double, ptr), so theoretically there are 9^7 (=4782969) combinations
+     * possible.  But because we don't need all of them, of course, we
+     * implement only the following well chosen subset (duplicates are ok):
+     *
+     * 1. `The basic hook'.
+     *
+     *    void func()
+     *
+     * 2. The standard set of signatures which form all combinations of
+     *    int&ptr based signatures for up to 3 arguments. We provide
+     *    them per default for module authors.
+     *
+     *    int func()
+     *    ptr func()
+     *    int func(int)
+     *    int func(ptr)
+     *    ptr func(int)
+     *    ptr func(ptr)
+     *    int func(int,int)
+     *    int func(int,ptr)
+     *    int func(ptr,int)
+     *    int func(ptr,ptr)
+     *    ptr func(int,int)
+     *    ptr func(int,ptr)
+     *    ptr func(ptr,int)
+     *    ptr func(ptr,ptr)
+     *    int func(int,int,int)
+     *    int func(int,int,ptr)
+     *    int func(int,ptr,int)
+     *    int func(int,ptr,ptr)
+     *    int func(ptr,int,int)
+     *    int func(ptr,int,ptr)
+     *    int func(ptr,ptr,int)
+     *    int func(ptr,ptr,ptr)
+     *    ptr func(int,int,int)
+     *    ptr func(int,int,ptr)
+     *    ptr func(int,ptr,int)
+     *    ptr func(int,ptr,ptr)
+     *    ptr func(ptr,int,int)
+     *    ptr func(ptr,int,ptr)
+     *    ptr func(ptr,ptr,int)
+     *    ptr func(ptr,ptr,ptr)
+     *
+     * 3. Actually currently used hooks.
+     *
+     *    int   func(ptr)                          [2x]
+     *    int   func(ptr,ptr)                      [2x]
+     *    int   func(ptr,ptr,int)                  [5x]
+     *    int   func(ptr,ptr,ptr,int)              [1x]
+     *    int   func(ptr,ptr,ptr,int,ptr)          [1x]
+     *    int   func(ptr,ptr,ptr,ptr,int)          [1x]
+     *    int   func(ptr,ptr,ptr,ptr,int,ptr)      [1x]
+     *    ptr   func(ptr,ptr)                      [3x]
+     *    ptr   func(ptr,ptr,ptr,ptr,ptr)          [1x]
+     *    void  func(ptr)                          [2x]
+     *    void  func(ptr,int,int)                  [1x]
+     *    void  func(ptr,ptr)                      [5x]
+     *    void  func(ptr,ptr,ptr)                  [3x]
+     *    void  func(ptr,ptr,ptr,ptr)              [2x]
+     *
+     * To simplify the programming task we generate the actual dispatch code
+     * for these calls via the embedded Perl script at the end of this source
+     * file. This script parses the above lines and generates the section
+     * below.  So, when you need more signature variants just add them to the
+     * above list and run
+     *
+     *     $ perl ap_hook.c
+     *
+     * This automatically updates the above code.
+     */
+
+    rc = TRUE;
+    v_rc = NULL;
+    if (!AP_HOOK_SIG_HAS(he->he_sig, RC, void)) {
+        if (he->he_modeid == AP_HOOK_MODE_DECLTMP) {
+            /* the return variable is a temporary one */ 
+            if (AP_HOOK_SIG_HAS(he->he_sig, RC, char))
+                v_rc = &v_tmp.v_char;
+            else if (AP_HOOK_SIG_HAS(he->he_sig, RC, int))
+                v_rc = &v_tmp.v_int;
+            else if (AP_HOOK_SIG_HAS(he->he_sig, RC, long))
+                v_rc = &v_tmp.v_long;
+            else if (AP_HOOK_SIG_HAS(he->he_sig, RC, float))
+                v_rc = &v_tmp.v_float;
+            else if (AP_HOOK_SIG_HAS(he->he_sig, RC, double))
+                v_rc = &v_tmp.v_double;
+            else if (AP_HOOK_SIG_HAS(he->he_sig, RC, ptr))
+                v_rc = &v_tmp.v_ptr;
+        }
+        else {
+            /* the return variable is provided by caller */ 
+            v_rc = va_arg(ap, void *);
+        }
+    }
+
+    /* ----BEGIN GENERATED SECTION-------- */
+    if (he->he_sig == AP_HOOK_SIG1(void)) {
+        /* Call: void func() */
+        ((void(*)())(hf->hf_ptr))();
+    }
+    else if (he->he_sig == AP_HOOK_SIG1(int)) {
+        /* Call: int func() */
+        *((int *)v_rc) = ((int(*)())(hf->hf_ptr))();
+        rc = (*((int *)v_rc) != he->he_modeval.v_int);
+    }
+    else if (he->he_sig == AP_HOOK_SIG1(ptr)) {
+        /* Call: ptr func() */
+        *((void * *)v_rc) = ((void *(*)())(hf->hf_ptr))();
+        rc = (*((void * *)v_rc) != he->he_modeval.v_ptr);
+    }
+    else if (he->he_sig == AP_HOOK_SIG2(int, int)) {
+        /* Call: int func(int) */
+        int   v1 = va_arg(ap, va_type(int));
+        *((int *)v_rc) = ((int(*)(int))(hf->hf_ptr))(v1);
+        rc = (*((int *)v_rc) != he->he_modeval.v_int);
+    }
+    else if (he->he_sig == AP_HOOK_SIG2(int, ptr)) {
+        /* Call: int func(ptr) */
+        void *v1 = va_arg(ap, va_type(ptr));
+        *((int *)v_rc) = ((int(*)(void *))(hf->hf_ptr))(v1);
+        rc = (*((int *)v_rc) != he->he_modeval.v_int);
+    }
+    else if (he->he_sig == AP_HOOK_SIG2(ptr, int)) {
+        /* Call: ptr func(int) */
+        int   v1 = va_arg(ap, va_type(int));
+        *((void * *)v_rc) = ((void *(*)(int))(hf->hf_ptr))(v1);
+        rc = (*((void * *)v_rc) != he->he_modeval.v_ptr);
+    }
+    else if (he->he_sig == AP_HOOK_SIG2(ptr, ptr)) {
+        /* Call: ptr func(ptr) */
+        void *v1 = va_arg(ap, va_type(ptr));
+        *((void * *)v_rc) = ((void *(*)(void *))(hf->hf_ptr))(v1);
+        rc = (*((void * *)v_rc) != he->he_modeval.v_ptr);
+    }
+    else if (he->he_sig == AP_HOOK_SIG3(int, int, int)) {
+        /* Call: int func(int,int) */
+        int   v1 = va_arg(ap, va_type(int));
+        int   v2 = va_arg(ap, va_type(int));
+        *((int *)v_rc) = ((int(*)(int, int))(hf->hf_ptr))(v1, v2);
+        rc = (*((int *)v_rc) != he->he_modeval.v_int);
+    }
+    else if (he->he_sig == AP_HOOK_SIG3(int, int, ptr)) {
+        /* Call: int func(int,ptr) */
+        int   v1 = va_arg(ap, va_type(int));
+        void *v2 = va_arg(ap, va_type(ptr));
+        *((int *)v_rc) = ((int(*)(int, void *))(hf->hf_ptr))(v1, v2);
+        rc = (*((int *)v_rc) != he->he_modeval.v_int);
+    }
+    else if (he->he_sig == AP_HOOK_SIG3(int, ptr, int)) {
+        /* Call: int func(ptr,int) */
+        void *v1 = va_arg(ap, va_type(ptr));
+        int   v2 = va_arg(ap, va_type(int));
+        *((int *)v_rc) = ((int(*)(void *, int))(hf->hf_ptr))(v1, v2);
+        rc = (*((int *)v_rc) != he->he_modeval.v_int);
+    }
+    else if (he->he_sig == AP_HOOK_SIG3(int, ptr, ptr)) {
+        /* Call: int func(ptr,ptr) */
+        void *v1 = va_arg(ap, va_type(ptr));
+        void *v2 = va_arg(ap, va_type(ptr));
+        *((int *)v_rc) = ((int(*)(void *, void *))(hf->hf_ptr))(v1, v2);
+        rc = (*((int *)v_rc) != he->he_modeval.v_int);
+    }
+    else if (he->he_sig == AP_HOOK_SIG3(ptr, int, int)) {
+        /* Call: ptr func(int,int) */
+        int   v1 = va_arg(ap, va_type(int));
+        int   v2 = va_arg(ap, va_type(int));
+        *((void * *)v_rc) = ((void *(*)(int, int))(hf->hf_ptr))(v1, v2);
+        rc = (*((void * *)v_rc) != he->he_modeval.v_ptr);
+    }
+    else if (he->he_sig == AP_HOOK_SIG3(ptr, int, ptr)) {
+        /* Call: ptr func(int,ptr) */
+        int   v1 = va_arg(ap, va_type(int));
+        void *v2 = va_arg(ap, va_type(ptr));
+        *((void * *)v_rc) = ((void *(*)(int, void *))(hf->hf_ptr))(v1, v2);
+        rc = (*((void * *)v_rc) != he->he_modeval.v_ptr);
+    }
+    else if (he->he_sig == AP_HOOK_SIG3(ptr, ptr, int)) {
+        /* Call: ptr func(ptr,int) */
+        void *v1 = va_arg(ap, va_type(ptr));
+        int   v2 = va_arg(ap, va_type(int));
+        *((void * *)v_rc) = ((void *(*)(void *, int))(hf->hf_ptr))(v1, v2);
+        rc = (*((void * *)v_rc) != he->he_modeval.v_ptr);
+    }
+    else if (he->he_sig == AP_HOOK_SIG3(ptr, ptr, ptr)) {
+        /* Call: ptr func(ptr,ptr) */
+        void *v1 = va_arg(ap, va_type(ptr));
+        void *v2 = va_arg(ap, va_type(ptr));
+        *((void * *)v_rc) = ((void *(*)(void *, void *))(hf->hf_ptr))(v1, v2);
+        rc = (*((void * *)v_rc) != he->he_modeval.v_ptr);
+    }
+    else if (he->he_sig == AP_HOOK_SIG4(int, int, int, int)) {
+        /* Call: int func(int,int,int) */
+        int   v1 = va_arg(ap, va_type(int));
+        int   v2 = va_arg(ap, va_type(int));
+        int   v3 = va_arg(ap, va_type(int));
+        *((int *)v_rc) = ((int(*)(int, int, int))(hf->hf_ptr))(v1, v2, v3);
+        rc = (*((int *)v_rc) != he->he_modeval.v_int);
+    }
+    else if (he->he_sig == AP_HOOK_SIG4(int, int, int, ptr)) {
+        /* Call: int func(int,int,ptr) */
+        int   v1 = va_arg(ap, va_type(int));
+        int   v2 = va_arg(ap, va_type(int));
+        void *v3 = va_arg(ap, va_type(ptr));
+        *((int *)v_rc) = ((int(*)(int, int, void *))(hf->hf_ptr))(v1, v2, v3);
+        rc = (*((int *)v_rc) != he->he_modeval.v_int);
+    }
+    else if (he->he_sig == AP_HOOK_SIG4(int, int, ptr, int)) {
+        /* Call: int func(int,ptr,int) */
+        int   v1 = va_arg(ap, va_type(int));
+        void *v2 = va_arg(ap, va_type(ptr));
+        int   v3 = va_arg(ap, va_type(int));
+        *((int *)v_rc) = ((int(*)(int, void *, int))(hf->hf_ptr))(v1, v2, v3);
+        rc = (*((int *)v_rc) != he->he_modeval.v_int);
+    }
+    else if (he->he_sig == AP_HOOK_SIG4(int, int, ptr, ptr)) {
+        /* Call: int func(int,ptr,ptr) */
+        int   v1 = va_arg(ap, va_type(int));
+        void *v2 = va_arg(ap, va_type(ptr));
+        void *v3 = va_arg(ap, va_type(ptr));
+        *((int *)v_rc) = ((int(*)(int, void *, void *))(hf->hf_ptr))(v1, v2, v3);
+        rc = (*((int *)v_rc) != he->he_modeval.v_int);
+    }
+    else if (he->he_sig == AP_HOOK_SIG4(int, ptr, int, int)) {
+        /* Call: int func(ptr,int,int) */
+        void *v1 = va_arg(ap, va_type(ptr));
+        int   v2 = va_arg(ap, va_type(int));
+        int   v3 = va_arg(ap, va_type(int));
+        *((int *)v_rc) = ((int(*)(void *, int, int))(hf->hf_ptr))(v1, v2, v3);
+        rc = (*((int *)v_rc) != he->he_modeval.v_int);
+    }
+    else if (he->he_sig == AP_HOOK_SIG4(int, ptr, int, ptr)) {
+        /* Call: int func(ptr,int,ptr) */
+        void *v1 = va_arg(ap, va_type(ptr));
+        int   v2 = va_arg(ap, va_type(int));
+        void *v3 = va_arg(ap, va_type(ptr));
+        *((int *)v_rc) = ((int(*)(void *, int, void *))(hf->hf_ptr))(v1, v2, v3);
+        rc = (*((int *)v_rc) != he->he_modeval.v_int);
+    }
+    else if (he->he_sig == AP_HOOK_SIG4(int, ptr, ptr, int)) {
+        /* Call: int func(ptr,ptr,int) */
+        void *v1 = va_arg(ap, va_type(ptr));
+        void *v2 = va_arg(ap, va_type(ptr));
+        int   v3 = va_arg(ap, va_type(int));
+        *((int *)v_rc) = ((int(*)(void *, void *, int))(hf->hf_ptr))(v1, v2, v3);
+        rc = (*((int *)v_rc) != he->he_modeval.v_int);
+    }
+    else if (he->he_sig == AP_HOOK_SIG4(int, ptr, ptr, ptr)) {
+        /* Call: int func(ptr,ptr,ptr) */
+        void *v1 = va_arg(ap, va_type(ptr));
+        void *v2 = va_arg(ap, va_type(ptr));
+        void *v3 = va_arg(ap, va_type(ptr));
+        *((int *)v_rc) = ((int(*)(void *, void *, void *))(hf->hf_ptr))(v1, v2, v3);
+        rc = (*((int *)v_rc) != he->he_modeval.v_int);
+    }
+    else if (he->he_sig == AP_HOOK_SIG4(ptr, int, int, int)) {
+        /* Call: ptr func(int,int,int) */
+        int   v1 = va_arg(ap, va_type(int));
+        int   v2 = va_arg(ap, va_type(int));
+        int   v3 = va_arg(ap, va_type(int));
+        *((void * *)v_rc) = ((void *(*)(int, int, int))(hf->hf_ptr))(v1, v2, v3);
+        rc = (*((void * *)v_rc) != he->he_modeval.v_ptr);
+    }
+    else if (he->he_sig == AP_HOOK_SIG4(ptr, int, int, ptr)) {
+        /* Call: ptr func(int,int,ptr) */
+        int   v1 = va_arg(ap, va_type(int));
+        int   v2 = va_arg(ap, va_type(int));
+        void *v3 = va_arg(ap, va_type(ptr));
+        *((void * *)v_rc) = ((void *(*)(int, int, void *))(hf->hf_ptr))(v1, v2, v3);
+        rc = (*((void * *)v_rc) != he->he_modeval.v_ptr);
+    }
+    else if (he->he_sig == AP_HOOK_SIG4(ptr, int, ptr, int)) {
+        /* Call: ptr func(int,ptr,int) */
+        int   v1 = va_arg(ap, va_type(int));
+        void *v2 = va_arg(ap, va_type(ptr));
+        int   v3 = va_arg(ap, va_type(int));
+        *((void * *)v_rc) = ((void *(*)(int, void *, int))(hf->hf_ptr))(v1, v2, v3);
+        rc = (*((void * *)v_rc) != he->he_modeval.v_ptr);
+    }
+    else if (he->he_sig == AP_HOOK_SIG4(ptr, int, ptr, ptr)) {
+        /* Call: ptr func(int,ptr,ptr) */
+        int   v1 = va_arg(ap, va_type(int));
+        void *v2 = va_arg(ap, va_type(ptr));
+        void *v3 = va_arg(ap, va_type(ptr));
+        *((void * *)v_rc) = ((void *(*)(int, void *, void *))(hf->hf_ptr))(v1, v2, v3);
+        rc = (*((void * *)v_rc) != he->he_modeval.v_ptr);
+    }
+    else if (he->he_sig == AP_HOOK_SIG4(ptr, ptr, int, int)) {
+        /* Call: ptr func(ptr,int,int) */
+        void *v1 = va_arg(ap, va_type(ptr));
+        int   v2 = va_arg(ap, va_type(int));
+        int   v3 = va_arg(ap, va_type(int));
+        *((void * *)v_rc) = ((void *(*)(void *, int, int))(hf->hf_ptr))(v1, v2, v3);
+        rc = (*((void * *)v_rc) != he->he_modeval.v_ptr);
+    }
+    else if (he->he_sig == AP_HOOK_SIG4(ptr, ptr, int, ptr)) {
+        /* Call: ptr func(ptr,int,ptr) */
+        void *v1 = va_arg(ap, va_type(ptr));
+        int   v2 = va_arg(ap, va_type(int));
+        void *v3 = va_arg(ap, va_type(ptr));
+        *((void * *)v_rc) = ((void *(*)(void *, int, void *))(hf->hf_ptr))(v1, v2, v3);
+        rc = (*((void * *)v_rc) != he->he_modeval.v_ptr);
+    }
+    else if (he->he_sig == AP_HOOK_SIG4(ptr, ptr, ptr, int)) {
+        /* Call: ptr func(ptr,ptr,int) */
+        void *v1 = va_arg(ap, va_type(ptr));
+        void *v2 = va_arg(ap, va_type(ptr));
+        int   v3 = va_arg(ap, va_type(int));
+        *((void * *)v_rc) = ((void *(*)(void *, void *, int))(hf->hf_ptr))(v1, v2, v3);
+        rc = (*((void * *)v_rc) != he->he_modeval.v_ptr);
+    }
+    else if (he->he_sig == AP_HOOK_SIG4(ptr, ptr, ptr, ptr)) {
+        /* Call: ptr func(ptr,ptr,ptr) */
+        void *v1 = va_arg(ap, va_type(ptr));
+        void *v2 = va_arg(ap, va_type(ptr));
+        void *v3 = va_arg(ap, va_type(ptr));
+        *((void * *)v_rc) = ((void *(*)(void *, void *, void *))(hf->hf_ptr))(v1, v2, v3);
+        rc = (*((void * *)v_rc) != he->he_modeval.v_ptr);
+    }
+    else if (he->he_sig == AP_HOOK_SIG5(int, ptr, ptr, ptr, int)) {
+        /* Call: int func(ptr,ptr,ptr,int) */
+        void *v1 = va_arg(ap, va_type(ptr));
+        void *v2 = va_arg(ap, va_type(ptr));
+        void *v3 = va_arg(ap, va_type(ptr));
+        int   v4 = va_arg(ap, va_type(int));
+        *((int *)v_rc) = ((int(*)(void *, void *, void *, int))(hf->hf_ptr))(v1, v2, v3, v4);
+        rc = (*((int *)v_rc) != he->he_modeval.v_int);
+    }
+    else if (he->he_sig == AP_HOOK_SIG6(int, ptr, ptr, ptr, int, ptr)) {
+        /* Call: int func(ptr,ptr,ptr,int,ptr) */
+        void *v1 = va_arg(ap, va_type(ptr));
+        void *v2 = va_arg(ap, va_type(ptr));
+        void *v3 = va_arg(ap, va_type(ptr));
+        int   v4 = va_arg(ap, va_type(int));
+        void *v5 = va_arg(ap, va_type(ptr));
+        *((int *)v_rc) = ((int(*)(void *, void *, void *, int, void *))(hf->hf_ptr))(v1, v2, v3, v4, v5);
+        rc = (*((int *)v_rc) != he->he_modeval.v_int);
+    }
+    else if (he->he_sig == AP_HOOK_SIG6(int, ptr, ptr, ptr, ptr, int)) {
+        /* Call: int func(ptr,ptr,ptr,ptr,int) */
+        void *v1 = va_arg(ap, va_type(ptr));
+        void *v2 = va_arg(ap, va_type(ptr));
+        void *v3 = va_arg(ap, va_type(ptr));
+        void *v4 = va_arg(ap, va_type(ptr));
+        int   v5 = va_arg(ap, va_type(int));
+        *((int *)v_rc) = ((int(*)(void *, void *, void *, void *, int))(hf->hf_ptr))(v1, v2, v3, v4, v5);
+        rc = (*((int *)v_rc) != he->he_modeval.v_int);
+    }
+    else if (he->he_sig == AP_HOOK_SIG7(int, ptr, ptr, ptr, ptr, int, ptr)) {
+        /* Call: int func(ptr,ptr,ptr,ptr,int,ptr) */
+        void *v1 = va_arg(ap, va_type(ptr));
+        void *v2 = va_arg(ap, va_type(ptr));
+        void *v3 = va_arg(ap, va_type(ptr));
+        void *v4 = va_arg(ap, va_type(ptr));
+        int   v5 = va_arg(ap, va_type(int));
+        void *v6 = va_arg(ap, va_type(ptr));
+        *((int *)v_rc) = ((int(*)(void *, void *, void *, void *, int, void *))(hf->hf_ptr))(v1, v2, v3, v4, v5, v6);
+        rc = (*((int *)v_rc) != he->he_modeval.v_int);
+    }
+    else if (he->he_sig == AP_HOOK_SIG6(ptr, ptr, ptr, ptr, ptr, ptr)) {
+        /* Call: ptr func(ptr,ptr,ptr,ptr,ptr) */
+        void *v1 = va_arg(ap, va_type(ptr));
+        void *v2 = va_arg(ap, va_type(ptr));
+        void *v3 = va_arg(ap, va_type(ptr));
+        void *v4 = va_arg(ap, va_type(ptr));
+        void *v5 = va_arg(ap, va_type(ptr));
+        *((void * *)v_rc) = ((void *(*)(void *, void *, void *, void *, void *))(hf->hf_ptr))(v1, v2, v3, v4, v5);
+        rc = (*((void * *)v_rc) != he->he_modeval.v_ptr);
+    }
+    else if (he->he_sig == AP_HOOK_SIG2(void, ptr)) {
+        /* Call: void func(ptr) */
+        void *v1 = va_arg(ap, va_type(ptr));
+        ((void(*)(void *))(hf->hf_ptr))(v1);
+    }
+    else if (he->he_sig == AP_HOOK_SIG4(void, ptr, int, int)) {
+        /* Call: void func(ptr,int,int) */
+        void *v1 = va_arg(ap, va_type(ptr));
+        int   v2 = va_arg(ap, va_type(int));
+        int   v3 = va_arg(ap, va_type(int));
+        ((void(*)(void *, int, int))(hf->hf_ptr))(v1, v2, v3);
+    }
+    else if (he->he_sig == AP_HOOK_SIG3(void, ptr, ptr)) {
+        /* Call: void func(ptr,ptr) */
+        void *v1 = va_arg(ap, va_type(ptr));
+        void *v2 = va_arg(ap, va_type(ptr));
+        ((void(*)(void *, void *))(hf->hf_ptr))(v1, v2);
+    }
+    else if (he->he_sig == AP_HOOK_SIG4(void, ptr, ptr, ptr)) {
+        /* Call: void func(ptr,ptr,ptr) */
+        void *v1 = va_arg(ap, va_type(ptr));
+        void *v2 = va_arg(ap, va_type(ptr));
+        void *v3 = va_arg(ap, va_type(ptr));
+        ((void(*)(void *, void *, void *))(hf->hf_ptr))(v1, v2, v3);
+    }
+    else if (he->he_sig == AP_HOOK_SIG5(void, ptr, ptr, ptr, ptr)) {
+        /* Call: void func(ptr,ptr,ptr,ptr) */
+        void *v1 = va_arg(ap, va_type(ptr));
+        void *v2 = va_arg(ap, va_type(ptr));
+        void *v3 = va_arg(ap, va_type(ptr));
+        void *v4 = va_arg(ap, va_type(ptr));
+        ((void(*)(void *, void *, void *, void *))(hf->hf_ptr))(v1, v2, v3, v4);
+    }
+    /* ----END GENERATED SECTION---------- */
+    else
+        ap_log_assert("hook signature not implemented", __FILE__, __LINE__);
+
+    if (he->he_modeid == AP_HOOK_MODE_ALL)
+        rc = FALSE;
+    else if (he->he_modeid == AP_HOOK_MODE_TOPMOST)
+        rc = TRUE;
+
+    return rc;
+}
+
+#endif /* EAPI */
+
+/*
+=cut
+##
+##  Embedded Perl script for generating the dispatch section
+##
+
+require 5.003;
+use strict;
+
+#   configuration
+my $file  = $0;
+my $begin = '----BEGIN GENERATED SECTION--------';
+my $end   = '----END GENERATED SECTION----------';
+
+#   special command: find used signatures
+if ($ARGV[0] eq 'used') {
+    my @S = `find .. -type f -name "*.c" -print`;
+    my $s;
+    my %T = ();
+    foreach $s (@S) {
+        $s =~ s|\n$||;
+        open(FP, "<$s") || die;
+        my $source = '';
+        $source .= $_ while (<FP>);
+        close(FP);
+        my %seen = ();
+        sub printme {
+            my ($src, $hook, $sig) = @_;
+            return if ($seen{$hook} == 1);
+            $seen{$hook} = 1;
+            my ($rc, $args) = ($sig =~ m|^([^,]+)(.*)$|);
+            $args =~ s|^,||;
+            $src =~ s|^.+/||;
+            my $sig = sprintf("%-6sfunc(%s)", $rc, $args);
+            $T{$sig}++; 
+        }
+        $source =~ s|\("([^"]+)",\s*AP_HOOK_SIG[0-9]\((.+?)\)|&printme($s, $1, $2), ''|sge;
+    }
+    my $t;
+    foreach $t (sort(keys(%T))) {
+        printf("     *    %-40s [%dx]\n", $t, $T{$t});
+    }
+    exit(0);
+}
+
+#   read ourself and keep a backup
+open(FP, "<$file") || die;
+my $source = '';
+$source .= $_ while (<FP>);
+close(FP);
+open(FP, ">$file.bak") || die;
+print FP $source;
+close(FP);
+
+#   now parse the signature lines and update the code
+my $o = '';
+my $next = 0;
+my $line;
+my %seen = ();
+foreach $line (split(/\n/, $source)) {
+    next if (not $line =~ m|\*\s+\S+\s+func\(.*\)|);
+    my ($sig, $rc, $param) = ($line =~ m|\*\s+((\S+)\s+func\((.*?)\))|);
+    $sig =~ s|\s+| |g;
+
+    next if ($seen{$sig} == 1);
+    $seen{$sig} = 1;
+
+    print "Generating code for `$sig'\n";
+
+    my @S = ($rc, split(/[\s,]+/, $param));
+    my @RS = @S;
+    my $i;
+    for ($i = 0; $i <= $#RS; $i++) {
+        $RS[$i] = 'void *' if ($RS[$i] eq 'ptr');
+        $RS[$i] = 'void *' if ($RS[$i] eq 'ctx');
+    }
+
+    $o .= "else " if ($next); $next++;
+    $o .= sprintf("if (he->he_sig == AP_HOOK_SIG%d(%s)) {\n", $#S+1, join(', ',@S));
+    $o .= sprintf("    \/\* Call: %s \*\/\n", $sig);
+    for ($i = 1; $i <= $#S; $i++) {
+        $o .= sprintf("    %-6sv%d = va_arg(ap, va_type(%s));\n", $RS[$i], $i, $S[$i]);
+    }
+    $o .= "    ";
+    $o .= sprintf("*((%s *)v_rc) = ", $RS[0]) if ($S[0] ne 'void');
+    $o .= sprintf("((%s(*)(%s))(hf->hf_ptr))", $RS[0], join(', ', @RS[1..$#RS]));
+    $o .= "(";
+    for ($i = 1; $i <= $#S; $i++) {
+        $o .= "hf->hf_ctx" if ($S[$i] eq 'ctx');
+        $o .= sprintf("v%d", $i) if ($S[$i] ne 'ctx');
+        $o .= ", " if ($i < $#S);
+    }
+    $o .= ");\n";
+    $o .= sprintf("    rc = (*((%s *)v_rc) != he->he_modeval.v_%s);\n", 
+                  $RS[0], $S[0]) if ($S[0] ne 'void');
+    $o .= "}\n";
+}
+
+#   insert the generated code at the target location
+$o =~ s|^|    |mg;
+$source =~ s|(\/\* $begin.+?\n).*\n(.*?\/\* $end)|$1$o$2|s;
+
+#   and update the source on disk
+print "Updating file `$file'\n";
+open(FP, ">$file") || die;
+print FP $source;
+close(FP);
+
+=pod
+*/
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/ap/ap_mm.c apache_1.3.33/src/ap/ap_mm.c
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/ap/ap_mm.c	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/ap/ap_mm.c	Mon Jul 18 15:22:20 2005
@@ -0,0 +1,178 @@
+/* ====================================================================
+ * Copyright (c) 1999-2000 The Apache Group.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the Apache Group
+ *    for use in the Apache HTTP server project (http://www.apache.org/)."
+ *
+ * 4. The names "Apache Server" and "Apache Group" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    apache@apache.org.
+ *
+ * 5. Products derived from this software may not be called "Apache"
+ *    nor may "Apache" appear in their names without prior written
+ *    permission of the Apache Group.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the Apache Group
+ *    for use in the Apache HTTP server project (http://www.apache.org/)."
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE APACHE GROUP ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Group and was originally based
+ * on public domain software written at the National Center for
+ * Supercomputing Applications, University of Illinois, Urbana-Champaign.
+ * For more information on the Apache Group and the Apache HTTP server
+ * project, please see <http://www.apache.org/>.
+ */
+
+/*
+**  ap_mm.c -- wrapper for MM shared memory library
+**
+**  This file has two reason:
+**
+**  1. Under DSO context we need stubs inside the Apache core code
+**     to make sure the MM library's code is actually available
+**     to the module DSOs.
+**
+**  2. When the MM library cannot be built on the current platform
+**     still provide dummy stubs so modules using the ap_mm_xxx()
+**     functions can be still built. But modules should use
+**     ap_mm_useable() to find out whether they really can use
+**     the MM stuff.
+*/
+                                       /*
+                                        * "What you see is all you get."
+                                        *     -- Brian Kernighan
+                                        */
+#ifdef EAPI
+
+#include "httpd.h"
+#include "ap_mm.h"
+
+#ifdef EAPI_MM
+#include "mm.h"
+API_EXPORT(int) ap_mm_useable(void) { return TRUE;  }
+#define STUB(val,nul)               { return val;   }
+#define STUB_STMT(stmt)             { stmt; return; }
+#else
+API_EXPORT(int) ap_mm_useable(void) { return FALSE; }
+#define STUB(val,nul)               { return nul;   }
+#define STUB_STMT(stmt)             { return;       }
+#endif
+
+API_EXPORT(int) ap_MM_create(size_t size, char *file) 
+    STUB(MM_create(size, file), FALSE)
+API_EXPORT(int) ap_MM_permission(mode_t mode, uid_t owner, gid_t group) 
+    STUB(MM_permission(mode, owner, group), -1)
+API_EXPORT(void) ap_MM_destroy(void)
+    STUB_STMT(MM_destroy())
+API_EXPORT(int) ap_MM_lock(ap_mm_lock_mode mode)
+    STUB(MM_lock(mode), FALSE)
+API_EXPORT(int) ap_MM_unlock(void)
+    STUB(MM_unlock(), FALSE)
+API_EXPORT(void *) ap_MM_malloc(size_t size)
+    STUB(MM_malloc(size), NULL)
+API_EXPORT(void *) ap_MM_realloc(void *ptr, size_t size)
+    STUB(MM_realloc(ptr, size), NULL)
+API_EXPORT(void) ap_MM_free(void *ptr)
+    STUB_STMT(MM_free(ptr))
+API_EXPORT(void *) ap_MM_calloc(size_t number, size_t size)
+    STUB(MM_calloc(number, size), NULL)
+API_EXPORT(char *) ap_MM_strdup(const char *str)
+    STUB(MM_strdup(str), NULL)
+API_EXPORT(size_t) ap_MM_sizeof(void *ptr)
+    STUB(MM_sizeof(ptr), 0)
+API_EXPORT(size_t) ap_MM_maxsize(void)
+    STUB(MM_maxsize(), 0)
+API_EXPORT(size_t) ap_MM_available(void)
+    STUB(MM_available(), 0)
+API_EXPORT(char *) ap_MM_error(void)
+    STUB(MM_error(), NULL)
+
+API_EXPORT(AP_MM *) ap_mm_create(size_t size, char *file)
+    STUB(mm_create(size, file), NULL)
+API_EXPORT(int) ap_mm_permission(AP_MM *mm, mode_t mode, uid_t owner, gid_t group) 
+    STUB(mm_permission(mm, mode, owner, group), -1)
+API_EXPORT(void) ap_mm_destroy(AP_MM *mm)
+    STUB_STMT(mm_destroy(mm))
+API_EXPORT(int) ap_mm_lock(AP_MM *mm, ap_mm_lock_mode mode)
+    STUB(mm_lock(mm, mode), FALSE)
+API_EXPORT(int) ap_mm_unlock(AP_MM *mm)
+    STUB(mm_unlock(mm), FALSE)
+API_EXPORT(void *) ap_mm_malloc(AP_MM *mm, size_t size)
+    STUB(mm_malloc(mm, size), NULL)
+API_EXPORT(void *) ap_mm_realloc(AP_MM *mm, void *ptr, size_t size)
+    STUB(mm_realloc(mm, ptr, size), NULL)
+API_EXPORT(void) ap_mm_free(AP_MM *mm, void *ptr)
+    STUB_STMT(mm_free(mm, ptr))
+API_EXPORT(void *) ap_mm_calloc(AP_MM *mm, size_t number, size_t size)
+    STUB(mm_calloc(mm, number, size), NULL)
+API_EXPORT(char *) ap_mm_strdup(AP_MM *mm, const char *str)
+    STUB(mm_strdup(mm, str), NULL)
+API_EXPORT(size_t) ap_mm_sizeof(AP_MM *mm, void *ptr)
+    STUB(mm_sizeof(mm, ptr), 0)
+API_EXPORT(size_t) ap_mm_maxsize(void)
+    STUB(mm_maxsize(), 0)
+API_EXPORT(size_t) ap_mm_available(AP_MM *mm)
+    STUB(mm_available(mm), 0)
+API_EXPORT(char *) ap_mm_error(void)
+    STUB(mm_error(), NULL)
+API_EXPORT(void) ap_mm_display_info(AP_MM *mm)
+    STUB_STMT(mm_display_info(mm))
+
+API_EXPORT(void *) ap_mm_core_create(size_t size, char *file)
+    STUB(mm_core_create(size, file), NULL)
+API_EXPORT(int) ap_mm_core_permission(void *core, mode_t mode, uid_t owner, gid_t group) 
+    STUB(mm_core_permission(core, mode, owner, group), -1)
+API_EXPORT(void) ap_mm_core_delete(void *core)
+    STUB_STMT(mm_core_delete(core))
+API_EXPORT(size_t) ap_mm_core_size(void *core)
+    STUB(mm_core_size(core), 0)
+API_EXPORT(int) ap_mm_core_lock(void *core, ap_mm_lock_mode mode)
+    STUB(mm_core_lock(core, mode), FALSE)
+API_EXPORT(int) ap_mm_core_unlock(void *core)
+    STUB(mm_core_unlock(core), FALSE)
+API_EXPORT(size_t) ap_mm_core_maxsegsize(void)
+    STUB(mm_core_maxsegsize(), 0)
+API_EXPORT(size_t) ap_mm_core_align2page(size_t size)
+    STUB(mm_core_align2page(size), 0)
+API_EXPORT(size_t) ap_mm_core_align2word(size_t size)
+    STUB(mm_core_align2word(size), 0)
+
+API_EXPORT(void) ap_mm_lib_error_set(unsigned int type, const char *str)
+    STUB_STMT(mm_lib_error_set(type, str))
+API_EXPORT(char *) ap_mm_lib_error_get(void)
+    STUB(mm_lib_error_get(), NULL)
+API_EXPORT(int) ap_mm_lib_version(void)
+    STUB(mm_lib_version(), 0)
+
+#endif /* EAPI */
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/helpers/GuessOS apache_1.3.33/src/helpers/GuessOS
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/helpers/GuessOS	Thu Sep 16 01:45:17 2004
+++ apache_1.3.33/src/helpers/GuessOS	Mon Jul 18 16:14:56 2005
@@ -27,6 +27,12 @@
 # Be as similar to the output of config.guess/config.sub
 # as possible.
 
+# Cross-compilation test (etlinux)
+if [ "$CROSS_COMPILE" != "" ] ; then
+       echo $ARCH-whatever-linux22
+       exit 0
+fi
+
 # Handle TPF before the other operating systems
 # since it's compiled on non-TPF platforms.
 # This keeps GuessOS from returning incorrect
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/helpers/TestCompile apache_1.3.33/src/helpers/TestCompile
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/helpers/TestCompile	Mon Feb 16 23:23:09 2004
+++ apache_1.3.33/src/helpers/TestCompile	Mon Jul 18 15:22:19 2005
@@ -1,4 +1,4 @@
-#!/bin/sh
+#!/bin/bash
 #
 # Copyright 1999-2004 The Apache Software Foundation
 #
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/helpers/find-dbm-lib apache_1.3.33/src/helpers/find-dbm-lib
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/helpers/find-dbm-lib	Mon Feb 16 23:23:09 2004
+++ apache_1.3.33/src/helpers/find-dbm-lib	Mon Jul 18 15:22:19 2005
@@ -25,19 +25,25 @@
     else
 	found_dbm=0
 	case "$PLAT" in
-	    *-linux*)
+	    *-linux* | *-GNU/Hurd*)
 		# many systems don't have -ldbm
 		DBM_LIB=""
-		if ./helpers/TestCompile lib ndbm dbm_open; then
+		if ./helpers/TestCompile lib db; then
+		    DBM_LIB="-ldb"
+		    CFLAGS="$CFLAGS -DDB_DBM_HSEARCH=1"
+		elif ./helpers/TestCompile lib db __db_ndbm_open; then
+		    DBM_LIB="-ldb"
+		    CFLAGS="$CFLAGS -DDB_DBM_HSEARCH=1"
+		elif ./helpers/TestCompile lib db1 dbm_open; then
+		    # For Red Hat 7, if not handled by the ndbm case above
+		    DBM_LIB="-ldb1"
+		    CFLAGS="$CFLAGS -I/usr/include/db1"
+ 		elif ./helpers/TestCompile lib ndbm dbm_open; then
 		    DBM_LIB="-lndbm"
 		    if ./helpers/TestCompile lib db1 dbm_open; then
 			# Red Hat needs this; ndbm.h lives in db1
 			CFLAGS="$CFLAGS -I/usr/include/db1"
 		    fi
-		elif ./helpers/TestCompile lib db1 dbm_open; then
-		    # For Red Hat 7, if not handled by the ndbm case above
-		    DBM_LIB="-ldb1"
-		    CFLAGS="$CFLAGS -I/usr/include/db1"
                 elif ./helpers/TestCompile lib gdbm dbm_open; then
                     DBM_LIB="-lgdbm"
                     CFLAGS="$CFLAGS -I/usr/include/gdbm"
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/helpers/find-dbm-lib.orig apache_1.3.33/src/helpers/find-dbm-lib.orig
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/helpers/find-dbm-lib.orig	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/helpers/find-dbm-lib.orig	Mon Jul 18 15:22:18 2005
@@ -0,0 +1,95 @@
+# Copyright 1999-2004 The Apache Software Foundation
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+#
+# Our config tool sucks... if this script decides to modify the
+# LIBS variable it won't be used by any of the other TestCompiles.
+# So unless we protect ourselves with the found_dbm variable
+# we'd end up having to do the work twice... and we'd end up putting
+# two -ldbm -ldbm into the LIBS variable.
+
+if [ "x$found_dbm" = "x" ]; then
+    if ./helpers/TestCompile func dbm_open; then
+	found_dbm=1
+    else
+	found_dbm=0
+	case "$PLAT" in
+	    *-linux*)
+		# many systems don't have -ldbm
+		DBM_LIB=""
+		if ./helpers/TestCompile lib db; then
+		    DBM_LIB="-ldb"
+		    CFLAGS="$CFLAGS -DDB_DBM_HSEARCH=1"
+		elif ./helpers/TestCompile lib db __db_ndbm_open; then
+		    DBM_LIB="-ldb"
+		    CFLAGS="$CFLAGS -DDB_DBM_HSEARCH=1"
+		elif ./helpers/TestCompile lib db1 dbm_open; then
+		    # For Red Hat 7, if not handled by the ndbm case above
+		    DBM_LIB="-ldb1"
+		    CFLAGS="$CFLAGS -I/usr/include/db1"
+ 		elif ./helpers/TestCompile lib ndbm dbm_open; then
+		    DBM_LIB="-lndbm"
+		    if ./helpers/TestCompile lib db1 dbm_open; then
+			# Red Hat needs this; ndbm.h lives in db1
+			CFLAGS="$CFLAGS -I/usr/include/db1"
+		    fi
+                elif ./helpers/TestCompile lib gdbm dbm_open; then
+                    DBM_LIB="-lgdbm"
+                    CFLAGS="$CFLAGS -I/usr/include/gdbm"
+		elif ./helpers/TestCompile lib dbm dbm_open; then
+		    DBM_LIB="-ldbm"
+		fi
+		if [ "x$DBM_LIB" != "x" ]; then
+		    LIBS="$LIBS $DBM_LIB"
+		    found_dbm=1
+		fi
+		;;
+        *-cygwin*)
+        # we use the shared DLL version of gdbm if available
+        DBM_LIB=""
+        if ./helpers/TestCompile lib gdbm dbm_open; then
+            DBM_LIB="-lgdbm"
+            LIBS="$LIBS $DBM_LIB"
+            found_dbm=1
+        fi
+        ;;
+	    *)
+		if [ "x$DBM_LIB" != "x" ]; then
+		    oldLIBS="$LIBS"
+		    LIBS="$LIBS $DBM_LIB"
+		    if ./helpers/TestCompile func dbm_open; then
+			found_dbm=1
+		    else
+			found_dbm=0
+			LIBS="$oldLIBS"
+		    fi
+		else
+		    for dblib in dbm ndbm db
+		    do
+			DBM_LIB=""
+			if ./helpers/TestCompile lib $dblib dbm_open; then
+			    DBM_LIB="-l${dblib}"
+			    LIBS="$LIBS $DBM_LIB"
+			    found_dbm=1
+			    break
+			fi
+		    done
+		fi
+		;;
+	esac
+	if [ "x$found_dbm" = "x1" ]; then
+	    echo " + using $DBM_LIB for DBM support"
+	fi
+    fi
+fi
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/helpers/fmn.sh apache_1.3.33/src/helpers/fmn.sh
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/helpers/fmn.sh	Mon Feb 16 23:23:09 2004
+++ apache_1.3.33/src/helpers/fmn.sh	Mon Jul 18 15:22:20 2005
@@ -24,8 +24,8 @@
 modfile=$1
 
 #   the part from the Configure script
-tmpfile=${TMPDIR-/tmp}/fmn.tmp.$$
-rm -f $tmpfile
+tmpfile=`mktemp -t fmn.XXXXXX || tempfile --prefix=fmn` || {echo "$0: Cannot create temporary file" >&2; exit 1; }
+trap "rm -f -- \"$tmpfile\";" 0 1 2 3 13 15
 modname=''
 ext=`echo $modfile | sed 's/^.*\.//'`
 modbase=`echo $modfile | sed 's/\.[^.]*$//'`
@@ -52,8 +52,8 @@
     modname=`echo $modbase | sed 's/^.*\///' | \
         sed 's/^mod_//' | sed 's/^lib//' | sed 's/$/_module/'`
 fi
-rm -f $tmpfile
 
 #   output: the name of the module structure symbol
 echo "$modname"
 
+exit 0
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/include/ap_alloc.h apache_1.3.33/src/include/ap_alloc.h
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/include/ap_alloc.h	Mon Feb 16 23:25:08 2004
+++ apache_1.3.33/src/include/ap_alloc.h	Mon Jul 18 15:22:25 2005
@@ -52,6 +52,15 @@
 API_EXPORT(pool *) ap_init_alloc(void);		/* Set up everything */
 void ap_cleanup_alloc(void);
 API_EXPORT(pool *) ap_make_sub_pool(pool *);	/* All pools are subpools of permanent_pool */
+#if defined(EAPI)
+typedef enum { AP_POOL_RD, AP_POOL_RW } ap_pool_lock_mode;
+int ap_shared_pool_possible(void);
+void ap_init_alloc_shared(int);
+void ap_kill_alloc_shared(void);
+API_EXPORT(pool *) ap_make_shared_sub_pool(pool *);
+API_EXPORT(int) ap_acquire_pool(pool *, ap_pool_lock_mode);
+API_EXPORT(int) ap_release_pool(pool *);
+#endif
 API_EXPORT(void) ap_destroy_pool(pool *);
 
 /* pools have nested lifetimes -- sub_pools are destroyed when the
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/include/ap_config.h apache_1.3.33/src/include/ap_config.h
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/include/ap_config.h	Thu Sep 16 01:45:17 2004
+++ apache_1.3.33/src/include/ap_config.h	Mon Jul 18 15:22:18 2005
@@ -487,6 +487,13 @@
 #endif
 #define AP_ENABLE_EXCEPTION_HOOK
 
+#elif defined(HURD)
+#define HAVE_SYSLOG 1
+#define HAVE_MMAP 1
+#define USE_MMAP_FILES 1
+#define USE_MMAP_SCOREBOARD 1
+#include <sys/time.h>
+
 #elif defined(SCO)
 #undef HAVE_GMTOFF
 #undef NO_KILLPG
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/include/ap_config.h.orig apache_1.3.33/src/include/ap_config.h.orig
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/include/ap_config.h.orig	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/include/ap_config.h.orig	Thu Sep 16 01:45:17 2004
@@ -0,0 +1,1461 @@
+/* Copyright 1999-2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef AP_CONFIG_H
+#define AP_CONFIG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * ap_config.h: system-dependant #defines and includes...
+ * See PORTING for a listing of what they mean
+ */
+
+#include "ap_mmn.h"		/* MODULE_MAGIC_NUMBER_ */
+
+/*
+ * Support for platform dependent autogenerated defines
+ */
+#if !defined(WIN32) && !defined(NETWARE) && !defined(TPF)
+#include "ap_config_auto.h"
+#endif
+
+#if defined(WIN32) || defined(NETWARE)
+/* not available under WIN32, so provide important entries manually */
+#undef HAVE_UNISTD_H
+#endif
+
+/* Have to include sys/stat.h before ../win32/os.h so we can override
+stat() properly */
+#ifndef NETWARE
+#include <sys/types.h>
+#endif
+#include <sys/stat.h>
+
+
+/* So that we can use inline on some critical functions, and use
+ * GNUC attributes (such as to get -Wall warnings for printf-like
+ * functions).  Only do this in gcc 2.7 or later ... it may work
+ * on earlier stuff, but why chance it.
+ *
+ * We've since discovered that the gcc shipped with NeXT systems
+ * as "cc" is completely broken.  It claims to be __GNUC__ and so
+ * on, but it doesn't implement half of the things that __GNUC__
+ * means.  In particular it's missing inline and the __attribute__
+ * stuff.  So we hack around it.  PR#1613. -djg
+ */
+#if !defined(__GNUC__) || __GNUC__ < 2 || \
+    (__GNUC__ == 2 && __GNUC_MINOR__ < 7) ||\
+    defined(NEXT)
+#define ap_inline
+#define __attribute__(__x)
+#define ENUM_BITFIELD(e,n,w)  signed int n : w
+#else
+#define ap_inline __inline__
+#define USE_GNU_INLINE
+#define ENUM_BITFIELD(e,n,w)  e n : w
+#endif
+
+#include "os.h"
+
+/* Define one of these according to your system. */
+#if defined(MINT)
+typedef int rlim_t;
+#define JMP_BUF sigjmp_buf
+#define NO_LONG_DOUBLE
+#define HAVE_FLOCK_SERIALIZED_ACCEPT
+#define _BSD_SOURCE
+#define EAGAIN EWOULDBLOCK
+int initgroups (char *, int);     
+char *crypt (const char *pw, const char *salt);
+int gethostname (char *name, int namelen);
+
+#elif defined(MPE)
+#include <sys/times.h>
+#define NO_SETSID
+#define NO_KILLPG
+#define NO_WRITEV
+#define HAVE_SHMGET 1
+#define USE_SHMGET_SCOREBOARD
+/* 
+   UID/GID isn't a native concept for MPE, and it's definitely not a 100%
+   Unix implementation.  There isn't a traditional superuser concept either,
+   so we're forced to liberalize SHM security a bit so the parent & children
+   can communicate when they're running with different UIDs within the same
+   GID (the GID will *always* be the same on MPE).  Thus the weird SHM_R and
+   SHM_W below.
+*/
+#define SHM_R 0440  /* Read permission */
+#define SHM_W 0220  /* Write permission */
+#define NEED_INITGROUPS
+#define NEED_STRCASECMP
+#define NEED_STRDUP
+#define NEED_STRNCASECMP
+extern void GETPRIVMODE();
+extern void GETUSERMODE();
+extern char *inet_ntoa();
+#define NO_SLACK
+#define S_IEXEC  S_IXUSR
+#define S_IREAD  S_IRUSR
+#define S_IWRITE S_IWUSR
+#define PF_INET  AF_INET
+#define HAVE_FCNTL_SERIALIZED_ACCEPT
+
+#elif defined(SUNOS4)
+#define HAVE_GMTOFF 1
+#undef NO_KILLPG
+#undef NO_SETSID
+char *crypt(const char *pw, const char *salt);
+char *mktemp(char *);
+#define HAVE_MMAP 1
+#define USE_MMAP_SCOREBOARD
+#define USE_MMAP_FILES
+#include <sys/time.h>
+#define NEED_STRERROR
+typedef int rlim_t;
+#define memmove(a,b,c) bcopy(b,a,c)
+#define NO_LINGCLOSE
+#define HAVE_FLOCK_SERIALIZED_ACCEPT
+#define NEED_DIFFTIME
+#define HAVE_SYSLOG 1
+
+#elif defined(SOLARIS2)
+#undef HAVE_GMTOFF
+#define NO_KILLPG
+#undef NO_SETSID
+#define bzero(a,b) memset(a,0,b)
+#define HAVE_SYSVSEM_SERIALIZED_ACCEPT
+#define HAVE_FCNTL_SERIALIZED_ACCEPT
+#define HAVE_PTHREAD_SERIALIZED_ACCEPT
+#if !defined(USE_SYSVSEM_SERIALIZED_ACCEPT) && \
+    !defined(USE_PTHREAD_SERIALIZED_ACCEPT)
+#define USE_FCNTL_SERIALIZED_ACCEPT
+#endif
+#define NEED_UNION_SEMUN
+#define HAVE_MMAP 1
+#define USE_MMAP_SCOREBOARD
+#define USE_MMAP_FILES
+int gethostname(char *name, int namelen);
+#define HAVE_SYSLOG 1
+#define SYS_SIGLIST _sys_siglist
+#define AP_ENABLE_EXCEPTION_HOOK
+#define NONBLOCK_WHEN_MULTI_LISTEN
+
+#elif defined(IRIX)
+#undef HAVE_GMTOFF
+/* IRIX has killpg, but it's only in _BSD_COMPAT, so don't use it in case
+ * there's some weird conflict with non-BSD signals */
+#define NO_KILLPG
+#undef NO_SETSID
+#define HAVE_FLOCK_SERIALIZED_ACCEPT
+#define HAVE_FCNTL_SERIALIZED_ACCEPT
+#define HAVE_USLOCK_SERIALIZED_ACCEPT
+#define HAVE_SYSVSEM_SERIALIZED_ACCEPT
+#if !defined(USE_FLOCK_SERIALIZED_ACCEPT) && \
+    !defined(USE_USLOCK_SERIALIZED_ACCEPT) && \
+    !defined(USE_SYSVSEM_SERIALIZED_ACCEPT)
+#define USE_FCNTL_SERIALIZED_ACCEPT
+#endif
+#define HAVE_SHMGET 1
+#define USE_SHMGET_SCOREBOARD
+#define HAVE_MMAP 1
+#define USE_MMAP_FILES
+#define NO_LONG_DOUBLE
+#define NO_LINGCLOSE
+#define HAVE_SYSLOG 1
+#define NONBLOCK_WHEN_MULTI_LISTEN
+
+#elif defined(HIUX)
+#undef HAVE_GMTOFF
+#define NO_KILLPG
+#undef NO_SETSID
+#ifndef _HIUX_SOURCE
+#define _HIUX_SOURCE
+#endif
+#define HAVE_SHMGET 1
+#define USE_SHMGET_SCOREBOARD
+#define SELECT_NEEDS_CAST
+#define HAVE_SYSLOG 1
+
+#elif defined(HPUX11)
+#ifndef _HPUX_SOURCE
+#define _HPUX_SOURCE
+#endif
+#define HAVE_SHMGET
+#define USE_SHMGET_SCOREBOARD
+#undef  HAVE_GMTOFF
+#define HAVE_FCNTL_SERIALIZED_ACCEPT
+#define HAVE_MMAP
+#define USE_MMAP_FILES
+#define NO_KILLPG
+#undef  NO_SETSID
+#define HAVE_SYSLOG
+#define AP_ENABLE_EXCEPTION_HOOK
+
+#elif defined(HPUX) || defined(HPUX10)
+#undef HAVE_GMTOFF
+#define NO_KILLPG
+#undef NO_SETSID
+#define HAVE_FCNTL_SERIALIZED_ACCEPT
+#ifndef _HPUX_SOURCE
+#define _HPUX_SOURCE
+#endif
+#define HAVE_SHMGET 1
+#define USE_SHMGET_SCOREBOARD
+#define HAVE_SYSLOG 1
+#ifndef HPUX10
+#define SELECT_NEEDS_CAST
+typedef int rlim_t;
+#endif
+
+#elif defined(AIX)
+#undef HAVE_GMTOFF
+#undef NO_KILLPG
+#undef NO_SETSID
+#ifndef __ps2__
+#define HAVE_MMAP 1
+#define USE_MMAP_SCOREBOARD
+#define USE_MMAP_FILES
+#define HAVE_SYSLOG 1
+#ifndef DEFAULT_GROUP
+#define DEFAULT_GROUP "nobody"
+#endif
+#endif
+#ifndef DEFAULT_USER
+#define DEFAULT_USER "nobody"
+#endif
+#ifdef NEED_RLIM_T
+typedef int rlim_t;
+#endif
+#define HAVE_FCNTL_SERIALIZED_ACCEPT
+#define HAVE_SYSVSEM_SERIALIZED_ACCEPT
+#define NEED_UNION_SEMUN
+#if AIX >= 430
+#define HAVE_PTHREAD_SERIALIZED_ACCEPT
+#endif
+#define USE_FCNTL_SERIALIZED_ACCEPT
+#if AIX >= 432
+#define SINGLE_LISTEN_UNSERIALIZED_ACCEPT 
+#endif
+#ifdef USEBCOPY
+#define memmove(a,b,c) bcopy(b,a,c)
+#endif
+#if AIX >= 510
+#define NET_SIZE_T socklen_t
+#elif AIX >= 420
+#define NET_SIZE_T size_t
+#endif
+#define AP_ENABLE_EXCEPTION_HOOK
+#define NONBLOCK_WHEN_MULTI_LISTEN
+
+#elif defined(ULTRIX)
+/* we don't want to use sys/resource.h under
+   Ultrix although this header exists. */
+#undef HAVE_SYS_RESOURCE_H
+#define HAVE_GMTOFF 1
+#undef NO_KILLPG
+#undef NO_SETSID
+#define ULTRIX_BRAIN_DEATH
+#define NEED_STRDUP
+/* If you have Ultrix 4.3, and are using cc, const is broken */
+#ifndef __ultrix__		/* Hack to check for pre-Ultrix 4.4 cc */
+#define const			/* Not implemented */
+#endif
+
+#elif defined(OSF1)
+#define HAVE_GMTOFF 1
+#undef NO_KILLPG
+#undef NO_SETSID
+#define HAVE_MMAP 1
+#define USE_MMAP_SCOREBOARD
+#define USE_MMAP_FILES
+#define NO_LONG_DOUBLE
+#define HAVE_SYSLOG 1
+#define HAVE_FLOCK_SERIALIZED_ACCEPT
+#define SINGLE_LISTEN_UNSERIALIZED_ACCEPT
+#define NONBLOCK_WHEN_MULTI_LISTEN
+
+#elif defined(PARAGON)
+#define HAVE_GMTOFF 1
+#undef NO_KILLPG
+#undef NO_SETSID
+#define HAVE_MMAP 1
+#define USE_MMAP_SCOREBOARD
+#define USE_MMAP_FILES
+#define NO_LONG_DOUBLE
+#define HAVE_SYSLOG 1
+typedef int rlim_t;
+
+#elif defined(SEQUENT)
+#define DEFAULT_USER "nobody"
+#define DEFAULT_GROUP "nobody"
+#define NO_SHMGET 1
+#define HAVE_MMAP 1
+#define HAVE_SYSLOG 1
+#define USE_MMAP_FILES 1
+#define USE_MMAP_SCOREBOARD 1
+#define HAVE_FCNTL_SERIALIZED_ACCEPT 1
+#define JMP_BUF sigjmp_buf
+#undef NO_SETSID
+#if SEQUENT < 40
+typedef int rlim_t;
+#define NO_GETTIMEOFDAY
+#undef HAVE_SYS_RESOURCE_H /* exists but does not provide *rlimit funcs */
+#include <sys/times.h>
+#endif
+#if SEQUENT < 42
+#define NEED_STRCASECMP
+#define NEED_STRNCASECMP
+#endif
+#if SEQUENT < 44
+#define NO_KILLPG 1
+#define NET_SIZE_T int
+#endif
+#if SEQUENT >= 44
+#undef NO_KILLPG
+#define NET_SIZE_T size_t
+#endif
+
+#elif defined(NEXT)
+typedef unsigned short mode_t;
+typedef int rlim_t;
+#define HAVE_GMTOFF 1
+#undef NO_KILLPG
+#define NO_SETSID
+#define NEED_STRDUP
+#define NO_LINGCLOSE
+#undef _POSIX_SOURCE
+#ifndef FD_CLOEXEC
+#define FD_CLOEXEC 1
+#endif
+#ifndef S_ISDIR
+#define S_ISDIR(m)      (((m)&(S_IFMT)) == (S_IFDIR))
+#endif
+#ifndef S_ISREG
+#define S_ISREG(m)      (((m)&(S_IFMT)) == (S_IFREG))
+#endif
+#ifndef S_IXUSR
+#define S_IXUSR 00100
+#endif
+#ifndef S_IRGRP
+#define S_IRGRP 00040
+#endif
+#ifndef S_IXGRP
+#define S_IXGRP 00010
+#endif
+#ifndef S_IROTH
+#define S_IROTH 00004
+#endif
+#ifndef S_IXOTH
+#define S_IXOTH 00001
+#endif
+#ifndef S_IRUSR
+#define S_IRUSR S_IREAD
+#endif
+#ifndef S_IWUSR
+#define S_IWUSR S_IWRITE
+#endif
+#ifndef S_IWGRP
+#define S_IWGRP	000020
+#endif
+#ifndef S_IWOTH
+#define S_IWOTH 000002
+#endif
+
+#define STDIN_FILENO  0
+#define STDOUT_FILENO 1
+#define STDERR_FILENO 2
+
+/* PR#2293 fix */
+#define	ap_wait_t	union wait
+#define waitpid(a,b,c) wait4((a) == -1 ? 0 : (a),(union wait *)(b),c,NULL)
+#define WEXITSTATUS(status)     (int)( WIFEXITED(status) ? ( (status).w_retcode ) : -1)
+#define WTERMSIG(status)	(int)( (status).w_termsig )
+
+typedef int pid_t;
+#define USE_LONGJMP
+#define NO_USE_SIGACTION
+#define HAVE_SYSLOG 1
+
+#if defined(__DYNAMIC__)
+#define HAVE_DYLD
+#define DYLD_CANT_UNLOAD
+#endif
+
+#elif defined(DARWIN) /* Darwin (Mac OS) */
+#undef PLATFORM
+#define PLATFORM "Darwin"
+#define HAVE_DYLD
+#define HAVE_GMTOFF
+#define HAVE_MMAP
+#define USE_MMAP_FILES
+#define USE_MMAP_SCOREBOARD
+#ifdef MAC_OS_X_SERVER
+#define MAP_TMPFILE
+#endif /* MAC_OS_X_SERVER */
+#define HAVE_RESOURCE
+#define HAVE_SNPRINTF
+#define JMP_BUF jmp_buf
+#define USE_LONGJMP
+#define HAVE_FLOCK_SERIALIZED_ACCEPT
+#define HAVE_FCNTL_SERIALIZED_ACCEPT
+#define USE_FLOCK_SERIALIZED_ACCEPT
+#define SINGLE_LISTEN_UNSERIALIZED_ACCEPT
+#define AP_ENABLE_EXCEPTION_HOOK
+
+#elif defined(LINUX)
+
+#if LINUX > 1
+#include <features.h>
+
+/* libc4 systems probably still work, it probably doesn't define
+ *  __GNU_LIBRARY__
+ * libc5 systems define __GNU_LIBRARY__ == 1, but don't define __GLIBC__
+ * glibc 2.x and later systems define __GNU_LIBRARY__ == 6, but list it as
+ * "deprecated in favour of __GLIBC__"; the value 6 will never be changed.
+ * glibc 1.x systems (i.e. redhat 4.x on sparc/alpha) should have
+ * __GLIBC__ < 2
+ * all glibc based systems need crypt.h
+ */
+#if defined(__GNU_LIBRARY__) && __GNU_LIBRARY__ > 1
+#include <crypt.h>
+#endif
+
+/* glibc 2.0.0 through 2.0.4 need size_t * here, where 2.0.5 needs socklen_t *
+ * there's no way to discern between these two libraries.  But using int should
+ * be portable because otherwise these libs would be hopelessly broken with
+ * reams of existing networking code.  We'll use socklen_t * for 2.1.x and
+ * later.
+ *
+ * int works for all the earlier libs, and is picked up by default later.
+ */
+#if defined(__GLIBC__) && (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 0))
+#define NET_SIZE_T socklen_t
+#endif
+
+#define HAVE_SHMGET 1
+#define USE_SHMGET_SCOREBOARD
+#define HAVE_MMAP 1
+#define USE_MMAP_FILES
+
+#if LINUX > 20
+/* see Pine.LNX.4.21.0011041233550.1897-100000@twinlark.arctic.org
+ * in new-httpd archives for performance numbers indicating these
+ * are the right choices for linux 2.2.x and later
+ */
+#define HAVE_SYSVSEM_SERIALIZED_ACCEPT
+#define HAVE_FCNTL_SERIALIZED_ACCEPT
+#define SINGLE_LISTEN_UNSERIALIZED_ACCEPT 
+#include <sys/sem.h>
+#if _SEM_SEMUN_UNDEFINED
+#define NEED_UNION_SEMUN
+#endif
+#else
+#define USE_FCNTL_SERIALIZED_ACCEPT
+#endif
+
+#define SYS_SIGLIST	_sys_siglist
+
+#else
+#define USE_FCNTL_SERIALIZED_ACCEPT
+#endif
+
+#undef HAVE_GMTOFF
+#undef NO_KILLPG
+#undef NO_SETSID
+#undef NEED_STRDUP
+#include <sys/time.h>
+#define HAVE_SYSLOG 1
+
+/* glibc 2.1 and later finally define rlim_t */
+#if !defined(__GLIBC__) || __GLIBC__ < 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ < 1)
+typedef int rlim_t;
+#endif
+#define AP_ENABLE_EXCEPTION_HOOK
+
+#elif defined(SCO)
+#undef HAVE_GMTOFF
+#undef NO_KILLPG
+#undef NO_SETSID
+#define NEED_INITGROUPS
+#define NO_WRITEV
+#include <sys/time.h>
+#define HAVE_SYSLOG 1
+#undef HAVE_SYS_RESOURCE_H
+
+#elif defined(ATHEOS)
+
+#include <features.h>
+#include <crypt.h>
+#include <sys/time.h>
+
+#define HAVE_FCNTL_SERIALIZED_ACCEPT
+#define USE_FCNTL_SERIALIZED_ACCEPT
+
+#undef HAVE_GMTOFF
+#undef NO_KILLPG
+#undef NO_SETSID
+#undef NEED_STRDUP
+#define HAVE_SYSLOG 1
+
+#ifdef PLATFORM
+#undef PLATFORM
+#endif
+#define PLATFORM "AtheOS"
+
+#elif defined(SCO5)
+
+#define HAVE_FCNTL_SERIALIZED_ACCEPT
+#define HAVE_MMAP 1
+#define USE_MMAP_SCOREBOARD
+#define USE_MMAP_FILES
+#define SecureWare
+#define HAVE_SYSLOG 1
+
+/* Although SCO 5 defines these in <strings.h> (note the "s") they don't have
+   consts. Sigh. */
+extern int strcasecmp(const char *, const char *);
+extern int strncasecmp(const char *, const char *, unsigned);
+
+#elif defined(AUX3)
+/* These are to let -Wall compile more cleanly */
+extern int strcasecmp(const char *, const char *);
+extern int strncasecmp(const char *, const char *, unsigned);
+extern int set42sig(), getopt(), getpeername(), bzero();
+extern int listen(), bind(), socket(), getsockname();
+extern int accept(), gethostname(), connect(), lstat();
+extern int select(), killpg(), shutdown();
+extern int initgroups(), setsockopt();
+extern char *shmat();
+extern int shmctl();
+extern int shmget();
+extern char *sbrk();
+extern char *crypt();
+#include <sys/time.h>
+#undef HAVE_GMTOFF
+#undef NO_KILLPG
+#undef NO_SETSID
+#define NEED_STRDUP
+/* fcntl() locking is expensive with NFS */
+#define HAVE_FLOCK_SERIALIZED_ACCEPT
+#define SINGLE_LISTEN_UNSERIALIZED_ACCEPT
+#define HAVE_SHMGET 1
+#define USE_SHMGET_SCOREBOARD
+/*
+ * NOTE: If when you run Apache under A/UX and you get a warning
+ * that httpd couldn't move break, then the below value for
+ * MOVEBREAK (64megs) is too large for your setup. Try reducing
+ * to 0x2000000 which is still PLENTY of space. I doubt if
+ * even on heavy systems sbrk() would be called at all...
+ */
+#define MOVEBREAK		0x4000000
+#define NO_LINGCLOSE
+#define NO_SLACK
+#define HAVE_SYSLOG 1
+#undef HAVE_SYS_RESOURCE_H	/* exists but does not provide *rlimit funcs */
+
+#elif defined(SVR4)
+#define NO_KILLPG
+#undef  NO_SETSID
+#undef NEED_STRDUP
+#ifndef MPRAS
+#define NEED_STRCASECMP
+#ifndef ENCORE
+#define NEED_STRNCASECMP
+#endif /* ENCORE */
+#endif /* MPRAS */
+#define bzero(a,b) memset(a,0,b)
+/* A lot of SVR4 systems need this */
+#define HAVE_FCNTL_SERIALIZED_ACCEPT
+#ifdef SNI
+#define HAVE_SYSVSEM_SERIALIZED_ACCEPT
+#endif
+#ifndef USE_SYSVSEM_SERIALIZED_ACCEPT
+#define USE_FCNTL_SERIALIZED_ACCEPT
+#endif
+#define HAVE_SYSLOG 1
+#define NET_SIZE_T size_t
+#define HAVE_SHMGET 1
+#define USE_SHMGET_SCOREBOARD
+#ifdef _OSD_POSIX /* BS2000-POSIX mainframe needs initgroups */
+#define NEED_HASHBANG_EMUL /* execve() doesn't start shell scripts by default */
+#define _KMEMUSER          /* Enable SHM_R/SHM_W defines in <shm.h> */
+#define AP_ENABLE_EXCEPTION_HOOK
+#undef NEED_STRCASECMP
+#undef NEED_STRNCASECMP
+#undef bzero
+#endif /*_OSD_POSIX*/
+
+#elif defined(UW)
+#define HAVE_FCNTL_SERIALIZED_ACCEPT
+#if UW < 700
+#define NO_LINGCLOSE
+#define NO_KILLPG
+#else
+#define SINGLE_LISTEN_UNSERIALIZED_ACCEPT
+#endif
+#undef  NO_SETSID
+#undef NEED_STRDUP
+#define NEED_STRCASECMP
+#define NEED_STRNCASECMP
+#define bzero(a,b) memset(a,0,b)
+#define HAVE_MMAP 1
+#define USE_MMAP_SCOREBOARD
+#define USE_MMAP_FILES
+#define HAVE_SHMGET 1
+#undef USE_SHMGET_SCOREBOARD	/* force use of mmap() scoreboard */
+#include <sys/time.h>
+#if UW >= 200
+#define _POSIX_SOURCE
+#endif
+#define NET_SIZE_T size_t
+#define HAVE_SYSLOG 1
+
+#elif defined(DGUX)
+#define NO_KILLPG
+#undef  NO_SETSID
+#undef NEED_STRDUP
+#ifdef _IX86_DG
+#undef NEED_STRCASECMP
+#undef NEED_STRNCASECMP
+#else
+#define NEED_STRCASECMP
+#define NEED_STRNCASECMP
+#endif
+#define bzero(a,b) memset(a,0,b)
+/* A lot of SVR4 systems need this */
+#define HAVE_FCNTL_SERIALIZED_ACCEPT
+#define ap_inet_addr inet_network
+#define HAVE_SYSLOG 1
+
+#elif defined(__NetBSD__) || defined(__OpenBSD__) || defined(NETBSD)
+#define HAVE_GMTOFF 1
+#undef NO_KILLPG
+#undef NO_SETSID
+#define HAVE_SYSLOG 1
+#ifndef DEFAULT_USER
+#define DEFAULT_USER "nobody"
+#endif
+#ifndef DEFAULT_GROUP
+#define DEFAULT_GROUP "nogroup"
+#endif
+#define HAVE_SHMGET 1
+#define HAVE_MMAP 1
+#define USE_MMAP_SCOREBOARD
+#define USE_MMAP_FILES
+#define HAVE_FLOCK_SERIALIZED_ACCEPT
+#if defined(__OpenBSD__)
+#define HAVE_SYSVSEM_SERIALIZED_ACCEPT
+#define USE_SYSVSEM_SERIALIZED_ACCEPT
+#include <sys/param.h>
+#if (OpenBSD >= 199912)
+#define NET_SIZE_T socklen_t
+#endif
+#endif
+#define SINGLE_LISTEN_UNSERIALIZED_ACCEPT
+
+#elif defined(UTS21)
+#undef HAVE_GMTOFF
+#undef NO_KILLPG
+#define NO_SETSID
+#define NEED_WAITPID
+#define STDIN_FILENO 0
+#define STDOUT_FILENO 1
+#define STDERR_FILENO 2
+#define HAVE_SYSLOG 1
+#define USE_LONGJMP
+#define JMP_BUF jmp_buf
+#define NO_USE_SIGACTION
+#define NEED_STRERROR
+#define NEED_STRSTR
+#define NEED_HASHBANG_EMUL
+#define NDELAY_PIPE_RETURNS_ZERO
+#define NO_DATA NO_ADDRESS
+#define	ap_wait_t		union wait
+#define WEXITSTATUS(status)	(int)((status).w_retcode)
+#define WTERMSIG(status)	(int)((status).w_termsig)
+#define strftime(buf,bufsize,fmt,tm)    ascftime(buf,fmt,tm)
+#undef HAVE_SYS_RESOURCE_H /* exists but does not provide *rlimit funcs */
+#include <sys/types.h>
+#include <sys/time.h>     
+
+#elif defined(APOLLO)
+#undef HAVE_GMTOFF
+#undef NO_KILLPG
+#undef NO_SETSID
+#define HAVE_SYSLOG 1
+
+#elif defined(__FreeBSD__) || defined(__bsdi__)
+#if defined(__FreeBSD__)
+#include <osreldate.h>
+#endif
+#define HAVE_GMTOFF 1
+#undef NO_KILLPG
+#undef NO_SETSID
+#define HAVE_MMAP 1
+#define USE_MMAP_SCOREBOARD
+#define USE_MMAP_FILES
+#ifndef DEFAULT_USER
+#define DEFAULT_USER "nobody"
+#endif
+#ifndef DEFAULT_GROUP
+#define DEFAULT_GROUP "nogroup"
+#endif
+#if defined(__bsdi__) || \
+(defined(__FreeBSD_version) && (__FreeBSD_version < 220000))
+typedef quad_t rlim_t;
+#endif
+#define HAVE_FLOCK_SERIALIZED_ACCEPT
+#define SINGLE_LISTEN_UNSERIALIZED_ACCEPT
+#define HAVE_SYSLOG 1
+#define SYS_SIGLIST sys_siglist
+#if (defined(__FreeBSD_version) && (__FreeBSD_version >= 400000))
+#define NET_SIZE_T socklen_t
+#endif
+
+#elif defined(QNX)
+#ifndef crypt
+char *crypt(const char *pw, const char *salt);
+#endif
+#ifndef initgroups
+int initgroups(char *, int);
+#endif
+#ifndef strncasecmp
+#define strncasecmp strnicmp
+#endif
+#undef NO_KILLPG
+#undef NO_SETSID
+#define NEED_INITGROUPS
+#define NEED_SELECT_H
+#define NEED_PROCESS_H
+#include <unix.h>
+#define HAVE_MMAP 1
+#define USE_POSIX_SCOREBOARD
+#define HAVE_FLOCK_SERIALIZED_ACCEPT
+#define SINGLE_LISTEN_UNSERIALIZED_ACCEPT
+#define HAVE_SYSLOG 1
+
+#elif defined(LYNXOS)
+#undef HAVE_GMTOFF
+#undef USE_MMAP_SCOREBOARD
+#undef USE_SHMGET_SCOREBOARD
+#undef HAVE_FCNTL_SERIALIZED_ACCEPT
+#undef HAVE_FLOCK_SERIALIZED_ACCEPT
+#define HAVE_NONE_SERIALIZED_ACCEPT
+#define USE_LONGJMP
+#undef NO_KILLPG
+#undef NO_SETSID
+#undef NO_USE_SIGACTION
+#undef NO_LINGCLOSE
+extern char *crypt(char *pw, char *salt);
+typedef int rlim_t;
+#define HAVE_SYSLOG 1
+
+#elif defined(UXPDS)
+#undef NEED_STRCASECMP
+#undef NEED_STRNCASECMP
+#undef NEED_STRDUP
+#undef HAVE_GMTOFF
+#define NO_KILLPG
+#undef NO_SETSID
+#define bzero(a,b) memset(a,0,b)
+#define HAVE_FCNTL_SERIALIZED_ACCEPT
+#define HAVE_MMAP 1
+#define USE_MMAP_SCOREBOARD
+#define USE_MMAP_FILES
+#define HAVE_SYSLOG 1
+
+#elif defined(OS2)
+/* Defines required for EMX OS/2 port. */
+#define NO_KILLPG
+#define NEED_STRCASECMP
+#define NEED_STRNCASECMP
+#define NEED_PROCESS_H
+#define NO_SETSID
+#define NO_TIMES
+#define CASE_BLIND_FILESYSTEM
+/* Add some drive name support */
+#define chdir _chdir2
+#include <sys/time.h>
+#define MAXSOCKETS 2048
+#define USE_OS2_SCOREBOARD
+#define NO_RELIABLE_PIPED_LOGS
+#define HAVE_OS2SEM_SERIALIZED_ACCEPT
+#define SINGLE_LISTEN_UNSERIALIZED_ACCEPT
+#define NO_SLACK
+#define FOPEN_REQUIRES_T
+
+#elif defined(__MACHTEN__)
+typedef int rlim_t;
+#undef NO_KILLPG
+#define NO_SETSID
+#define HAVE_GMTOFF 1
+#ifndef __MACHTEN_PPC__
+#ifndef __MACHTEN_68K__
+#define __MACHTEN_68K__
+#endif
+#define HAVE_FLOCK_SERIALIZED_ACCEPT
+#define NO_USE_SIGACTION
+#define JMP_BUF sigjmp_buf
+#define USE_LONGJMP
+#undef NEED_STRDUP
+#else
+#define HAVE_SHMGET 1
+#define USE_SHMGET_SCOREBOARD
+#define HAVE_FCNTL_SERIALIZED_ACCEPT
+#endif
+
+/* Convex OS v11 */
+#elif defined(CONVEXOS11)
+#undef HAVE_GMTOFF
+#undef NO_KILLPG
+#undef NO_SETSID
+#undef NEED_STRDUP
+#define HAVE_MMAP 1
+#define USE_MMAP_SCOREBOARD
+#define USE_MMAP_FILES
+#define HAVE_SYSLOG 1
+
+#define NO_TIMEZONE
+#include <stdio.h>
+#include <sys/types.h>
+typedef int rlim_t;
+
+#elif defined(ISC)
+#include <net/errno.h>
+#define NO_KILLPG
+#undef NO_SETSID
+#define HAVE_SHMGET 1
+#define USE_SHMGET_SCOREBOARD
+#define HAVE_FCNTL_SERIALIZED_ACCEPT
+#define HAVE_SYSLOG 1
+
+#elif defined(NEWSOS)
+#define HAVE_SHMGET 1
+#define USE_SHMGET_SCOREBOARD
+#define USE_LONGJMP
+#define NO_SETSID
+#define NO_USE_SIGACTION
+#define NEED_WAITPID
+#define NO_OTHER_CHILD
+#define HAVE_SYSLOG 1
+#include <sys/time.h>
+#include <stdlib.h>
+#include <sys/types.h>
+typedef int pid_t;
+typedef int rlim_t;
+typedef int mode_t;
+
+#elif defined(RISCIX)
+#include <sys/time.h>
+typedef int rlim_t;
+#define NO_USE_SIGACTION
+#define USE_LONGJMP
+#define NEED_STRCASECMP
+#define NEED_STRNCASECMP
+#define NEED_STRDUP
+
+#elif defined(BEOS)
+#undef PLATFORM
+#define PLATFORM "BeOS"
+#include <stddef.h>
+#include <kernel/OS.h>
+
+#define HAVE_BEOS_SERIALIZED_ACCEPT
+#define SINGLE_LISTEN_UNSERIALIZED_ACCEPT
+
+#define NO_WRITEV
+#define NO_KILLPG
+#define NEED_INITGROUPS
+#define PF_INET AF_INET
+#define S_IEXEC S_IXUSR
+
+#elif defined(BONE)
+#undef PLATFORM
+#define PLATFORM "BeOS BONE"
+#include <kernel/OS.h>
+
+#define NO_KILLPG
+#define NEED_INITGROUPS
+#define S_IEXEC S_IXUSR
+#define HAVE_BEOS_SERIALIZED_ACCEPT
+#define SINGLE_LISTEN_UNSERIALIZED_ACCEPT
+
+#elif defined(_CX_SX)
+#define JMP_BUF sigjmp_buf
+#include <sys/types.h>
+#include <sys/time.h>
+
+#elif defined(WIN32)
+
+/* All windows stuff is now in os/win32/os.h */
+
+#elif defined(TPF) /* IBM Transaction Processing Facility operating system */
+
+/* All TPF definitions are now in os/tpf/os.h */
+
+#elif defined(__TANDEM)
+#define NO_WRITEV
+#define NO_KILLPG
+#define NEED_INITGROUPS
+#define NO_SLACK
+
+#elif defined(OS390)                /* IBM OS/390 Operating System      */
+#define HAVE_MMAP
+#define HAVE_SHMGET
+#define USE_SHMGET_SCOREBOARD
+#define USE_MMAP_FILES
+#define NEED_UNION_SEMUN
+#define HAVE_SYSVSEM_SERIALIZED_ACCEPT
+#define HAVE_FCNTL_SERIALIZED_ACCEPT
+#define _POSIX_SOURCE
+#include <signal.h>
+#ifdef SIGDUMP  /* SIGDUMP is not defined by OS/390 v1r2 */
+#define NSIG SIGDUMP+1
+#else
+#define NSIG 40
+#endif
+#define JMP_BUF sigjmp_buf
+#define _XOPEN_SOURCE_EXTENDED 1
+#define _OPEN_MSGQ_EXT
+#define _XOPEN_SOURCE
+#define SHM_R S_IRUSR
+#define SHM_W S_IWUSR
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/msg.h>
+#include <sys/socket.h>
+#define NET_SIZE_T size_t
+#define NEED_HASHBANG_EMUL
+#define NONBLOCK_WHEN_MULTI_LISTEN
+
+#elif defined(CYGWIN)               /* Cygwin 1.x POSIX layer for Win32 */
+#define SYSTEM_UID 18
+#define JMP_BUF jmp_buf
+#define NO_KILLPG
+#define NO_SETSID
+#define USE_LONGJMP
+#define GDBM_STATIC
+#define HAVE_MMAP 1
+#define USE_MMAP_SCOREBOARD
+#define USE_MMAP_FILES
+#define HAVE_SYSLOG 1
+#define HAVE_FCNTL_SERIALIZED_ACCEPT
+#define HAVE_PTHREAD_SERIALIZED_ACCEPT
+#define SINGLE_LISTEN_UNSERIALIZED_ACCEPT
+#if !defined(USE_FCNTL_SERIALIZED_ACCEPT)
+#define USE_PTHREAD_SERIALIZED_ACCEPT
+#endif
+
+#elif defined(NETWARE)
+#define NONBLOCK_WHEN_MULTI_LISTEN
+
+#else
+/* Unknown system - Edit these to match */
+#ifdef BSD
+#define HAVE_GMTOFF 1
+#else
+#undef HAVE_GMTOFF
+#endif
+/* NO_KILLPG is set on systems that don't have killpg */
+#undef NO_KILLPG
+/* NO_SETSID is set on systems that don't have setsid */
+#undef NO_SETSID
+/* NEED_STRDUP is set on stupid systems that don't have strdup. */
+#undef NEED_STRDUP
+#endif
+
+#ifdef HAVE_SYS_PARAM_H
+#include <sys/param.h>
+#endif /* HAVE_SYS_PARAM_H */
+
+/* stuff marked API_EXPORT is part of the API, and intended for use
+ * by modules
+ */
+#ifndef API_EXPORT
+#define API_EXPORT(type)    type
+#endif
+
+/* Stuff marked API_EXPORT_NONSTD is part of the API, and intended for
+ * use by modules.  The difference between API_EXPORT and
+ * API_EXPORT_NONSTD is that the latter is required for any functions
+ * which use varargs or are used via indirect function call.  This
+ * is to accomodate the two calling conventions in windows dlls.
+ */
+#ifndef API_EXPORT_NONSTD
+#define API_EXPORT_NONSTD(type)    type
+#endif
+
+#ifndef MODULE_VAR_EXPORT
+#define MODULE_VAR_EXPORT
+#endif
+#ifndef API_VAR_EXPORT
+#define API_VAR_EXPORT
+#endif
+
+/* modules should not used functions marked CORE_EXPORT
+ * or CORE_EXPORT_NONSTD */
+#ifndef CORE_EXPORT
+#define CORE_EXPORT	API_EXPORT
+#endif
+#ifndef CORE_EXPORT_NONSTD
+#define CORE_EXPORT_NONSTD	API_EXPORT_NONSTD
+#endif
+
+/* On Darwin, symbols that conflict with loaded dylibs
+ * (eg. System framework) need to be declared as private symbols with
+ * __private_extern__.
+ * For other systems, make that a no-op.
+ */
+#if defined(DARWIN) && defined(__DYNAMIC__)
+#define ap_private_extern __private_extern__
+#else
+#define ap_private_extern
+#endif
+
+/*
+ * The particular directory style your system supports. If you have dirent.h
+ * in /usr/include (POSIX) or /usr/include/sys (SYSV), #include 
+ * that file and define DIR_TYPE to be dirent. Otherwise, if you have 
+ * /usr/include/sys/dir.h, define DIR_TYPE to be direct and include that
+ * file. If you have neither, I'm confused.
+ */
+
+#ifndef NETWARE
+#include <sys/types.h>
+#endif
+#include <stdarg.h>
+
+#if !defined(NEXT) && !defined(WIN32)
+#include <dirent.h>
+#define DIR_TYPE dirent
+#elif !defined(WIN32)
+#include <sys/dir.h>
+#define DIR_TYPE direct
+#else
+#define DIR_TYPE dirent
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#ifdef __TANDEM
+#include <strings.h>
+#endif
+#include "ap_ctype.h"
+#if !defined(MPE) && !defined(WIN32) && !defined(TPF41) && !defined(__TANDEM) && !defined(NETWARE)
+#include <sys/file.h>
+#endif
+#if !defined(WIN32) && !defined(NETWARE)
+#include <sys/socket.h>
+#ifdef HAVE_SYS_SELECT_H
+#include <sys/select.h>
+#endif /* HAVE_SYS_SELECT_H */
+#ifndef TPF41
+#include <netinet/in.h>
+#endif /* ndef TPF41 */
+#if defined(OS390) && !defined(NO_ADDRESS)
+#define NO_ADDRESS NO_DATA  /* Not defined properly by OS/390 v1r2 */
+#endif
+#include <netdb.h>
+#include <sys/ioctl.h>
+#if !defined(MPE) && !defined(BEOS) && !defined(TPF41)
+#include <arpa/inet.h>		/* for inet_ntoa */
+#endif
+#include <sys/wait.h>
+#include <pwd.h>
+#include <grp.h>
+#include <fcntl.h>
+#ifndef BEOS
+#define closesocket(s) close(s)
+#endif
+#ifndef O_BINARY
+#define O_BINARY (0)
+#endif
+#endif /* ndef WIN32 */
+
+#include <limits.h>
+#include <time.h>		/* for ctime */
+#ifdef WIN32
+#define strftime(s,max,format,tm)  os_strftime(s,max,format,tm)
+#endif
+#include <signal.h>
+#ifdef NETWARE
+#undef SIGKILL
+#undef SA_NOCLDSTOP
+#undef SIGALRM
+#undef SIGCHILD
+#undef SIGCONT
+#undef SIGHUP
+#undef SIGPIPE
+#undef SIGQUIT
+#undef SIGSTOP
+#undef SIGTSTP
+#undef SIGTTIN
+#undef SIGTTOU
+#undef SIGUSR1
+#undef SIGUSR2
+#undef SIG_BLOCK
+#undef SIG_SETMASK
+#undef SIG_UNBLOCK
+#endif
+#if defined(TPF41) && defined(NSIG)
+#undef NSIG
+#endif
+#include <errno.h>
+#if !defined(QNX) && !defined(CONVEXOS11) && !defined(NEXT) && !defined(TPF41) && !defined(NETWARE) && !defined(MPE)
+#include <memory.h>
+#endif
+
+#ifdef NEED_PROCESS_H
+#include <process.h>
+#endif
+
+#if defined(WIN32) || defined(USE_HSREGEX)
+#include "hsregex.h"
+#else
+#include <regex.h>
+#endif
+
+#ifdef HAVE_SYS_RESOURCE_H
+#include <sys/resource.h>
+#ifdef SUNOS4
+int getrlimit(int, struct rlimit *);
+int setrlimit(int, struct rlimit *);
+#endif
+#endif
+#ifdef USE_MMAP_SCOREBOARD
+#if !defined(OS2) && !defined(WIN32)
+/* This file is not needed for OS/2 */
+#include <sys/mman.h>
+#endif
+#endif
+#if !defined(MAP_ANON) && defined(MAP_ANONYMOUS)
+#define MAP_ANON MAP_ANONYMOUS
+#endif
+
+#if defined(USE_MMAP_FILES) && (defined(NO_MMAP) || !defined(HAVE_MMAP))
+#undef USE_MMAP_FILES
+#endif
+
+#if defined(USE_MMAP_SCOREBOARD) && (defined(NO_MMAP) || !defined(HAVE_MMAP))
+#undef USE_MMAP_SCOREBOARD
+#endif
+
+#if defined(USE_SHMGET_SCOREBOARD) && (defined(NO_SHMGET) || !defined(HAVE_SHMGET))
+#undef USE_SHMGET_SCOREBOARD
+#endif
+
+/* A USE_FOO_SERIALIZED_ACCEPT implies a HAVE_FOO_SERIALIZED_ACCEPT */
+#if defined(USE_USLOCK_SERIALIZED_ACCEPT) && !defined(HAVE_USLOCK_SERIALIZED_ACCEPT)
+#define HAVE_USLOCK_SERIALIZED_ACCEPT
+#endif
+#if defined(USE_PTHREAD_SERIALIZED_ACCEPT) && !defined(HAVE_PTHREAD_SERIALIZED_ACCEPT)
+#define HAVE_PTHREAD_SERIALIZED_ACCEPT
+#endif
+#if defined(USE_SYSVSEM_SERIALIZED_ACCEPT) && !defined(HAVE_SYSVSEM_SERIALIZED_ACCEPT)
+#define HAVE_SYSVSEM_SERIALIZED_ACCEPT
+#endif
+#if defined(USE_FCNTL_SERIALIZED_ACCEPT) && !defined(HAVE_FCNTL_SERIALIZED_ACCEPT)
+#define HAVE_FCNTL_SERIALIZED_ACCEPT
+#endif
+#if defined(USE_FLOCK_SERIALIZED_ACCEPT) && !defined(HAVE_FLOCK_SERIALIZED_ACCEPT)
+#define HAVE_FLOCK_SERIALIZED_ACCEPT
+#endif
+#if defined(USE_OS2SEM_SERIALIZED_ACCEPT) && !defined(HAVE_OS2SEM_SERIALIZED_ACCEPT)
+#define HAVE_OS2SEM_SERIALIZED_ACCEPT
+#endif
+#if defined(USE_TPF_CORE_SERIALIZED_ACCEPT) && !defined(HAVE_TPF_CORE_SERIALIZED_ACCEPT)
+#define HAVE_TPF_CORE_SERIALIZED_ACCEPT
+#endif
+#if defined(USE_BEOS_SERIALIZED_ACCEPT) && !defined(HAVE_BEOS_SERIALIZED_ACCEPT)
+#define HAVE_BEOS_SERIALIZED_ACCEPT
+#endif
+#if defined(USE_NONE_SERIALIZED_ACCEPT) && !defined(HAVE_NONE_SERIALIZED_ACCEPT)
+#define HAVE_NONE_SERIALIZED_ACCEPT
+#endif
+
+#ifndef LOGNAME_MAX
+#define LOGNAME_MAX 25
+#endif
+
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+
+#ifdef ultrix
+#define ULTRIX_BRAIN_DEATH
+#endif
+
+#ifndef S_ISLNK
+#define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
+#endif
+
+#ifndef INADDR_NONE
+#define INADDR_NONE ((unsigned long) -1)
+#endif
+
+/*
+ * Replace signal function with sigaction equivalent
+ */
+#ifndef NO_USE_SIGACTION
+typedef void Sigfunc(int);
+
+#if defined(SIG_IGN) && !defined(SIG_ERR)
+#define SIG_ERR ((Sigfunc *)-1)
+#endif
+
+/*
+ * For some strange reason, QNX defines signal to signal. Eliminate it.
+ */
+#ifdef signal
+#undef signal
+#endif
+#define signal(s,f)	ap_signal(s,f)
+Sigfunc *signal(int signo, Sigfunc * func);
+#endif
+
+#include <setjmp.h>
+
+#if defined(USE_LONGJMP)
+#define ap_longjmp(x, y)        longjmp((x), (y))
+#define ap_setjmp(x)            setjmp(x)
+#ifndef JMP_BUF
+#define JMP_BUF jmp_buf
+#endif
+#else
+#define ap_longjmp(x, y)        siglongjmp((x), (y))
+#define ap_setjmp(x)            sigsetjmp((x), 1)
+#ifndef JMP_BUF
+#define JMP_BUF sigjmp_buf
+#endif
+#endif
+
+/* Majority of os's want to verify FD_SETSIZE */
+#if !defined(WIN32) && !defined(TPF) && !defined(NETWARE)
+#define CHECK_FD_SETSIZE
+#endif
+
+#ifdef USE_TPF_SELECT
+#define ap_select(_a, _b, _c, _d, _e)	\
+	tpf_select(_a, _b, _c, _d, _e)
+#elif defined(SELECT_NEEDS_CAST)
+#define ap_select(_a, _b, _c, _d, _e)   \
+    select((_a), (int *)(_b), (int *)(_c), (int *)(_d), (_e))
+#else
+#define ap_select(_a, _b, _c, _d, _e)   \
+	select(_a, _b, _c, _d, _e)
+#endif
+
+#ifdef USE_TPF_ACCEPT
+#define ap_accept(_fd, _sa, _ln)	tpf_accept(_fd, _sa, _ln)
+#else
+#define ap_accept(_fd, _sa, _ln)	accept(_fd, _sa, _ln)
+#endif
+
+#ifdef NEED_SIGNAL_INTERRUPT
+#define ap_check_signals()	tpf_process_signals()
+#else
+#define ap_check_signals()
+#endif
+
+#ifdef ULTRIX_BRAIN_DEATH
+#define ap_fdopen(d,m) fdopen((d), (char *)(m))
+#else
+#define ap_fdopen(d,m) fdopen((d), (m))
+#endif
+
+#ifndef ap_inet_addr
+#define ap_inet_addr inet_addr
+#endif
+
+#ifdef NO_OTHER_CHILD
+#define NO_RELIABLE_PIPED_LOGS
+#endif
+
+/* When the underlying OS doesn't support exec() of scripts which start
+ * with a HASHBANG (#!) followed by interpreter name and args, define this.
+ */
+#ifdef NEED_HASHBANG_EMUL
+extern int ap_execle(const char *filename, const char *arg,...);
+extern int ap_execve(const char *filename, char * const argv[],
+                     char * const envp[]);
+/* ap_execle() is a wrapper function around ap_execve(). */
+#define execle  ap_execle
+#define execve(path,argv,envp)  ap_execve(path,argv,envp)
+#endif
+
+/* Finding offsets of elements within structures.
+ * Taken from the X code... they've sweated portability of this stuff
+ * so we don't have to.  Sigh...
+ */
+
+#if defined(CRAY) || (defined(__arm) && !defined(LINUX))
+#ifdef __STDC__
+#define XtOffset(p_type,field) _Offsetof(p_type,field)
+#else
+#ifdef CRAY2
+#define XtOffset(p_type,field) \
+	(sizeof(int)*((unsigned int)&(((p_type)NULL)->field)))
+
+#else /* !CRAY2 */
+
+#define XtOffset(p_type,field) ((unsigned int)&(((p_type)NULL)->field))
+
+#endif /* !CRAY2 */
+#endif /* __STDC__ */
+#else /* ! (CRAY || __arm) */
+
+#define XtOffset(p_type,field) \
+	((long) (((char *) (&(((p_type)NULL)->field))) - ((char *) NULL)))
+
+#endif /* !CRAY */
+
+#ifndef XtOffsetOf
+#ifdef offsetof
+#define XtOffsetOf(s_type,field) offsetof(s_type,field)
+#else
+#define XtOffsetOf(s_type,field) XtOffset(s_type*,field)
+#endif
+#endif
+
+/*
+ * NET_SIZE_T exists because of shortsightedness on the POSIX committee.  BSD
+ * systems used "int *" as the parameter to accept(), getsockname(),
+ * getpeername() et al.  Consequently many unixes took an int * for that
+ * parameter.  The POSIX committee decided that "int" was just too generic and
+ * had to be replaced with size_t almost everywhere.  There's no problem with
+ * that when you're passing by value.  But when you're passing by reference
+ * this creates a gross source incompatibility with existing programs.  On
+ * 32-bit architectures it creates only a warning.  On 64-bit architectures it
+ * creates broken code -- because "int *" is a pointer to a 64-bit quantity and
+ * "size_t *" is frequently a pointer to a 32-bit quantity.
+ *
+ * Some Unixes adopted "size_t *" for the sake of POSIX compliance.  Others
+ * ignored it because it was such a broken interface.  Chaos ensued.  POSIX
+ * finally woke up and decided that it was wrong and created a new type
+ * socklen_t.  The only useful value for socklen_t is int, and that's how
+ * everyone who has a clue implements it.  It is almost always the case that
+ * NET_SIZE_T should be defined to be an int, unless the system being compiled
+ * for was created in the window of POSIX madness.
+ */
+#ifndef NET_SIZE_T
+#define NET_SIZE_T int
+#endif
+
+/* Linux defines __WCOREDUMP, but doesn't define WCOREDUMP unless __USE_BSD
+ * is in use... we'd prefer to just use WCOREDUMP everywhere.
+ */
+#if defined(__WCOREDUMP) && !defined(WCOREDUMP)
+#define WCOREDUMP __WCOREDUMP
+#endif
+
+#ifdef SUNOS_LIB_PROTOTYPES
+/* Prototypes needed to get a clean compile with gcc -Wall.
+ * Believe it or not, these do have to be declared, at least on SunOS,
+ * because they aren't mentioned in the relevant system headers.
+ * Sun Quality Software.  Gotta love it.  This section is not 
+ * currently (13Nov97) used.
+ */
+
+int getopt(int, char **, char *);
+
+int strcasecmp(const char *, const char *);
+int strncasecmp(const char *, const char *, int);
+int toupper(int);
+int tolower(int);
+
+int printf(char *,...);
+int fprintf(FILE *, char *,...);
+int fputs(char *, FILE *);
+int fread(char *, int, int, FILE *);
+int fwrite(char *, int, int, FILE *);
+int fgetc(FILE *);
+char *fgets(char *s, int, FILE*);
+int fflush(FILE *);
+int fclose(FILE *);
+int ungetc(int, FILE *);
+int _filbuf(FILE *);	/* !!! */
+int _flsbuf(unsigned char, FILE *);	/* !!! */
+int sscanf(char *, char *,...);
+void setbuf(FILE *, char *);
+void perror(char *);
+
+time_t time(time_t *);
+int strftime(char *, int, const char *, struct tm *);
+
+int initgroups(char *, int);
+int wait3(int *, int, void *);	/* Close enough for us... */
+int lstat(const char *, struct stat *);
+int stat(const char *, struct stat *);
+int flock(int, int);
+#ifndef NO_KILLPG
+int killpg(int, int);
+#endif
+int socket(int, int, int);
+int setsockopt(int, int, int, const char *, int);
+int listen(int, int);
+int bind(int, struct sockaddr *, int);
+int connect(int, struct sockaddr *, int);
+int accept(int, struct sockaddr *, int *);
+int shutdown(int, int);
+
+int getsockname(int s, struct sockaddr *name, int *namelen);
+int getpeername(int s, struct sockaddr *name, int *namelen);
+int gethostname(char *name, int namelen);
+void syslog(int, char *,...);
+char *mktemp(char *);
+
+int vfprintf(FILE *, const char *, va_list);
+
+#endif /* SUNOS_LIB_PROTOTYPES */
+
+/* The assumption is that when the functions are missing,
+ * then there's no matching prototype available either.
+ * Declare what is needed exactly as the replacement routines implement it.
+ */
+#ifdef NEED_STRDUP
+extern char *strdup (const char *str);
+#endif
+#ifdef NEED_STRCASECMP
+extern int strcasecmp (const char *a, const char *b);
+#endif
+#ifdef NEED_STRNCASECMP
+extern int strncasecmp (const char *a, const char *b, int n);
+#endif
+#ifdef NEED_INITGROUPS
+extern int initgroups(const char *name, gid_t basegid);
+#endif
+#ifdef NEED_WAITPID
+extern int waitpid(pid_t pid, int *statusp, int options);
+#endif
+#ifdef NEED_STRERROR
+extern char *strerror (int err);
+#endif
+#ifdef NEED_DIFFTIME
+extern double difftime(time_t time1, time_t time0);
+#endif
+
+#ifndef ap_wait_t
+#define ap_wait_t int
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* !AP_CONFIG_H */
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/include/ap_ctx.h apache_1.3.33/src/include/ap_ctx.h
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/include/ap_ctx.h	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/include/ap_ctx.h	Mon Jul 18 15:22:20 2005
@@ -0,0 +1,110 @@
+/* ====================================================================
+ * Copyright (c) 1998-2000 The Apache Group.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the Apache Group
+ *    for use in the Apache HTTP server project (http://www.apache.org/)."
+ *
+ * 4. The names "Apache Server" and "Apache Group" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    apache@apache.org.
+ *
+ * 5. Products derived from this software may not be called "Apache"
+ *    nor may "Apache" appear in their names without prior written
+ *    permission of the Apache Group.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the Apache Group
+ *    for use in the Apache HTTP server project (http://www.apache.org/)."
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE APACHE GROUP ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Group and was originally based
+ * on public domain software written at the National Center for
+ * Supercomputing Applications, University of Illinois, Urbana-Champaign.
+ * For more information on the Apache Group and the Apache HTTP server
+ * project, please see <http://www.apache.org/>.
+ *
+ */
+
+/*
+**  Generic Context Interface for Apache
+**  Written by Ralf S. Engelschall <rse@engelschall.com> 
+*/
+
+#ifdef EAPI
+
+#ifndef AP_CTX_H
+#define AP_CTX_H
+
+#ifndef FALSE
+#define FALSE 0
+#define TRUE  !FALSE
+#endif
+
+/*
+ * Internal Context Record Definition
+ */
+
+#define AP_CTX_MAX_ENTRIES 1024
+
+typedef struct {
+    char *ce_key;
+    void *ce_val;
+} ap_ctx_entry;
+
+typedef struct {
+    pool          *cr_pool;
+    ap_ctx_entry **cr_entry;
+} ap_ctx_rec;
+
+typedef ap_ctx_rec ap_ctx;
+
+/*
+ * Some convinience macros for storing _numbers_ 0...n in contexts, i.e.
+ * treating numbers as pointers but keeping track of the NULL return code of
+ * ap_ctx_get.
+ */
+#define AP_CTX_NUM2PTR(n) (void *)(((unsigned long)(n))+1)
+#define AP_CTX_PTR2NUM(p) (unsigned long)(((char *)(p))-1)
+
+/*
+ * Prototypes for Context Handling Functions
+ */
+
+API_EXPORT(ap_ctx *)ap_ctx_new(pool *p);
+API_EXPORT(void)    ap_ctx_set(ap_ctx *ctx, char *key, void *val);
+API_EXPORT(void *)  ap_ctx_get(ap_ctx *ctx, char *key);
+API_EXPORT(ap_ctx *)ap_ctx_overlay(pool *p, ap_ctx *over, ap_ctx *base);
+
+#endif /* AP_CTX_H */
+
+#endif /* EAPI */
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/include/ap_hook.h apache_1.3.33/src/include/ap_hook.h
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/include/ap_hook.h	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/include/ap_hook.h	Mon Jul 18 15:22:20 2005
@@ -0,0 +1,710 @@
+#if 0
+=cut
+#endif
+/* ====================================================================
+ * Copyright (c) 1998-2000 The Apache Group.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the Apache Group
+ *    for use in the Apache HTTP server project (http://www.apache.org/)."
+ *
+ * 4. The names "Apache Server" and "Apache Group" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    apache@apache.org.
+ *
+ * 5. Products derived from this software may not be called "Apache"
+ *    nor may "Apache" appear in their names without prior written
+ *    permission of the Apache Group.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the Apache Group
+ *    for use in the Apache HTTP server project (http://www.apache.org/)."
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE APACHE GROUP ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Group and was originally based
+ * on public domain software written at the National Center for
+ * Supercomputing Applications, University of Illinois, Urbana-Champaign.
+ * For more information on the Apache Group and the Apache HTTP server
+ * project, please see <http://www.apache.org/>.
+ *
+ */
+
+/*
+**  Implementation of a Generic Hook Interface for Apache
+**  Written by Ralf S. Engelschall <rse@engelschall.com> 
+**
+**  See POD document at end of this file for description.
+**  View it with the command ``pod2man ap_hook.h | nroff -man | more''
+**
+**  Attention: This header file is a little bit tricky.
+**             It's a combination of a C source and an embedded POD document
+**             The purpose of this is to have both things together at one
+**             place. So you can both pass this file to the C compiler and 
+**             the pod2man translater.
+*/
+
+#ifdef EAPI
+
+#ifndef AP_HOOK_H
+#define AP_HOOK_H
+
+/*
+ * Function Signature Specification:
+ *
+ * We encode the complete signature ingredients as a bitfield
+ * stored in a single unsigned long integer value, which can be
+ * constructed with AP_HOOK_SIGx(...)
+ */
+
+/* the type of the signature bitfield */
+typedef unsigned long int ap_hook_sig;
+
+/* the mask (bin) 111 (hex 0x7) for the triples in the bitfield */
+#define AP_HOOK_SIG_TRIPLE_MASK  0x7
+
+/* the position of the triple */
+#define AP_HOOK_SIG_TRIPLE_POS(n) ((n)*3)
+
+/* the constructor for triple #n with value v */
+#define AP_HOOK_SIG_TRIPLE(n,v) \
+        (((ap_hook_sig)(v))<<((AP_HOOK_##n)*3))
+
+/* the check whether triple #n in sig contains value v */
+#define AP_HOOK_SIG_HAS(sig,n,v) \
+        ((((ap_hook_sig)(sig))&AP_HOOK_SIG_TRIPLE(n, AP_HOOK_SIG_TRIPLE_MASK)) == (AP_HOOK_##n##_##v))
+
+/* utility function to get triple #n in sig */
+#define AP_HOOK_SIG_TRIPLE_GET(sig,n) \
+        ((((ap_hook_sig)(sig))>>AP_HOOK_SIG_TRIPLE_POS(n))&(AP_HOOK_SIG_TRIPLE_MASK))
+
+/* utility function to set triple #n in sig to value v */
+#define AP_HOOK_SIG_TRIPLE_SET(sig,n,v) \
+        ((((ap_hook_sig)(sig))&~(AP_HOOK_SIG_TRIPLE_MASK<<AP_HOOK_SIG_TRIPLE_POS(n)))|((v)<<AP_HOOK_SIG_TRIPLE_POS(n)))
+
+/* define the ingredients for the triple #0: id stuff */
+#define AP_HOOK_ID          0
+#define AP_HOOK_ID_ok       AP_HOOK_SIG_TRIPLE(ID,0)
+#define AP_HOOK_ID_undef    AP_HOOK_SIG_TRIPLE(ID,1)
+
+/* define the ingredients for the triple #1: return code */
+#define AP_HOOK_RC          1
+#define AP_HOOK_RC_void     AP_HOOK_SIG_TRIPLE(RC,0)
+#define AP_HOOK_RC_char     AP_HOOK_SIG_TRIPLE(RC,1)
+#define AP_HOOK_RC_int      AP_HOOK_SIG_TRIPLE(RC,2)
+#define AP_HOOK_RC_long     AP_HOOK_SIG_TRIPLE(RC,3)
+#define AP_HOOK_RC_float    AP_HOOK_SIG_TRIPLE(RC,4)
+#define AP_HOOK_RC_double   AP_HOOK_SIG_TRIPLE(RC,5)
+#define AP_HOOK_RC_ptr      AP_HOOK_SIG_TRIPLE(RC,6)
+
+/* define the ingredients for the triple #2: argument 1 */
+#define AP_HOOK_A1          2
+#define AP_HOOK_A1_ctx      AP_HOOK_SIG_TRIPLE(A1,0)
+#define AP_HOOK_A1_char     AP_HOOK_SIG_TRIPLE(A1,1)
+#define AP_HOOK_A1_int      AP_HOOK_SIG_TRIPLE(A1,2)
+#define AP_HOOK_A1_long     AP_HOOK_SIG_TRIPLE(A1,3)
+#define AP_HOOK_A1_float    AP_HOOK_SIG_TRIPLE(A1,4)
+#define AP_HOOK_A1_double   AP_HOOK_SIG_TRIPLE(A1,5)
+#define AP_HOOK_A1_ptr      AP_HOOK_SIG_TRIPLE(A1,6)
+
+/* define the ingredients for the triple #3: argument 2 */
+#define AP_HOOK_A2          3
+#define AP_HOOK_A2_ctx      AP_HOOK_SIG_TRIPLE(A2,0)
+#define AP_HOOK_A2_char     AP_HOOK_SIG_TRIPLE(A2,1)
+#define AP_HOOK_A2_int      AP_HOOK_SIG_TRIPLE(A2,2)
+#define AP_HOOK_A2_long     AP_HOOK_SIG_TRIPLE(A2,3)
+#define AP_HOOK_A2_float    AP_HOOK_SIG_TRIPLE(A2,4)
+#define AP_HOOK_A2_double   AP_HOOK_SIG_TRIPLE(A2,5)
+#define AP_HOOK_A2_ptr      AP_HOOK_SIG_TRIPLE(A2,6)
+
+/* define the ingredients for the triple #4: argument 3 */
+#define AP_HOOK_A3          4
+#define AP_HOOK_A3_ctx      AP_HOOK_SIG_TRIPLE(A3,0)
+#define AP_HOOK_A3_char     AP_HOOK_SIG_TRIPLE(A3,1)
+#define AP_HOOK_A3_int      AP_HOOK_SIG_TRIPLE(A3,2)
+#define AP_HOOK_A3_long     AP_HOOK_SIG_TRIPLE(A3,3)
+#define AP_HOOK_A3_float    AP_HOOK_SIG_TRIPLE(A3,4)
+#define AP_HOOK_A3_double   AP_HOOK_SIG_TRIPLE(A3,5)
+#define AP_HOOK_A3_ptr      AP_HOOK_SIG_TRIPLE(A3,6)
+
+/* define the ingredients for the triple #5: argument 4 */
+#define AP_HOOK_A4          5
+#define AP_HOOK_A4_ctx      AP_HOOK_SIG_TRIPLE(A4,0)
+#define AP_HOOK_A4_char     AP_HOOK_SIG_TRIPLE(A4,1)
+#define AP_HOOK_A4_int      AP_HOOK_SIG_TRIPLE(A4,2)
+#define AP_HOOK_A4_long     AP_HOOK_SIG_TRIPLE(A4,3)
+#define AP_HOOK_A4_float    AP_HOOK_SIG_TRIPLE(A4,4)
+#define AP_HOOK_A4_double   AP_HOOK_SIG_TRIPLE(A4,5)
+#define AP_HOOK_A4_ptr      AP_HOOK_SIG_TRIPLE(A4,6)
+
+/* define the ingredients for the triple #6: argument 5 */
+#define AP_HOOK_A5          6
+#define AP_HOOK_A5_ctx      AP_HOOK_SIG_TRIPLE(A5,0)
+#define AP_HOOK_A5_char     AP_HOOK_SIG_TRIPLE(A5,1)
+#define AP_HOOK_A5_int      AP_HOOK_SIG_TRIPLE(A5,2)
+#define AP_HOOK_A5_long     AP_HOOK_SIG_TRIPLE(A5,3)
+#define AP_HOOK_A5_float    AP_HOOK_SIG_TRIPLE(A5,4)
+#define AP_HOOK_A5_double   AP_HOOK_SIG_TRIPLE(A5,5)
+#define AP_HOOK_A5_ptr      AP_HOOK_SIG_TRIPLE(A5,6)
+
+/* define the ingredients for the triple #7: argument 6 */
+#define AP_HOOK_A6          7
+#define AP_HOOK_A6_ctx      AP_HOOK_SIG_TRIPLE(A6,0)
+#define AP_HOOK_A6_char     AP_HOOK_SIG_TRIPLE(A6,1)
+#define AP_HOOK_A6_int      AP_HOOK_SIG_TRIPLE(A6,2)
+#define AP_HOOK_A6_long     AP_HOOK_SIG_TRIPLE(A6,3)
+#define AP_HOOK_A6_float    AP_HOOK_SIG_TRIPLE(A6,4)
+#define AP_HOOK_A6_double   AP_HOOK_SIG_TRIPLE(A6,5)
+#define AP_HOOK_A6_ptr      AP_HOOK_SIG_TRIPLE(A6,6)
+
+/* define the ingredients for the triple #8: argument 7 */
+#define AP_HOOK_A7          8
+#define AP_HOOK_A7_ctx      AP_HOOK_SIG_TRIPLE(A7,0)
+#define AP_HOOK_A7_char     AP_HOOK_SIG_TRIPLE(A7,1)
+#define AP_HOOK_A7_int      AP_HOOK_SIG_TRIPLE(A7,2)
+#define AP_HOOK_A7_long     AP_HOOK_SIG_TRIPLE(A7,3)
+#define AP_HOOK_A7_float    AP_HOOK_SIG_TRIPLE(A7,4)
+#define AP_HOOK_A7_double   AP_HOOK_SIG_TRIPLE(A7,5)
+#define AP_HOOK_A7_ptr      AP_HOOK_SIG_TRIPLE(A7,6)
+
+/* define the ingredients for the triple #9: argument 8 */
+#define AP_HOOK_A8          9
+#define AP_HOOK_A8_ctx      AP_HOOK_SIG_TRIPLE(9,0)
+#define AP_HOOK_A8_char     AP_HOOK_SIG_TRIPLE(9,1)
+#define AP_HOOK_A8_int      AP_HOOK_SIG_TRIPLE(9,2)
+#define AP_HOOK_A8_long     AP_HOOK_SIG_TRIPLE(9,3)
+#define AP_HOOK_A8_float    AP_HOOK_SIG_TRIPLE(9,4)
+#define AP_HOOK_A8_double   AP_HOOK_SIG_TRIPLE(9,5)
+#define AP_HOOK_A8_ptr      AP_HOOK_SIG_TRIPLE(9,6)
+  
+/* the constructor for unknown signatures */
+#define AP_HOOK_SIG_UNKNOWN AP_HOOK_ID_undef
+
+/* the constructor for signatures with 1 type */
+#define AP_HOOK_SIG1(rc) \
+        (AP_HOOK_RC_##rc)
+
+/* the constructor for signatures with 2 types */
+#define AP_HOOK_SIG2(rc,a1) \
+        (AP_HOOK_RC_##rc|AP_HOOK_A1_##a1)
+
+/* the constructor for signatures with 3 types */
+#define AP_HOOK_SIG3(rc,a1,a2) \
+        (AP_HOOK_RC_##rc|AP_HOOK_A1_##a1|AP_HOOK_A2_##a2)
+
+/* the constructor for signatures with 4 types */
+#define AP_HOOK_SIG4(rc,a1,a2,a3) \
+        (AP_HOOK_RC_##rc|AP_HOOK_A1_##a1|AP_HOOK_A2_##a2|AP_HOOK_A3_##a3)
+
+/* the constructor for signatures with 5 types */
+#define AP_HOOK_SIG5(rc,a1,a2,a3,a4) \
+        (AP_HOOK_RC_##rc|AP_HOOK_A1_##a1|AP_HOOK_A2_##a2|AP_HOOK_A3_##a3|AP_HOOK_A4_##a4)
+
+/* the constructor for signatures with 6 types */
+#define AP_HOOK_SIG6(rc,a1,a2,a3,a4,a5) \
+        (AP_HOOK_RC_##rc|AP_HOOK_A1_##a1|AP_HOOK_A2_##a2|AP_HOOK_A3_##a3|AP_HOOK_A4_##a4|AP_HOOK_A5_##a5)
+
+/* the constructor for signatures with 7 types */
+#define AP_HOOK_SIG7(rc,a1,a2,a3,a4,a5,a6) \
+        (AP_HOOK_RC_##rc|AP_HOOK_A1_##a1|AP_HOOK_A2_##a2|AP_HOOK_A3_##a3|AP_HOOK_A4_##a4|AP_HOOK_A5_##a5|AP_HOOK_A6_##a6)
+
+/* the constructor for signatures with 8 types */
+#define AP_HOOK_SIG8(rc,a1,a2,a3,a4,a5,a6,a7) \
+        (AP_HOOK_RC_##rc|AP_HOOK_A1_##a1|AP_HOOK_A2_##a2|AP_HOOK_A3_##a3|AP_HOOK_A4_##a4|AP_HOOK_A5_##a5|AP_HOOK_A6_##a6|AP_HOOK_A7_##a7)
+
+/* the constructor for signatures with 9 types */
+#define AP_HOOK_SIG9(rc,a1,a2,a3,a4,a5,a6,a7,a8) \
+        (AP_HOOK_RC_##rc|AP_HOOK_A1_##a1|AP_HOOK_A2_##a2|AP_HOOK_A3_##a3|AP_HOOK_A4_##a4|AP_HOOK_A5_##a5|AP_HOOK_A6_##a6|AP_HOOK_A7_##a7|AP_HOOK_A8_##a8)
+
+/*
+ * Return Value Mode Identification
+ */
+
+/* the type of the return value modes */
+typedef unsigned int ap_hook_mode;
+
+/* the mode of the return value */
+#define AP_HOOK_MODE_UNKNOWN  0
+#define AP_HOOK_MODE_TOPMOST  1
+#define AP_HOOK_MODE_DECLINE  2
+#define AP_HOOK_MODE_DECLTMP  3
+#define AP_HOOK_MODE_ALL      4
+
+/* the constructors for the return value modes */
+#define AP_HOOK_TOPMOST       AP_HOOK_MODE_TOPMOST
+#define AP_HOOK_DECLINE(val)  AP_HOOK_MODE_DECLINE, (val)   
+#define AP_HOOK_DECLTMP(val)  AP_HOOK_MODE_DECLTMP, (val)   
+#define AP_HOOK_ALL           AP_HOOK_MODE_ALL
+
+/*
+ * Hook State Identification
+ */
+
+/* the type of the hook state */
+typedef unsigned short int ap_hook_state;
+
+/* the values of the hook state */
+#define AP_HOOK_STATE_UNDEF       0
+#define AP_HOOK_STATE_NOTEXISTANT 1
+#define AP_HOOK_STATE_ESTABLISHED 2
+#define AP_HOOK_STATE_CONFIGURED  3
+#define AP_HOOK_STATE_REGISTERED  4
+
+/*
+ * Hook Context Identification
+ *
+ * Notice: Null is ok here, because AP_HOOK_NOCTX is just a dummy argument
+ *         because we know from the signature whether the argument is a
+ *         context value or just the dummy value.
+ */
+
+#define AP_HOOK_NOCTX  (void *)(0)
+#define AP_HOOK_CTX(v) (void *)(v)
+
+/*
+ * Internal Hook Record Definition
+ */
+
+/* the union holding the arbitrary decline values */
+typedef union {
+    char   v_char;
+    int    v_int;
+    long   v_long;
+    float  v_float;
+    double v_double;
+    void  *v_ptr;
+} ap_hook_value;
+
+/* the structure holding one hook function and its context */
+typedef struct {
+    void *hf_ptr;              /* function pointer       */
+    void *hf_ctx;              /* function context       */
+} ap_hook_func;
+
+/* the structure holding one hook entry with all its registered functions */
+typedef struct {
+    char          *he_hook;    /* hook name (=unique id) */
+    ap_hook_sig    he_sig;     /* hook signature         */
+    int            he_modeid;  /* hook mode id           */
+    ap_hook_value  he_modeval; /* hook mode value        */
+    ap_hook_func **he_func;    /* hook registered funcs  */
+} ap_hook_entry;
+
+/* the maximum number of hooks and functions per hook */
+#define AP_HOOK_MAX_ENTRIES 512
+#define AP_HOOK_MAX_FUNCS   128
+
+/*
+ * Extended Variable Argument (vararg) Support
+ *
+ * In ANSI C varargs exists, but because the prototypes of function with
+ * varargs cannot reflect the types of the varargs, K&R argument passing
+ * conventions have to apply for the compiler.  This means mainly a conversion
+ * of shorter type variants to the maximum variant (according to sizeof). The
+ * above va_type() macro provides this mapping from the wanted types to the
+ * physically used ones.
+ */
+
+/* the mapping */
+#define VA_TYPE_char   int
+#define VA_TYPE_short  int
+#define VA_TYPE_int    int
+#define VA_TYPE_long   long
+#define VA_TYPE_float  double
+#define VA_TYPE_double double
+#define VA_TYPE_ptr    void *
+#define VA_TYPE_ctx    void *
+
+/* the constructor */
+#ifdef  va_type
+#undef  va_type
+#endif
+#define va_type(type)  VA_TYPE_ ## type
+
+/*
+ * Miscellaneous stuff
+ */
+
+#ifndef FALSE
+#define FALSE 0
+#define TRUE  !FALSE
+#endif
+
+/*
+ * Wrapper macros for the callback-function register/unregister calls.  
+ * 
+ * Background: Strict ANSI C doesn't allow a function pointer to be treated as
+ * a void pointer on argument passing, but we cannot declare the argument as a
+ * function prototype, because the functions can have arbitrary signatures. So
+ * we have to use a void pointer here. But to not require explicit casts on
+ * function pointers for every register/unregister call, we smooth the API a
+ * little bit by providing these macros.
+ */
+
+#define ap_hook_register(hook,func,ctx) ap_hook_register_I(hook,(void *)(func),ctx)
+#define ap_hook_unregister(hook,func)   ap_hook_unregister_I(hook,(void *)(func))
+
+/*
+ * Prototypes for the hook API functions
+ */
+
+API_EXPORT(void)          ap_hook_init         (void);
+API_EXPORT(void)          ap_hook_kill         (void);
+API_EXPORT(int)           ap_hook_configure    (char *hook, ap_hook_sig sig, ap_hook_mode modeid, ...);
+API_EXPORT(int)           ap_hook_register_I   (char *hook, void *func, void *ctx);
+API_EXPORT(int)           ap_hook_unregister_I (char *hook, void *func);
+API_EXPORT(ap_hook_state) ap_hook_status       (char *hook);
+API_EXPORT(int)           ap_hook_use          (char *hook, ap_hook_sig sig, ap_hook_mode modeid, ...);
+API_EXPORT(int)           ap_hook_call         (char *hook, ...);
+
+#endif /* AP_HOOK_H */
+
+#endif /* EAPI */
+/*
+=pod
+##
+##  Embedded POD document
+##
+
+=head1 NAME
+
+B<ap_hook> - B<Generic Hook Interface for Apache>
+
+=head1 SYNOPSIS
+
+B<Hook Library Setup:>
+
+ void ap_hook_init(void);
+ void ap_hook_kill(void);
+
+B<Hook Configuration and Registration:>
+
+ int ap_hook_configure(char *hook, ap_hook_sig sig, ap_hook_mode mode);
+ int ap_hook_register(char *hook, void *func, void *ctx);
+ int ap_hook_unregister(char *hook, void *func);
+
+B<Hook Usage:>
+
+ ap_hook_state ap_hook_status(char *hook);
+ int ap_hook_use(char *hook, ap_hook_sig sig, ap_hook_mode mode, ...);
+ int ap_hook_call(char *hook, ...);
+
+B<Hook Signature Constructors> (ap_hook_sig):
+
+ AP_HOOK_SIG1(rc)
+ AP_HOOK_SIG2(rc,a1)
+ AP_HOOK_SIG3(rc,a1,a2)
+ AP_HOOK_SIG4(rc,a1,a2,a3)
+ AP_HOOK_SIG5(rc,a1,a2,a3,a4)
+ AP_HOOK_SIG6(rc,a1,a2,a3,a4,a5)
+ AP_HOOK_SIG7(rc,a1,a2,a3,a4,a5,a6)
+ AP_HOOK_SIG8(rc,a1,a2,a3,a4,a5,a6,a7)
+
+B<Hook Modes Constructors> (ap_hook_mode):
+
+ AP_HOOK_TOPMOST
+ AP_HOOK_DECLINE(value)
+ AP_HOOK_DECLTMP(value)
+ AP_HOOK_ALL
+
+B<Hook States> (ap_hook_state):
+
+ AP_HOOK_STATE_UNDEF
+ AP_HOOK_STATE_NOTEXISTANT
+ AP_HOOK_STATE_ESTABLISHED
+ AP_HOOK_STATE_CONFIGURED 
+ AP_HOOK_STATE_REGISTERED
+
+=head1 DESCRIPTION
+
+This library implements a generic hook interface for Apache which can be used
+to loosely couple code through arbitrary hooks. There are two use cases for
+this mechanism:
+
+=over 3
+
+=item B<1. Extension and Overrides>
+
+Inside a specific code section you want to perform a specific function call
+for extension reasons.  But you want to allow one or more modules to implement
+this function by registering hooks. Those hooks are registered on a stack and
+can be even configured to have a I<decline> return value. As long as there are
+functions which return the decline value the next function on the stack is
+tried. When the first function doesn't return the decline value the hook call
+stops. 
+
+The original intent of this use case is to provide a flexible extension
+mechanism where modules can override functionality.
+
+=item B<2. Intercommunication>
+
+Inside a specific code you have a function you want to export. But you first
+want to allow other code to override this function.  And second you want to
+export this function without real object file symbol references. Instead you
+want to register the function and let the users call this function by name. 
+
+The original intent of this use case is to allow inter-module communication
+without direct symbol references, which are a big I<no-no> for the I<Dynamic
+Shared Object> (DSO) situation.
+
+=back
+
+And the following design goals existed:
+
+=over 3
+
+=item B<1. Minimum code changes>
+
+The hook calls should look very similar to the corresponding direct function
+call to allow one to easily translate it. And the total amount of changes for
+the hook registration, hook configuration and hook usage should be as small as
+possible to minimize the total code changes. Additionally a shorthand API
+function (ap_hook_use) should be provided which lets one trivially add a hook
+by just changing the code at a single location.
+
+=item B<2. The hook call has to be maximum flexible>
+
+In order to avoid nasty hacks, maximum flexiblity for the hook calls is
+needed, i.e. any function signature (the set of types for the return value and
+the arguments) should be supported.  And it should be possible to
+register always a context (ctx) variable with a function which is passed to
+the corresponding function when the hook call is performed.
+
+=back
+
+The implementation of this library directly followed these two design goals.
+
+=head1 USAGE
+
+Using this hook API is a four-step process:
+
+=over 3
+
+=item B<1. Initialization>
+
+Initialize or destroy the hook mechanism inside your application program:
+
+ ap_hook_init();
+    :
+ ap_hook_kill();
+
+=item B<2. Configuration>
+
+Configure a particular hook by specifing its name, signature and return type
+semantic:
+
+ ap_hook_configure("lookup", AP_HOOK_SIG2(ptr,ptr,ctx), AP_HOOK_DECLINE(NULL));
+ ap_hook_configure("setup", AP_HOOK_SIG2(int,ptr,char), AP_HOOK_DECLTMP(FALSE));
+ ap_hook_configure("read", AP_HOOK_SIG2(void,ptr), AP_HOOK_TOPMOST);
+ ap_hook_configure("logit", AP_HOOK_SIG2(void,ptr), AP_HOOK_ALL);
+
+This configures four hooks: 
+
+A hook named C<lookup> with the signature C<void *lookup(void *, void *)>
+(where the second argument is C<NULL> or the private context pointer of the
+hook function which can be optionally provided at the registration step
+later) and a return code semantic which says: Proceed as long as the
+registered lookup functions return C<NULL> or no more registered functions
+exists. A call for this hook has to provide 2 argument only (a pointer to the
+return variable and the first argument), because the context is
+implicitly provided by the hook mechanism. Sample idea: I<The first function
+who was successful in looking up a variable provides the value>.
+
+A hook named C<setup> with the signature C<int setup(void *, char)" and a
+return code semantic equal to the one of the C<lookup> hook. But the decline
+return value is implemented by a temporay variable of the hook mechanism and
+only used for the decline decision. So a call to this hook has to provide 2
+arguments only (the first and second argument, but no address to a return
+value). Sample idea: I<Any function can handle the setup and when one
+function handled it stops the processing by indicating this with the return
+value>.
+
+A hook named C<read> with the signature C<void read(void *)> and a return code
+semantic which says: Only the top most function on the registered function
+stack is tried (and independet of a possible return value in non-void
+context). A call to this hook has to provide exactly 1 argument (the
+single argument to the hook function). Sample idea: I<We want to
+use a read function and allow others to override it, but independent how much
+registered functions exists, only top most (= last registered) function
+overrides and is used>.
+
+A hook named C<logit> with the signature C<void logit(void *)> and a return
+code semantic which says: All registered functions on the hook functioin stack
+are tried. Sample idea: I<We pass a FILE pointer to the logging functions and
+any function can log whatever it wants>.
+
+=item B<3. Registration>
+
+Register the actual functions which should be used by the hook:
+
+ ap_hook_register("lookup", mylookup, mycontext);
+ ap_hook_register("setup", mysetup);
+ ap_hook_register("read", myread);
+ ap_hook_register("logit", mylogit);
+
+This registers the function C<mylookup()> under the C<lookup> hook with the
+private context given by the variable C<mycontext>. And it registers the
+function C<mysetup()> under the C<setup> hook without any context. Same for
+C<myread> and C<mylogit>.
+
+=item B<4. Usage>
+
+Finally use the hooks, i.e. instead of using direct function calls like
+        
+ rc = mylookup(a1, a2);
+ rc = mysetup(a1, a2);
+ myread(a1);
+ mylogit(a1);
+
+you now use:
+
+ ap_hook_call("lookup", &rc, a1, a2);
+ ap_hook_call("setup", &rc, a1, a2);
+ ap_hook_call("read", a1);
+ ap_hook_call("logit", a1);
+
+which are internally translated to:
+
+ rc = mylookup(a1, a2, mycontext);
+ rc = mysetup(a1, a2);
+ myread(a1);
+ mylogit(a1);
+
+Notice two things here: First the context (C<mycontext>) for the C<mylookup()>
+function is automatically added by the hook mechanism. And it is a different
+(and not fixed) context for each registered function, of course.  Second,
+return values always have to be pushed into variables and a pointer to them
+has to be given as the second argument to C<ap_hook_call> (except for
+functions which have a void return type, of course).
+
+BTW, the return value of C<ap_hook_call()> is always C<TRUE> or C<FALSE>.
+C<TRUE> when at least one function call was successful (always the case for
+C<AP_HOOK_TOPMOST> and C<AP_HOOK_ALL>). C<FALSE> when all functions
+returned the decline value or no functions are registered at all.
+
+=back
+
+=head1 RESTRICTIONS
+
+To make the hook implementation efficient and to not bloat up the code too
+much a few restrictions have to make:
+
+=over 3
+
+=item 1.
+
+Only function calls with up to 4 arguments are implemented. When more are
+needed you can either extend the hook implementation by using more bits for
+the signature configuration or you can do a workaround when the function is
+your own one: Put the remaining (N-4-1) arguments into a structure and pass
+only a pointer (one argument) as the forth argument.
+
+=item 2.
+
+Only the following ANSI C variable types are supported:
+
+ - For the return value: 
+   void (= none), char, int, float, double, ptr (= void *)
+ - For the arguments:
+   ctx  (= context), char, int, float, double, ptr (= void *)
+
+This means in theory that 6^5 (=7776) signature combinations are possible. But
+because we don't need all of them inside Apache and it would bloat up the code
+too dramatically we implement only a subset of those combinations. The
+implemented signatures can be specified inside C<ap_hook.c> and the
+corresponding code can be automatically generated by running ``C<perl
+ap_hook.c>'' (yeah, no joke ;-).  So when you need a hook with a different
+still not implemented signature you either have to again use a workaround as
+above (i.e. use a structure) or just add the signature to the C<ap_hook.c>
+file.
+
+=head1 EXAMPLE
+
+We want to call `C<ssize_t read(int, void *, size_t)>' through hooks in order
+to allow modules to override this call.  So, somewhere we have a replacement
+function for C<read()> defined (same signature, of course):
+
+ ssize_t my_read(int, void *, size_t);
+
+We now configure a C<read> hook. Here the C<AP_HOOK_SIGx()> macro defines the
+signature of the C<read()>-like callback functions and has to match the
+prototype of C<read()>. But we have to replace typedefs with the physical
+underlaying ANSI C types. And C<AP_HOOK_DECLINE()> sets the return value of
+the read()-like functions which forces the next hook to be called (here -1).
+And we register the original C<read()> function as the default hook.
+
+ ap_hook_configure("read", 
+                   AP_HOOK_SIG4(int,int,ptr,int), 
+                   AP_HOOK_DECLINE(-1));
+ ap_hook_register("read", read);
+
+Now a module wants to override the C<read()> call and registers the
+C<my_read()> function:
+
+ ap_hook_register("read", my_read);
+
+The function logically gets pushed onto a stack, so the execution order is the
+reverse registering order, i.e. I<last registered - first called>. Now we can
+replace the standard C<read()> call
+
+ bytes = read(fd, buf, bufsize);
+ if (bytes == -1)
+    ...error...
+
+with the hook based call:
+
+  rc = ap_hook_call("read", &bytes, fd, buf, bufsize);
+  if (rc == FALSE)
+     ...error...
+
+Now internally the following is done: The call `C<bytes = my_read(fd, buf,
+bufsize)>' is done. When it returns not -1 (the decline value) nothing
+more is done. But when C<my_read()> returns -1 the next function is tried:
+`C<bytes = read(fd, buf, bufsize)>'. When this one also returns -1 you get
+`rc == FALSE'. When it finally returns not -1 you get `rc == TRUE'.
+
+=head1 SEE ALSO
+
+ap_ctx(3)
+
+=head1 HISTORY
+
+The ap_hook(3) interface was originally designed and 
+implemented in October 1998 by Ralf S. Engelschall.
+
+=head1 AUTHOR
+
+ Ralf S. Engelschall
+ rse@engelschall.com
+ www.engelschall.com
+
+=cut
+*/
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/include/ap_mm.h apache_1.3.33/src/include/ap_mm.h
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/include/ap_mm.h	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/include/ap_mm.h	Mon Jul 18 15:22:20 2005
@@ -0,0 +1,130 @@
+/* ====================================================================
+ * Copyright (c) 1999-2000 The Apache Group.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the Apache Group
+ *    for use in the Apache HTTP server project (http://www.apache.org/)."
+ *
+ * 4. The names "Apache Server" and "Apache Group" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    apache@apache.org.
+ *
+ * 5. Products derived from this software may not be called "Apache"
+ *    nor may "Apache" appear in their names without prior written
+ *    permission of the Apache Group.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the Apache Group
+ *    for use in the Apache HTTP server project (http://www.apache.org/)."
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE APACHE GROUP ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Group and was originally based
+ * on public domain software written at the National Center for
+ * Supercomputing Applications, University of Illinois, Urbana-Champaign.
+ * For more information on the Apache Group and the Apache HTTP server
+ * project, please see <http://www.apache.org/>.
+ */
+
+/*
+**
+** ap_mm.h -- wrapper code for MM shared memory library
+**
+*/
+
+#ifdef EAPI
+
+#ifndef AP_MM_H 
+#define AP_MM_H 1
+
+#ifndef FALSE
+#define FALSE 0
+#define TRUE  !FALSE
+#endif
+
+API_EXPORT(int) ap_mm_useable(void);
+
+typedef void AP_MM;
+typedef enum { AP_MM_LOCK_RD, AP_MM_LOCK_RW } ap_mm_lock_mode;
+
+/* Global Malloc-Replacement API */
+API_EXPORT(int)     ap_MM_create(size_t size, char *file);
+API_EXPORT(int)     ap_MM_permission(mode_t mode, uid_t owner, gid_t group);
+API_EXPORT(void)    ap_MM_destroy(void);
+API_EXPORT(int)     ap_MM_lock(ap_mm_lock_mode mode);
+API_EXPORT(int)     ap_MM_unlock(void);
+API_EXPORT(void *)  ap_MM_malloc(size_t size);
+API_EXPORT(void *)  ap_MM_realloc(void *ptr, size_t size);
+API_EXPORT(void)    ap_MM_free(void *ptr);
+API_EXPORT(void *)  ap_MM_calloc(size_t number, size_t size);
+API_EXPORT(char *)  ap_MM_strdup(const char *str);
+API_EXPORT(size_t)  ap_MM_sizeof(void *ptr);
+API_EXPORT(size_t)  ap_MM_maxsize(void);
+API_EXPORT(size_t)  ap_MM_available(void);
+API_EXPORT(char *)  ap_MM_error(void);
+
+/* Standard Malloc-Style API */
+API_EXPORT(AP_MM *) ap_mm_create(size_t size, char *file);
+API_EXPORT(int)     ap_mm_permission(AP_MM *mm, mode_t mode, uid_t owner, gid_t group);
+API_EXPORT(void)    ap_mm_destroy(AP_MM *mm);
+API_EXPORT(int)     ap_mm_lock(AP_MM *mm, ap_mm_lock_mode mode);
+API_EXPORT(int)     ap_mm_unlock(AP_MM *mm);
+API_EXPORT(void *)  ap_mm_malloc(AP_MM *mm, size_t size);
+API_EXPORT(void *)  ap_mm_realloc(AP_MM *mm, void *ptr, size_t size);
+API_EXPORT(void)    ap_mm_free(AP_MM *mm, void *ptr);
+API_EXPORT(void *)  ap_mm_calloc(AP_MM *mm, size_t number, size_t size);
+API_EXPORT(char *)  ap_mm_strdup(AP_MM *mm, const char *str);
+API_EXPORT(size_t)  ap_mm_sizeof(AP_MM *mm, void *ptr);
+API_EXPORT(size_t)  ap_mm_maxsize(void);
+API_EXPORT(size_t)  ap_mm_available(AP_MM *mm);
+API_EXPORT(char *)  ap_mm_error(void);
+API_EXPORT(void)    ap_mm_display_info(AP_MM *mm);
+
+/* Low-Level Shared Memory API */
+API_EXPORT(void *)  ap_mm_core_create(size_t size, char *file);
+API_EXPORT(int)     ap_mm_core_permission(void *core, mode_t mode, uid_t owner, gid_t group);
+API_EXPORT(void)    ap_mm_core_delete(void *core);
+API_EXPORT(size_t)  ap_mm_core_size(void *core);
+API_EXPORT(int)     ap_mm_core_lock(void *core, ap_mm_lock_mode mode);
+API_EXPORT(int)     ap_mm_core_unlock(void *core);
+API_EXPORT(size_t)  ap_mm_core_maxsegsize(void);
+API_EXPORT(size_t)  ap_mm_core_align2page(size_t size);
+API_EXPORT(size_t)  ap_mm_core_align2word(size_t size);
+
+/* Internal Library API */
+API_EXPORT(void)    ap_mm_lib_error_set(unsigned int, const char *str);
+API_EXPORT(char *)  ap_mm_lib_error_get(void);
+API_EXPORT(int)     ap_mm_lib_version(void);
+
+#endif /* AP_MM_H */
+
+#endif /* EAPI */
+
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/include/ap_mmn.h apache_1.3.33/src/include/ap_mmn.h
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/include/ap_mmn.h	Thu Apr 15 17:51:51 2004
+++ apache_1.3.33/src/include/ap_mmn.h	Mon Jul 18 15:22:25 2005
@@ -205,7 +205,23 @@
  *                        in core_dir_config.
  */
 
+/* 
+ * Under Extended API situations we replace the magic cookie "AP13" with
+ * "EAPI" to let us distinguish between the EAPI module structure (which
+ * contain additional pointers at the end) and standard module structures
+ * (which lack at least NULL's for the pointers at the end).  This is
+ * important because standard ("AP13") modules would dump core when we
+ * dispatch over the additional hooks because NULL's are missing at the end of
+ * the module structure. See also the code in mod_so for details on loading
+ * (we accept both "AP13" and "EAPI").
+ */
+#ifdef EAPI
+#define MODULE_MAGIC_COOKIE_AP13 0x41503133UL /* "AP13" */
+#define MODULE_MAGIC_COOKIE_EAPI 0x45415049UL /* "EAPI" */
+#define MODULE_MAGIC_COOKIE      MODULE_MAGIC_COOKIE_EAPI 
+#else
 #define MODULE_MAGIC_COOKIE 0x41503133UL /* "AP13" */
+#endif
 
 #ifndef MODULE_MAGIC_NUMBER_MAJOR
 #define MODULE_MAGIC_NUMBER_MAJOR 19990320
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/include/buff.h apache_1.3.33/src/include/buff.h
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/include/buff.h	Mon Feb 16 23:25:08 2004
+++ apache_1.3.33/src/include/buff.h	Mon Jul 18 15:22:25 2005
@@ -82,6 +82,10 @@
     /* transport handle, for RPC binding handle or some such */
     void *t_handle;
 
+#ifdef EAPI
+    ap_ctx *ctx;
+#endif /* EAPI */
+
 #ifdef B_SFIO
     Sfio_t *sf_in;
     Sfio_t *sf_out;
@@ -137,6 +141,10 @@
 /* Internal routines */
 API_EXPORT(int) ap_bflsbuf(int c, BUFF *fb);
 API_EXPORT(int) ap_bfilbuf(BUFF *fb);
+
+#ifdef EAPI
+#define ap_bpeekc(fb) ( ((fb)->incnt == 0) ? EOF : *((fb)->inptr) )
+#endif
 
 #ifndef CHARSET_EBCDIC
 
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/include/hsregex.h apache_1.3.33/src/include/hsregex.h
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/include/hsregex.h	Thu Apr 15 17:51:51 2004
+++ apache_1.3.33/src/include/hsregex.h	Mon Jul 18 15:22:18 2005
@@ -22,7 +22,7 @@
 #define ap_private_extern
 #endif
 
-typedef off_t regoff_t;
+typedef int regoff_t;
 typedef struct {
 	int re_magic;
 	size_t re_nsub;		/* number of parenthesized subexpressions */
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/include/hsregex.h.orig apache_1.3.33/src/include/hsregex.h.orig
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/include/hsregex.h.orig	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/include/hsregex.h.orig	Thu Apr 15 17:51:51 2004
@@ -0,0 +1,89 @@
+/* DON'T EVEN THINK ABOUT EDITING THIS, go see regex/Makefile,
+ * search for mkh */
+#ifndef _REGEX_H_
+#define	_REGEX_H_	/* never again */
+/* ========= begin header generated by ./mkh ========= */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* === regex2.h === */
+#ifndef API_EXPORT
+#ifdef WIN32
+#define API_EXPORT(type)    __declspec(dllexport) type __stdcall
+#else
+#define API_EXPORT(type)    type
+#endif
+#endif
+
+#if defined(MAC_OS) || defined(MAC_OS_X_SERVER)
+#define ap_private_extern __private_extern__
+#else
+#define ap_private_extern
+#endif
+
+typedef off_t regoff_t;
+typedef struct {
+	int re_magic;
+	size_t re_nsub;		/* number of parenthesized subexpressions */
+	const char *re_endp;	/* end pointer for REG_PEND */
+	struct re_guts *re_g;	/* none of your business :-) */
+} regex_t;
+typedef struct {
+	regoff_t rm_so;		/* start of match */
+	regoff_t rm_eo;		/* end of match */
+} regmatch_t;
+
+
+/* === regcomp.c === */
+API_EXPORT(int) regcomp(regex_t *, const char *, int);
+#define	REG_BASIC	0000
+#define	REG_EXTENDED	0001
+#define	REG_ICASE	0002
+#define	REG_NOSUB	0004
+#define	REG_NEWLINE	0010
+#define	REG_NOSPEC	0020
+#define	REG_PEND	0040
+#define	REG_DUMP	0200
+
+
+/* === regerror.c === */
+#define	REG_NOMATCH	 1
+#define	REG_BADPAT	 2
+#define	REG_ECOLLATE	 3
+#define	REG_ECTYPE	 4
+#define	REG_EESCAPE	 5
+#define	REG_ESUBREG	 6
+#define	REG_EBRACK	 7
+#define	REG_EPAREN	 8
+#define	REG_EBRACE	 9
+#define	REG_BADBR	10
+#define	REG_ERANGE	11
+#define	REG_ESPACE	12
+#define	REG_BADRPT	13
+#define	REG_EMPTY	14
+#define	REG_ASSERT	15
+#define	REG_INVARG	16
+#define	REG_ATOI	255	/* convert name to number (!) */
+#define	REG_ITOA	0400	/* convert number to name (!) */
+API_EXPORT(size_t) regerror(int, const regex_t *, char *, size_t);
+
+
+/* === regexec.c === */
+API_EXPORT(int) regexec(const regex_t *, const char *, size_t, regmatch_t [], int);
+#define	REG_NOTBOL	00001
+#define	REG_NOTEOL	00002
+#define	REG_STARTEND	00004
+#define	REG_TRACE	00400	/* tracing of execution */
+#define	REG_LARGE	01000	/* force large representation */
+#define	REG_BACKR	02000	/* force use of backref code */
+
+
+/* === regfree.c === */
+API_EXPORT(void) regfree(regex_t *);
+
+#ifdef __cplusplus
+}
+#endif
+/* ========= end header generated by ./mkh ========= */
+#endif
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/include/http_conf_globals.h apache_1.3.33/src/include/http_conf_globals.h
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/include/http_conf_globals.h	Mon Feb 16 23:25:08 2004
+++ apache_1.3.33/src/include/http_conf_globals.h	Mon Jul 18 15:22:25 2005
@@ -52,6 +52,9 @@
 #endif
 extern int ap_dump_settings;
 extern API_VAR_EXPORT int ap_extended_status;
+#ifdef EAPI
+extern API_VAR_EXPORT ap_ctx *ap_global_ctx;
+#endif /* EAPI */
 
 extern API_VAR_EXPORT char *ap_pid_fname;
 extern API_VAR_EXPORT char *ap_scoreboard_fname;
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/include/http_config.h apache_1.3.33/src/include/http_config.h
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/include/http_config.h	Mon Feb 16 23:25:08 2004
+++ apache_1.3.33/src/include/http_config.h	Mon Jul 18 15:22:25 2005
@@ -233,6 +233,65 @@
     void (*child_exit) (server_rec *, pool *);
 #endif
     int (*post_read_request) (request_rec *);
+
+#ifdef EAPI
+    /*
+     * ANSI C guarantees us that we can at least _extend_ the module structure
+     * with additional hooks without the need to change all existing modules.
+     * Because: ``If there are fewer initializers in the list than members of
+     * the structure, the trailing members are initialized with 0.'' (The C
+     * Programming Language, 2nd Ed., A8.7 Initialization). So we just
+     * have to put our additional hooks here:
+     *
+     * add_module: 
+     *     Called from within ap_add_module() right after the module structure
+     *     was linked into the Apache internal module list.  It is mainly
+     *     intended to be used to define configuration defines (<IfDefine>)
+     *     which have to be available directly after a LoadModule/AddModule.
+     *     Actually this is the earliest possible hook a module can use.
+     *
+     * remove_module: 
+     *     Called from within ap_remove_module() right before the module
+     *     structure is kicked out from the Apache internal module list.
+     *     Actually this is last possible hook a module can use and exists for
+     *     consistency with the add_module hook.
+     *
+     * rewrite_command:
+     *     Called right after a configuration directive line was read and
+     *     before it is processed. It is mainly intended to be used for
+     *     rewriting directives in order to provide backward compatibility to
+     *     old directive variants.
+     *
+     * new_connection:
+     *     Called from within the internal new_connection() function, right
+     *     after the conn_rec structure for the new established connection was
+     *     created and before Apache starts processing the request with
+     *     ap_read_request().  It is mainly intended to be used to setup/run
+     *     connection dependent things like sending start headers for
+     *     on-the-fly compression, etc.
+     *
+     * close_connection:
+     *     Called from within the Apache dispatching loop just before any
+     *     ap_bclose() is performed on the socket connection, but a long time
+     *     before any pool cleanups are done for the connection (which can be
+     *     too late for some applications).  It is mainly intended to be used
+     *     to close/finalize connection dependent things like sending end
+     *     headers for on-the-fly compression, etc.
+     */
+#ifdef ULTRIX_BRAIN_DEATH
+    void  (*add_module) ();
+    void  (*remove_module) ();
+    char *(*rewrite_command) ();
+    void  (*new_connection) ();
+    void  (*close_connection) ();
+#else
+    void  (*add_module) (struct module_struct *);
+    void  (*remove_module) (struct module_struct *);
+    char *(*rewrite_command) (cmd_parms *, void *config, const char *);
+    void  (*new_connection) (conn_rec *);
+    void  (*close_connection) (conn_rec *);
+#endif
+#endif /* EAPI */
 } module;
 
 /* Initializer for the first few module slots, which are only
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/include/httpd.h apache_1.3.33/src/include/httpd.h
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/include/httpd.h	Wed Oct 27 18:34:01 2004
+++ apache_1.3.33/src/include/httpd.h	Mon Jul 18 15:22:25 2005
@@ -27,7 +27,19 @@
 /* Headers in which EVERYONE has an interest... */
 
 #include "ap_config.h"
+#ifdef EAPI
+#include "ap_mm.h"
+#endif
 #include "ap_alloc.h"
+/*
+ * Include the Extended API headers.
+ * Don't move the position. It has to be after ap_alloc.h because it uses the
+ * pool stuff but before buff.h because the buffer stuff uses the EAPI, too. 
+ */
+#ifdef EAPI
+#include "ap_hook.h"
+#include "ap_ctx.h"
+#endif /* EAPI */
 #include "buff.h"
 #include "ap.h"
 
@@ -102,8 +114,13 @@
 #define ap_http_method(r) ap_os_http_method((void*)r)
 #define ap_default_port(r) ap_os_default_port((void*)r)
 #else
+#ifdef EAPI
+#define ap_http_method(r)   (((r)->ctx != NULL && ap_ctx_get((r)->ctx, "ap::http::method") != NULL) ? ((char *)ap_ctx_get((r)->ctx, "ap::http::method")) : "http")
+#define ap_default_port(r)  (((r)->ctx != NULL && ap_ctx_get((r)->ctx, "ap::default::port") != NULL) ? atoi((char *)ap_ctx_get((r)->ctx, "ap::default::port")) : DEFAULT_HTTP_PORT)
+#else /* EAPI */
 #define ap_http_method(r)	"http"
 #define ap_default_port(r)	DEFAULT_HTTP_PORT
+#endif /* EAPI */
 #endif
 
 /* --------- Default user name and group name running standalone ---------- */
@@ -312,6 +329,19 @@
 #define SCOREBOARD_MAINTENANCE_INTERVAL 1000000
 #endif
 
+/*
+ * Unix only:
+ * Path to Shared Memory Files 
+ */
+#ifdef EAPI
+#ifndef EAPI_MM_CORE_PATH
+#define EAPI_MM_CORE_PATH "logs/mm"
+#endif
+#ifndef EAPI_MM_CORE_MAXSIZE
+#define EAPI_MM_CORE_MAXSIZE 1024*1024*1 /* max. 1MB */
+#endif
+#endif
+
 /* Number of requests to try to handle in a single process.  If <= 0,
  * the children don't die off.  That's the default here, since I'm still
  * interested in finding and stanching leaks.
@@ -404,6 +434,9 @@
 API_EXPORT(const char *) ap_get_server_version(void);
 API_EXPORT(void) ap_add_version_component(const char *component);
 API_EXPORT(const char *) ap_get_server_built(void);
+#ifdef EAPI
+API_EXPORT(void) ap_add_config_define(const char *define);
+#endif /* EAPI */
 
 /* Numeric release version identifier: MMNNFFRBB: major minor fix final beta
  * Always increases along the same track as the source branch.
@@ -807,6 +840,10 @@
  * record to improve 64bit alignment the next time we need to break
  * binary compatibility for some other reason.
  */
+
+#ifdef EAPI
+    ap_ctx *ctx;
+#endif /* EAPI */
 };
 
 
@@ -855,6 +892,9 @@
     char *local_host;		/* used for ap_get_server_name when
 				 * UseCanonicalName is set to DNS
 				 * (ignores setting of HostnameLookups) */
+#ifdef EAPI
+    ap_ctx *ctx;
+#endif /* EAPI */
 };
 
 /* Per-vhost config... */
@@ -927,6 +967,10 @@
     int limit_req_line;      /* limit on size of the HTTP request line    */
     int limit_req_fieldsize; /* limit on size of any request header field */
     int limit_req_fields;    /* limit on number of request header fields  */
+
+#ifdef EAPI
+    ap_ctx *ctx;
+#endif /* EAPI */
 };
 
 /* These are more like real hosts than virtual hosts */
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/include/os-inline.c apache_1.3.33/src/include/os-inline.c
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/include/os-inline.c	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/include/os-inline.c	Fri Feb 20 22:01:04 2004
@@ -0,0 +1,46 @@
+/* Copyright 1999-2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * This file contains functions which can be inlined if the compiler
+ * has an "inline" modifier. Because of this, this file is both a
+ * header file and a compilable module.
+ *
+ * Only inlineable functions should be defined in here. They must all
+ * include the INLINE modifier. 
+ *
+ * If the compiler supports inline, this file will be #included as a
+ * header file from os.h to create all the inline function
+ * definitions. INLINE will be defined to whatever is required on
+ * function definitions to make them inline declarations.
+ *
+ * If the compiler does not support inline, this file will be compiled
+ * as a normal C file into libos.a (along with os.c). In this case
+ * INLINE will _not_ be set so we can use this to test if we are
+ * compiling this source file.  
+ */
+
+#ifndef INLINE
+#define INLINE
+
+/* Anything required only when compiling */
+#include "ap_config.h"
+
+#endif
+
+INLINE int ap_os_is_path_absolute(const char *file)
+{
+  return file[0] == '/';
+}
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/include/os.h apache_1.3.33/src/include/os.h
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/include/os.h	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/include/os.h	Fri Feb 20 22:01:04 2004
@@ -0,0 +1,108 @@
+/* Copyright 1999-2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef APACHE_OS_H
+#define APACHE_OS_H
+
+#include "ap_config.h"
+
+#ifndef PLATFORM
+#define PLATFORM "Unix"
+#endif
+
+/*
+ * This file in included in all Apache source code. It contains definitions
+ * of facilities available on _this_ operating system (HAVE_* macros),
+ * and prototypes of OS specific functions defined in os.c or os-inline.c
+ */
+
+#if !defined(INLINE) && defined(USE_GNU_INLINE)
+/* Compiler supports inline, so include the inlineable functions as
+ * part of the header
+ */
+#define INLINE extern ap_inline
+
+INLINE int ap_os_is_path_absolute(const char *file);
+
+#include "os-inline.c"
+
+#else
+
+/* Compiler does not support inline, so prototype the inlineable functions
+ * as normal
+ */
+extern int ap_os_is_path_absolute(const char *file);
+#endif
+
+/* Other ap_os_ routines not used by this platform */
+
+#define ap_os_is_filename_valid(f)          (1)
+#define ap_os_kill(pid, sig)                kill(pid, sig)
+
+/*
+ *  Abstraction layer for loading
+ *  Apache modules under run-time via 
+ *  dynamic shared object (DSO) mechanism
+ */
+
+#ifdef HAVE_DL_H
+#include <dl.h>
+#endif
+
+/*
+ * Do not use native AIX DSO support on releases of AIX prior
+ * to 4.3. 
+ */
+#ifdef AIX
+#if AIX < 430
+#undef HAVE_DLFCN_H
+#endif
+#endif
+
+#ifdef HAVE_DLFCN_H
+#include <dlfcn.h>
+#else
+void *dlopen(const char *, int);
+int dlclose(void *);
+void *dlsym(void *, const char *);
+const char *dlerror(void);
+#endif
+
+/* probably on an older system that doesn't support RTLD_NOW or RTLD_LAZY.
+ * The below define is a lie since we are really doing RTLD_LAZY since the
+ * system doesn't support RTLD_NOW.
+ */
+#ifndef RTLD_NOW
+#define RTLD_NOW 1
+#endif
+
+#ifndef RTLD_GLOBAL
+#define RTLD_GLOBAL 0
+#endif
+
+#if (defined(__FreeBSD__) ||\
+     defined(__OpenBSD__) ||\
+     defined(__NetBSD__)     ) && !defined(__ELF__)
+#define DLSYM_NEEDS_UNDERSCORE
+#endif
+
+#define     ap_os_dso_handle_t  void *
+void        ap_os_dso_init(void);
+void *      ap_os_dso_load(const char *);
+void        ap_os_dso_unload(void *);
+void *      ap_os_dso_sym(void *, const char *);
+const char *ap_os_dso_error(void);
+
+#endif	/* !APACHE_OS_H */
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/main/Makefile.tmpl apache_1.3.33/src/main/Makefile.tmpl
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/main/Makefile.tmpl	Fri Jun 23 01:22:27 2000
+++ apache_1.3.33/src/main/Makefile.tmpl	Mon Jul 18 15:22:52 2005
@@ -1,5 +1,6 @@
 
 CFLAGS=$(OPTIM) $(CFLAGS1) $(EXTRA_CFLAGS)
+HOST_CFLAGS=$(CFLAGS)
 LIBS=$(EXTRA_LIBS) $(LIBS1)
 INCLUDES=$(INCLUDES1) $(INCLUDES0) $(EXTRA_INCLUDES)
 LDFLAGS=$(LDFLAGS1) $(EXTRA_LDFLAGS)
@@ -33,13 +34,13 @@
 	./gen_uri_delims >uri_delims.h
 
 gen_uri_delims: gen_uri_delims.o
-	$(CC) $(CFLAGS) $(LDFLAGS) -o gen_uri_delims gen_uri_delims.o $(LIBS)
+	$(HOSTCC) $(INCLUDES) $(HOST_CFLAGS) $(LDFLAGS) -o gen_uri_delims gen_uri_delims.o $(LIBS)
 
 test_char.h: gen_test_char
 	./gen_test_char >test_char.h
 
 gen_test_char: gen_test_char.o
-	$(CC) $(CFLAGS) $(LDFLAGS) -o gen_test_char gen_test_char.o $(LIBS)
+	$(HOSTCC) $(INCLUDES) $(HOST_CFLAGS) $(LDFLAGS) -o gen_test_char gen_test_char.o $(LIBS)
 
 # We really don't expect end users to use this rule.  It works only with
 # gcc, and rebuilds Makefile.tmpl.  You have to re-run Configure after
@@ -73,7 +74,9 @@
  $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h $(INCDIR)/ap_ctype.h \
  $(INCDIR)/hsregex.h $(INCDIR)/ap_alloc.h $(INCDIR)/buff.h \
  $(INCDIR)/ap.h $(INCDIR)/util_uri.h
+	$(HOSTCC) $(INCLUDES) $(HOST_CFLAGS) -c -o $@ $<
 gen_uri_delims.o: gen_uri_delims.c
+	$(HOSTCC) $(INCLUDES) $(HOST_CFLAGS) -c -o $@ $<
 http_config.o: http_config.c $(INCDIR)/httpd.h $(INCDIR)/ap_config.h \
  $(INCDIR)/ap_mmn.h $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h \
  $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h $(INCDIR)/ap_alloc.h \
@@ -81,6 +84,7 @@
  $(INCDIR)/http_config.h $(INCDIR)/http_core.h $(INCDIR)/http_log.h \
  $(INCDIR)/http_request.h $(INCDIR)/http_conf_globals.h \
  $(INCDIR)/http_vhost.h $(INCDIR)/explain.h
+	$(CC) $(INCLUDES) $(HOST_CFLAGS) -c -o $@ $<
 http_core.o: http_core.c $(INCDIR)/httpd.h $(INCDIR)/ap_config.h \
  $(INCDIR)/ap_mmn.h $(INCDIR)/ap_config_auto.h $(OSDIR)/os.h \
  $(INCDIR)/ap_ctype.h $(INCDIR)/hsregex.h $(INCDIR)/ap_alloc.h \
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/main/alloc.c apache_1.3.33/src/main/alloc.c
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/main/alloc.c	Sun Jul  4 13:34:36 2004
+++ apache_1.3.33/src/main/alloc.c	Mon Jul 18 15:22:25 2005
@@ -21,6 +21,10 @@
  */
 
 #include "httpd.h"
+#ifdef EAPI
+#include "http_config.h"
+#include "http_conf_globals.h"
+#endif
 #include "multithread.h"
 #include "http_log.h"
 
@@ -95,6 +99,10 @@
 #define BLOCK_MINALLOC	0
 #endif
 
+#if defined(EAPI) && defined(EAPI_MM)
+static AP_MM *mm = NULL;
+#endif
+
 /*****************************************************************
  *
  * Managing free storage blocks...
@@ -123,6 +131,9 @@
 	char *endp;
 	union block_hdr *next;
 	char *first_avail;
+#if defined(EAPI) && defined(EAPI_MM)
+	int is_shm;
+#endif
 #ifdef POOL_DEBUG
 	union block_hdr *global_next;
 	struct pool *owning_pool;
@@ -173,7 +184,11 @@
 /* Get a completely new block from the system pool. Note that we rely on
    malloc() to provide aligned memory. */
 
+#if defined(EAPI) && defined(EAPI_MM)
+static union block_hdr *malloc_block(int size, int is_shm)
+#else
 static union block_hdr *malloc_block(int size)
+#endif
 {
     union block_hdr *blok;
     int request_size;
@@ -189,6 +204,11 @@
     num_malloc_bytes += size + sizeof(union block_hdr);
 #endif
     request_size = size + sizeof(union block_hdr);
+#if defined(EAPI) && defined(EAPI_MM)
+    if (is_shm)
+        blok = (union block_hdr *)ap_mm_malloc(mm, request_size);
+    else
+#endif
     blok = (union block_hdr *) malloc(request_size);
     if (blok == NULL) {
 	fprintf(stderr, "Ouch!  malloc(%d) failed in malloc_block()\n",
@@ -196,6 +216,9 @@
 	exit(1);
     }
     debug_fill(blok, size + sizeof(union block_hdr));
+#if defined(EAPI) && defined(EAPI_MM)
+    blok->h.is_shm = is_shm;
+#endif
     blok->h.next = NULL;
     blok->h.first_avail = (char *) (blok + 1);
     blok->h.endp = size + blok->h.first_avail;
@@ -256,6 +279,10 @@
     if (blok == NULL)
 	return;			/* Sanity check --- freeing empty pool? */
 
+#if defined(EAPI) && defined(EAPI_MM)
+    if (blok->h.is_shm)
+        (void)ap_mm_lock(mm, AP_MM_LOCK_RW);
+#endif
     (void) ap_acquire_mutex(alloc_mutex);
     old_free_list = block_freelist;
     block_freelist = blok;
@@ -302,6 +329,10 @@
 #endif
 
     (void) ap_release_mutex(alloc_mutex);
+#if defined(EAPI) && defined(EAPI_MM)
+    if (blok->h.is_shm)
+        (void)ap_mm_unlock(mm);
+#endif
 #endif
 }
 
@@ -310,7 +341,11 @@
  * if necessary.  Must be called with alarms blocked.
  */
 
+#if defined(EAPI) && defined(EAPI_MM)
+static union block_hdr *new_block(int min_size, int is_shm)
+#else
 static union block_hdr *new_block(int min_size)
+#endif
 {
     union block_hdr **lastptr = &block_freelist;
     union block_hdr *blok = block_freelist;
@@ -320,7 +355,12 @@
      */
 
     while (blok != NULL) {
+#if defined(EAPI) && defined(EAPI_MM)
+    if (blok->h.is_shm == is_shm &&
+        min_size + BLOCK_MINFREE <= blok->h.endp - blok->h.first_avail) {
+#else
 	if (min_size + BLOCK_MINFREE <= blok->h.endp - blok->h.first_avail) {
+#endif
 	    *lastptr = blok->h.next;
 	    blok->h.next = NULL;
 	    debug_verify_filled(blok->h.first_avail, blok->h.endp,
@@ -336,7 +376,11 @@
     /* Nope. */
 
     min_size += BLOCK_MINFREE;
+#if defined(EAPI) && defined(EAPI_MM)
+    blok = malloc_block((min_size > BLOCK_MINALLOC) ? min_size : BLOCK_MINALLOC, is_shm);
+#else
     blok = malloc_block((min_size > BLOCK_MINALLOC) ? min_size : BLOCK_MINALLOC);
+#endif
     return blok;
 }
 
@@ -386,6 +430,9 @@
 #ifdef POOL_DEBUG
     struct pool *joined;
 #endif
+#if defined(EAPI) && defined(EAPI_MM)
+    int is_shm;
+#endif
 };
 
 static pool *permanent_pool;
@@ -400,16 +447,28 @@
 #define POOL_HDR_CLICKS (1 + ((sizeof(struct pool) - 1) / CLICK_SZ))
 #define POOL_HDR_BYTES (POOL_HDR_CLICKS * CLICK_SZ)
 
+#if defined(EAPI) && defined(EAPI_MM)
+static struct pool *make_sub_pool_internal(struct pool *p, int is_shm)
+#else
 API_EXPORT(struct pool *) ap_make_sub_pool(struct pool *p)
+#endif
 {
     union block_hdr *blok;
     pool *new_pool;
 
     ap_block_alarms();
 
+#if defined(EAPI) && defined(EAPI_MM)
+    if (is_shm)
+        (void)ap_mm_lock(mm, AP_MM_LOCK_RW);
+#endif
     (void) ap_acquire_mutex(alloc_mutex);
 
+#if defined(EAPI) && defined(EAPI_MM)
+    blok = new_block(POOL_HDR_BYTES, is_shm);
+#else
     blok = new_block(POOL_HDR_BYTES);
+#endif
     new_pool = (pool *) blok->h.first_avail;
     blok->h.first_avail += POOL_HDR_BYTES;
 #ifdef POOL_DEBUG
@@ -428,12 +487,38 @@
 	p->sub_pools = new_pool;
     }
 
+#if defined(EAPI) && defined(EAPI_MM)
+    new_pool->is_shm = is_shm;
+#endif
+
     (void) ap_release_mutex(alloc_mutex);
+#if defined(EAPI) && defined(EAPI_MM)
+    if (is_shm)
+	(void)ap_mm_unlock(mm);
+#endif
     ap_unblock_alarms();
 
     return new_pool;
 }
 
+#if defined(EAPI)
+#if defined(EAPI_MM)
+API_EXPORT(struct pool *) ap_make_sub_pool(struct pool *p)
+{
+    return make_sub_pool_internal(p, 0);
+}
+API_EXPORT(struct pool *) ap_make_shared_sub_pool(struct pool *p)
+{
+    return make_sub_pool_internal(p, 1);
+}
+#else
+API_EXPORT(struct pool *) ap_make_shared_sub_pool(struct pool *p)
+{
+    return NULL;
+}
+#endif
+#endif
+
 #ifdef POOL_DEBUG
 static void stack_var_init(char *s)
 {
@@ -448,6 +533,13 @@
 }
 #endif
 
+#if defined(EAPI)
+int ap_shared_pool_possible(void)
+{
+    return ap_mm_useable();
+}
+#endif
+
 #ifdef ALLOC_STATS
 static void dump_stats(void)
 {
@@ -480,6 +572,58 @@
     return permanent_pool;
 }
 
+#if defined(EAPI)
+void ap_init_alloc_shared(int early)
+{
+#if defined(EAPI_MM)
+    int mm_size;
+    char *mm_path;
+    char *err1, *err2;
+
+    if (early) {
+        /* process very early on startup */
+        mm_size = ap_mm_maxsize();
+        if (mm_size > EAPI_MM_CORE_MAXSIZE)
+            mm_size = EAPI_MM_CORE_MAXSIZE;
+        mm_path = ap_server_root_relative(permanent_pool, 
+                  ap_psprintf(permanent_pool, "%s.%ld", 
+                              EAPI_MM_CORE_PATH, (long)getpid()));
+        if ((mm = ap_mm_create(mm_size, mm_path)) == NULL) {
+            fprintf(stderr, "Ouch! ap_mm_create(%d, \"%s\") failed\n", mm_size, mm_path);
+            err1 = ap_mm_error();
+            if (err1 == NULL)
+                err1 = "-unknown-";
+            err2 = strerror(errno);
+            if (err2 == NULL)
+                err2 = "-unknown-";
+            fprintf(stderr, "Error: MM: %s: OS: %s\n", err1, err2);
+            exit(1);
+        }
+    }
+    else {
+        /* process a lot later on startup */
+#ifdef WIN32
+        ap_mm_permission(mm, (_S_IREAD|_S_IWRITE), ap_user_id, -1);
+#else
+        ap_mm_permission(mm, (S_IRUSR|S_IWUSR), ap_user_id, -1);
+#endif
+    }
+#endif /* EAPI_MM */
+    return; 
+}
+
+void ap_kill_alloc_shared(void)
+{
+#if defined(EAPI_MM)
+    if (mm != NULL) {
+        ap_mm_destroy(mm);
+        mm = NULL;
+    }
+#endif /* EAPI_MM */
+    return;
+}
+#endif /* EAPI */
+
 void ap_cleanup_alloc(void)
 {
     ap_destroy_mutex(alloc_mutex);
@@ -490,10 +634,18 @@
 {
     ap_block_alarms();
 
+#if defined(EAPI) && defined(EAPI_MM)
+    if (a->is_shm)
+        (void)ap_mm_lock(mm, AP_MM_LOCK_RW);
+#endif
     (void) ap_acquire_mutex(alloc_mutex);
     while (a->sub_pools)
 	ap_destroy_pool(a->sub_pools);
     (void) ap_release_mutex(alloc_mutex);
+#if defined(EAPI) && defined(EAPI_MM)
+    if (a->is_shm)
+	    (void)ap_mm_unlock(mm);
+#endif
     /* Don't hold the mutex during cleanups. */
     run_cleanups(a->cleanups);
     a->cleanups = NULL;
@@ -527,6 +679,10 @@
     ap_block_alarms();
     ap_clear_pool(a);
 
+#if defined(EAPI) && defined(EAPI_MM)
+    if (a->is_shm)
+	(void)ap_mm_lock(mm, AP_MM_LOCK_RW);
+#endif
     (void) ap_acquire_mutex(alloc_mutex);
     if (a->parent) {
 	if (a->parent->sub_pools == a)
@@ -537,6 +693,10 @@
 	    a->sub_next->sub_prev = a->sub_prev;
     }
     (void) ap_release_mutex(alloc_mutex);
+#if defined(EAPI) && defined(EAPI_MM)
+    if (a->is_shm)
+	(void)ap_mm_unlock(mm);
+#endif
 
     free_blocks(a->first);
     ap_unblock_alarms();
@@ -551,6 +711,30 @@
     return bytes_in_block_list(block_freelist);
 }
 
+#if defined(EAPI)
+API_EXPORT(int) ap_acquire_pool(pool *p, ap_pool_lock_mode mode)
+{
+#if defined(EAPI_MM)
+    if (!p->is_shm)
+        return 1;
+    return ap_mm_lock(mm, mode == AP_POOL_RD ? AP_MM_LOCK_RD : AP_MM_LOCK_RW);
+#else
+	return 1;
+#endif
+}
+
+API_EXPORT(int) ap_release_pool(pool *p)
+{
+#if defined(EAPI_MM)
+    if (!p->is_shm)
+        return 1;
+    return ap_mm_unlock(mm);
+#else
+	return 1;
+#endif
+}
+#endif /* EAPI */
+
 /*****************************************************************
  * POOL_DEBUG support
  */
@@ -716,16 +900,31 @@
 
     ap_block_alarms();
 
+#if defined(EAPI) && defined(EAPI_MM)
+    if (a->is_shm)
+	(void)ap_mm_lock(mm, AP_MM_LOCK_RW);
+#endif
     (void) ap_acquire_mutex(alloc_mutex);
 
+#if defined(EAPI) && defined(EAPI_MM)
+    blok = new_block(size, a->is_shm);
+#else
     blok = new_block(size);
+#endif
     a->last->h.next = blok;
     a->last = blok;
 #ifdef POOL_DEBUG
     blok->h.owning_pool = a;
 #endif
+#if defined(EAPI) && defined(EAPI_MM)
+    blok->h.is_shm = a->is_shm;
+#endif
 
     (void) ap_release_mutex(alloc_mutex);
+#if defined(EAPI) && defined(EAPI_MM)
+    if (a->is_shm)
+	(void)ap_mm_unlock(mm);
+#endif
 
     ap_unblock_alarms();
 
@@ -842,6 +1041,11 @@
     size = cur_len << 1;
     if (size < AP_PSPRINTF_MIN_SIZE)
         size = AP_PSPRINTF_MIN_SIZE;
+#if defined(EAPI) && defined(EAPI_MM)
+    if (ps->block->h.is_shm)
+        ptr = ap_mm_realloc(ps->base, size);
+    else
+#endif
     ptr = realloc(ps->base, size);
     if (ptr == NULL) {
 	fputs("Ouch!  Out of memory!\n", stderr);
@@ -865,9 +1069,21 @@
         size = AP_PSPRINTF_MIN_SIZE;
 
     /* must try another blok */
+#if defined(EAPI) && defined(EAPI_MM)
+    if (blok->h.is_shm)
+	(void)ap_mm_lock(mm, AP_MM_LOCK_RW);
+#endif
     (void) ap_acquire_mutex(alloc_mutex);
+#if defined(EAPI) && defined(EAPI_MM)
+    nblok = new_block(size, blok->h.is_shm);
+#else
     nblok = new_block(size);
+#endif
     (void) ap_release_mutex(alloc_mutex);
+#if defined(EAPI) && defined(EAPI_MM)
+    if (blok->h.is_shm)
+	(void)ap_mm_unlock(mm);
+#endif
     memcpy(nblok->h.first_avail, blok->h.first_avail, cur_len);
     ps->vbuff.curpos = nblok->h.first_avail + cur_len;
     /* save a byte for the NUL terminator */
@@ -876,10 +1092,18 @@
     /* did we allocate the current blok? if so free it up */
     if (ps->got_a_new_block) {
 	debug_fill(blok->h.first_avail, blok->h.endp - blok->h.first_avail);
+#if defined(EAPI) && defined(EAPI_MM)
+    if (blok->h.is_shm)
+	(void)ap_mm_lock(mm, AP_MM_LOCK_RW);
+#endif
 	(void) ap_acquire_mutex(alloc_mutex);
 	blok->h.next = block_freelist;
 	block_freelist = blok;
 	(void) ap_release_mutex(alloc_mutex);
+#if defined(EAPI) && defined(EAPI_MM)
+    if (blok->h.is_shm)
+	(void)ap_mm_unlock(mm);
+#endif
     }
     ps->blok = nblok;
     ps->got_a_new_block = 1;
@@ -898,6 +1122,11 @@
     void *ptr;
 
     ap_block_alarms();
+#if defined(EAPI) && defined(EAPI_MM)
+    if (p->is_shm)
+        ps.base = ap_mm_malloc(mm, 512);
+    else
+#endif
     ps.base = malloc(512);
     if (ps.base == NULL) {
 	fputs("Ouch!  Out of memory!\n", stderr);
@@ -910,6 +1139,11 @@
     *ps.vbuff.curpos++ = '\0';
     ptr = ps.base;
     /* shrink */
+#if defined(EAPI) && defined(EAPI_MM)
+    if (p->is_shm)
+        ptr = ap_mm_realloc(ptr, (char *)ps.vbuff.curpos - (char *)ptr);
+    else
+#endif
     ptr = realloc(ptr, (char *)ps.vbuff.curpos - (char *)ptr);
     if (ptr == NULL) {
 	fputs("Ouch!  Out of memory!\n", stderr);
@@ -1959,7 +2193,7 @@
 #ifdef WIN32
     modeFlags = _S_IREAD | _S_IWRITE;
 #else
-    modeFlags = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;
+    modeFlags = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP;
 #endif
 
     ap_block_alarms();
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/main/alloc.c.orig apache_1.3.33/src/main/alloc.c.orig
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/main/alloc.c.orig	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/main/alloc.c.orig	Sun Jul  4 13:34:36 2004
@@ -0,0 +1,2879 @@
+/* Copyright 1999-2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * Resource allocation code... the code here is responsible for making
+ * sure that nothing leaks.
+ *
+ * rst --- 4/95 --- 6/95
+ */
+
+#include "httpd.h"
+#include "multithread.h"
+#include "http_log.h"
+
+#include <stdarg.h>
+
+#ifdef OS2
+#define INCL_DOS
+#include <os2.h>
+#endif
+
+/* debugging support, define this to enable code which helps detect re-use
+ * of freed memory and other such nonsense.
+ *
+ * The theory is simple.  The FILL_BYTE (0xa5) is written over all malloc'd
+ * memory as we receive it, and is written over everything that we free up
+ * during a clear_pool.  We check that blocks on the free list always
+ * have the FILL_BYTE in them, and we check during palloc() that the bytes
+ * still have FILL_BYTE in them.  If you ever see garbage URLs or whatnot
+ * containing lots of 0xa5s then you know something used data that's been
+ * freed or uninitialized.
+ */
+/* #define ALLOC_DEBUG */
+
+/* debugging support, if defined all allocations will be done with
+ * malloc and free()d appropriately at the end.  This is intended to be
+ * used with something like Electric Fence or Purify to help detect
+ * memory problems.  Note that if you're using efence then you should also
+ * add in ALLOC_DEBUG.  But don't add in ALLOC_DEBUG if you're using Purify
+ * because ALLOC_DEBUG would hide all the uninitialized read errors that
+ * Purify can diagnose.
+ */
+/* #define ALLOC_USE_MALLOC */
+
+/* Pool debugging support.  This is intended to detect cases where the
+ * wrong pool is used when assigning data to an object in another pool.
+ * In particular, it causes the table_{set,add,merge}n routines to check
+ * that their arguments are safe for the table they're being placed in.
+ * It currently only works with the unix multiprocess model, but could
+ * be extended to others.
+ */
+/* #define POOL_DEBUG */
+
+/* Provide diagnostic information about make_table() calls which are
+ * possibly too small.  This requires a recent gcc which supports
+ * __builtin_return_address().  The error_log output will be a
+ * message such as:
+ *    table_push: table created by 0x804d874 hit limit of 10
+ * Use "l *0x804d874" to find the source that corresponds to.  It
+ * indicates that a table allocated by a call at that address has
+ * possibly too small an initial table size guess.
+ */
+/* #define MAKE_TABLE_PROFILE */
+
+/* Provide some statistics on the cost of allocations.  It requires a
+ * bit of an understanding of how alloc.c works.
+ */
+/* #define ALLOC_STATS */
+
+#ifdef POOL_DEBUG
+#ifdef ALLOC_USE_MALLOC
+# error "sorry, no support for ALLOC_USE_MALLOC and POOL_DEBUG at the same time"
+#endif
+#ifdef MULTITHREAD
+# error "sorry, no support for MULTITHREAD and POOL_DEBUG at the same time"
+#endif
+#endif
+
+#ifdef ALLOC_USE_MALLOC
+#undef BLOCK_MINFREE
+#undef BLOCK_MINALLOC
+#define BLOCK_MINFREE	0
+#define BLOCK_MINALLOC	0
+#endif
+
+/*****************************************************************
+ *
+ * Managing free storage blocks...
+ */
+
+union align {
+    /* Types which are likely to have the longest RELEVANT alignment
+     * restrictions...
+     */
+
+    char *cp;
+    void (*f) (void);
+    long l;
+    FILE *fp;
+    double d;
+};
+
+#define CLICK_SZ (sizeof(union align))
+
+union block_hdr {
+    union align a;
+
+    /* Actual header... */
+
+    struct {
+	char *endp;
+	union block_hdr *next;
+	char *first_avail;
+#ifdef POOL_DEBUG
+	union block_hdr *global_next;
+	struct pool *owning_pool;
+#endif
+    } h;
+};
+
+static union block_hdr *block_freelist = NULL;
+static mutex *alloc_mutex = NULL;
+static mutex *spawn_mutex = NULL;
+#ifdef POOL_DEBUG
+static char *known_stack_point;
+static int stack_direction;
+static union block_hdr *global_block_list;
+#define FREE_POOL	((struct pool *)(-1))
+#endif
+#ifdef ALLOC_STATS
+static unsigned long long num_free_blocks_calls;
+static unsigned long long num_blocks_freed;
+static unsigned max_blocks_in_one_free;
+static unsigned num_malloc_calls;
+static unsigned num_malloc_bytes;
+#endif
+
+#ifdef ALLOC_DEBUG
+#define FILL_BYTE	((char)(0xa5))
+
+#define debug_fill(ptr,size)	((void)memset((ptr), FILL_BYTE, (size)))
+
+static ap_inline void debug_verify_filled(const char *ptr,
+    const char *endp, const char *error_msg)
+{
+    for (; ptr < endp; ++ptr) {
+	if (*ptr != FILL_BYTE) {
+	    fputs(error_msg, stderr);
+	    abort();
+	    exit(1);
+	}
+    }
+}
+
+#else
+#define debug_fill(a,b)
+#define debug_verify_filled(a,b,c)
+#endif
+
+
+/* Get a completely new block from the system pool. Note that we rely on
+   malloc() to provide aligned memory. */
+
+static union block_hdr *malloc_block(int size)
+{
+    union block_hdr *blok;
+    int request_size;
+
+#ifdef ALLOC_DEBUG
+    /* make some room at the end which we'll fill and expect to be
+     * always filled
+     */
+    size += CLICK_SZ;
+#endif
+#ifdef ALLOC_STATS
+    ++num_malloc_calls;
+    num_malloc_bytes += size + sizeof(union block_hdr);
+#endif
+    request_size = size + sizeof(union block_hdr);
+    blok = (union block_hdr *) malloc(request_size);
+    if (blok == NULL) {
+	fprintf(stderr, "Ouch!  malloc(%d) failed in malloc_block()\n",
+                request_size);
+	exit(1);
+    }
+    debug_fill(blok, size + sizeof(union block_hdr));
+    blok->h.next = NULL;
+    blok->h.first_avail = (char *) (blok + 1);
+    blok->h.endp = size + blok->h.first_avail;
+#ifdef ALLOC_DEBUG
+    blok->h.endp -= CLICK_SZ;
+#endif
+#ifdef POOL_DEBUG
+    blok->h.global_next = global_block_list;
+    global_block_list = blok;
+    blok->h.owning_pool = NULL;
+#endif
+
+    return blok;
+}
+
+
+
+#if defined(ALLOC_DEBUG) && !defined(ALLOC_USE_MALLOC)
+static void chk_on_blk_list(union block_hdr *blok, union block_hdr *free_blk)
+{
+    debug_verify_filled(blok->h.endp, blok->h.endp + CLICK_SZ,
+	"Ouch!  Someone trounced the padding at the end of a block!\n");
+    while (free_blk) {
+	if (free_blk == blok) {
+	    fprintf(stderr, "Ouch!  Freeing free block\n");
+	    abort();
+	    exit(1);
+	}
+	free_blk = free_blk->h.next;
+    }
+}
+#else
+#define chk_on_blk_list(_x, _y)
+#endif
+
+/* Free a chain of blocks --- must be called with alarms blocked. */
+
+static void free_blocks(union block_hdr *blok)
+{
+#ifdef ALLOC_USE_MALLOC
+    union block_hdr *next;
+
+    for (; blok; blok = next) {
+	next = blok->h.next;
+	free(blok);
+    }
+#else
+#ifdef ALLOC_STATS
+    unsigned num_blocks;
+#endif
+    /* First, put new blocks at the head of the free list ---
+     * we'll eventually bash the 'next' pointer of the last block
+     * in the chain to point to the free blocks we already had.
+     */
+
+    union block_hdr *old_free_list;
+
+    if (blok == NULL)
+	return;			/* Sanity check --- freeing empty pool? */
+
+    (void) ap_acquire_mutex(alloc_mutex);
+    old_free_list = block_freelist;
+    block_freelist = blok;
+
+    /*
+     * Next, adjust first_avail pointers of each block --- have to do it
+     * sooner or later, and it simplifies the search in new_block to do it
+     * now.
+     */
+
+#ifdef ALLOC_STATS
+    num_blocks = 1;
+#endif
+    while (blok->h.next != NULL) {
+#ifdef ALLOC_STATS
+	++num_blocks;
+#endif
+	chk_on_blk_list(blok, old_free_list);
+	blok->h.first_avail = (char *) (blok + 1);
+	debug_fill(blok->h.first_avail, blok->h.endp - blok->h.first_avail);
+#ifdef POOL_DEBUG
+	blok->h.owning_pool = FREE_POOL;
+#endif
+	blok = blok->h.next;
+    }
+
+    chk_on_blk_list(blok, old_free_list);
+    blok->h.first_avail = (char *) (blok + 1);
+    debug_fill(blok->h.first_avail, blok->h.endp - blok->h.first_avail);
+#ifdef POOL_DEBUG
+    blok->h.owning_pool = FREE_POOL;
+#endif
+
+    /* Finally, reset next pointer to get the old free blocks back */
+
+    blok->h.next = old_free_list;
+
+#ifdef ALLOC_STATS
+    if (num_blocks > max_blocks_in_one_free) {
+	max_blocks_in_one_free = num_blocks;
+    }
+    ++num_free_blocks_calls;
+    num_blocks_freed += num_blocks;
+#endif
+
+    (void) ap_release_mutex(alloc_mutex);
+#endif
+}
+
+
+/* Get a new block, from our own free list if possible, from the system
+ * if necessary.  Must be called with alarms blocked.
+ */
+
+static union block_hdr *new_block(int min_size)
+{
+    union block_hdr **lastptr = &block_freelist;
+    union block_hdr *blok = block_freelist;
+
+    /* First, see if we have anything of the required size
+     * on the free list...
+     */
+
+    while (blok != NULL) {
+	if (min_size + BLOCK_MINFREE <= blok->h.endp - blok->h.first_avail) {
+	    *lastptr = blok->h.next;
+	    blok->h.next = NULL;
+	    debug_verify_filled(blok->h.first_avail, blok->h.endp,
+		"Ouch!  Someone trounced a block on the free list!\n");
+	    return blok;
+	}
+	else {
+	    lastptr = &blok->h.next;
+	    blok = blok->h.next;
+	}
+    }
+
+    /* Nope. */
+
+    min_size += BLOCK_MINFREE;
+    blok = malloc_block((min_size > BLOCK_MINALLOC) ? min_size : BLOCK_MINALLOC);
+    return blok;
+}
+
+
+/* Accounting */
+
+static long bytes_in_block_list(union block_hdr *blok)
+{
+    long size = 0;
+
+    while (blok) {
+	size += blok->h.endp - (char *) (blok + 1);
+	blok = blok->h.next;
+    }
+
+    return size;
+}
+
+
+/*****************************************************************
+ *
+ * Pool internals and management...
+ * NB that subprocesses are not handled by the generic cleanup code,
+ * basically because we don't want cleanups for multiple subprocesses
+ * to result in multiple three-second pauses.
+ */
+
+struct process_chain;
+struct cleanup;
+
+static void run_cleanups(struct cleanup *);
+static void free_proc_chain(struct process_chain *);
+
+struct pool {
+    union block_hdr *first;
+    union block_hdr *last;
+    struct cleanup *cleanups;
+    struct process_chain *subprocesses;
+    struct pool *sub_pools;
+    struct pool *sub_next;
+    struct pool *sub_prev;
+    struct pool *parent;
+    char *free_first_avail;
+#ifdef ALLOC_USE_MALLOC
+    void *allocation_list;
+#endif
+#ifdef POOL_DEBUG
+    struct pool *joined;
+#endif
+};
+
+static pool *permanent_pool;
+
+/* Each pool structure is allocated in the start of its own first block,
+ * so we need to know how many bytes that is (once properly aligned...).
+ * This also means that when a pool's sub-pool is destroyed, the storage
+ * associated with it is *completely* gone, so we have to make sure it
+ * gets taken off the parent's sub-pool list...
+ */
+
+#define POOL_HDR_CLICKS (1 + ((sizeof(struct pool) - 1) / CLICK_SZ))
+#define POOL_HDR_BYTES (POOL_HDR_CLICKS * CLICK_SZ)
+
+API_EXPORT(struct pool *) ap_make_sub_pool(struct pool *p)
+{
+    union block_hdr *blok;
+    pool *new_pool;
+
+    ap_block_alarms();
+
+    (void) ap_acquire_mutex(alloc_mutex);
+
+    blok = new_block(POOL_HDR_BYTES);
+    new_pool = (pool *) blok->h.first_avail;
+    blok->h.first_avail += POOL_HDR_BYTES;
+#ifdef POOL_DEBUG
+    blok->h.owning_pool = new_pool;
+#endif
+
+    memset((char *) new_pool, '\0', sizeof(struct pool));
+    new_pool->free_first_avail = blok->h.first_avail;
+    new_pool->first = new_pool->last = blok;
+
+    if (p) {
+	new_pool->parent = p;
+	new_pool->sub_next = p->sub_pools;
+	if (new_pool->sub_next)
+	    new_pool->sub_next->sub_prev = new_pool;
+	p->sub_pools = new_pool;
+    }
+
+    (void) ap_release_mutex(alloc_mutex);
+    ap_unblock_alarms();
+
+    return new_pool;
+}
+
+#ifdef POOL_DEBUG
+static void stack_var_init(char *s)
+{
+    char t;
+
+    if (s < &t) {
+	stack_direction = 1; /* stack grows up */
+    }
+    else {
+	stack_direction = -1; /* stack grows down */
+    }
+}
+#endif
+
+#ifdef ALLOC_STATS
+static void dump_stats(void)
+{
+    fprintf(stderr,
+	"alloc_stats: [%d] #free_blocks %llu #blocks %llu max %u #malloc %u #bytes %u\n",
+	(int)getpid(),
+	num_free_blocks_calls,
+	num_blocks_freed,
+	max_blocks_in_one_free,
+	num_malloc_calls,
+	num_malloc_bytes);
+}
+#endif
+
+API_EXPORT(pool *) ap_init_alloc(void)
+{
+#ifdef POOL_DEBUG
+    char s;
+
+    known_stack_point = &s;
+    stack_var_init(&s);
+#endif
+    alloc_mutex = ap_create_mutex(NULL);
+    spawn_mutex = ap_create_mutex(NULL);
+    permanent_pool = ap_make_sub_pool(NULL);
+#ifdef ALLOC_STATS
+    atexit(dump_stats);
+#endif
+
+    return permanent_pool;
+}
+
+void ap_cleanup_alloc(void)
+{
+    ap_destroy_mutex(alloc_mutex);
+    ap_destroy_mutex(spawn_mutex);
+}
+
+API_EXPORT(void) ap_clear_pool(struct pool *a)
+{
+    ap_block_alarms();
+
+    (void) ap_acquire_mutex(alloc_mutex);
+    while (a->sub_pools)
+	ap_destroy_pool(a->sub_pools);
+    (void) ap_release_mutex(alloc_mutex);
+    /* Don't hold the mutex during cleanups. */
+    run_cleanups(a->cleanups);
+    a->cleanups = NULL;
+    free_proc_chain(a->subprocesses);
+    a->subprocesses = NULL;
+    free_blocks(a->first->h.next);
+    a->first->h.next = NULL;
+
+    a->last = a->first;
+    a->first->h.first_avail = a->free_first_avail;
+    debug_fill(a->first->h.first_avail,
+	a->first->h.endp - a->first->h.first_avail);
+
+#ifdef ALLOC_USE_MALLOC
+    {
+	void *c, *n;
+
+	for (c = a->allocation_list; c; c = n) {
+	    n = *(void **)c;
+	    free(c);
+	}
+	a->allocation_list = NULL;
+    }
+#endif
+
+    ap_unblock_alarms();
+}
+
+API_EXPORT(void) ap_destroy_pool(pool *a)
+{
+    ap_block_alarms();
+    ap_clear_pool(a);
+
+    (void) ap_acquire_mutex(alloc_mutex);
+    if (a->parent) {
+	if (a->parent->sub_pools == a)
+	    a->parent->sub_pools = a->sub_next;
+	if (a->sub_prev)
+	    a->sub_prev->sub_next = a->sub_next;
+	if (a->sub_next)
+	    a->sub_next->sub_prev = a->sub_prev;
+    }
+    (void) ap_release_mutex(alloc_mutex);
+
+    free_blocks(a->first);
+    ap_unblock_alarms();
+}
+
+API_EXPORT(long) ap_bytes_in_pool(pool *p)
+{
+    return bytes_in_block_list(p->first);
+}
+API_EXPORT(long) ap_bytes_in_free_blocks(void)
+{
+    return bytes_in_block_list(block_freelist);
+}
+
+/*****************************************************************
+ * POOL_DEBUG support
+ */
+#ifdef POOL_DEBUG
+
+/* the unix linker defines this symbol as the last byte + 1 of
+ * the executable... so it includes TEXT, BSS, and DATA
+ */
+extern char _end;
+
+/* is ptr in the range [lo,hi) */
+#define is_ptr_in_range(ptr, lo, hi)	\
+    (((unsigned long)(ptr) - (unsigned long)(lo)) \
+	< \
+	(unsigned long)(hi) - (unsigned long)(lo))
+
+/* Find the pool that ts belongs to, return NULL if it doesn't
+ * belong to any pool.
+ */
+API_EXPORT(pool *) ap_find_pool(const void *ts)
+{
+    const char *s = ts;
+    union block_hdr **pb;
+    union block_hdr *b;
+
+    /* short-circuit stuff which is in TEXT, BSS, or DATA */
+    if (is_ptr_in_range(s, 0, &_end)) {
+	return NULL;
+    }
+    /* consider stuff on the stack to also be in the NULL pool...
+     * XXX: there's cases where we don't want to assume this
+     */
+    if ((stack_direction == -1 && is_ptr_in_range(s, &ts, known_stack_point))
+	|| (stack_direction == 1 && is_ptr_in_range(s, known_stack_point, &ts))) {
+	abort();
+	return NULL;
+    }
+    ap_block_alarms();
+    /* search the global_block_list */
+    for (pb = &global_block_list; *pb; pb = &b->h.global_next) {
+	b = *pb;
+	if (is_ptr_in_range(s, b, b->h.endp)) {
+	    if (b->h.owning_pool == FREE_POOL) {
+		fprintf(stderr,
+		    "Ouch!  find_pool() called on pointer in a free block\n");
+		abort();
+		exit(1);
+	    }
+	    if (b != global_block_list) {
+		/* promote b to front of list, this is a hack to speed
+		 * up the lookup */
+		*pb = b->h.global_next;
+		b->h.global_next = global_block_list;
+		global_block_list = b;
+	    }
+	    ap_unblock_alarms();
+	    return b->h.owning_pool;
+	}
+    }
+    ap_unblock_alarms();
+    return NULL;
+}
+
+/* return TRUE iff a is an ancestor of b
+ * NULL is considered an ancestor of all pools
+ */
+API_EXPORT(int) ap_pool_is_ancestor(pool *a, pool *b)
+{
+    if (a == NULL) {
+	return 1;
+    }
+    while (a->joined) {
+	a = a->joined;
+    }
+    while (b) {
+	if (a == b) {
+	    return 1;
+	}
+	b = b->parent;
+    }
+    return 0;
+}
+
+/* All blocks belonging to sub will be changed to point to p
+ * instead.  This is a guarantee by the caller that sub will not
+ * be destroyed before p is.
+ */
+API_EXPORT(void) ap_pool_join(pool *p, pool *sub)
+{
+    union block_hdr *b;
+
+    /* We could handle more general cases... but this is it for now. */
+    if (sub->parent != p) {
+	fprintf(stderr, "pool_join: p is not parent of sub\n");
+	abort();
+    }
+    ap_block_alarms();
+    while (p->joined) {
+	p = p->joined;
+    }
+    sub->joined = p;
+    for (b = global_block_list; b; b = b->h.global_next) {
+	if (b->h.owning_pool == sub) {
+	    b->h.owning_pool = p;
+	}
+    }
+    ap_unblock_alarms();
+}
+#endif
+
+/*****************************************************************
+ *
+ * Allocating stuff...
+ */
+
+
+API_EXPORT(void *) ap_palloc(struct pool *a, int reqsize)
+{
+#ifdef ALLOC_USE_MALLOC
+    int size = reqsize + CLICK_SZ;
+    void *ptr;
+
+    ap_block_alarms();
+    ptr = malloc(size);
+    if (ptr == NULL) {
+	fputs("Ouch!  Out of memory!\n", stderr);
+	exit(1);
+    }
+    debug_fill(ptr, size); /* might as well get uninitialized protection */
+    *(void **)ptr = a->allocation_list;
+    a->allocation_list = ptr;
+    ap_unblock_alarms();
+    return (char *)ptr + CLICK_SZ;
+#else
+
+    /* Round up requested size to an even number of alignment units (core clicks)
+     */
+
+    int nclicks = 1 + ((reqsize - 1) / CLICK_SZ);
+    int size = nclicks * CLICK_SZ;
+
+    /* First, see if we have space in the block most recently
+     * allocated to this pool
+     */
+
+    union block_hdr *blok = a->last;
+    char *first_avail = blok->h.first_avail;
+    char *new_first_avail;
+
+    if (reqsize <= 0)
+	return NULL;
+
+    new_first_avail = first_avail + size;
+
+    if (new_first_avail <= blok->h.endp) {
+	debug_verify_filled(first_avail, blok->h.endp,
+	    "Ouch!  Someone trounced past the end of their allocation!\n");
+	blok->h.first_avail = new_first_avail;
+	return (void *) first_avail;
+    }
+
+    /* Nope --- get a new one that's guaranteed to be big enough */
+
+    ap_block_alarms();
+
+    (void) ap_acquire_mutex(alloc_mutex);
+
+    blok = new_block(size);
+    a->last->h.next = blok;
+    a->last = blok;
+#ifdef POOL_DEBUG
+    blok->h.owning_pool = a;
+#endif
+
+    (void) ap_release_mutex(alloc_mutex);
+
+    ap_unblock_alarms();
+
+    first_avail = blok->h.first_avail;
+    blok->h.first_avail += size;
+
+    return (void *) first_avail;
+#endif
+}
+
+API_EXPORT(void *) ap_pcalloc(struct pool *a, int size)
+{
+    void *res = ap_palloc(a, size);
+    memset(res, '\0', size);
+    return res;
+}
+
+API_EXPORT(char *) ap_pstrdup(struct pool *a, const char *s)
+{
+    char *res;
+    size_t len;
+
+    if (s == NULL)
+	return NULL;
+    len = strlen(s) + 1;
+    res = ap_palloc(a, len);
+    memcpy(res, s, len);
+    return res;
+}
+
+API_EXPORT(char *) ap_pstrndup(struct pool *a, const char *s, int n)
+{
+    char *res;
+
+    if (s == NULL)
+	return NULL;
+    res = ap_palloc(a, n + 1);
+    memcpy(res, s, n);
+    res[n] = '\0';
+    return res;
+}
+
+API_EXPORT_NONSTD(char *) ap_pstrcat(pool *a,...)
+{
+    char *cp, *argp, *res;
+
+    /* Pass one --- find length of required string */
+
+    int len = 0;
+    va_list adummy;
+
+    va_start(adummy, a);
+
+    while ((cp = va_arg(adummy, char *)) != NULL)
+	     len += strlen(cp);
+
+    va_end(adummy);
+
+    /* Allocate the required string */
+
+    res = (char *) ap_palloc(a, len + 1);
+    cp = res;
+    *cp = '\0';
+
+    /* Pass two --- copy the argument strings into the result space */
+
+    va_start(adummy, a);
+
+    while ((argp = va_arg(adummy, char *)) != NULL) {
+	strcpy(cp, argp);
+	cp += strlen(argp);
+    }
+
+    va_end(adummy);
+
+    /* Return the result string */
+
+    return res;
+}
+
+/* ap_psprintf is implemented by writing directly into the current
+ * block of the pool, starting right at first_avail.  If there's
+ * insufficient room, then a new block is allocated and the earlier
+ * output is copied over.  The new block isn't linked into the pool
+ * until all the output is done.
+ *
+ * Note that this is completely safe because nothing else can
+ * allocate in this pool while ap_psprintf is running.  alarms are
+ * blocked, and the only thing outside of alloc.c that's invoked
+ * is ap_vformatter -- which was purposefully written to be
+ * self-contained with no callouts.
+ */
+
+struct psprintf_data {
+    ap_vformatter_buff vbuff;
+#ifdef ALLOC_USE_MALLOC
+    char *base;
+#else
+    union block_hdr *blok;
+    int got_a_new_block;
+#endif
+};
+
+#define AP_PSPRINTF_MIN_SIZE 32  /* Minimum size of allowable avail block */
+
+static int psprintf_flush(ap_vformatter_buff *vbuff)
+{
+    struct psprintf_data *ps = (struct psprintf_data *)vbuff;
+#ifdef ALLOC_USE_MALLOC
+    int cur_len, size;
+    char *ptr;
+
+    cur_len = (char *)ps->vbuff.curpos - ps->base;
+    size = cur_len << 1;
+    if (size < AP_PSPRINTF_MIN_SIZE)
+        size = AP_PSPRINTF_MIN_SIZE;
+    ptr = realloc(ps->base, size);
+    if (ptr == NULL) {
+	fputs("Ouch!  Out of memory!\n", stderr);
+	exit(1);
+    }
+    ps->base = ptr;
+    ps->vbuff.curpos = ptr + cur_len;
+    ps->vbuff.endpos = ptr + size - 1;
+    return 0;
+#else
+    union block_hdr *blok;
+    union block_hdr *nblok;
+    size_t cur_len, size;
+    char *strp;
+
+    blok = ps->blok;
+    strp = ps->vbuff.curpos;
+    cur_len = strp - blok->h.first_avail;
+    size = cur_len << 1;
+    if (size < AP_PSPRINTF_MIN_SIZE)
+        size = AP_PSPRINTF_MIN_SIZE;
+
+    /* must try another blok */
+    (void) ap_acquire_mutex(alloc_mutex);
+    nblok = new_block(size);
+    (void) ap_release_mutex(alloc_mutex);
+    memcpy(nblok->h.first_avail, blok->h.first_avail, cur_len);
+    ps->vbuff.curpos = nblok->h.first_avail + cur_len;
+    /* save a byte for the NUL terminator */
+    ps->vbuff.endpos = nblok->h.endp - 1;
+
+    /* did we allocate the current blok? if so free it up */
+    if (ps->got_a_new_block) {
+	debug_fill(blok->h.first_avail, blok->h.endp - blok->h.first_avail);
+	(void) ap_acquire_mutex(alloc_mutex);
+	blok->h.next = block_freelist;
+	block_freelist = blok;
+	(void) ap_release_mutex(alloc_mutex);
+    }
+    ps->blok = nblok;
+    ps->got_a_new_block = 1;
+    /* note that we've deliberately not linked the new block onto
+     * the pool yet... because we may need to flush again later, and
+     * we'd have to spend more effort trying to unlink the block.
+     */
+    return 0;
+#endif
+}
+
+API_EXPORT(char *) ap_pvsprintf(pool *p, const char *fmt, va_list ap)
+{
+#ifdef ALLOC_USE_MALLOC
+    struct psprintf_data ps;
+    void *ptr;
+
+    ap_block_alarms();
+    ps.base = malloc(512);
+    if (ps.base == NULL) {
+	fputs("Ouch!  Out of memory!\n", stderr);
+	exit(1);
+    }
+    /* need room at beginning for allocation_list */
+    ps.vbuff.curpos = ps.base + CLICK_SZ;
+    ps.vbuff.endpos = ps.base + 511;
+    ap_vformatter(psprintf_flush, &ps.vbuff, fmt, ap);
+    *ps.vbuff.curpos++ = '\0';
+    ptr = ps.base;
+    /* shrink */
+    ptr = realloc(ptr, (char *)ps.vbuff.curpos - (char *)ptr);
+    if (ptr == NULL) {
+	fputs("Ouch!  Out of memory!\n", stderr);
+	exit(1);
+    }
+    *(void **)ptr = p->allocation_list;
+    p->allocation_list = ptr;
+    ap_unblock_alarms();
+    return (char *)ptr + CLICK_SZ;
+#else
+    struct psprintf_data ps;
+    char *strp;
+    int size;
+
+    ap_block_alarms();
+    ps.blok = p->last;
+    ps.vbuff.curpos = ps.blok->h.first_avail;
+    ps.vbuff.endpos = ps.blok->h.endp - 1;	/* save one for NUL */
+    ps.got_a_new_block = 0;
+
+    if (ps.blok->h.first_avail == ps.blok->h.endp)
+        psprintf_flush(&ps.vbuff);		/* ensure room for NUL */
+    ap_vformatter(psprintf_flush, &ps.vbuff, fmt, ap);
+
+    strp = ps.vbuff.curpos;
+    *strp++ = '\0';
+
+    size = strp - ps.blok->h.first_avail;
+    size = (1 + ((size - 1) / CLICK_SZ)) * CLICK_SZ;
+    strp = ps.blok->h.first_avail;	/* save away result pointer */
+    ps.blok->h.first_avail += size;
+
+    /* have to link the block in if it's a new one */
+    if (ps.got_a_new_block) {
+	p->last->h.next = ps.blok;
+	p->last = ps.blok;
+#ifdef POOL_DEBUG
+	ps.blok->h.owning_pool = p;
+#endif
+    }
+    ap_unblock_alarms();
+
+    return strp;
+#endif
+}
+
+API_EXPORT_NONSTD(char *) ap_psprintf(pool *p, const char *fmt, ...)
+{
+    va_list ap;
+    char *res;
+
+    va_start(ap, fmt);
+    res = ap_pvsprintf(p, fmt, ap);
+    va_end(ap);
+    return res;
+}
+
+/*****************************************************************
+ *
+ * The 'array' functions...
+ */
+
+static void make_array_core(array_header *res, pool *p, int nelts, int elt_size)
+{
+    if (nelts < 1)
+	nelts = 1;		/* Assure sanity if someone asks for
+				 * array of zero elts.
+				 */
+
+    res->elts = ap_pcalloc(p, nelts * elt_size);
+
+    res->pool = p;
+    res->elt_size = elt_size;
+    res->nelts = 0;		/* No active elements yet... */
+    res->nalloc = nelts;	/* ...but this many allocated */
+}
+
+API_EXPORT(array_header *) ap_make_array(pool *p, int nelts, int elt_size)
+{
+    array_header *res = (array_header *) ap_palloc(p, sizeof(array_header));
+
+    make_array_core(res, p, nelts, elt_size);
+    return res;
+}
+
+API_EXPORT(void *) ap_push_array(array_header *arr)
+{
+    if (arr->nelts == arr->nalloc) {
+	int new_size = (arr->nalloc <= 0) ? 1 : arr->nalloc * 2;
+	char *new_data;
+
+	new_data = ap_pcalloc(arr->pool, arr->elt_size * new_size);
+
+	memcpy(new_data, arr->elts, arr->nalloc * arr->elt_size);
+	arr->elts = new_data;
+	arr->nalloc = new_size;
+    }
+
+    ++arr->nelts;
+    return arr->elts + (arr->elt_size * (arr->nelts - 1));
+}
+
+API_EXPORT(void) ap_array_cat(array_header *dst, const array_header *src)
+{
+    int elt_size = dst->elt_size;
+
+    if (dst->nelts + src->nelts > dst->nalloc) {
+	int new_size = (dst->nalloc <= 0) ? 1 : dst->nalloc * 2;
+	char *new_data;
+
+	while (dst->nelts + src->nelts > new_size)
+	    new_size *= 2;
+
+	new_data = ap_pcalloc(dst->pool, elt_size * new_size);
+	memcpy(new_data, dst->elts, dst->nalloc * elt_size);
+
+	dst->elts = new_data;
+	dst->nalloc = new_size;
+    }
+
+    memcpy(dst->elts + dst->nelts * elt_size, src->elts, elt_size * src->nelts);
+    dst->nelts += src->nelts;
+}
+
+API_EXPORT(array_header *) ap_copy_array(pool *p, const array_header *arr)
+{
+    array_header *res = ap_make_array(p, arr->nalloc, arr->elt_size);
+
+    memcpy(res->elts, arr->elts, arr->elt_size * arr->nelts);
+    res->nelts = arr->nelts;
+    return res;
+}
+
+/* This cute function copies the array header *only*, but arranges
+ * for the data section to be copied on the first push or arraycat.
+ * It's useful when the elements of the array being copied are
+ * read only, but new stuff *might* get added on the end; we have the
+ * overhead of the full copy only where it is really needed.
+ */
+
+static ap_inline void copy_array_hdr_core(array_header *res,
+    const array_header *arr)
+{
+    res->elts = arr->elts;
+    res->elt_size = arr->elt_size;
+    res->nelts = arr->nelts;
+    res->nalloc = arr->nelts;	/* Force overflow on push */
+}
+
+API_EXPORT(array_header *) ap_copy_array_hdr(pool *p, const array_header *arr)
+{
+    array_header *res = (array_header *) ap_palloc(p, sizeof(array_header));
+
+    res->pool = p;
+    copy_array_hdr_core(res, arr);
+    return res;
+}
+
+/* The above is used here to avoid consing multiple new array bodies... */
+
+API_EXPORT(array_header *) ap_append_arrays(pool *p,
+					 const array_header *first,
+					 const array_header *second)
+{
+    array_header *res = ap_copy_array_hdr(p, first);
+
+    ap_array_cat(res, second);
+    return res;
+}
+
+/* ap_array_pstrcat generates a new string from the pool containing
+ * the concatenated sequence of substrings referenced as elements within
+ * the array.  The string will be empty if all substrings are empty or null,
+ * or if there are no elements in the array.
+ * If sep is non-NUL, it will be inserted between elements as a separator.
+ */
+API_EXPORT(char *) ap_array_pstrcat(pool *p, const array_header *arr,
+                                    const char sep)
+{
+    char *cp, *res, **strpp;
+    int i, len;
+
+    if (arr->nelts <= 0 || arr->elts == NULL)      /* Empty table? */
+        return (char *) ap_pcalloc(p, 1);
+
+    /* Pass one --- find length of required string */
+
+    len = 0;
+    for (i = 0, strpp = (char **) arr->elts; ; ++strpp) {
+        if (strpp && *strpp != NULL) {
+            len += strlen(*strpp);
+        }
+        if (++i >= arr->nelts)
+            break;
+        if (sep)
+            ++len;
+    }
+
+    /* Allocate the required string */
+
+    res = (char *) ap_palloc(p, len + 1);
+    cp = res;
+
+    /* Pass two --- copy the argument strings into the result space */
+
+    for (i = 0, strpp = (char **) arr->elts; ; ++strpp) {
+        if (strpp && *strpp != NULL) {
+            len = strlen(*strpp);
+            memcpy(cp, *strpp, len);
+            cp += len;
+        }
+        if (++i >= arr->nelts)
+            break;
+        if (sep)
+            *cp++ = sep;
+    }
+
+    *cp = '\0';
+
+    /* Return the result string */
+
+    return res;
+}
+
+
+/*****************************************************************
+ *
+ * The "table" functions.
+ */
+
+/* XXX: if you tweak this you should look at is_empty_table() and table_elts()
+ * in ap_alloc.h */
+struct table {
+    /* This has to be first to promote backwards compatibility with
+     * older modules which cast a table * to an array_header *...
+     * they should use the table_elts() function for most of the
+     * cases they do this for.
+     */
+    array_header a;
+#ifdef MAKE_TABLE_PROFILE
+    void *creator;
+#endif
+};
+
+#ifdef MAKE_TABLE_PROFILE
+static table_entry *table_push(table *t)
+{
+    if (t->a.nelts == t->a.nalloc) {
+	fprintf(stderr,
+	    "table_push: table created by %p hit limit of %u\n",
+	    t->creator, t->a.nalloc);
+    }
+    return (table_entry *) ap_push_array(&t->a);
+}
+#else
+#define table_push(t)	((table_entry *) ap_push_array(&(t)->a))
+#endif
+
+
+API_EXPORT(table *) ap_make_table(pool *p, int nelts)
+{
+    table *t = ap_palloc(p, sizeof(table));
+
+    make_array_core(&t->a, p, nelts, sizeof(table_entry));
+#ifdef MAKE_TABLE_PROFILE
+    t->creator = __builtin_return_address(0);
+#endif
+    return t;
+}
+
+API_EXPORT(table *) ap_copy_table(pool *p, const table *t)
+{
+    table *new = ap_palloc(p, sizeof(table));
+
+#ifdef POOL_DEBUG
+    /* we don't copy keys and values, so it's necessary that t->a.pool
+     * have a life span at least as long as p
+     */
+    if (!ap_pool_is_ancestor(t->a.pool, p)) {
+	fprintf(stderr, "copy_table: t's pool is not an ancestor of p\n");
+	abort();
+    }
+#endif
+    make_array_core(&new->a, p, t->a.nalloc, sizeof(table_entry));
+    memcpy(new->a.elts, t->a.elts, t->a.nelts * sizeof(table_entry));
+    new->a.nelts = t->a.nelts;
+    return new;
+}
+
+API_EXPORT(void) ap_clear_table(table *t)
+{
+    t->a.nelts = 0;
+}
+
+API_EXPORT(const char *) ap_table_get(const table *t, const char *key)
+{
+    table_entry *elts = (table_entry *) t->a.elts;
+    int i;
+
+    if (key == NULL)
+	return NULL;
+
+    for (i = 0; i < t->a.nelts; ++i)
+	if (!strcasecmp(elts[i].key, key))
+	    return elts[i].val;
+
+    return NULL;
+}
+
+API_EXPORT(void) ap_table_set(table *t, const char *key, const char *val)
+{
+    register int i, j, k;
+    table_entry *elts = (table_entry *) t->a.elts;
+    int done = 0;
+
+    for (i = 0; i < t->a.nelts; ) {
+	if (!strcasecmp(elts[i].key, key)) {
+	    if (!done) {
+		elts[i].val = ap_pstrdup(t->a.pool, val);
+		done = 1;
+		++i;
+	    }
+	    else {		/* delete an extraneous element */
+		for (j = i, k = i + 1; k < t->a.nelts; ++j, ++k) {
+		    elts[j].key = elts[k].key;
+		    elts[j].val = elts[k].val;
+		}
+		--t->a.nelts;
+	    }
+	}
+	else {
+	    ++i;
+	}
+    }
+
+    if (!done) {
+	elts = (table_entry *) table_push(t);
+	elts->key = ap_pstrdup(t->a.pool, key);
+	elts->val = ap_pstrdup(t->a.pool, val);
+    }
+}
+
+API_EXPORT(void) ap_table_setn(table *t, const char *key, const char *val)
+{
+    register int i, j, k;
+    table_entry *elts = (table_entry *) t->a.elts;
+    int done = 0;
+
+#ifdef POOL_DEBUG
+    {
+	if (!ap_pool_is_ancestor(ap_find_pool(key), t->a.pool)) {
+	    fprintf(stderr, "table_set: key not in ancestor pool of t\n");
+	    abort();
+	}
+	if (!ap_pool_is_ancestor(ap_find_pool(val), t->a.pool)) {
+	    fprintf(stderr, "table_set: val not in ancestor pool of t\n");
+	    abort();
+	}
+    }
+#endif
+
+    for (i = 0; i < t->a.nelts; ) {
+	if (!strcasecmp(elts[i].key, key)) {
+	    if (!done) {
+		elts[i].val = (char *)val;
+		done = 1;
+		++i;
+	    }
+	    else {		/* delete an extraneous element */
+		for (j = i, k = i + 1; k < t->a.nelts; ++j, ++k) {
+		    elts[j].key = elts[k].key;
+		    elts[j].val = elts[k].val;
+		}
+		--t->a.nelts;
+	    }
+	}
+	else {
+	    ++i;
+	}
+    }
+
+    if (!done) {
+	elts = (table_entry *) table_push(t);
+	elts->key = (char *)key;
+	elts->val = (char *)val;
+    }
+}
+
+API_EXPORT(void) ap_table_unset(table *t, const char *key)
+{
+    register int i, j, k;
+    table_entry *elts = (table_entry *) t->a.elts;
+
+    for (i = 0; i < t->a.nelts;) {
+	if (!strcasecmp(elts[i].key, key)) {
+
+	    /* found an element to skip over
+	     * there are any number of ways to remove an element from
+	     * a contiguous block of memory.  I've chosen one that
+	     * doesn't do a memcpy/bcopy/array_delete, *shrug*...
+	     */
+	    for (j = i, k = i + 1; k < t->a.nelts; ++j, ++k) {
+		elts[j].key = elts[k].key;
+		elts[j].val = elts[k].val;
+	    }
+	    --t->a.nelts;
+	}
+	else {
+	    ++i;
+	}
+    }
+}
+
+API_EXPORT(void) ap_table_merge(table *t, const char *key, const char *val)
+{
+    table_entry *elts = (table_entry *) t->a.elts;
+    int i;
+
+    for (i = 0; i < t->a.nelts; ++i)
+	if (!strcasecmp(elts[i].key, key)) {
+	    elts[i].val = ap_pstrcat(t->a.pool, elts[i].val, ", ", val, NULL);
+	    return;
+	}
+
+    elts = (table_entry *) table_push(t);
+    elts->key = ap_pstrdup(t->a.pool, key);
+    elts->val = ap_pstrdup(t->a.pool, val);
+}
+
+API_EXPORT(void) ap_table_mergen(table *t, const char *key, const char *val)
+{
+    table_entry *elts = (table_entry *) t->a.elts;
+    int i;
+
+#ifdef POOL_DEBUG
+    {
+	if (!ap_pool_is_ancestor(ap_find_pool(key), t->a.pool)) {
+	    fprintf(stderr, "table_set: key not in ancestor pool of t\n");
+	    abort();
+	}
+	if (!ap_pool_is_ancestor(ap_find_pool(val), t->a.pool)) {
+	    fprintf(stderr, "table_set: key not in ancestor pool of t\n");
+	    abort();
+	}
+    }
+#endif
+
+    for (i = 0; i < t->a.nelts; ++i) {
+	if (!strcasecmp(elts[i].key, key)) {
+	    elts[i].val = ap_pstrcat(t->a.pool, elts[i].val, ", ", val, NULL);
+	    return;
+	}
+    }
+
+    elts = (table_entry *) table_push(t);
+    elts->key = (char *)key;
+    elts->val = (char *)val;
+}
+
+API_EXPORT(void) ap_table_add(table *t, const char *key, const char *val)
+{
+    table_entry *elts = (table_entry *) t->a.elts;
+
+    elts = (table_entry *) table_push(t);
+    elts->key = ap_pstrdup(t->a.pool, key);
+    elts->val = ap_pstrdup(t->a.pool, val);
+}
+
+API_EXPORT(void) ap_table_addn(table *t, const char *key, const char *val)
+{
+    table_entry *elts = (table_entry *) t->a.elts;
+
+#ifdef POOL_DEBUG
+    {
+	if (!ap_pool_is_ancestor(ap_find_pool(key), t->a.pool)) {
+	    fprintf(stderr, "table_set: key not in ancestor pool of t\n");
+	    abort();
+	}
+	if (!ap_pool_is_ancestor(ap_find_pool(val), t->a.pool)) {
+	    fprintf(stderr, "table_set: key not in ancestor pool of t\n");
+	    abort();
+	}
+    }
+#endif
+
+    elts = (table_entry *) table_push(t);
+    elts->key = (char *)key;
+    elts->val = (char *)val;
+}
+
+API_EXPORT(table *) ap_overlay_tables(pool *p, const table *overlay, const table *base)
+{
+    table *res;
+
+#ifdef POOL_DEBUG
+    /* we don't copy keys and values, so it's necessary that
+     * overlay->a.pool and base->a.pool have a life span at least
+     * as long as p
+     */
+    if (!ap_pool_is_ancestor(overlay->a.pool, p)) {
+	fprintf(stderr, "overlay_tables: overlay's pool is not an ancestor of p\n");
+	abort();
+    }
+    if (!ap_pool_is_ancestor(base->a.pool, p)) {
+	fprintf(stderr, "overlay_tables: base's pool is not an ancestor of p\n");
+	abort();
+    }
+#endif
+
+    res = ap_palloc(p, sizeof(table));
+    /* behave like append_arrays */
+    res->a.pool = p;
+    copy_array_hdr_core(&res->a, &overlay->a);
+    ap_array_cat(&res->a, &base->a);
+
+    return res;
+}
+
+/* And now for something completely abstract ...
+
+ * For each key value given as a vararg:
+ *   run the function pointed to as
+ *     int comp(void *r, char *key, char *value);
+ *   on each valid key-value pair in the table t that matches the vararg key,
+ *   or once for every valid key-value pair if the vararg list is empty,
+ *   until the function returns false (0) or we finish the table.
+ *
+ * Note that we restart the traversal for each vararg, which means that
+ * duplicate varargs will result in multiple executions of the function
+ * for each matching key.  Note also that if the vararg list is empty,
+ * only one traversal will be made and will cut short if comp returns 0.
+ *
+ * Note that the table_get and table_merge functions assume that each key in
+ * the table is unique (i.e., no multiple entries with the same key).  This
+ * function does not make that assumption, since it (unfortunately) isn't
+ * true for some of Apache's tables.
+ *
+ * Note that rec is simply passed-on to the comp function, so that the
+ * caller can pass additional info for the task.
+ */
+API_EXPORT_NONSTD(void) ap_table_do(int (*comp) (void *, const char *, const char *), 
+	                            void *rec, const table *t,...)
+{
+    va_list vp;
+    char *argp;
+    table_entry *elts = (table_entry *) t->a.elts;
+    int rv, i;
+
+    va_start(vp, t);
+
+    argp = va_arg(vp, char *);
+
+    do {
+	for (rv = 1, i = 0; rv && (i < t->a.nelts); ++i) {
+	    if (elts[i].key && (!argp || !strcasecmp(elts[i].key, argp))) {
+		rv = (*comp) (rec, elts[i].key, elts[i].val);
+	    }
+	}
+    } while (argp && ((argp = va_arg(vp, char *)) != NULL));
+
+    va_end(vp);
+}
+
+/* Curse libc and the fact that it doesn't guarantee a stable sort.  We
+ * have to enforce stability ourselves by using the order field.  If it
+ * provided a stable sort then we wouldn't even need temporary storage to
+ * do the work below. -djg
+ *
+ * ("stable sort" means that equal keys retain their original relative
+ * ordering in the output.)
+ */
+typedef struct {
+    char *key;
+    char *val;
+    int order;
+} overlap_key;
+
+static int sort_overlap(const void *va, const void *vb)
+{
+    const overlap_key *a = va;
+    const overlap_key *b = vb;
+    int r;
+
+    r = strcasecmp(a->key, b->key);
+    if (r) {
+	return r;
+    }
+    return a->order - b->order;
+}
+
+/* prefer to use the stack for temp storage for overlaps smaller than this */
+#ifndef AP_OVERLAP_TABLES_ON_STACK
+#define AP_OVERLAP_TABLES_ON_STACK	(512)
+#endif
+
+API_EXPORT(void) ap_overlap_tables(table *a, const table *b, unsigned flags)
+{
+    overlap_key cat_keys_buf[AP_OVERLAP_TABLES_ON_STACK];
+    overlap_key *cat_keys;
+    int nkeys;
+    table_entry *e;
+    table_entry *last_e;
+    overlap_key *left;
+    overlap_key *right;
+    overlap_key *last;
+
+    nkeys = a->a.nelts + b->a.nelts;
+    if (nkeys < AP_OVERLAP_TABLES_ON_STACK) {
+	cat_keys = cat_keys_buf;
+    }
+    else {
+	/* XXX: could use scratch free space in a or b's pool instead...
+	 * which could save an allocation in b's pool.
+	 */
+	cat_keys = ap_palloc(b->a.pool, sizeof(overlap_key) * nkeys);
+    }
+
+    nkeys = 0;
+
+    /* Create a list of the entries from a concatenated with the entries
+     * from b.
+     */
+    e = (table_entry *)a->a.elts;
+    last_e = e + a->a.nelts;
+    while (e < last_e) {
+	cat_keys[nkeys].key = e->key;
+	cat_keys[nkeys].val = e->val;
+	cat_keys[nkeys].order = nkeys;
+	++nkeys;
+	++e;
+    }
+
+    e = (table_entry *)b->a.elts;
+    last_e = e + b->a.nelts;
+    while (e < last_e) {
+	cat_keys[nkeys].key = e->key;
+	cat_keys[nkeys].val = e->val;
+	cat_keys[nkeys].order = nkeys;
+	++nkeys;
+	++e;
+    }
+
+    qsort(cat_keys, nkeys, sizeof(overlap_key), sort_overlap);
+
+    /* Now iterate over the sorted list and rebuild a.
+     * Start by making sure it has enough space.
+     */
+    a->a.nelts = 0;
+    if (a->a.nalloc < nkeys) {
+	a->a.elts = ap_palloc(a->a.pool, a->a.elt_size * nkeys * 2);
+	a->a.nalloc = nkeys * 2;
+    }
+
+    /*
+     * In both the merge and set cases we retain the invariant:
+     *
+     * left->key, (left+1)->key, (left+2)->key, ..., (right-1)->key
+     * are all equal keys.  (i.e. strcasecmp returns 0)
+     *
+     * We essentially need to find the maximal
+     * right for each key, then we can do a quick merge or set as
+     * appropriate.
+     */
+
+    if (flags & AP_OVERLAP_TABLES_MERGE) {
+	left = cat_keys;
+	last = left + nkeys;
+	while (left < last) {
+	    right = left + 1;
+	    if (right == last
+		|| strcasecmp(left->key, right->key)) {
+		ap_table_addn(a, left->key, left->val);
+		left = right;
+	    }
+	    else {
+		char *strp;
+		char *value;
+		size_t len;
+
+		/* Have to merge some headers.  Let's re-use the order field,
+		 * since it's handy... we'll store the length of val there.
+		 */
+		left->order = strlen(left->val);
+		len = left->order;
+		do {
+		    right->order = strlen(right->val);
+		    len += 2 + right->order;
+		    ++right;
+		} while (right < last
+			&& !strcasecmp(left->key, right->key));
+		/* right points one past the last header to merge */
+		value = ap_palloc(a->a.pool, len + 1);
+		strp = value;
+		for (;;) {
+		    memcpy(strp, left->val, left->order);
+		    strp += left->order;
+		    ++left;
+		    if (left == right) break;
+		    *strp++ = ',';
+		    *strp++ = ' ';
+		}
+		*strp = 0;
+		ap_table_addn(a, (left-1)->key, value);
+	    }
+	}
+    }
+    else {
+	left = cat_keys;
+	last = left + nkeys;
+	while (left < last) {
+	    right = left + 1;
+	    while (right < last && !strcasecmp(left->key, right->key)) {
+		++right;
+	    }
+	    ap_table_addn(a, (right-1)->key, (right-1)->val);
+	    left = right;
+	}
+    }
+}
+
+/*****************************************************************
+ *
+ * Managing generic cleanups.  
+ */
+
+struct cleanup {
+    void *data;
+    void (*plain_cleanup) (void *);
+    void (*child_cleanup) (void *);
+    struct cleanup *next;
+};
+
+API_EXPORT(void) ap_register_cleanup_ex(pool *p, void *data,
+				      void (*plain_cleanup) (void *),
+				      void (*child_cleanup) (void *),
+				      int (*magic_cleanup) (void *))
+{
+    struct cleanup *c;
+    if (p) {
+	c = (struct cleanup *) ap_palloc(p, sizeof(struct cleanup));
+	c->data = data;
+	c->plain_cleanup = plain_cleanup;
+	c->child_cleanup = child_cleanup;
+	c->next = p->cleanups;
+	p->cleanups = c;
+    }
+    /* attempt to do magic even if not passed a pool. Allows us
+     * to perform the magic, therefore, "whenever" we want/need */
+    if (magic_cleanup) {
+	if (!magic_cleanup(data)) 
+	   ap_log_error(APLOG_MARK, APLOG_WARNING, NULL,
+		 "exec() may not be safe");
+    }
+}
+
+API_EXPORT(void) ap_register_cleanup(pool *p, void *data,
+				     void (*plain_cleanup) (void *),
+				     void (*child_cleanup) (void *))
+{
+    ap_register_cleanup_ex(p, data, plain_cleanup, child_cleanup, NULL);
+}
+
+API_EXPORT(void) ap_kill_cleanup(pool *p, void *data, void (*cleanup) (void *))
+{
+    struct cleanup *c = p->cleanups;
+    struct cleanup **lastp = &p->cleanups;
+
+    while (c) {
+	if (c->data == data && c->plain_cleanup == cleanup) {
+	    *lastp = c->next;
+	    break;
+	}
+
+	lastp = &c->next;
+	c = c->next;
+    }
+}
+
+API_EXPORT(void) ap_run_cleanup(pool *p, void *data, void (*cleanup) (void *))
+{
+    ap_block_alarms();		/* Run cleanup only once! */
+    (*cleanup) (data);
+    ap_kill_cleanup(p, data, cleanup);
+    ap_unblock_alarms();
+}
+
+static void run_cleanups(struct cleanup *c)
+{
+    while (c) {
+	(*c->plain_cleanup) (c->data);
+	c = c->next;
+    }
+}
+
+static void run_child_cleanups(struct cleanup *c)
+{
+    while (c) {
+	(*c->child_cleanup) (c->data);
+	c = c->next;
+    }
+}
+
+static void cleanup_pool_for_exec(pool *p)
+{
+    run_child_cleanups(p->cleanups);
+    p->cleanups = NULL;
+
+    for (p = p->sub_pools; p; p = p->sub_next)
+	cleanup_pool_for_exec(p);
+}
+
+API_EXPORT(void) ap_cleanup_for_exec(void)
+{
+#if !defined(WIN32) && !defined(OS2) && !defined(NETWARE)
+    /*
+     * Don't need to do anything on NT, NETWARE or OS/2, because I
+     * am actually going to spawn the new process - not
+     * exec it. All handles that are not inheritable, will
+     * be automajically closed. The only problem is with
+     * file handles that are open, but there isn't much
+     * I can do about that (except if the child decides
+     * to go out and close them
+     */
+    ap_block_alarms();
+    cleanup_pool_for_exec(permanent_pool);
+    ap_unblock_alarms();
+#endif /* ndef WIN32 */
+}
+
+API_EXPORT_NONSTD(void) ap_null_cleanup(void *data)
+{
+    /* do nothing cleanup routine */
+}
+
+/*****************************************************************
+ *
+ * Files and file descriptors; these are just an application of the
+ * generic cleanup interface.
+ */
+
+#if defined(WIN32)
+/* Provided by service.c, internal to the core library (not exported) */
+BOOL isWindowsNT(void);
+
+int ap_close_handle_on_exec(HANDLE nth)
+{
+    /* Protect the fd so that it will not be inherited by child processes */
+    if (isWindowsNT()) {
+        DWORD hinfo;
+        if (!GetHandleInformation(nth, &hinfo)) {
+	    ap_log_error(APLOG_MARK, APLOG_ERR, NULL, "GetHandleInformation"
+                         "(%08x) failed", nth);
+	    return 0;
+        }
+        if ((hinfo & HANDLE_FLAG_INHERIT)
+                && !SetHandleInformation(nth, HANDLE_FLAG_INHERIT, 0)) {
+	    ap_log_error(APLOG_MARK, APLOG_ERR, NULL, "SetHandleInformation"
+                         "(%08x, HANDLE_FLAG_INHERIT, 0) failed", nth);
+	    return 0;
+        }
+        return 1;
+    }
+    else /* Win9x */ {
+        /* XXX: This API doesn't work... you can't change the handle by just
+         * 'touching' it... you must duplicat to a second handle and close
+         * the original.
+         */
+        return 0;
+    }
+}
+
+int ap_close_fd_on_exec(int fd)
+{
+    return ap_close_handle_on_exec((HANDLE)_get_osfhandle(fd));
+}
+
+#else
+
+int ap_close_fd_on_exec(int fd)
+{
+#if defined(F_SETFD) && defined(FD_CLOEXEC)
+    /* Protect the fd so that it will not be inherited by child processes */
+    if(fcntl(fd, F_SETFD, FD_CLOEXEC) < 0) {
+	ap_log_error(APLOG_MARK, APLOG_ERR, NULL,
+		     "fcntl(%d, F_SETFD, FD_CLOEXEC) failed", fd);
+	return 0;
+    }
+
+    return 1;
+#else
+    return 0;
+#endif
+}
+
+#endif /* ndef(WIN32) */
+
+static void fd_cleanup(void *fdv)
+{
+    close((int) (long) fdv);
+}
+
+static int fd_magic_cleanup(void *fdv)
+{
+    return ap_close_fd_on_exec((int) (long) fdv);
+}
+
+API_EXPORT(void) ap_note_cleanups_for_fd_ex(pool *p, int fd, int domagic)
+{
+#if defined(NETWARE)
+    domagic = 0; /* skip magic for NetWare, at least for now */
+#endif
+    ap_register_cleanup_ex(p, (void *) (long) fd, fd_cleanup, fd_cleanup,
+                           domagic ? fd_magic_cleanup : NULL);
+}
+
+API_EXPORT(void) ap_note_cleanups_for_fd(pool *p, int fd)
+{
+    ap_note_cleanups_for_fd_ex(p, fd, 0);
+}
+
+API_EXPORT(void) ap_kill_cleanups_for_fd(pool *p, int fd)
+{
+    ap_kill_cleanup(p, (void *) (long) fd, fd_cleanup);
+}
+
+API_EXPORT(int) ap_popenf_ex(pool *a, const char *name, int flg, int mode,
+                             int domagic)
+{
+    int fd;
+    int save_errno;
+
+    ap_block_alarms();
+    fd = open(name, flg, mode);
+    save_errno = errno;
+    if (fd >= 0) {
+	fd = ap_slack(fd, AP_SLACK_HIGH);
+	ap_note_cleanups_for_fd_ex(a, fd, domagic);
+    }
+    ap_unblock_alarms();
+    errno = save_errno;
+    return fd;
+}
+
+API_EXPORT(int) ap_popenf(pool *a, const char *name, int flg, int mode)
+{
+    return ap_popenf_ex(a, name, flg, mode, 0);
+}
+
+API_EXPORT(int) ap_pclosef(pool *a, int fd)
+{
+    int res;
+    int save_errno;
+
+    ap_block_alarms();
+    res = close(fd);
+    save_errno = errno;
+    ap_kill_cleanup(a, (void *) (long) fd, fd_cleanup);
+    ap_unblock_alarms();
+    errno = save_errno;
+    return res;
+}
+
+#ifdef WIN32
+static void h_cleanup(void *nth)
+{
+    CloseHandle((HANDLE) nth);
+}
+
+static int h_magic_cleanup(void *nth)
+{
+    /* Set handle not-inherited
+     */
+    return ap_close_handle_on_exec((HANDLE) nth);
+}
+
+API_EXPORT(void) ap_note_cleanups_for_h_ex(pool *p, HANDLE nth, int domagic)
+{
+    ap_register_cleanup_ex(p, (void *) nth, h_cleanup, h_cleanup,
+                           domagic ? h_magic_cleanup : NULL);
+}
+
+API_EXPORT(void) ap_note_cleanups_for_h(pool *p, HANDLE nth)
+{
+    ap_note_cleanups_for_h_ex(p, nth, 0);
+}
+
+API_EXPORT(int) ap_pcloseh(pool *a, HANDLE hDevice)
+{
+    int res=0;
+    int save_errno;
+
+    ap_block_alarms();
+    
+    if (!CloseHandle(hDevice)) {
+        res = GetLastError();
+    }
+    
+    save_errno = errno;
+    ap_kill_cleanup(a, (void *) hDevice, h_cleanup);
+    ap_unblock_alarms();
+    errno = save_errno;
+    return res;
+}
+#endif
+
+/* Note that we have separate plain_ and child_ cleanups for FILE *s,
+ * since fclose() would flush I/O buffers, which is extremely undesirable;
+ * we just close the descriptor.
+ */
+
+static void file_cleanup(void *fpv)
+{
+    fclose((FILE *) fpv);
+}
+
+static void file_child_cleanup(void *fpv)
+{
+    close(fileno((FILE *) fpv));
+}
+
+static int file_magic_cleanup(void *fpv)
+{
+    return ap_close_fd_on_exec(fileno((FILE *) fpv));
+}
+
+API_EXPORT(void) ap_note_cleanups_for_file_ex(pool *p, FILE *fp, int domagic)
+{
+#if defined(NETWARE)
+    domagic = 0; /* skip magic for NetWare, at least for now */
+#endif
+    ap_register_cleanup_ex(p, (void *) fp, file_cleanup, file_child_cleanup,
+                           domagic ? file_magic_cleanup : NULL);
+}
+
+API_EXPORT(void) ap_note_cleanups_for_file(pool *p, FILE *fp)
+{
+    ap_note_cleanups_for_file_ex(p, fp, 0);
+}
+
+API_EXPORT(FILE *) ap_pfopen(pool *a, const char *name, const char *mode)
+{
+    FILE *fd = NULL;
+    int baseFlag, desc;
+    int modeFlags = 0;
+    int saved_errno;
+
+#ifdef WIN32
+    modeFlags = _S_IREAD | _S_IWRITE;
+#else
+    modeFlags = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;
+#endif
+
+    ap_block_alarms();
+
+    if (*mode == 'a') {
+	/* Work around faulty implementations of fopen */
+	baseFlag = (*(mode + 1) == '+') ? O_RDWR : O_WRONLY;
+	desc = open(name, baseFlag | O_APPEND | O_CREAT,
+		    modeFlags);
+	if (desc >= 0) {
+	    desc = ap_slack(desc, AP_SLACK_LOW);
+	    fd = ap_fdopen(desc, mode);
+	}
+    }
+    else {
+	fd = fopen(name, mode);
+    }
+    saved_errno = errno;
+    if (fd != NULL)
+	ap_note_cleanups_for_file(a, fd);
+    ap_unblock_alarms();
+    errno = saved_errno;
+    return fd;
+}
+
+API_EXPORT(FILE *) ap_pfdopen(pool *a, int fd, const char *mode)
+{
+    FILE *f;
+    int saved_errno;
+
+    ap_block_alarms();
+    f = ap_fdopen(fd, mode);
+    saved_errno = errno;
+    if (f != NULL)
+	ap_note_cleanups_for_file(a, f);
+    ap_unblock_alarms();
+    errno = saved_errno;
+    return f;
+}
+
+
+API_EXPORT(int) ap_pfclose(pool *a, FILE *fd)
+{
+    int res;
+
+    ap_block_alarms();
+    res = fclose(fd);
+    ap_kill_cleanup(a, (void *) fd, file_cleanup);
+    ap_unblock_alarms();
+    return res;
+}
+
+/*
+ * DIR * with cleanup
+ */
+
+static void dir_cleanup(void *dv)
+{
+    closedir((DIR *) dv);
+}
+
+API_EXPORT(DIR *) ap_popendir(pool *p, const char *name)
+{
+    DIR *d;
+    int save_errno;
+
+    ap_block_alarms();
+    d = opendir(name);
+    if (d == NULL) {
+	save_errno = errno;
+	ap_unblock_alarms();
+	errno = save_errno;
+	return NULL;
+    }
+    ap_register_cleanup(p, (void *) d, dir_cleanup, dir_cleanup);
+    ap_unblock_alarms();
+    return d;
+}
+
+API_EXPORT(void) ap_pclosedir(pool *p, DIR * d)
+{
+    ap_block_alarms();
+    ap_kill_cleanup(p, (void *) d, dir_cleanup);
+    closedir(d);
+    ap_unblock_alarms();
+}
+
+/*****************************************************************
+ *
+ * Files and file descriptors; these are just an application of the
+ * generic cleanup interface.
+ */
+
+static void socket_cleanup(void *fdv)
+{
+    closesocket((int) (long) fdv);
+}
+
+static int socket_magic_cleanup(void *fpv)
+{
+#ifdef WIN32
+    return ap_close_handle_on_exec((HANDLE) fpv);
+#else
+    return ap_close_fd_on_exec((int) (long) fpv);
+#endif
+}
+
+API_EXPORT(void) ap_note_cleanups_for_socket_ex(pool *p, int fd, int domagic)
+{
+#if defined(TPF) || defined(NETWARE)
+    domagic = 0; /* skip magic (fcntl) for TPF sockets, at least for now */
+#endif
+    ap_register_cleanup_ex(p, (void *) (long) fd, socket_cleanup,
+                           socket_cleanup,
+                           domagic ? socket_magic_cleanup : NULL);
+}
+
+API_EXPORT(void) ap_note_cleanups_for_socket(pool *p, int fd)
+{
+    ap_note_cleanups_for_socket_ex(p, fd, 0);
+}
+
+API_EXPORT(void) ap_kill_cleanups_for_socket(pool *p, int sock)
+{
+    ap_kill_cleanup(p, (void *) (long) sock, socket_cleanup);
+}
+
+API_EXPORT(int) ap_psocket_ex(pool *p, int domain, int type, int protocol,
+                              int domagic)
+{
+    int fd;
+
+    ap_block_alarms();
+    fd = socket(domain, type, protocol);
+    if (fd == -1) {
+	int save_errno = errno;
+	ap_unblock_alarms();
+	errno = save_errno;
+	return -1;
+    }
+    ap_note_cleanups_for_socket_ex(p, fd, domagic);
+    ap_unblock_alarms();
+    return fd;
+}
+
+API_EXPORT(int) ap_psocket(pool *p, int domain, int type, int protocol)
+{
+    return ap_psocket_ex(p, domain, type, protocol, 0);
+}
+
+API_EXPORT(int) ap_pclosesocket(pool *a, int sock)
+{
+    int res;
+    int save_errno;
+
+    ap_block_alarms();
+    res = closesocket(sock);
+#if defined(WIN32) || defined(NETWARE)
+    errno = WSAGetLastError();
+#endif /* WIN32 */
+    save_errno = errno;
+    ap_kill_cleanup(a, (void *) (long) sock, socket_cleanup);
+    ap_unblock_alarms();
+    errno = save_errno;
+    return res;
+}
+
+
+/*
+ * Here's a pool-based interface to POSIX regex's regcomp().
+ * Note that we return regex_t instead of being passed one.
+ * The reason is that if you use an already-used regex_t structure,
+ * the memory that you've already allocated gets forgotten, and
+ * regfree() doesn't clear it. So we don't allow it.
+ */
+
+static void regex_cleanup(void *preg)
+{
+    regfree((regex_t *) preg);
+}
+
+API_EXPORT(regex_t *) ap_pregcomp(pool *p, const char *pattern, int cflags)
+{
+    regex_t *preg = ap_palloc(p, sizeof(regex_t));
+
+    if (regcomp(preg, pattern, cflags))
+	return NULL;
+
+    ap_register_cleanup(p, (void *) preg, regex_cleanup, regex_cleanup);
+
+    return preg;
+}
+
+
+API_EXPORT(void) ap_pregfree(pool *p, regex_t * reg)
+{
+    ap_block_alarms();
+    regfree(reg);
+    ap_kill_cleanup(p, (void *) reg, regex_cleanup);
+    ap_unblock_alarms();
+}
+
+/*****************************************************************
+ *
+ * More grotty system stuff... subprocesses.  Frump.  These don't use
+ * the generic cleanup interface because I don't want multiple
+ * subprocesses to result in multiple three-second pauses; the
+ * subprocesses have to be "freed" all at once.  If someone comes
+ * along with another resource they want to allocate which has the
+ * same property, we might want to fold support for that into the
+ * generic interface, but for now, it's a special case
+ */
+
+struct process_chain {
+    pid_t pid;
+    enum kill_conditions kill_how;
+    struct process_chain *next;
+};
+
+API_EXPORT(void) ap_note_subprocess(pool *a, pid_t pid, enum kill_conditions 
+how) {
+    struct process_chain *new =
+    (struct process_chain *) ap_palloc(a, sizeof(struct process_chain));
+
+    new->pid = pid;
+    new->kill_how = how;
+    new->next = a->subprocesses;
+    a->subprocesses = new;
+}
+
+#ifdef WIN32
+#define os_pipe(fds) _pipe(fds, 512, O_BINARY | O_NOINHERIT)
+#else
+#define os_pipe(fds) pipe(fds)
+#endif /* WIN32 */
+
+/* for ap_fdopen, to get binary mode */
+#if defined (OS2) || defined (WIN32) || defined (NETWARE)
+#define BINMODE	"b"
+#else
+#define BINMODE
+#endif
+
+static pid_t spawn_child_core(pool *p, int (*func) (void *, child_info *),
+			    void *data,enum kill_conditions kill_how,
+			    int *pipe_in, int *pipe_out, int *pipe_err)
+{
+    pid_t pid;
+    int in_fds[2];
+    int out_fds[2];
+    int err_fds[2];
+    int save_errno;
+
+    if (pipe_in && os_pipe(in_fds) < 0) {
+	return 0;
+    }
+
+    if (pipe_out && os_pipe(out_fds) < 0) {
+	save_errno = errno;
+	if (pipe_in) {
+	    close(in_fds[0]);
+	    close(in_fds[1]);
+	}
+	errno = save_errno;
+	return 0;
+    }
+
+    if (pipe_err && os_pipe(err_fds) < 0) {
+	save_errno = errno;
+	if (pipe_in) {
+	    close(in_fds[0]);
+	    close(in_fds[1]);
+	}
+	if (pipe_out) {
+	    close(out_fds[0]);
+	    close(out_fds[1]);
+	}
+	errno = save_errno;
+	return 0;
+    }
+
+#ifdef WIN32
+
+    {
+	HANDLE thread_handle;
+	int hStdIn, hStdOut, hStdErr;
+	int old_priority;
+	child_info info;
+
+	(void) ap_acquire_mutex(spawn_mutex);
+	thread_handle = GetCurrentThread();	/* doesn't need to be closed */
+	old_priority = GetThreadPriority(thread_handle);
+	SetThreadPriority(thread_handle, THREAD_PRIORITY_HIGHEST);
+	/* Now do the right thing with your pipes */
+	if (pipe_in) {
+	    hStdIn = dup(fileno(stdin));
+	    if(dup2(in_fds[0], fileno(stdin)))
+		ap_log_error(APLOG_MARK, APLOG_ERR, NULL, "dup2(stdin) failed");
+	    close(in_fds[0]);
+	}
+	if (pipe_out) {
+	    hStdOut = dup(fileno(stdout));
+	    close(fileno(stdout));
+	    if(dup2(out_fds[1], fileno(stdout)))
+		ap_log_error(APLOG_MARK, APLOG_ERR, NULL, "dup2(stdout) failed");
+	    close(out_fds[1]);
+	}
+	if (pipe_err) {
+	    hStdErr = dup(fileno(stderr));
+	    if(dup2(err_fds[1], fileno(stderr)))
+		ap_log_error(APLOG_MARK, APLOG_ERR, NULL, "dup2(stderr) failed");
+	    close(err_fds[1]);
+	}
+
+	info.hPipeInputRead   = GetStdHandle(STD_INPUT_HANDLE);
+	info.hPipeOutputWrite = GetStdHandle(STD_OUTPUT_HANDLE);
+	info.hPipeErrorWrite  = GetStdHandle(STD_ERROR_HANDLE);
+
+	pid = (*func) (data, &info);
+        if (pid == -1) pid = 0;   /* map Win32 error code onto Unix default */
+
+        if (!pid) {
+	    save_errno = errno;
+	    close(in_fds[1]);
+	    close(out_fds[0]);
+	    close(err_fds[0]);
+	}
+
+	/* restore the original stdin, stdout and stderr */
+	if (pipe_in) {
+	    dup2(hStdIn, fileno(stdin));
+	    close(hStdIn);
+        }
+	if (pipe_out) {
+	    dup2(hStdOut, fileno(stdout));
+	    close(hStdOut);
+	}
+	if (pipe_err) {
+	    dup2(hStdErr, fileno(stderr));
+	    close(hStdErr);
+	}
+
+        if (pid) {
+	    ap_note_subprocess(p, pid, kill_how);
+	    if (pipe_in) {
+		*pipe_in = in_fds[1];
+	    }
+	    if (pipe_out) {
+		*pipe_out = out_fds[0];
+	    }
+	    if (pipe_err) {
+		*pipe_err = err_fds[0];
+	    }
+	}
+	SetThreadPriority(thread_handle, old_priority);
+	(void) ap_release_mutex(spawn_mutex);
+	/*
+	 * go on to the end of the function, where you can
+	 * return the pid
+	 */
+        if (!pid) {
+            errno = save_errno;
+        }
+    }
+#elif defined(NETWARE)
+     /* NetWare currently has no pipes yet. This will
+        be solved with the new libc for NetWare soon. */
+     pid = 0;
+#elif defined(OS2)
+    {
+        int save_in=-1, save_out=-1, save_err=-1;
+        
+        if (pipe_out) {
+            save_out = dup(STDOUT_FILENO);
+            dup2(out_fds[1], STDOUT_FILENO);
+            close(out_fds[1]);
+            DosSetFHState(out_fds[0], OPEN_FLAGS_NOINHERIT);
+        }
+
+        if (pipe_in) {
+            save_in = dup(STDIN_FILENO);
+            dup2(in_fds[0], STDIN_FILENO);
+            close(in_fds[0]);
+            DosSetFHState(in_fds[1], OPEN_FLAGS_NOINHERIT);
+        }
+
+        if (pipe_err) {
+            save_err = dup(STDERR_FILENO);
+            dup2(err_fds[1], STDERR_FILENO);
+            close(err_fds[1]);
+            DosSetFHState(err_fds[0], OPEN_FLAGS_NOINHERIT);
+        }
+        
+        pid = func(data, NULL);
+    
+        if ( pid )
+            ap_note_subprocess(p, pid, kill_how);
+
+        if (pipe_out) {
+            close(STDOUT_FILENO);
+            dup2(save_out, STDOUT_FILENO);
+            close(save_out);
+            *pipe_out = out_fds[0];
+        }
+
+        if (pipe_in) {
+            close(STDIN_FILENO);
+            dup2(save_in, STDIN_FILENO);
+            close(save_in);
+            *pipe_in = in_fds[1];
+        }
+
+        if (pipe_err) {
+            close(STDERR_FILENO);
+            dup2(save_err, STDERR_FILENO);
+            close(save_err);
+            *pipe_err = err_fds[0];
+        }
+    }
+#elif defined(TPF)
+   return (pid = ap_tpf_spawn_child(p, func, data, kill_how,	
+                 pipe_in, pipe_out, pipe_err, out_fds, in_fds, err_fds));		
+#else
+
+    if ((pid = fork()) < 0) {
+	save_errno = errno;
+	if (pipe_in) {
+	    close(in_fds[0]);
+	    close(in_fds[1]);
+	}
+	if (pipe_out) {
+	    close(out_fds[0]);
+	    close(out_fds[1]);
+	}
+	if (pipe_err) {
+	    close(err_fds[0]);
+	    close(err_fds[1]);
+	}
+	errno = save_errno;
+	return 0;
+    }
+
+    if (!pid) {
+	/* Child process */
+	RAISE_SIGSTOP(SPAWN_CHILD);
+
+	if (pipe_out) {
+	    close(out_fds[0]);
+	    dup2(out_fds[1], STDOUT_FILENO);
+	    close(out_fds[1]);
+	}
+
+	if (pipe_in) {
+	    close(in_fds[1]);
+	    dup2(in_fds[0], STDIN_FILENO);
+	    close(in_fds[0]);
+	}
+
+	if (pipe_err) {
+	    close(err_fds[0]);
+	    dup2(err_fds[1], STDERR_FILENO);
+	    close(err_fds[1]);
+	}
+
+	/* HP-UX SIGCHLD fix goes here, if someone will remind me what it is... */
+	signal(SIGCHLD, SIG_DFL);	/* Was that it? */
+
+	func(data, NULL);
+	exit(1);		/* Should only get here if the exec in func() failed */
+    }
+
+    /* Parent process */
+
+    ap_note_subprocess(p, pid, kill_how);
+
+    if (pipe_out) {
+	close(out_fds[1]);
+	*pipe_out = out_fds[0];
+    }
+
+    if (pipe_in) {
+	close(in_fds[0]);
+	*pipe_in = in_fds[1];
+    }
+
+    if (pipe_err) {
+	close(err_fds[1]);
+	*pipe_err = err_fds[0];
+    }
+#endif /* WIN32 */
+
+    return pid;
+}
+
+
+API_EXPORT(int) ap_spawn_child(pool *p, int (*func) (void *, child_info *),
+			       void *data, enum kill_conditions kill_how,
+			       FILE **pipe_in, FILE **pipe_out,
+			       FILE **pipe_err)
+{
+    int fd_in, fd_out, fd_err;
+    pid_t pid;
+    int save_errno;
+
+    ap_block_alarms();
+
+    pid = spawn_child_core(p, func, data, kill_how,
+			   pipe_in ? &fd_in : NULL,
+			   pipe_out ? &fd_out : NULL,
+			   pipe_err ? &fd_err : NULL);
+
+    if (pid == 0) {
+	save_errno = errno;
+	ap_unblock_alarms();
+	errno = save_errno;
+	return 0;
+    }
+
+    if (pipe_out) {
+	*pipe_out = ap_fdopen(fd_out, "r" BINMODE);
+	if (*pipe_out)
+	    ap_note_cleanups_for_file(p, *pipe_out);
+	else
+	    close(fd_out);
+    }
+
+    if (pipe_in) {
+	*pipe_in = ap_fdopen(fd_in, "w" BINMODE);
+	if (*pipe_in)
+	    ap_note_cleanups_for_file(p, *pipe_in);
+	else
+	    close(fd_in);
+    }
+
+    if (pipe_err) {
+	*pipe_err = ap_fdopen(fd_err, "r" BINMODE);
+	if (*pipe_err)
+	    ap_note_cleanups_for_file(p, *pipe_err);
+	else
+	    close(fd_err);
+    }
+
+    ap_unblock_alarms();
+    return pid;
+}
+
+API_EXPORT(int) ap_bspawn_child(pool *p, int (*func) (void *, child_info *), void *data,
+				enum kill_conditions kill_how,
+				BUFF **pipe_in, BUFF **pipe_out, BUFF **pipe_err)
+{
+#ifdef WIN32
+    SECURITY_ATTRIBUTES sa = {0};  
+    HANDLE hPipeOutputRead  = NULL;
+    HANDLE hPipeOutputWrite = NULL;
+    HANDLE hPipeInputRead   = NULL;
+    HANDLE hPipeInputWrite  = NULL;
+    HANDLE hPipeErrorRead   = NULL;
+    HANDLE hPipeErrorWrite  = NULL;
+    HANDLE hPipeInputWriteDup = NULL;
+    HANDLE hPipeOutputReadDup = NULL;
+    HANDLE hPipeErrorReadDup  = NULL;
+    HANDLE hCurrentProcess;
+    pid_t pid = 0;
+    child_info info;
+
+
+    ap_block_alarms();
+
+    /*
+     *  First thing to do is to create the pipes that we will use for stdin, stdout, and
+     *  stderr in the child process.
+     */      
+    sa.nLength = sizeof(sa);
+    sa.bInheritHandle = TRUE;
+    sa.lpSecurityDescriptor = NULL;
+
+
+    /* Create pipes for standard input/output/error redirection. */
+    if (pipe_in && !CreatePipe(&hPipeInputRead, &hPipeInputWrite, &sa, 0))
+	return 0;
+
+    if (pipe_out && !CreatePipe(&hPipeOutputRead, &hPipeOutputWrite, &sa, 0)) {
+	if(pipe_in) {
+	    CloseHandle(hPipeInputRead);
+	    CloseHandle(hPipeInputWrite);
+	}
+	return 0;
+    }
+
+    if (pipe_err && !CreatePipe(&hPipeErrorRead, &hPipeErrorWrite, &sa, 0)) {
+	if(pipe_in) {
+	    CloseHandle(hPipeInputRead);
+	    CloseHandle(hPipeInputWrite);
+	}
+	if(pipe_out) {
+	    CloseHandle(hPipeOutputRead);
+	    CloseHandle(hPipeOutputWrite);
+	}
+	return 0;
+    }
+    /*
+     * When the pipe handles are created, the security descriptor
+     * indicates that the handle can be inherited.  However, we do not
+     * want the server side handles to the pipe to be inherited by the
+     * child CGI process. If the child CGI does inherit the server
+     * side handles, then the child may be left around if the server
+     * closes its handles (e.g. if the http connection is aborted),
+     * because the child will have a valid copy of handles to both
+     * sides of the pipes, and no I/O error will occur.  Microsoft
+     * recommends using DuplicateHandle to turn off the inherit bit
+     * under NT and Win95.
+     */
+    hCurrentProcess = GetCurrentProcess();
+    if ((pipe_in && !DuplicateHandle(hCurrentProcess, hPipeInputWrite,
+				     hCurrentProcess,
+				     &hPipeInputWriteDup, 0, FALSE,
+				     DUPLICATE_SAME_ACCESS))
+	|| (pipe_out && !DuplicateHandle(hCurrentProcess, hPipeOutputRead,
+					 hCurrentProcess, &hPipeOutputReadDup,
+					 0, FALSE, DUPLICATE_SAME_ACCESS))
+	|| (pipe_err && !DuplicateHandle(hCurrentProcess, hPipeErrorRead,
+					 hCurrentProcess, &hPipeErrorReadDup,
+					 0, FALSE, DUPLICATE_SAME_ACCESS))) {
+	if (pipe_in) {
+	    CloseHandle(hPipeInputRead);
+	    CloseHandle(hPipeInputWrite);
+	}
+	if (pipe_out) {
+	    CloseHandle(hPipeOutputRead);
+	    CloseHandle(hPipeOutputWrite);
+	}
+	if (pipe_err) {
+	    CloseHandle(hPipeErrorRead);
+	    CloseHandle(hPipeErrorWrite);
+	}
+	return 0;
+    }
+    else {
+	if (pipe_in) {
+	    CloseHandle(hPipeInputWrite);
+	    hPipeInputWrite = hPipeInputWriteDup;
+	}
+	if (pipe_out) {
+	    CloseHandle(hPipeOutputRead);
+	    hPipeOutputRead = hPipeOutputReadDup;
+	}
+	if (pipe_err) {
+	    CloseHandle(hPipeErrorRead);
+	    hPipeErrorRead = hPipeErrorReadDup;
+	}
+    }
+
+    /* The script writes stdout to this pipe handle */
+    info.hPipeOutputWrite = hPipeOutputWrite;  
+
+    /* The script reads stdin from this pipe handle */
+    info.hPipeInputRead = hPipeInputRead;
+
+    /* The script writes stderr to this pipe handle */
+    info.hPipeErrorWrite = hPipeErrorWrite;    
+     
+    /*
+     *  Try to launch the CGI.  Under the covers, this call 
+     *  will try to pick up the appropriate interpreter if 
+     *  one is needed.
+     */
+    pid = func(data, &info);
+    if (pid == -1) {
+        /* Things didn't work, so cleanup */
+        pid = 0;   /* map Win32 error code onto Unix default */
+        CloseHandle(hPipeOutputRead);
+        CloseHandle(hPipeInputWrite);
+        CloseHandle(hPipeErrorRead);
+    }
+    else {
+        if (pipe_out) {
+            /*
+             *  This pipe represents stdout for the script, 
+             *  so we read from this pipe.
+             */
+	    /* Create a read buffer */
+            *pipe_out = ap_bcreate(p, B_RD);
+
+	    /* Setup the cleanup routine for the handle */
+            ap_note_cleanups_for_h_ex(p, hPipeOutputRead, 1);   
+
+	    /* Associate the handle with the new buffer */
+            ap_bpushh(*pipe_out, hPipeOutputRead);
+        }
+        
+        if (pipe_in) {
+            /*
+             *  This pipe represents stdin for the script, so we 
+             *  write to this pipe.
+             */
+	    /* Create a write buffer */
+            *pipe_in = ap_bcreate(p, B_WR);             
+
+	    /* Setup the cleanup routine for the handle */
+            ap_note_cleanups_for_h_ex(p, hPipeInputWrite, 1);
+
+	    /* Associate the handle with the new buffer */
+            ap_bpushh(*pipe_in, hPipeInputWrite);
+
+        }
+      
+        if (pipe_err) {
+            /*
+             *  This pipe represents stderr for the script, so 
+             *  we read from this pipe.
+             */
+	    /* Create a read buffer */
+            *pipe_err = ap_bcreate(p, B_RD);
+
+	    /* Setup the cleanup routine for the handle */
+            ap_note_cleanups_for_h_ex(p, hPipeErrorRead, 1);
+
+	    /* Associate the handle with the new buffer */
+            ap_bpushh(*pipe_err, hPipeErrorRead);
+        }
+    }  
+
+
+    /*
+     * Now that handles have been inherited, close them to be safe.
+     * You don't want to read or write to them accidentally, and we
+     * sure don't want to have a handle leak.
+     */
+    CloseHandle(hPipeOutputWrite);
+    CloseHandle(hPipeInputRead);
+    CloseHandle(hPipeErrorWrite);
+
+#else
+    int fd_in, fd_out, fd_err;
+    pid_t pid;
+    int save_errno;
+
+    ap_block_alarms();
+
+    pid = spawn_child_core(p, func, data, kill_how,
+			   pipe_in ? &fd_in : NULL,
+			   pipe_out ? &fd_out : NULL,
+			   pipe_err ? &fd_err : NULL);
+
+    if (pid == 0) {
+	save_errno = errno;
+	ap_unblock_alarms();
+	errno = save_errno;
+	return 0;
+    }
+
+    if (pipe_out) {
+	*pipe_out = ap_bcreate(p, B_RD);
+	ap_note_cleanups_for_fd_ex(p, fd_out, 0);
+	ap_bpushfd(*pipe_out, fd_out, fd_out);
+    }
+
+    if (pipe_in) {
+	*pipe_in = ap_bcreate(p, B_WR);
+	ap_note_cleanups_for_fd_ex(p, fd_in, 0);
+	ap_bpushfd(*pipe_in, fd_in, fd_in);
+    }
+
+    if (pipe_err) {
+	*pipe_err = ap_bcreate(p, B_RD);
+	ap_note_cleanups_for_fd_ex(p, fd_err, 0);
+	ap_bpushfd(*pipe_err, fd_err, fd_err);
+    }
+#endif
+
+    ap_unblock_alarms();
+    return pid;
+}
+
+
+/* 
+ * Timing constants for killing subprocesses
+ * There is a total 3-second delay between sending a SIGINT 
+ * and sending of the final SIGKILL.
+ * TIMEOUT_INTERVAL should be set to TIMEOUT_USECS / 64
+ * for the exponential timeout algorithm.
+ */
+#define TIMEOUT_USECS    3000000
+#define TIMEOUT_INTERVAL   46875
+
+static void free_proc_chain(struct process_chain *procs)
+{
+    /* Dispose of the subprocesses we've spawned off in the course of
+     * whatever it was we're cleaning up now.  This may involve killing
+     * some of them off...
+     */
+    struct process_chain *p;
+    int need_timeout = 0;
+    int status;
+#if !defined(WIN32) && !defined(NETWARE)
+    int timeout_interval;
+    struct timeval tv;
+#endif
+
+    if (procs == NULL)
+	return;			/* No work.  Whew! */
+
+    /* First, check to see if we need to do the SIGTERM, sleep, SIGKILL
+     * dance with any of the processes we're cleaning up.  If we've got
+     * any kill-on-sight subprocesses, ditch them now as well, so they
+     * don't waste any more cycles doing whatever it is that they shouldn't
+     * be doing anymore.
+     */
+#ifdef WIN32
+    /* Pick up all defunct processes */
+    for (p = procs; p; p = p->next) {
+	if (GetExitCodeProcess((HANDLE) p->pid, &status)) {
+	    p->kill_how = kill_never;
+	}
+    }
+
+
+    for (p = procs; p; p = p->next) {
+	if (p->kill_how == kill_after_timeout) {
+	    need_timeout = 1;
+	}
+	else if (p->kill_how == kill_always) {
+	    TerminateProcess((HANDLE) p->pid, 1);
+	}
+    }
+    /* Sleep only if we have to... */
+
+    if (need_timeout)
+	sleep(3);
+
+    /* OK, the scripts we just timed out for have had a chance to clean up
+     * --- now, just get rid of them, and also clean up the system accounting
+     * goop...
+     */
+
+    for (p = procs; p; p = p->next) {
+	if (p->kill_how == kill_after_timeout)
+	    TerminateProcess((HANDLE) p->pid, 1);
+    }
+
+    for (p = procs; p; p = p->next) {
+	CloseHandle((HANDLE) p->pid);
+    }
+#elif defined(NETWARE)
+#else
+#ifndef NEED_WAITPID
+    /* Pick up all defunct processes */
+    for (p = procs; p; p = p->next) {
+	if (waitpid(p->pid, (int *) 0, WNOHANG) > 0) {
+	    p->kill_how = kill_never;
+	}
+    }
+#endif
+
+    for (p = procs; p; p = p->next) {
+	if ((p->kill_how == kill_after_timeout)
+	    || (p->kill_how == kill_only_once)) {
+	    /*
+	     * This is totally bogus, but seems to be the
+	     * only portable (as in reliable) way to accomplish
+	     * this. Note that this implies an unavoidable
+	     * delay.
+	     */
+	    ap_os_kill(p->pid, SIGTERM);
+	    need_timeout = 1;
+	}
+	else if (p->kill_how == kill_always) {
+	    kill(p->pid, SIGKILL);
+	}
+    }
+
+    /* Sleep only if we have to. The sleep algorithm grows
+     * by a factor of two on each iteration. TIMEOUT_INTERVAL
+     * is equal to TIMEOUT_USECS / 64.
+     */
+    if (need_timeout) {
+        timeout_interval = TIMEOUT_INTERVAL;
+        tv.tv_sec = 0;
+        tv.tv_usec = timeout_interval;
+        ap_select(0, NULL, NULL, NULL, &tv);
+
+        do {
+            need_timeout = 0;
+            for (p = procs; p; p = p->next) {
+                if (p->kill_how == kill_after_timeout) {
+                    if (waitpid(p->pid, (int *) 0, WNOHANG | WUNTRACED) > 0)
+                        p->kill_how = kill_never;
+                    else
+                        need_timeout = 1;
+                }
+            }
+            if (need_timeout) {
+                if (timeout_interval >= TIMEOUT_USECS) {
+                    break;
+                }
+                tv.tv_sec = timeout_interval / 1000000;
+                tv.tv_usec = timeout_interval % 1000000;
+                ap_select(0, NULL, NULL, NULL, &tv);
+                timeout_interval *= 2;
+            }
+        } while (need_timeout);
+    }
+
+    /* OK, the scripts we just timed out for have had a chance to clean up
+     * --- now, just get rid of them, and also clean up the system accounting
+     * goop...
+     */
+
+    for (p = procs; p; p = p->next) {
+	if (p->kill_how == kill_after_timeout)
+	    kill(p->pid, SIGKILL);
+
+	if (p->kill_how != kill_never)
+	    waitpid(p->pid, &status, 0);
+    }
+#endif /* !WIN32 && !NETWARE*/
+}
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/main/buff.c apache_1.3.33/src/main/buff.c
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/main/buff.c	Mon Feb 16 23:29:32 2004
+++ apache_1.3.33/src/main/buff.c	Mon Jul 18 15:22:25 2005
@@ -250,6 +250,9 @@
     }
     else
 #endif
+#ifdef EAPI
+	if (!ap_hook_call("ap::buff::read", &rv, fb, buf, nbyte))
+#endif /* EAPI */
 	rv = read(fb->fd_in, buf, nbyte);
     
     return rv;
@@ -261,6 +264,9 @@
 
 #if defined (WIN32) || defined(NETWARE) || defined(CYGWIN_WINSOCK) 
     if (fb->flags & B_SOCKET) {
+#ifdef EAPI
+	if (!ap_hook_call("ap::buff::recvwithtimeout", &rv, fb, buf, nbyte))
+#endif /* EAPI */
 	rv = ap_recvwithtimeout(fb->fd_in, buf, nbyte, 0);
 	if (rv == SOCKET_ERROR)
 	    errno = WSAGetLastError();
@@ -308,6 +314,9 @@
     }
     else
 #endif
+#ifdef EAPI
+	if (!ap_hook_call("ap::buff::write", &rv, fb, buf, nbyte))
+#endif /* EAPI */
 #if defined (B_SFIO)
 	rv = sfwrite(fb->sf_out, buf, nbyte);
 #else
@@ -338,6 +347,9 @@
    
 #if defined(WIN32) || defined(NETWARE)
     if (fb->flags & B_SOCKET) {
+#ifdef EAPI
+	if (!ap_hook_call("ap::buff::sendwithtimeout", &rv, fb, buf, nbyte))
+#endif /* EAPI */
 	rv = ap_sendwithtimeout(fb->fd, buf, nbyte, 0);
 	if (rv == SOCKET_ERROR)
 	    errno = WSAGetLastError();
@@ -421,6 +433,10 @@
     fb->callback_data = NULL;
     fb->filter_callback = NULL;
 
+#ifdef EAPI
+    fb->ctx = ap_ctx_new(p);
+#endif /* EAPI */
+
     return fb;
 }
 
@@ -1073,6 +1089,9 @@
     i = 0;
     while (i < nvec) {
 	do
+#ifdef EAPI
+	    if (!ap_hook_call("ap::buff::writev", &rv, fb, &vec[i], nvec -i))
+#endif /* EAPI */
 	    rv = writev(fb->fd, &vec[i], nvec - i);
 	while (rv == -1 && (errno == EINTR || errno == EAGAIN)
 	       && !(fb->flags & B_EOUT));
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/main/http_config.c apache_1.3.33/src/main/http_config.c
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/main/http_config.c	Mon May 10 21:30:43 2004
+++ apache_1.3.33/src/main/http_config.c	Mon Jul 18 15:22:25 2005
@@ -557,6 +557,20 @@
 	m->name = tmp;
     }
 #endif /*_OSD_POSIX*/
+
+#ifdef EAPI
+    /*
+     * Invoke the `add_module' hook inside the now existing set
+     * of modules to let them all now that this module was added.
+     */
+    {
+        module *m2;
+        for (m2 = top_module; m2 != NULL; m2 = m2->next)
+            if (m2->magic == MODULE_MAGIC_COOKIE_EAPI)
+                if (m2->add_module != NULL)
+                    (*m2->add_module)(m);
+    }
+#endif /* EAPI */
 }
 
 /* 
@@ -571,6 +585,21 @@
 {
     module *modp;
 
+#ifdef EAPI
+    /*
+     * Invoke the `remove_module' hook inside the now existing
+     * set of modules to let them all now that this module is
+     * beeing removed.
+     */
+    {
+        module *m2;
+        for (m2 = top_module; m2 != NULL; m2 = m2->next)
+            if (m2->magic == MODULE_MAGIC_COOKIE_EAPI)
+                if (m2->remove_module != NULL)
+                    (*m2->remove_module)(m);
+    }
+#endif /* EAPI */
+
     modp = top_module;
     if (modp == m) {
 	/* We are the top module, special case */
@@ -964,6 +993,27 @@
     const command_rec *cmd;
     module *mod = top_module;
 
+#ifdef EAPI
+    /*
+     * Invoke the `rewrite_command' of modules to allow
+     * they to rewrite the directive line before we
+     * process it.
+     */
+    {
+        module *m;
+        char *cp;
+        for (m = top_module; m != NULL; m = m->next) {
+            if (m->magic == MODULE_MAGIC_COOKIE_EAPI) {
+                if (m->rewrite_command != NULL) {
+                    cp = (m->rewrite_command)(parms, config, l);
+                    if (cp != NULL)
+                        l = cp;
+                }
+            }
+        }
+    }
+#endif /* EAPI */
+
     if ((l[0] == '#') || (!l[0]))
 	return NULL;
 
@@ -1164,6 +1214,31 @@
     return strcmp(f1->fname,f2->fname);
 }
 
+static int fname_valid(const char *fname) {
+    const char *c = fname;
+    char bad_dpkg[] = "*.dpkg*";
+
+    if (!isalnum(*c)) {
+        return 0;
+    }
+    ++c;
+    
+    
+    while (*c) {
+        if (!isalnum(*c) && *c!='_' && *c!='-' && *c!='.') {
+            return 0;
+        }
+        ++c;
+    }
+
+    if (!ap_fnmatch(bad_dpkg, fname, 0)) {
+        return 0;
+    }
+
+    return 1;
+}
+        
+
 CORE_EXPORT(void) ap_process_resource_config(server_rec *s, char *fname, pool *p, pool *ptemp)
 {
     const char *errmsg;
@@ -1227,7 +1302,7 @@
 	 * entries here and store 'em away. Recall we need full pathnames
 	 * for this.
 	 */
-	fprintf(stderr, "Processing config directory: %s\n", fname);
+	/* fprintf(stderr, "Processing config directory: %s\n", fname); */
 #ifdef NETWARE
 	dirp = ap_popendir(p, fname);
 #else
@@ -1249,7 +1324,8 @@
 	    if (strcmp(dir_entry->d_name, ".") &&
 		strcmp(dir_entry->d_name, "..") &&
                 (!ispatt ||
-                 !ap_fnmatch(pattern,dir_entry->d_name, FNM_PERIOD)) ) {
+                 !ap_fnmatch(pattern,dir_entry->d_name, FNM_PERIOD))
+                 && fname_valid(dir_entry->d_name)) {
 		fnew = (fnames *) ap_push_array(candidates);
 		fnew->fname = ap_make_full_path(p, path, dir_entry->d_name);
 	    }
@@ -1264,7 +1340,7 @@
 	     */
 	    for (current = 0; current < candidates->nelts; ++current) {
 	        fnew = &((fnames *) candidates->elts)[current];
-		fprintf(stderr, " Processing config file: %s\n", fnew->fname);
+		/* fprintf(stderr, " Processing config file: %s\n", fnew->fname); */
 		ap_process_resource_config(s, fnew->fname, p, ptemp);
 	    }
 	}
@@ -1428,6 +1504,10 @@
     s->limit_req_fieldsize = main_server->limit_req_fieldsize;
     s->limit_req_fields = main_server->limit_req_fields;
 
+#ifdef EAPI
+    s->ctx = ap_ctx_new(p);
+#endif /* EAPI */
+
     *ps = s;
 
     return ap_parse_vhost_addrs(p, hostname, s);
@@ -1538,6 +1618,10 @@
 
     s->module_config = create_server_config(p, s);
     s->lookup_defaults = create_default_per_dir_config(p);
+
+#ifdef EAPI
+    s->ctx = ap_ctx_new(p);
+#endif /* EAPI */
 
     return s;
 }
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/main/http_config.c.orig apache_1.3.33/src/main/http_config.c.orig
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/main/http_config.c.orig	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/main/http_config.c.orig	Mon Jul 18 15:22:19 2005
@@ -0,0 +1,1770 @@
+/* Copyright 1999-2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * http_config.c: once was auxillary functions for reading httpd's config
+ * file and converting filenames into a namespace
+ *
+ * Rob McCool 
+ * 
+ * Wall-to-wall rewrite for Apache... commands which are part of the
+ * server core can now be found next door in "http_core.c".  Now contains
+ * general command loop, and functions which do bookkeeping for the new
+ * Apache config stuff (modules and configuration vectors).
+ *
+ * rst
+ *
+ */
+
+#define CORE_PRIVATE
+
+#include "httpd.h"
+#include "http_config.h"
+#include "http_core.h"
+#include "http_log.h"		/* for errors in parse_htaccess */
+#include "http_request.h"	/* for default_handler (see invoke_handler) */
+#include "http_conf_globals.h"	/* Sigh... */
+#include "http_vhost.h"
+#include "explain.h"
+#include "fnmatch.h"
+
+DEF_Explain
+
+/****************************************************************
+ *
+ * We begin with the functions which deal with the linked list
+ * of modules which control just about all of the server operation.
+ */
+
+/* total_modules is the number of modules that have been linked
+ * into the server.
+ */
+static int total_modules = 0;
+/* dynamic_modules is the number of modules that have been added
+ * after the pre-loaded ones have been set up. It shouldn't be larger
+ * than DYNAMIC_MODULE_LIMIT.
+ */
+static int dynamic_modules = 0;
+API_VAR_EXPORT module *top_module = NULL;
+API_VAR_EXPORT module **ap_loaded_modules=NULL;
+
+typedef int (*handler_func) (request_rec *);
+typedef void *(*dir_maker_func) (pool *, char *);
+typedef void *(*merger_func) (pool *, void *, void *);
+
+/* Dealing with config vectors.  These are associated with per-directory,
+ * per-server, and per-request configuration, and have a void* pointer for
+ * each modules.  The nature of the structure pointed to is private to the
+ * module in question... the core doesn't (and can't) know.  However, there
+ * are defined interfaces which allow it to create instances of its private
+ * per-directory and per-server structures, and to merge the per-directory
+ * structures of a directory and its subdirectory (producing a new one in
+ * which the defaults applying to the base directory have been properly
+ * overridden).
+ */
+
+#ifndef ap_get_module_config
+API_EXPORT(void *) ap_get_module_config(void *conf_vector, module *m)
+{
+    void **confv = (void **) conf_vector;
+    return confv[m->module_index];
+}
+#endif
+
+#ifndef ap_set_module_config
+API_EXPORT(void) ap_set_module_config(void *conf_vector, module *m, void *val)
+{
+    void **confv = (void **) conf_vector;
+    confv[m->module_index] = val;
+}
+#endif
+
+static void *create_empty_config(pool *p)
+{
+    void **conf_vector = (void **) ap_pcalloc(p, sizeof(void *) *
+				    (total_modules + DYNAMIC_MODULE_LIMIT));
+    return (void *) conf_vector;
+}
+
+static void *create_default_per_dir_config(pool *p)
+{
+    void **conf_vector = (void **) ap_pcalloc(p, sizeof(void *) * (total_modules + DYNAMIC_MODULE_LIMIT));
+    module *modp;
+
+    for (modp = top_module; modp; modp = modp->next) {
+	dir_maker_func df = modp->create_dir_config;
+
+	if (df)
+	    conf_vector[modp->module_index] = (*df) (p, NULL);
+    }
+
+    return (void *) conf_vector;
+}
+
+CORE_EXPORT(void *)
+     ap_merge_per_dir_configs(pool *p, void *base, void *new)
+{
+    void **conf_vector = (void **) ap_palloc(p, sizeof(void *) * total_modules);
+    void **base_vector = (void **) base;
+    void **new_vector = (void **) new;
+    module *modp;
+
+    for (modp = top_module; modp; modp = modp->next) {
+	merger_func df = modp->merge_dir_config;
+	int i = modp->module_index;
+
+	if (df && new_vector[i])
+	    conf_vector[i] = (*df) (p, base_vector[i], new_vector[i]);
+	else
+	    conf_vector[i] = new_vector[i] ? new_vector[i] : base_vector[i];
+    }
+
+    return (void *) conf_vector;
+}
+
+static void *create_server_config(pool *p, server_rec *s)
+{
+    void **conf_vector = (void **) ap_pcalloc(p, sizeof(void *) * (total_modules + DYNAMIC_MODULE_LIMIT));
+    module *modp;
+
+    for (modp = top_module; modp; modp = modp->next) {
+	if (modp->create_server_config)
+	    conf_vector[modp->module_index] = (*modp->create_server_config) (p, s);
+    }
+
+    return (void *) conf_vector;
+}
+
+static void merge_server_configs(pool *p, void *base, void *virt)
+{
+    /* Can reuse the 'virt' vector for the spine of it, since we don't
+     * have to deal with the moral equivalent of .htaccess files here...
+     */
+
+    void **base_vector = (void **) base;
+    void **virt_vector = (void **) virt;
+    module *modp;
+
+    for (modp = top_module; modp; modp = modp->next) {
+	merger_func df = modp->merge_server_config;
+	int i = modp->module_index;
+
+	if (!virt_vector[i])
+	    virt_vector[i] = base_vector[i];
+	else if (df)
+	    virt_vector[i] = (*df) (p, base_vector[i], virt_vector[i]);
+    }
+}
+
+CORE_EXPORT(void *) ap_create_request_config(pool *p)
+{
+    return create_empty_config(p);
+}
+
+CORE_EXPORT(void *) ap_create_per_dir_config(pool *p)
+{
+    return create_empty_config(p);
+}
+
+#ifdef EXPLAIN
+
+struct {
+    int offset;
+    char *method;
+} aMethods[] =
+
+{
+#define m(meth)	{ XtOffsetOf(module,meth),#meth }
+    m(translate_handler),
+    m(ap_check_user_id),
+    m(auth_checker),
+    m(type_checker),
+    m(fixer_upper),
+    m(logger),
+    { -1, "?" },
+#undef m
+};
+
+char *ShowMethod(module *modp, int offset)
+{
+    int n;
+    static char buf[200];
+
+    for (n = 0; aMethods[n].offset >= 0; ++n)
+	if (aMethods[n].offset == offset)
+	    break;
+    ap_snprintf(buf, sizeof(buf), "%s:%s", modp->name, aMethods[n].method);
+    return buf;
+}
+#else
+#define ShowMethod(modp,offset)
+#endif
+
+/****************************************************************
+ *
+ * Dispatch through the modules to find handlers for various phases
+ * of request handling.  These are invoked by http_request.c to actually
+ * do the dirty work of slogging through the module structures.
+ */
+
+/*
+ * Optimized run_method routines.  The observation here is that many modules
+ * have NULL for most of the methods.  So we build optimized lists of
+ * everything.  If you think about it, this is really just like a sparse array
+ * implementation to avoid scanning the zero entries.
+ */
+static const int method_offsets[] =
+{
+    XtOffsetOf(module, translate_handler),
+    XtOffsetOf(module, ap_check_user_id),
+    XtOffsetOf(module, auth_checker),
+    XtOffsetOf(module, access_checker),
+    XtOffsetOf(module, type_checker),
+    XtOffsetOf(module, fixer_upper),
+    XtOffsetOf(module, logger),
+    XtOffsetOf(module, header_parser),
+    XtOffsetOf(module, post_read_request)
+};
+#define NMETHODS	(sizeof (method_offsets)/sizeof (method_offsets[0]))
+
+static struct {
+    int translate_handler;
+    int ap_check_user_id;
+    int auth_checker;
+    int access_checker;
+    int type_checker;
+    int fixer_upper;
+    int logger;
+    int header_parser;
+    int post_read_request;
+} offsets_into_method_ptrs;
+
+/*
+ * This is just one big array of method_ptrs.  It's constructed such that,
+ * for example, method_ptrs[ offsets_into_method_ptrs.logger ] is the first
+ * logger function.  You go one-by-one from there until you hit a NULL.
+ * This structure was designed to hopefully maximize cache-coolness.
+ */
+static handler_func *method_ptrs;
+
+
+void ap_cleanup_method_ptrs()
+{
+    if (method_ptrs) {
+        free(method_ptrs);
+    }
+}
+
+/* routine to reconstruct all these shortcuts... called after every
+ * add_module.
+ * XXX: this breaks if modules dink with their methods pointers
+ */
+static void build_method_shortcuts(void)
+{
+    module *modp;
+    int how_many_ptrs;
+    int i;
+    int next_ptr;
+    handler_func fp;
+
+    if (method_ptrs) {
+	/* free up any previous set of method_ptrs */
+	free(method_ptrs);
+    }
+
+    /* first we count how many functions we have */
+    how_many_ptrs = 0;
+    for (modp = top_module; modp; modp = modp->next) {
+	for (i = 0; i < NMETHODS; ++i) {
+	    if (*(handler_func *) (method_offsets[i] + (char *) modp)) {
+		++how_many_ptrs;
+	    }
+	}
+    }
+    method_ptrs = malloc((how_many_ptrs + NMETHODS) * sizeof(handler_func));
+    if (method_ptrs == NULL) {
+	fprintf(stderr, "Ouch!  Out of memory in build_method_shortcuts()!\n");
+    }
+    next_ptr = 0;
+    for (i = 0; i < NMETHODS; ++i) {
+	/* XXX: This is an itsy bit presumptuous about the alignment
+	 * constraints on offsets_into_method_ptrs.  I can't remember if
+	 * ANSI says this has to be true... -djg */
+	((int *) &offsets_into_method_ptrs)[i] = next_ptr;
+	for (modp = top_module; modp; modp = modp->next) {
+	    fp = *(handler_func *) (method_offsets[i] + (char *) modp);
+	    if (fp) {
+		method_ptrs[next_ptr++] = fp;
+	    }
+	}
+	method_ptrs[next_ptr++] = NULL;
+    }
+}
+
+
+static int run_method(request_rec *r, int offset, int run_all)
+{
+    int i;
+
+    for (i = offset; method_ptrs[i]; ++i) {
+	handler_func mod_handler = method_ptrs[i];
+
+	if (mod_handler) {
+	    int result;
+
+	    result = (*mod_handler) (r);
+
+	    if (result != DECLINED && (!run_all || result != OK))
+		return result;
+	}
+    }
+
+    return run_all ? OK : DECLINED;
+}
+
+API_EXPORT(int) ap_translate_name(request_rec *r)
+{
+    return run_method(r, offsets_into_method_ptrs.translate_handler, 0);
+}
+
+API_EXPORT(int) ap_check_access(request_rec *r)
+{
+    return run_method(r, offsets_into_method_ptrs.access_checker, 1);
+}
+
+API_EXPORT(int) ap_find_types(request_rec *r)
+{
+    return run_method(r, offsets_into_method_ptrs.type_checker, 0);
+}
+
+API_EXPORT(int) ap_run_fixups(request_rec *r)
+{
+    return run_method(r, offsets_into_method_ptrs.fixer_upper, 1);
+}
+
+API_EXPORT(int) ap_log_transaction(request_rec *r)
+{
+    return run_method(r, offsets_into_method_ptrs.logger, 1);
+}
+
+API_EXPORT(int) ap_header_parse(request_rec *r)
+{
+    return run_method(r, offsets_into_method_ptrs.header_parser, 1);
+}
+
+API_EXPORT(int) ap_run_post_read_request(request_rec *r)
+{
+    return run_method(r, offsets_into_method_ptrs.post_read_request, 1);
+}
+
+/* Auth stuff --- anything that defines one of these will presumably
+ * want to define something for the other.  Note that check_auth is
+ * separate from check_access to make catching some config errors easier.
+ */
+
+API_EXPORT(int) ap_check_user_id(request_rec *r)
+{
+    return run_method(r, offsets_into_method_ptrs.ap_check_user_id, 0);
+}
+
+API_EXPORT(int) ap_check_auth(request_rec *r)
+{
+    return run_method(r, offsets_into_method_ptrs.auth_checker, 0);
+}
+
+/*
+ * For speed/efficiency we generate a compact list of all the handlers
+ * and wildcard handlers.  This means we won't have to scan the entire
+ * module list looking for handlers... where we'll find a whole whack
+ * of NULLs.
+ */
+typedef struct {
+    handler_rec hr;
+    size_t len;
+} fast_handler_rec;
+
+static fast_handler_rec *handlers;
+static fast_handler_rec *wildhandlers;
+
+static void init_handlers(pool *p)
+{
+    module *modp;
+    int nhandlers = 0;
+    int nwildhandlers = 0;
+    const handler_rec *handp;
+    fast_handler_rec *ph, *pw;
+    char *starp;
+
+    for (modp = top_module; modp; modp = modp->next) {
+	if (!modp->handlers)
+	    continue;
+	for (handp = modp->handlers; handp->content_type; ++handp) {
+	    if (strchr(handp->content_type, '*')) {
+                nwildhandlers ++;
+            } else {
+                nhandlers ++;
+            }
+        }
+    }
+    ph = handlers = ap_palloc(p, sizeof(*ph)*(nhandlers + 1));
+    pw = wildhandlers = ap_palloc(p, sizeof(*pw)*(nwildhandlers + 1));
+    for (modp = top_module; modp; modp = modp->next) {
+	if (!modp->handlers)
+	    continue;
+	for (handp = modp->handlers; handp->content_type; ++handp) {
+	    if ((starp = strchr(handp->content_type, '*'))) {
+                pw->hr.content_type = handp->content_type;
+                pw->hr.handler = handp->handler;
+		pw->len = starp - handp->content_type;
+                pw ++;
+            } else {
+                ph->hr.content_type = handp->content_type;
+                ph->hr.handler = handp->handler;
+		ph->len = strlen(handp->content_type);
+                ph ++;
+            }
+        }
+    }
+    pw->hr.content_type = NULL;
+    pw->hr.handler = NULL;
+    ph->hr.content_type = NULL;
+    ph->hr.handler = NULL;
+}
+
+API_EXPORT(int) ap_invoke_handler(request_rec *r)
+{
+    fast_handler_rec *handp;
+    const char *handler;
+    char *p;
+    size_t handler_len;
+    int result = HTTP_INTERNAL_SERVER_ERROR;
+
+    if (r->handler) {
+	handler = r->handler;
+	handler_len = strlen(handler);
+    }
+    else {
+	handler = r->content_type ? r->content_type : ap_default_type(r);
+	if ((p = strchr(handler, ';')) != NULL) { /* MIME type arguments */
+	    while (p > handler && p[-1] == ' ')
+		--p;		/* strip trailing spaces */
+	    handler_len = p - handler;
+	}
+	else {
+	    handler_len = strlen(handler);
+	}
+    }
+
+    /* Pass one --- direct matches */
+
+    for (handp = handlers; handp->hr.content_type; ++handp) {
+	if (handler_len == handp->len
+	    && !strncmp(handler, handp->hr.content_type, handler_len)) {
+            result = (*handp->hr.handler) (r);
+
+            if (result != DECLINED)
+                return result;
+        }
+    }
+
+    /* Pass two --- wildcard matches */
+
+    for (handp = wildhandlers; handp->hr.content_type; ++handp) {
+	if (handler_len >= handp->len
+	    && !strncmp(handler, handp->hr.content_type, handp->len)) {
+             result = (*handp->hr.handler) (r);
+
+             if (result != DECLINED)
+                 return result;
+         }
+    }
+
+    if (result == HTTP_INTERNAL_SERVER_ERROR && r->handler && r->filename) {
+        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, r,
+            "handler \"%s\" not found for: %s", r->handler, r->filename);
+    }
+    return HTTP_INTERNAL_SERVER_ERROR;
+}
+
+/* One-time setup for precompiled modules --- NOT to be done on restart */
+
+API_EXPORT(void) ap_add_module(module *m)
+{
+    /* This could be called from an AddModule httpd.conf command,
+     * after the file has been linked and the module structure within it
+     * teased out...
+     */
+
+    if (m->version != MODULE_MAGIC_NUMBER_MAJOR) {
+	fprintf(stderr, "%s: module \"%s\" is not compatible with this "
+		"version of Apache.\n", ap_server_argv0, m->name);
+	fprintf(stderr, "Please contact the vendor for the correct version.\n");
+#ifdef NETWARE
+        clean_parent_exit(1);
+#else    
+	exit(1);
+#endif
+    }
+
+    if (m->next == NULL) {
+	m->next = top_module;
+	top_module = m;
+    }
+    if (m->module_index == -1) {
+	m->module_index = total_modules++;
+	dynamic_modules++;
+
+	if (dynamic_modules > DYNAMIC_MODULE_LIMIT) {
+	    fprintf(stderr, "%s: module \"%s\" could not be loaded, because"
+		    " the dynamic\n", ap_server_argv0, m->name);
+	    fprintf(stderr, "module limit was reached. Please increase "
+		    "DYNAMIC_MODULE_LIMIT and recompile.\n");
+#ifdef NETWARE
+            clean_parent_exit(1);
+#else
+	    exit(1);
+#endif
+	}
+    }
+
+    /* Some C compilers put a complete path into __FILE__, but we want
+     * only the filename (e.g. mod_includes.c). So check for path
+     * components (Unix and DOS), and remove them.
+     */
+
+    if (strrchr(m->name, '/'))
+	m->name = 1 + strrchr(m->name, '/');
+    if (strrchr(m->name, '\\'))
+	m->name = 1 + strrchr(m->name, '\\');
+
+#ifdef _OSD_POSIX /* __FILE__="*POSIX(/home/martin/apache/src/modules/standard/mod_info.c)" */
+    /* We cannot fix the string in-place, because it's const */
+    if (m->name[strlen(m->name)-1]==')') {
+	char *tmp = strdup(m->name);	/* FIXME:memory leak, albeit a small one */
+	tmp[strlen(tmp)-1] = '\0';
+	m->name = tmp;
+    }
+#endif /*_OSD_POSIX*/
+}
+
+/* 
+ * remove_module undoes what add_module did. There are some caveats:
+ * when the module is removed, its slot is lost so all the current
+ * per-dir and per-server configurations are invalid. So we should
+ * only ever call this function when you are invalidating almost
+ * all our current data. I.e. when doing a restart.
+ */
+
+API_EXPORT(void) ap_remove_module(module *m)
+{
+    module *modp;
+
+    modp = top_module;
+    if (modp == m) {
+	/* We are the top module, special case */
+	top_module = modp->next;
+	m->next = NULL;
+    }
+    else {
+	/* Not the top module, find use. When found modp will
+	 * point to the module _before_ us in the list
+	 */
+
+	while (modp && modp->next != m) {
+	    modp = modp->next;
+	}
+	if (!modp) {
+	    /* Uh-oh, this module doesn't exist */
+	    ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, NULL,
+		"Cannot remove module %s: not found in module list",
+		m->name);
+	    return;
+	}
+	/* Eliminate us from the module list */
+	modp->next = modp->next->next;
+    }
+
+    m->module_index = -1;	/* simulate being unloaded, should
+				 * be unnecessary */
+    dynamic_modules--;
+    total_modules--;
+}
+
+API_EXPORT(void) ap_add_loaded_module(module *mod)
+{
+    module **m;
+
+    /* 
+     *  Add module pointer to top of chained module list 
+     */
+    ap_add_module(mod);
+
+    /* 
+     *  And module pointer to list of loaded modules 
+     *
+     *  Notes: 1. ap_add_module() would already complain if no more space
+     *            exists for adding a dynamically loaded module
+     *         2. ap_add_module() accepts double-inclusion, so we have
+     *            to accept this, too.
+     */
+    for (m = ap_loaded_modules; *m != NULL; m++)
+        ;
+    *m++ = mod;
+    *m = NULL;
+}
+
+API_EXPORT(void) ap_remove_loaded_module(module *mod)
+{
+    module **m;
+    module **m2;
+    int done;
+
+    /* 
+     *  Remove module pointer from chained module list 
+     */
+    ap_remove_module(mod);
+
+    /* 
+     *  Remove module pointer from list of loaded modules
+     *
+     *  Note: 1. We cannot determine if the module was successfully
+     *           removed by ap_remove_module().
+     *        2. We have not to complain explicity when the module
+     *           is not found because ap_remove_module() did it
+     *           for us already.
+     */
+    for (m = m2 = ap_loaded_modules, done = 0; *m2 != NULL; m2++) {
+        if (*m2 == mod && done == 0)
+            done = 1;
+        else
+            *m++ = *m2;
+    }
+    *m = NULL;
+}
+
+API_EXPORT(void) ap_setup_prelinked_modules(void)
+{
+    module **m;
+    module **m2;
+
+    /*
+     *  Initialise total_modules variable and module indices
+     */
+    total_modules = 0;
+    for (m = ap_preloaded_modules; *m != NULL; m++)
+        (*m)->module_index = total_modules++;
+
+    /* 
+     *  Initialise list of loaded modules
+     */
+    ap_loaded_modules = (module **)malloc(
+        sizeof(module *)*(total_modules+DYNAMIC_MODULE_LIMIT+1));
+    if (ap_loaded_modules == NULL) {
+	fprintf(stderr, "Ouch!  Out of memory in ap_setup_prelinked_modules()!\n");
+#ifdef NETWARE
+        clean_parent_exit(1);
+#else
+	exit(1);
+#endif
+    }
+    for (m = ap_preloaded_modules, m2 = ap_loaded_modules; *m != NULL; )
+        *m2++ = *m++;
+    *m2 = NULL;
+
+    /*
+     *   Initialize chain of linked (=activate) modules
+     */
+    for (m = ap_prelinked_modules; *m != NULL; m++)
+        ap_add_module(*m);
+}
+
+API_EXPORT(const char *) ap_find_module_name(module *m)
+{
+    return m->name;
+}
+
+API_EXPORT(module *) ap_find_linked_module(const char *name)
+{
+    module *modp;
+
+    for (modp = top_module; modp; modp = modp->next) {
+	if (strcmp(modp->name, name) == 0)
+	    return modp;
+    }
+    return NULL;
+}
+
+/* Add a named module.  Returns 1 if module found, 0 otherwise.  */
+API_EXPORT(int) ap_add_named_module(const char *name)
+{
+    module *modp;
+    int i = 0;
+
+    for (modp = ap_loaded_modules[i]; modp; modp = ap_loaded_modules[++i]) {
+	if (strcmp(modp->name, name) == 0) {
+	    /* Only add modules that are not already enabled.  */
+	    if (modp->next == NULL) {
+		ap_add_module(modp);
+	    }
+	    return 1;
+	}
+    }
+
+    return 0;
+}
+
+/* Clear the internal list of modules, in preparation for starting over. */
+API_EXPORT(void) ap_clear_module_list()
+{
+    module **m = &top_module;
+    module **next_m;
+
+    while (*m) {
+	next_m = &((*m)->next);
+	*m = NULL;
+	m = next_m;
+    }
+
+    /* This is required; so we add it always.  */
+    ap_add_named_module("http_core.c");
+}
+
+/*****************************************************************
+ *
+ * Resource, access, and .htaccess config files now parsed by a common
+ * command loop.
+ *
+ * Let's begin with the basics; parsing the line and
+ * invoking the function...
+ */
+
+static const char *invoke_cmd(const command_rec *cmd, cmd_parms *parms,
+			    void *mconfig, const char *args)
+{
+    char *w, *w2, *w3;
+    const char *errmsg;
+
+    if ((parms->override & cmd->req_override) == 0)
+	return ap_pstrcat(parms->pool, cmd->name, " not allowed here", NULL);
+
+    parms->info = cmd->cmd_data;
+    parms->cmd = cmd;
+
+    switch (cmd->args_how) {
+    case RAW_ARGS:
+	return ((const char *(*)(cmd_parms *, void *, const char *))
+		(cmd->func)) (parms, mconfig, args);
+
+    case NO_ARGS:
+	if (*args != 0)
+	    return ap_pstrcat(parms->pool, cmd->name, " takes no arguments",
+			   NULL);
+
+	return ((const char *(*)(cmd_parms *, void *))
+		(cmd->func)) (parms, mconfig);
+
+    case TAKE1:
+	w = ap_getword_conf(parms->pool, &args);
+
+	if (*w == '\0' || *args != 0)
+	    return ap_pstrcat(parms->pool, cmd->name, " takes one argument",
+			    cmd->errmsg ? ", " : NULL, cmd->errmsg, NULL);
+
+	return ((const char *(*)(cmd_parms *, void *, const char *))
+		(cmd->func)) (parms, mconfig, w);
+
+    case TAKE2:
+
+	w = ap_getword_conf(parms->pool, &args);
+	w2 = ap_getword_conf(parms->pool, &args);
+
+	if (*w == '\0' || *w2 == '\0' || *args != 0)
+	    return ap_pstrcat(parms->pool, cmd->name, " takes two arguments",
+			    cmd->errmsg ? ", " : NULL, cmd->errmsg, NULL);
+
+	return ((const char *(*)(cmd_parms *, void *, const char *,
+			const char *)) (cmd->func)) (parms, mconfig, w, w2);
+
+    case TAKE12:
+
+	w = ap_getword_conf(parms->pool, &args);
+	w2 = ap_getword_conf(parms->pool, &args);
+
+	if (*w == '\0' || *args != 0)
+	    return ap_pstrcat(parms->pool, cmd->name, " takes 1-2 arguments",
+			    cmd->errmsg ? ", " : NULL, cmd->errmsg, NULL);
+
+	return ((const char *(*)(cmd_parms *, void *, const char *,
+			    const char *)) (cmd->func)) (parms, mconfig, w,
+							    *w2 ? w2 : NULL);
+
+    case TAKE3:
+
+	w = ap_getword_conf(parms->pool, &args);
+	w2 = ap_getword_conf(parms->pool, &args);
+	w3 = ap_getword_conf(parms->pool, &args);
+
+	if (*w == '\0' || *w2 == '\0' || *w3 == '\0' || *args != 0)
+	    return ap_pstrcat(parms->pool, cmd->name, " takes three arguments",
+			    cmd->errmsg ? ", " : NULL, cmd->errmsg, NULL);
+
+	return ((const char *(*)(cmd_parms *, void *, const char *,
+			    const char *, const char *)) (cmd->func)) (parms,
+							mconfig, w, w2, w3);
+
+    case TAKE23:
+
+	w = ap_getword_conf(parms->pool, &args);
+	w2 = ap_getword_conf(parms->pool, &args);
+	w3 = *args ? ap_getword_conf(parms->pool, &args) : NULL;
+
+	if (*w == '\0' || *w2 == '\0' || *args != 0)
+	    return ap_pstrcat(parms->pool, cmd->name,
+			    " takes two or three arguments",
+			    cmd->errmsg ? ", " : NULL, cmd->errmsg, NULL);
+
+	return ((const char *(*)(cmd_parms *, void *, const char *,
+			    const char *, const char *)) (cmd->func)) (parms,
+							mconfig, w, w2, w3);
+
+    case TAKE123:
+
+	w = ap_getword_conf(parms->pool, &args);
+	w2 = *args ? ap_getword_conf(parms->pool, &args) : NULL;
+	w3 = *args ? ap_getword_conf(parms->pool, &args) : NULL;
+
+	if (*w == '\0' || *args != 0)
+	    return ap_pstrcat(parms->pool, cmd->name,
+			    " takes one, two or three arguments",
+			    cmd->errmsg ? ", " : NULL, cmd->errmsg, NULL);
+
+	return ((const char *(*)(cmd_parms *, void *, const char *,
+			    const char *, const char *)) (cmd->func)) (parms,
+							mconfig, w, w2, w3);
+
+    case TAKE13:
+
+	w = ap_getword_conf(parms->pool, &args);
+	w2 = *args ? ap_getword_conf(parms->pool, &args) : NULL;
+	w3 = *args ? ap_getword_conf(parms->pool, &args) : NULL;
+
+	if (*w == '\0' || (w2 && *w2 && !w3) || *args != 0)
+	    return ap_pstrcat(parms->pool, cmd->name,
+			    " takes one or three arguments",
+			    cmd->errmsg ? ", " : NULL, cmd->errmsg, NULL);
+
+	return ((const char *(*)(cmd_parms *, void *, const char *,
+			    const char *, const char *)) (cmd->func)) (parms,
+							mconfig, w, w2, w3);
+
+    case ITERATE:
+
+	while (*(w = ap_getword_conf(parms->pool, &args)) != '\0')
+	if   ((errmsg = ((const char *(*)(cmd_parms *, void *,
+			const char *)) (cmd->func)) (parms, mconfig, w)))
+		    return errmsg;
+
+	return NULL;
+
+    case ITERATE2:
+
+	w = ap_getword_conf(parms->pool, &args);
+
+	if (*w == '\0' || *args == 0)
+	    return ap_pstrcat(parms->pool, cmd->name,
+			    " requires at least two arguments",
+			    cmd->errmsg ? ", " : NULL, cmd->errmsg, NULL);
+
+
+	while (*(w2 = ap_getword_conf(parms->pool, &args)) != '\0')
+	    if   ((errmsg = ((const char *(*)(cmd_parms *, void *,
+			    const char *, const char *)) (cmd->func)) (parms,
+							    mconfig, w, w2)))
+			return errmsg;
+
+	return NULL;
+
+    case FLAG:
+
+	w = ap_getword_conf(parms->pool, &args);
+
+	if (*w == '\0' || (strcasecmp(w, "on") && strcasecmp(w, "off")))
+	    return ap_pstrcat(parms->pool, cmd->name, " must be On or Off",
+			    NULL);
+
+	return ((const char *(*)(cmd_parms *, void *, int))
+		(cmd->func)) (parms, mconfig, strcasecmp(w, "off") != 0);
+
+    default:
+
+	return ap_pstrcat(parms->pool, cmd->name,
+		    " is improperly configured internally (server bug)",
+			NULL);
+    }
+}
+
+CORE_EXPORT(const command_rec *) ap_find_command(const char *name, const command_rec *cmds)
+{
+    while (cmds->name)
+	if (!strcasecmp(name, cmds->name))
+	    return cmds;
+	else
+	    ++cmds;
+
+    return NULL;
+}
+
+CORE_EXPORT(const command_rec *) ap_find_command_in_modules(const char *cmd_name, module **mod)
+{
+    const command_rec *cmdp;
+    module *modp;
+
+    for (modp = *mod; modp; modp = modp->next)
+	if (modp->cmds && (cmdp = ap_find_command(cmd_name, modp->cmds))) {
+	    *mod = modp;
+	    return cmdp;
+	}
+
+    return NULL;
+}
+
+CORE_EXPORT(void *) ap_set_config_vectors(cmd_parms *parms, void *config, module *mod)
+{
+    void *mconfig = ap_get_module_config(config, mod);
+    void *sconfig = ap_get_module_config(parms->server->module_config, mod);
+
+    if (!mconfig && mod->create_dir_config) {
+	mconfig = (*mod->create_dir_config) (parms->pool, parms->path);
+	ap_set_module_config(config, mod, mconfig);
+    }
+
+    if (!sconfig && mod->create_server_config) {
+	sconfig = (*mod->create_server_config) (parms->pool, parms->server);
+	ap_set_module_config(parms->server->module_config, mod, sconfig);
+    }
+    return mconfig;
+}
+
+CORE_EXPORT(const char *) ap_handle_command(cmd_parms *parms, void *config, const char *l)
+{
+    void *oldconfig;
+    const char *args, *cmd_name, *retval;
+    const command_rec *cmd;
+    module *mod = top_module;
+
+    if ((l[0] == '#') || (!l[0]))
+	return NULL;
+
+    args = l;
+    cmd_name = ap_getword_conf(parms->temp_pool, &args);
+    if (*cmd_name == '\0')
+	return NULL;
+
+    oldconfig = parms->context;
+    parms->context = config;
+    do {
+	if (!(cmd = ap_find_command_in_modules(cmd_name, &mod))) {
+            errno = EINVAL;
+            return ap_pstrcat(parms->pool, "Invalid command '", cmd_name,
+                           "', perhaps mis-spelled or defined by a module "
+                           "not included in the server configuration", NULL);
+	}
+	else {
+	    void *mconfig = ap_set_config_vectors(parms,config, mod);
+
+	    retval = invoke_cmd(cmd, parms, mconfig, args);
+	    mod = mod->next;	/* Next time around, skip this one */
+	}
+    } while (retval && !strcmp(retval, DECLINE_CMD));
+    parms->context = oldconfig;
+
+    return retval;
+}
+
+API_EXPORT(const char *) ap_srm_command_loop(cmd_parms *parms, void *config)
+{
+    char l[MAX_STRING_LEN];
+
+    while (!(ap_cfg_getline(l, MAX_STRING_LEN, parms->config_file))) {
+	const char *errmsg = ap_handle_command(parms, config, l);
+        if (errmsg) {
+	    return errmsg;
+	}
+    }
+
+    return NULL;
+}
+
+/*
+ * Generic command functions...
+ */
+
+API_EXPORT_NONSTD(const char *) ap_set_string_slot(cmd_parms *cmd,
+						char *struct_ptr, char *arg)
+{
+    /* This one's pretty generic... */
+
+    int offset = (int) (long) cmd->info;
+    *(char **) (struct_ptr + offset) = arg;
+    return NULL;
+}
+
+API_EXPORT_NONSTD(const char *) ap_set_string_slot_lower(cmd_parms *cmd,
+						char *struct_ptr, char *arg)
+{
+    /* This one's pretty generic... */
+
+    int offset = (int) (long) cmd->info;
+    ap_str_tolower(arg);
+    *(char **) (struct_ptr + offset) = arg;
+    return NULL;
+}
+
+API_EXPORT_NONSTD(const char *) ap_set_flag_slot(cmd_parms *cmd,
+					      char *struct_ptr, int arg)
+{
+    /* This one's pretty generic too... */
+
+    int offset = (int) (long) cmd->info;
+    *(int *) (struct_ptr + offset) = arg ? 1 : 0;
+    return NULL;
+}
+
+API_EXPORT_NONSTD(const char *) ap_set_file_slot(cmd_parms *cmd, char *struct_ptr, char *arg)
+{
+    /* Prepend server_root to relative arg.
+       This allows .htaccess to be independent of server_root,
+       so the server can be moved or mirrored with less pain.  */
+    char *p;
+    int offset = (int) (long) cmd->info;
+#ifndef OS2
+    arg = ap_os_canonical_filename(cmd->pool, arg);
+#endif
+    if (ap_os_is_path_absolute(arg))
+	p = arg;
+    else
+	p = ap_make_full_path(cmd->pool, ap_server_root, arg);
+    *(char **) (struct_ptr + offset) = p;
+    return NULL;
+}
+
+/*****************************************************************
+ *
+ * Reading whole config files...
+ */
+
+static cmd_parms default_parms =
+{NULL, 0, -1, NULL, NULL, NULL, NULL, NULL, NULL, NULL};
+
+API_EXPORT(char *) ap_server_root_relative(pool *p, char *file)
+{
+#ifndef OS2
+    file = ap_os_canonical_filename(p, file);
+#endif
+    if(ap_os_is_path_absolute(file))
+	return file;
+    return ap_make_full_path(p, ap_server_root, file);
+}
+
+
+/* This structure and the following functions are needed for the
+ * table-based config file reading. They are passed to the
+ * cfg_open_custom() routine.
+ */
+
+/* Structure to be passed to cfg_open_custom(): it contains an
+ * index which is incremented from 0 to nelts on each call to
+ * cfg_getline() (which in turn calls arr_elts_getstr())
+ * and an array_header pointer for the string array.
+ */
+typedef struct {
+    array_header *array;
+    int curr_idx;
+} arr_elts_param_t;
+
+
+/* arr_elts_getstr() returns the next line from the string array. */
+static void *arr_elts_getstr(void *buf, size_t bufsiz, void *param)
+{
+    arr_elts_param_t *arr_param = (arr_elts_param_t *) param;
+
+    /* End of array reached? */
+    if (++arr_param->curr_idx > arr_param->array->nelts)
+        return NULL;
+
+    /* return the line */
+    ap_cpystrn(buf, ((char **) arr_param->array->elts)[arr_param->curr_idx - 1], bufsiz);
+
+    return buf;
+}
+
+
+/* arr_elts_close(): dummy close routine (makes sure no more lines can be read) */
+static int arr_elts_close(void *param)
+{
+    arr_elts_param_t *arr_param = (arr_elts_param_t *) param;
+    arr_param->curr_idx = arr_param->array->nelts;
+    return 0;
+}
+
+static void process_command_config(server_rec *s, array_header *arr, pool *p,
+				    pool *ptemp)
+{
+    const char *errmsg;
+    cmd_parms parms;
+    arr_elts_param_t arr_parms;
+
+    arr_parms.curr_idx = 0;
+    arr_parms.array = arr;
+
+    parms = default_parms;
+    parms.pool = p;
+    parms.temp_pool = ptemp;
+    parms.server = s;
+    parms.override = (RSRC_CONF | OR_ALL) & ~(OR_AUTHCFG | OR_LIMIT);
+    parms.config_file = ap_pcfg_open_custom(p, "-c/-C directives",
+                                         &arr_parms, NULL,
+                                         arr_elts_getstr, arr_elts_close);
+
+    errmsg = ap_srm_command_loop(&parms, s->lookup_defaults);
+
+    if (errmsg) {
+        fprintf(stderr, "Syntax error in -C/-c directive:\n%s\n", errmsg);
+#ifdef NETWARE
+        clean_parent_exit(1);
+#else
+        exit(1);
+#endif
+    }
+
+    ap_cfg_closefile(parms.config_file);
+}
+
+typedef struct {
+    char *fname;
+} fnames;
+
+static int fname_alphasort(const void *fn1, const void *fn2)
+{
+    const fnames *f1 = fn1;
+    const fnames *f2 = fn2;
+
+    return strcmp(f1->fname,f2->fname);
+}
+
+static int fname_valid(const char *fname) {
+    const char *c = fname;
+    char bad_dpkg[] = "*.dpkg*";
+
+    if (!isalnum(*c)) {
+        return 0;
+    }
+    ++c;
+    
+    
+    while (*c) {
+        if (!isalnum(*c) && *c!='_' && *c!='-' && *c!='.') {
+            return 0;
+        }
+        ++c;
+    }
+
+    if (!ap_fnmatch(bad_dpkg, fname, 0)) {
+        return 0;
+    }
+
+    return 1;
+}
+        
+
+CORE_EXPORT(void) ap_process_resource_config(server_rec *s, char *fname, pool *p, pool *ptemp)
+{
+    const char *errmsg;
+    cmd_parms parms;
+    struct stat finfo;
+    int ispatt;
+    fname = ap_server_root_relative(p, fname);
+
+    if (!(strcmp(fname, ap_server_root_relative(p, RESOURCE_CONFIG_FILE))) ||
+	!(strcmp(fname, ap_server_root_relative(p, ACCESS_CONFIG_FILE)))) {
+	if (stat(fname, &finfo) == -1)
+	    return;
+    }
+
+    /* don't require conf/httpd.conf if we have a -C or -c switch */
+    if((ap_server_pre_read_config->nelts || ap_server_post_read_config->nelts) &&
+       !(strcmp(fname, ap_server_root_relative(p, SERVER_CONFIG_FILE)))) {
+	if (stat(fname, &finfo) == -1)
+	    return;
+    }
+
+    /* 
+     * here we want to check if the candidate file is really a
+     * directory, and most definitely NOT a symlink (to prevent
+     * horrible loops).  If so, let's recurse and toss it back into
+     * the function.
+     */
+    ispatt = ap_is_fnmatch(fname);
+    if (ispatt || ap_is_rdirectory(fname)) {
+	DIR *dirp;
+	struct DIR_TYPE *dir_entry;
+	int current;
+	array_header *candidates = NULL;
+	fnames *fnew;
+	char *path = ap_pstrdup(p,fname);
+	char *pattern = NULL;
+
+        if(ispatt && (pattern = strrchr(path, '/')) != NULL) {
+            *pattern++ = '\0';
+            if (ap_is_fnmatch(path)) {
+                fprintf(stderr, "%s: wildcard patterns not allowed in Include "
+                        "%s\n", ap_server_argv0, fname);
+                exit(1);
+            }
+
+            if (!ap_is_rdirectory(path)){ 
+                fprintf(stderr, "%s: Include directory '%s' not found",
+                        ap_server_argv0, path);
+                exit(1);
+            }
+            if (!ap_is_fnmatch(pattern)) {
+                fprintf(stderr, "%s: must include a wildcard pattern "
+                        "for Include %s\n", ap_server_argv0, fname);
+                exit(1);
+            }
+        }
+
+
+	/*
+	 * first course of business is to grok all the directory
+	 * entries here and store 'em away. Recall we need full pathnames
+	 * for this.
+	 */
+	/* fprintf(stderr, "Processing config directory: %s\n", fname); */
+#ifdef NETWARE
+	dirp = ap_popendir(p, fname);
+#else
+	dirp = ap_popendir(p, path);
+#endif
+	if (dirp == NULL) {
+	    perror("fopen");
+	    fprintf(stderr, "%s: could not open config directory %s\n",
+		ap_server_argv0, path);
+#ifdef NETWARE
+	    clean_parent_exit(1);
+#else
+	    exit(1);
+#endif
+	}
+	candidates = ap_make_array(p, 1, sizeof(fnames));
+	while ((dir_entry = readdir(dirp)) != NULL) {
+	    /* strip out '.' and '..' */
+	    if (strcmp(dir_entry->d_name, ".") &&
+		strcmp(dir_entry->d_name, "..") &&
+                (!ispatt ||
+                 !ap_fnmatch(pattern,dir_entry->d_name, FNM_PERIOD))
+                 && fname_valid(dir_entry->d_name)) {
+		fnew = (fnames *) ap_push_array(candidates);
+		fnew->fname = ap_make_full_path(p, path, dir_entry->d_name);
+	    }
+	}
+	ap_pclosedir(p, dirp);
+	if (candidates->nelts != 0) {
+            qsort((void *) candidates->elts, candidates->nelts,
+              sizeof(fnames), fname_alphasort);
+	    /*
+	     * Now recurse these... we handle errors and subdirectories
+	     * via the recursion, which is nice
+	     */
+	    for (current = 0; current < candidates->nelts; ++current) {
+	        fnew = &((fnames *) candidates->elts)[current];
+		/* fprintf(stderr, " Processing config file: %s\n", fnew->fname); */
+		ap_process_resource_config(s, fnew->fname, p, ptemp);
+	    }
+	}
+	return;
+    }
+    
+    /* GCC's initialization extensions are soooo nice here... */
+
+    parms = default_parms;
+    parms.pool = p;
+    parms.temp_pool = ptemp;
+    parms.server = s;
+    parms.override = (RSRC_CONF | OR_ALL) & ~(OR_AUTHCFG | OR_LIMIT);
+
+    if (!(parms.config_file = ap_pcfg_openfile(p,fname))) {
+	perror("fopen");
+	fprintf(stderr, "%s: could not open document config file %s\n",
+		ap_server_argv0, fname);
+#ifdef NETWARE
+        clean_parent_exit(1);
+#else
+	exit(1);
+#endif
+    }
+
+    errmsg = ap_srm_command_loop(&parms, s->lookup_defaults);
+
+    if (errmsg) {
+	fprintf(stderr, "Syntax error on line %d of %s:\n",
+		parms.config_file->line_number, parms.config_file->name);
+	fprintf(stderr, "%s\n", errmsg);
+#ifdef NETWARE
+        clean_parent_exit(1);
+#else
+	exit(1);
+#endif
+    }
+
+    ap_cfg_closefile(parms.config_file);
+}
+
+CORE_EXPORT(int) ap_parse_htaccess(void **result, request_rec *r, int override,
+		   const char *d, const char *access_name)
+{
+    configfile_t *f = NULL;
+    cmd_parms parms;
+    const char *errmsg;
+    char *filename = NULL;
+    const struct htaccess_result *cache;
+    struct htaccess_result *new;
+    void *dc = NULL;
+
+/* firstly, search cache */
+    for (cache = r->htaccess; cache != NULL; cache = cache->next)
+	if (cache->override == override && strcmp(cache->dir, d) == 0) {
+	    if (cache->htaccess != NULL)
+		*result = cache->htaccess;
+	    return OK;
+	}
+
+    parms = default_parms;
+    parms.override = override;
+    parms.pool = r->pool;
+    parms.temp_pool = r->pool;
+    parms.server = r->server;
+    parms.path = ap_pstrdup(r->pool, d);
+
+    /* loop through the access names and find the first one */
+
+    while (access_name[0]) {
+        filename = ap_make_full_path(r->pool, d,
+                                     ap_getword_conf(r->pool, &access_name));
+
+        if ((f = ap_pcfg_openfile(r->pool, filename)) != NULL) {
+
+            dc = ap_create_per_dir_config(r->pool);
+
+            parms.config_file = f;
+
+            errmsg = ap_srm_command_loop(&parms, dc);
+
+            ap_cfg_closefile(f);
+
+            if (errmsg) {
+                ap_log_rerror(APLOG_MARK, APLOG_ALERT|APLOG_NOERRNO, r,
+                              "%s: %s", filename, errmsg);
+                return HTTP_INTERNAL_SERVER_ERROR;
+            }
+            *result = dc;
+            break;
+        }
+        else if (errno != ENOENT && errno != ENOTDIR) {
+            ap_log_rerror(APLOG_MARK, APLOG_CRIT, r,
+                          "%s pcfg_openfile: unable to check htaccess file, "
+                          "ensure it is readable",
+                          filename);
+            ap_table_setn(r->notes, "error-notes",
+                          "Server unable to read htaccess file, denying "
+                          "access to be safe");
+            return HTTP_FORBIDDEN;
+        }
+    }
+
+/* cache it */
+    new = ap_palloc(r->pool, sizeof(struct htaccess_result));
+    new->dir = parms.path;
+    new->override = override;
+    new->htaccess = dc;
+/* add to head of list */
+    new->next = r->htaccess;
+    r->htaccess = new;
+
+    return OK;
+}
+
+
+CORE_EXPORT(const char *) ap_init_virtual_host(pool *p, const char *hostname,
+			      server_rec *main_server, server_rec **ps)
+{
+    server_rec *s = (server_rec *) ap_pcalloc(p, sizeof(server_rec));
+
+#ifdef RLIMIT_NOFILE
+    struct rlimit limits;
+
+    getrlimit(RLIMIT_NOFILE, &limits);
+    if (limits.rlim_cur < limits.rlim_max) {
+	limits.rlim_cur += 2;
+	if (setrlimit(RLIMIT_NOFILE, &limits) < 0) {
+	    perror("setrlimit(RLIMIT_NOFILE)");
+	    fprintf(stderr, "Cannot exceed hard limit for open files");
+	}
+    }
+#endif
+
+    s->server_admin = NULL;
+    s->server_hostname = NULL;
+    s->error_fname = NULL;
+    s->srm_confname = NULL;
+    s->access_confname = NULL;
+    s->timeout = 0;
+    s->keep_alive_timeout = 0;
+    s->keep_alive = -1;
+    s->keep_alive_max = -1;
+    s->error_log = main_server->error_log;
+    s->loglevel = main_server->loglevel;
+    /* useful default, otherwise we get a port of 0 on redirects */
+    s->port = main_server->port;
+    s->next = NULL;
+
+    s->is_virtual = 1;
+    s->names = ap_make_array(p, 4, sizeof(char **));
+    s->wild_names = ap_make_array(p, 4, sizeof(char **));
+
+    s->module_config = create_empty_config(p);
+    s->lookup_defaults = ap_create_per_dir_config(p);
+
+    s->server_uid = ap_user_id;
+    s->server_gid = ap_group_id;
+
+    s->limit_req_line = main_server->limit_req_line;
+    s->limit_req_fieldsize = main_server->limit_req_fieldsize;
+    s->limit_req_fields = main_server->limit_req_fields;
+
+    *ps = s;
+
+    return ap_parse_vhost_addrs(p, hostname, s);
+}
+
+
+static void fixup_virtual_hosts(pool *p, server_rec *main_server)
+{
+    server_rec *virt;
+
+    for (virt = main_server->next; virt; virt = virt->next) {
+	merge_server_configs(p, main_server->module_config,
+			     virt->module_config);
+
+	virt->lookup_defaults =
+	    ap_merge_per_dir_configs(p, main_server->lookup_defaults,
+				  virt->lookup_defaults);
+
+	if (virt->server_admin == NULL)
+	    virt->server_admin = main_server->server_admin;
+
+	if (virt->srm_confname == NULL)
+	    virt->srm_confname = main_server->srm_confname;
+
+	if (virt->access_confname == NULL)
+	    virt->access_confname = main_server->access_confname;
+
+	if (virt->timeout == 0)
+	    virt->timeout = main_server->timeout;
+
+	if (virt->keep_alive_timeout == 0)
+	    virt->keep_alive_timeout = main_server->keep_alive_timeout;
+
+	if (virt->keep_alive == -1)
+	    virt->keep_alive = main_server->keep_alive;
+
+	if (virt->keep_alive_max == -1)
+	    virt->keep_alive_max = main_server->keep_alive_max;
+
+	if (virt->send_buffer_size == 0)
+	    virt->send_buffer_size = main_server->send_buffer_size;
+
+	/* XXX: this is really something that should be dealt with by a
+	 * post-config api phase */
+	ap_core_reorder_directories(p, virt);
+    }
+    ap_core_reorder_directories(p, main_server);
+}
+
+/*****************************************************************
+ *
+ * Getting *everything* configured... 
+ */
+
+static void init_config_globals(pool *p)
+{
+    /* ServerRoot, server_confname set in httpd.c */
+
+    ap_standalone = 1;
+    ap_user_name = DEFAULT_USER;
+    ap_user_id = ap_uname2id(DEFAULT_USER);
+    ap_group_id = ap_gname2id(DEFAULT_GROUP);
+    ap_daemons_to_start = DEFAULT_START_DAEMON;
+    ap_daemons_min_free = DEFAULT_MIN_FREE_DAEMON;
+    ap_daemons_max_free = DEFAULT_MAX_FREE_DAEMON;
+    ap_daemons_limit = HARD_SERVER_LIMIT;
+    ap_pid_fname = DEFAULT_PIDLOG;
+    ap_scoreboard_fname = DEFAULT_SCOREBOARD;
+    ap_lock_fname = DEFAULT_LOCKFILE;
+    ap_max_requests_per_child = DEFAULT_MAX_REQUESTS_PER_CHILD;
+    ap_bind_address.s_addr = htonl(INADDR_ANY);
+    ap_listeners = NULL;
+    ap_listenbacklog = DEFAULT_LISTENBACKLOG;
+    ap_extended_status = 0;
+
+    /* Global virtual host hash bucket pointers.  Init to null. */
+    ap_init_vhost_config(p);
+
+    ap_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
+}
+
+static server_rec *init_server_config(pool *p)
+{
+    server_rec *s = (server_rec *) ap_pcalloc(p, sizeof(server_rec));
+
+    s->port = 0;
+    s->server_admin = DEFAULT_ADMIN;
+    s->server_hostname = NULL;
+    s->error_fname = DEFAULT_ERRORLOG;
+    s->error_log = stderr;
+    s->loglevel = DEFAULT_LOGLEVEL;
+    s->srm_confname = RESOURCE_CONFIG_FILE;
+    s->access_confname = ACCESS_CONFIG_FILE;
+    s->limit_req_line = DEFAULT_LIMIT_REQUEST_LINE;
+    s->limit_req_fieldsize = DEFAULT_LIMIT_REQUEST_FIELDSIZE;
+    s->limit_req_fields = DEFAULT_LIMIT_REQUEST_FIELDS;
+    s->timeout = DEFAULT_TIMEOUT;
+    s->keep_alive_timeout = DEFAULT_KEEPALIVE_TIMEOUT;
+    s->keep_alive_max = DEFAULT_KEEPALIVE;
+    s->keep_alive = 1;
+    s->next = NULL;
+    s->addrs = ap_pcalloc(p, sizeof(server_addr_rec));
+    /* NOT virtual host; don't match any real network interface */
+    s->addrs->host_addr.s_addr = htonl(INADDR_ANY);
+    s->addrs->host_port = 0;	/* matches any port */
+    s->addrs->virthost = "";	/* must be non-NULL */
+    s->names = s->wild_names = NULL;
+
+    s->module_config = create_server_config(p, s);
+    s->lookup_defaults = create_default_per_dir_config(p);
+
+    return s;
+}
+
+
+static void default_listeners(pool *p, server_rec *s)
+{
+    listen_rec *new;
+
+    if (ap_listeners != NULL) {
+	return;
+    }
+    /* allocate a default listener */
+    new = ap_pcalloc(p, sizeof(listen_rec));
+    new->local_addr.sin_family = AF_INET;
+    new->local_addr.sin_addr = ap_bind_address;
+    /* Buck ugly cast to get around terniary op bug in some (MS) compilers */
+    new->local_addr.sin_port = htons((unsigned short)(s->port ? s->port 
+                                                        : DEFAULT_HTTP_PORT));
+    new->fd = -1;
+    new->used = 0;
+    new->next = NULL;
+    ap_listeners = new;
+}
+
+
+API_EXPORT(server_rec *) ap_read_config(pool *p, pool *ptemp, char *confname)
+{
+    server_rec *s = init_server_config(p);
+
+    init_config_globals(p);
+
+    /* All server-wide config files now have the SAME syntax... */
+
+    process_command_config(s, ap_server_pre_read_config, p, ptemp);
+
+    ap_process_resource_config(s, confname, p, ptemp);
+    ap_process_resource_config(s, s->srm_confname, p, ptemp);
+    ap_process_resource_config(s, s->access_confname, p, ptemp);
+
+    process_command_config(s, ap_server_post_read_config, p, ptemp);
+
+    fixup_virtual_hosts(p, s);
+    default_listeners(p, s);
+    ap_fini_vhost_config(p, s);
+
+    return s;
+}
+
+API_EXPORT(void) ap_single_module_configure(pool *p, server_rec *s, module *m)
+{
+    if (m->create_server_config)
+        ap_set_module_config(s->module_config, m,
+                             (*m->create_server_config)(p, s));
+    if (m->create_dir_config)
+        ap_set_module_config(s->lookup_defaults, m,
+                             (*m->create_dir_config)(p, NULL));
+}
+
+API_EXPORT(void) ap_init_modules(pool *p, server_rec *s)
+{
+    module *m;
+
+    for (m = top_module; m; m = m->next)
+	if (m->init)
+	    (*m->init) (s, p);
+    build_method_shortcuts();
+    init_handlers(p);
+}
+
+API_EXPORT(void) ap_child_init_modules(pool *p, server_rec *s)
+{
+    module *m;
+
+    for (m = top_module; m; m = m->next)
+	if (m->child_init)
+	    (*m->child_init) (s, p);
+}
+
+API_EXPORT(void) ap_child_exit_modules(pool *p, server_rec *s)
+{
+    module *m;
+
+#ifdef SIGHUP
+    signal(SIGHUP, SIG_IGN);
+#endif
+#ifdef SIGUSR1
+    signal(SIGUSR1, SIG_IGN);
+#endif
+
+    for (m = top_module; m; m = m->next)
+	if (m->child_exit)
+	    (*m->child_exit) (s, p);
+
+}
+
+/********************************************************************
+ * Configuration directives are restricted in terms of where they may
+ * appear in the main configuration files and/or .htaccess files according
+ * to the bitmask req_override in the command_rec structure.
+ * If any of the overrides set in req_override are also allowed in the
+ * context in which the command is read, then the command is allowed.
+ * The context is determined as follows:
+ *
+ *    inside *.conf --> override = (RSRC_CONF|OR_ALL)&~(OR_AUTHCFG|OR_LIMIT);
+ *    within <Directory> or <Location> --> override = OR_ALL|ACCESS_CONF;
+ *    within .htaccess --> override = AllowOverride for current directory;
+ *
+ * the result is, well, a rather confusing set of possibilities for when
+ * a particular directive is allowed to be used.  This procedure prints
+ * in English where the given (pc) directive can be used.
+ */
+static void show_overrides(const command_rec *pc, module *pm)
+{
+    int n = 0;
+
+    printf("\tAllowed in *.conf ");
+    if ((pc->req_override & (OR_OPTIONS | OR_FILEINFO | OR_INDEXES)) ||
+	((pc->req_override & RSRC_CONF) &&
+	 ((pc->req_override & (ACCESS_CONF | OR_AUTHCFG | OR_LIMIT)))))
+	printf("anywhere");
+    else if (pc->req_override & RSRC_CONF)
+	printf("only outside <Directory>, <Files> or <Location>");
+    else
+	printf("only inside <Directory>, <Files> or <Location>");
+
+    /* Warn if the directive is allowed inside <Directory> or .htaccess
+     * but module doesn't support per-dir configuration */
+
+    if ((pc->req_override & (OR_ALL | ACCESS_CONF)) && !pm->create_dir_config)
+	printf(" [no per-dir config]");
+
+    if (pc->req_override & OR_ALL) {
+	printf(" and in .htaccess\n\twhen AllowOverride");
+
+	if ((pc->req_override & OR_ALL) == OR_ALL)
+	    printf(" isn't None");
+	else {
+	    printf(" includes ");
+
+	    if (pc->req_override & OR_AUTHCFG) {
+		if (n++)
+		    printf(" or ");
+		printf("AuthConfig");
+	    }
+	    if (pc->req_override & OR_LIMIT) {
+		if (n++)
+		    printf(" or ");
+		printf("Limit");
+	    }
+	    if (pc->req_override & OR_OPTIONS) {
+		if (n++)
+		    printf(" or ");
+		printf("Options");
+	    }
+	    if (pc->req_override & OR_FILEINFO) {
+		if (n++)
+		    printf(" or ");
+		printf("FileInfo");
+	    }
+	    if (pc->req_override & OR_INDEXES) {
+		if (n++)
+		    printf(" or ");
+		printf("Indexes");
+	    }
+	}
+    }
+    printf("\n");
+}
+
+/* Show the preloaded configuration directives, the help string explaining
+ * the directive arguments, in what module they are handled, and in
+ * what parts of the configuration they are allowed.  Used for httpd -L.
+ */
+API_EXPORT(void) ap_show_directives(void)
+{
+    const command_rec *pc;
+    int n;
+
+    for (n = 0; ap_loaded_modules[n]; ++n)
+	for (pc = ap_loaded_modules[n]->cmds; pc && pc->name; ++pc) {
+	    printf("%s (%s)\n", pc->name, ap_loaded_modules[n]->name);
+	    if (pc->errmsg)
+		printf("\t%s\n", pc->errmsg);
+	    show_overrides(pc, ap_loaded_modules[n]);
+	}
+}
+
+/* Show the preloaded module names.  Used for httpd -l. */
+API_EXPORT(void) ap_show_modules(void)
+{
+    int n;
+
+    printf("Compiled-in modules:\n");
+    for (n = 0; ap_loaded_modules[n]; ++n) {
+	printf("  %s\n", ap_loaded_modules[n]->name);
+    }
+#if !defined(WIN32) && !defined(NETWARE) && !defined(TPF)
+    printf("suexec: %s\n",
+	   ap_suexec_enabled
+	       ? "enabled; valid wrapper " SUEXEC_BIN
+	       : "disabled; invalid wrapper " SUEXEC_BIN);
+#endif
+}
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/main/http_core.c apache_1.3.33/src/main/http_core.c
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/main/http_core.c	Thu Sep 30 12:23:35 2004
+++ apache_1.3.33/src/main/http_core.c	Mon Jul 18 15:22:19 2005
@@ -2160,8 +2160,9 @@
 	else {
 	    cmd->server->server_uid = ap_user_id;
 	    fprintf(stderr,
-		    "Warning: User directive in <VirtualHost> "
+		    "ERROR: User directive in <VirtualHost> "
 		    "requires SUEXEC wrapper.\n");
+	    exit (1);
 	}
     }
 #if !defined (BIG_SECURITY_HOLE) && !defined (OS2)
@@ -2201,8 +2202,9 @@
 	else {
 	    cmd->server->server_gid = ap_group_id;
 	    fprintf(stderr,
-		    "Warning: Group directive in <VirtualHost> requires "
+		    "ERROR: Group directive in <VirtualHost> requires "
 		    "SUEXEC wrapper.\n");
+	    exit (1);
 	}
     }
 
@@ -2484,7 +2486,7 @@
            "of %d servers,\n", ap_daemons_limit, HARD_SERVER_LIMIT);
        fprintf(stderr, " lowering MaxClients to %d.  To increase, please "
            "see the\n", HARD_SERVER_LIMIT);
-       fprintf(stderr, " HARD_SERVER_LIMIT define in src/include/httpd.h.\n");
+       fprintf(stderr, " HARD_SERVER_LIMIT define in src/apaci.\n");
        ap_daemons_limit = HARD_SERVER_LIMIT;
     } 
     else if (ap_daemons_limit < 1) {
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/main/http_core.c.orig apache_1.3.33/src/main/http_core.c.orig
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/main/http_core.c.orig	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/main/http_core.c.orig	Mon Jul 18 15:22:18 2005
@@ -0,0 +1,4271 @@
+/* Copyright 1999-2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define CORE_PRIVATE
+#define ADD_EBCDICCONVERT_DEBUG_HEADER 0
+#include "httpd.h"
+#include "http_config.h"
+#include "http_core.h"
+#include "http_protocol.h"	/* For index_of_response().  Grump. */
+#include "http_request.h"
+#include "http_conf_globals.h"
+#include "http_vhost.h"
+#include "http_main.h"		/* For the default_handler below... */
+#include "http_log.h"
+#include "rfc1413.h"
+#include "util_md5.h"
+#include "scoreboard.h"
+#include "fnmatch.h"
+
+#ifdef USE_MMAP_FILES
+#include <sys/mman.h>
+
+/* mmap support for static files based on ideas from John Heidemann's
+ * patch against 1.0.5.  See
+ * <http://www.isi.edu/~johnh/SOFTWARE/APACHE/index.html>.
+ */
+
+/* Files have to be at least this big before they're mmap()d.  This is to deal
+ * with systems where the expense of doing an mmap() and an munmap() outweighs
+ * the benefit for small files.  It shouldn't be set lower than 1.
+ */
+#ifndef MMAP_THRESHOLD
+#ifdef SUNOS4
+#define MMAP_THRESHOLD		(8*1024)
+#else
+#define MMAP_THRESHOLD		1
+#endif
+#endif
+#endif
+#ifndef MMAP_LIMIT
+#define MMAP_LIMIT              (4*1024*1024)
+#endif
+
+typedef struct {
+    /* Custom response strings registered via ap_custom_response(),
+     * or NULL; check per-dir config if nothing found here
+     */
+    char **response_code_strings; /* from ap_custom_response(), not from
+                                   * ErrorDocument
+                                   */
+} core_request_config;
+
+/* Server core module... This module provides support for really basic
+ * server operations, including options and commands which control the
+ * operation of other modules.  Consider this the bureaucracy module.
+ *
+ * The core module also defines handlers, etc., do handle just enough
+ * to allow a server with the core module ONLY to actually serve documents
+ * (though it slaps DefaultType on all of 'em); this was useful in testing,
+ * but may not be worth preserving.
+ *
+ * This file could almost be mod_core.c, except for the stuff which affects
+ * the http_conf_globals.
+ */
+
+static void *create_core_dir_config(pool *a, char *dir)
+{
+    core_dir_config *conf;
+
+    conf = (core_dir_config *)ap_pcalloc(a, sizeof(core_dir_config));
+    if (!dir || dir[strlen(dir) - 1] == '/') {
+        conf->d = dir;
+    }
+    else if (strncmp(dir, "proxy:", 6) == 0) {
+        conf->d = ap_pstrdup(a, dir);
+    }
+    else {
+        conf->d = ap_pstrcat(a, dir, "/", NULL);
+    }
+    conf->d_is_fnmatch = conf->d ? (ap_is_fnmatch(conf->d) != 0) : 0;
+    conf->d_components = conf->d ? ap_count_dirs(conf->d) : 0;
+
+    conf->opts = dir ? OPT_UNSET : OPT_UNSET|OPT_ALL;
+    conf->opts_add = conf->opts_remove = OPT_NONE;
+    conf->override = dir ? OR_UNSET : OR_UNSET|OR_ALL;
+
+    conf->content_md5 = 2;
+
+    conf->use_canonical_name = USE_CANONICAL_NAME_UNSET;
+
+    conf->hostname_lookups = HOSTNAME_LOOKUP_UNSET;
+    conf->do_rfc1413 = DEFAULT_RFC1413 | 2; /* set bit 1 to indicate default */
+    conf->satisfy = SATISFY_NOSPEC;
+
+#ifdef RLIMIT_CPU
+    conf->limit_cpu = NULL;
+#endif
+#if defined(RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined(RLIMIT_AS)
+    conf->limit_mem = NULL;
+#endif
+#ifdef RLIMIT_NPROC
+    conf->limit_nproc = NULL;
+#endif
+
+    conf->limit_req_body = 0;
+    conf->sec = ap_make_array(a, 2, sizeof(void *));
+#ifdef WIN32
+    conf->script_interpreter_source = INTERPRETER_SOURCE_UNSET;
+#endif
+
+    conf->server_signature = srv_sig_unset;
+
+    conf->add_default_charset = ADD_DEFAULT_CHARSET_UNSET;
+    conf->add_default_charset_name = DEFAULT_ADD_DEFAULT_CHARSET_NAME;
+
+#ifdef CHARSET_EBCDIC
+    conf->ebcdicconversion_by_ext_in = ap_make_table(a, 4);
+    conf->ebcdicconversion_by_ext_out = ap_make_table(a, 4);
+    conf->ebcdicconversion_by_type_in = ap_make_table(a, 4);
+    conf->ebcdicconversion_by_type_out = ap_make_table(a, 4);
+    conf->x_ascii_magic_kludge = 0;
+#if ADD_EBCDICCONVERT_DEBUG_HEADER
+    conf->ebcdicconversion_debug_header = 0;
+#endif
+#endif /* CHARSET_EBCDIC */
+
+    /*
+     * Flag for use of inodes in ETags.
+     */
+    conf->etag_bits = ETAG_UNSET;
+    conf->etag_add = ETAG_UNSET;
+    conf->etag_remove = ETAG_UNSET;
+
+    return (void *)conf;
+}
+
+static void *merge_core_dir_configs(pool *a, void *basev, void *newv)
+{
+    core_dir_config *base = (core_dir_config *)basev;
+    core_dir_config *new = (core_dir_config *)newv;
+    core_dir_config *conf;
+    int i;
+  
+    conf = (core_dir_config *)ap_palloc(a, sizeof(core_dir_config));
+    memcpy((char *)conf, (const char *)base, sizeof(core_dir_config));
+    if (base->response_code_strings) {
+	conf->response_code_strings =
+	    ap_palloc(a, sizeof(*conf->response_code_strings)
+		      * RESPONSE_CODES);
+	memcpy(conf->response_code_strings, base->response_code_strings,
+	       sizeof(*conf->response_code_strings) * RESPONSE_CODES);
+    }
+    
+    conf->d = new->d;
+    conf->d_is_fnmatch = new->d_is_fnmatch;
+    conf->d_components = new->d_components;
+    conf->r = new->r;
+
+    if (new->opts & OPT_UNSET) {
+	/* there was no explicit setting of new->opts, so we merge
+	 * preserve the invariant (opts_add & opts_remove) == 0
+	 */
+	conf->opts_add = (conf->opts_add & ~new->opts_remove) | new->opts_add;
+	conf->opts_remove = (conf->opts_remove & ~new->opts_add)
+	                    | new->opts_remove;
+	conf->opts = (conf->opts & ~conf->opts_remove) | conf->opts_add;
+        if ((base->opts & OPT_INCNOEXEC) && (new->opts & OPT_INCLUDES)) {
+            conf->opts = (conf->opts & ~OPT_INCNOEXEC) | OPT_INCLUDES;
+	}
+    }
+    else {
+	/* otherwise we just copy, because an explicit opts setting
+	 * overrides all earlier +/- modifiers
+	 */
+	conf->opts = new->opts;
+	conf->opts_add = new->opts_add;
+	conf->opts_remove = new->opts_remove;
+    }
+
+    if (!(new->override & OR_UNSET)) {
+        conf->override = new->override;
+    }
+    if (new->ap_default_type) {
+        conf->ap_default_type = new->ap_default_type;
+    }
+    
+    if (new->ap_auth_type) {
+        conf->ap_auth_type = new->ap_auth_type;
+    }
+    if (new->ap_auth_name) {
+        conf->ap_auth_name = new->ap_auth_name;
+    }
+    if (new->ap_auth_nonce) {
+        conf->ap_auth_nonce = new->ap_auth_nonce;
+    }
+    if (new->ap_requires) {
+        conf->ap_requires = new->ap_requires;
+    }
+
+    if (new->response_code_strings) {
+	if (conf->response_code_strings == NULL) {
+	    conf->response_code_strings = ap_palloc(a,
+		sizeof(*conf->response_code_strings) * RESPONSE_CODES);
+	    memcpy(conf->response_code_strings, new->response_code_strings,
+		   sizeof(*conf->response_code_strings) * RESPONSE_CODES);
+	}
+	else {
+	    for (i = 0; i < RESPONSE_CODES; ++i) {
+	        if (new->response_code_strings[i] != NULL) {
+		    conf->response_code_strings[i]
+		        = new->response_code_strings[i];
+		}
+	    }
+	}
+    }
+    if (new->hostname_lookups != HOSTNAME_LOOKUP_UNSET) {
+	conf->hostname_lookups = new->hostname_lookups;
+    }
+    if ((new->do_rfc1413 & 2) == 0) {
+        conf->do_rfc1413 = new->do_rfc1413;
+    }
+    if ((new->content_md5 & 2) == 0) {
+        conf->content_md5 = new->content_md5;
+    }
+    if (new->use_canonical_name != USE_CANONICAL_NAME_UNSET) {
+	conf->use_canonical_name = new->use_canonical_name;
+    }
+
+#ifdef RLIMIT_CPU
+    if (new->limit_cpu) {
+        conf->limit_cpu = new->limit_cpu;
+    }
+#endif
+#if defined(RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined(RLIMIT_AS)
+    if (new->limit_mem) {
+        conf->limit_mem = new->limit_mem;
+    }
+#endif
+#ifdef RLIMIT_NPROC    
+    if (new->limit_nproc) {
+        conf->limit_nproc = new->limit_nproc;
+    }
+#endif
+
+    if (new->limit_req_body) {
+        conf->limit_req_body = new->limit_req_body;
+    }
+    conf->sec = ap_append_arrays(a, base->sec, new->sec);
+
+    if (new->satisfy != SATISFY_NOSPEC) {
+        conf->satisfy = new->satisfy;
+    }
+
+#ifdef WIN32
+    if (new->script_interpreter_source != INTERPRETER_SOURCE_UNSET) {
+        conf->script_interpreter_source = new->script_interpreter_source;
+    }
+#endif
+
+    if (new->server_signature != srv_sig_unset) {
+	conf->server_signature = new->server_signature;
+    }
+
+    if (new->add_default_charset != ADD_DEFAULT_CHARSET_UNSET) {
+	conf->add_default_charset = new->add_default_charset;
+	if (new->add_default_charset_name) {
+	    conf->add_default_charset_name = new->add_default_charset_name;
+	}
+    }
+
+#ifdef CHARSET_EBCDIC
+    conf->ebcdicconversion_by_ext_in = ap_overlay_tables(a, new->ebcdicconversion_by_ext_in,
+                                               base->ebcdicconversion_by_ext_in);
+    conf->ebcdicconversion_by_ext_out = ap_overlay_tables(a, new->ebcdicconversion_by_ext_out,
+                                               base->ebcdicconversion_by_ext_out);
+    conf->ebcdicconversion_by_type_in = ap_overlay_tables(a, new->ebcdicconversion_by_type_in,
+                                                base->ebcdicconversion_by_type_in);
+    conf->ebcdicconversion_by_type_out = ap_overlay_tables(a, new->ebcdicconversion_by_type_out,
+                                                base->ebcdicconversion_by_type_out);
+    conf->x_ascii_magic_kludge = new->x_ascii_magic_kludge ? new->x_ascii_magic_kludge : base->x_ascii_magic_kludge;
+#if ADD_EBCDICCONVERT_DEBUG_HEADER
+    conf->ebcdicconversion_debug_header = new->ebcdicconversion_debug_header ? new->ebcdicconversion_debug_header : base->ebcdicconversion_debug_header;
+#endif
+#endif /* CHARSET_EBCDIC */
+
+    /*
+     * Now merge the setting of the FileETag directive.
+     */
+    if (new->etag_bits == ETAG_UNSET) {
+        conf->etag_add =
+            (conf->etag_add & (~ new->etag_remove)) | new->etag_add;
+        conf->etag_remove =
+            (conf->opts_remove & (~ new->etag_add)) | new->etag_remove;
+        conf->etag_bits =
+            (conf->etag_bits & (~ conf->etag_remove)) | conf->etag_add;
+    }
+    else {
+        conf->etag_bits = new->etag_bits;
+        conf->etag_add = new->etag_add;
+        conf->etag_remove = new->etag_remove;
+    }
+    if (conf->etag_bits != ETAG_NONE) {
+        conf->etag_bits &= (~ ETAG_NONE);
+    }
+
+    if (new->cgi_command_args != AP_FLAG_UNSET) {
+        conf->cgi_command_args = new->cgi_command_args;
+    }
+
+    return (void*)conf;
+}
+
+static void *create_core_server_config(pool *a, server_rec *s)
+{
+    core_server_config *conf;
+    int is_virtual = s->is_virtual;
+  
+    conf = (core_server_config *)ap_pcalloc(a, sizeof(core_server_config));
+#ifdef GPROF
+    conf->gprof_dir = NULL;
+#endif
+    conf->access_name = is_virtual ? NULL : DEFAULT_ACCESS_FNAME;
+    conf->ap_document_root = is_virtual ? NULL : DOCUMENT_LOCATION;
+    conf->sec = ap_make_array(a, 40, sizeof(void *));
+    conf->sec_url = ap_make_array(a, 40, sizeof(void *));
+
+    /* recursion stopper */
+    conf->redirect_limit = 0;
+    conf->subreq_limit = 0;
+    conf->recursion_limit_set = 0;
+
+    return (void *)conf;
+}
+
+static void *merge_core_server_configs(pool *p, void *basev, void *virtv)
+{
+    core_server_config *base = (core_server_config *)basev;
+    core_server_config *virt = (core_server_config *)virtv;
+    core_server_config *conf;
+
+    conf = (core_server_config *)ap_pcalloc(p, sizeof(core_server_config));
+    *conf = *virt;
+    if (!conf->access_name) {
+        conf->access_name = base->access_name;
+    }
+    if (!conf->ap_document_root) {
+        conf->ap_document_root = base->ap_document_root;
+    }
+    conf->sec = ap_append_arrays(p, base->sec, virt->sec);
+    conf->sec_url = ap_append_arrays(p, base->sec_url, virt->sec_url);
+
+    conf->redirect_limit = virt->recursion_limit_set
+                           ? virt->redirect_limit
+                           : base->redirect_limit;
+
+    conf->subreq_limit = virt->recursion_limit_set
+                         ? virt->subreq_limit
+                         : base->subreq_limit;
+
+    return conf;
+}
+
+/* Add per-directory configuration entry (for <directory> section);
+ * these are part of the core server config.
+ */
+
+CORE_EXPORT(void) ap_add_per_dir_conf(server_rec *s, void *dir_config)
+{
+    core_server_config *sconf = ap_get_module_config(s->module_config,
+						     &core_module);
+    void **new_space = (void **)ap_push_array(sconf->sec);
+    
+    *new_space = dir_config;
+}
+
+CORE_EXPORT(void) ap_add_per_url_conf(server_rec *s, void *url_config)
+{
+    core_server_config *sconf = ap_get_module_config(s->module_config,
+						     &core_module);
+    void **new_space = (void **)ap_push_array(sconf->sec_url);
+    
+    *new_space = url_config;
+}
+
+CORE_EXPORT(void) ap_add_file_conf(core_dir_config *conf, void *url_config)
+{
+    void **new_space = (void **)ap_push_array(conf->sec);
+    
+    *new_space = url_config;
+}
+
+/* core_reorder_directories reorders the directory sections such that the
+ * 1-component sections come first, then the 2-component, and so on, finally
+ * followed by the "special" sections.  A section is "special" if it's a regex,
+ * or if it doesn't start with / -- consider proxy: matching.  All movements
+ * are in-order to preserve the ordering of the sections from the config files.
+ * See directory_walk().
+ */
+
+#if defined(HAVE_DRIVE_LETTERS)
+#define IS_SPECIAL(entry_core)	\
+    ((entry_core)->r != NULL \
+	|| ((entry_core)->d[0] != '/' && (entry_core)->d[1] != ':'))
+#elif defined(NETWARE)
+/* XXX: Fairly certain this is correct... '/' must prefix the path
+ *      or else in the case xyz:/ or abc/xyz:/, '/' must follow the ':'.
+ *      If there is no leading '/' or embedded ':/', then we are special.
+ */
+#define IS_SPECIAL(entry_core)	\
+    ((entry_core)->r != NULL \
+	|| ((entry_core)->d[0] != '/' \
+            && strchr((entry_core)->d, ':') \
+            && *(strchr((entry_core)->d, ':') + 1) != '/'))
+#else
+#define IS_SPECIAL(entry_core)	\
+    ((entry_core)->r != NULL || (entry_core)->d[0] != '/')
+#endif
+
+/* We need to do a stable sort, qsort isn't stable.  So to make it stable
+ * we'll be maintaining the original index into the list, and using it
+ * as the minor key during sorting.  The major key is the number of
+ * components (where a "special" section has infinite components).
+ */
+struct reorder_sort_rec {
+    void *elt;
+    int orig_index;
+};
+
+static int reorder_sorter(const void *va, const void *vb)
+{
+    const struct reorder_sort_rec *a = va;
+    const struct reorder_sort_rec *b = vb;
+    core_dir_config *core_a;
+    core_dir_config *core_b;
+
+    core_a = (core_dir_config *)ap_get_module_config(a->elt, &core_module);
+    core_b = (core_dir_config *)ap_get_module_config(b->elt, &core_module);
+    if (IS_SPECIAL(core_a)) {
+	if (!IS_SPECIAL(core_b)) {
+	    return 1;
+	}
+    }
+    else if (IS_SPECIAL(core_b)) {
+	return -1;
+    }
+    else {
+	/* we know they're both not special */
+	if (core_a->d_components < core_b->d_components) {
+	    return -1;
+	}
+	else if (core_a->d_components > core_b->d_components) {
+	    return 1;
+	}
+    }
+    /* Either they're both special, or they're both not special and have the
+     * same number of components.  In any event, we now have to compare
+     * the minor key. */
+    return a->orig_index - b->orig_index;
+}
+
+CORE_EXPORT(void) ap_core_reorder_directories(pool *p, server_rec *s)
+{
+    core_server_config *sconf;
+    array_header *sec;
+    struct reorder_sort_rec *sortbin;
+    int nelts;
+    void **elts;
+    int i;
+    pool *tmp;
+
+    sconf = ap_get_module_config(s->module_config, &core_module);
+    sec = sconf->sec;
+    nelts = sec->nelts;
+    elts = (void **)sec->elts;
+
+    /* we have to allocate tmp space to do a stable sort */
+    tmp = ap_make_sub_pool(p);
+    sortbin = ap_palloc(tmp, sec->nelts * sizeof(*sortbin));
+    for (i = 0; i < nelts; ++i) {
+	sortbin[i].orig_index = i;
+	sortbin[i].elt = elts[i];
+    }
+
+    qsort(sortbin, nelts, sizeof(*sortbin), reorder_sorter);
+
+    /* and now copy back to the original array */
+    for (i = 0; i < nelts; ++i) {
+      elts[i] = sortbin[i].elt;
+    }
+
+    ap_destroy_pool(tmp);
+}
+
+/*****************************************************************
+ *
+ * There are some elements of the core config structures in which
+ * other modules have a legitimate interest (this is ugly, but necessary
+ * to preserve NCSA back-compatibility).  So, we have a bunch of accessors
+ * here...
+ */
+
+API_EXPORT(int) ap_allow_options(request_rec *r)
+{
+    core_dir_config *conf = 
+      (core_dir_config *)ap_get_module_config(r->per_dir_config, &core_module); 
+
+    return conf->opts; 
+} 
+
+API_EXPORT(int) ap_allow_overrides(request_rec *r) 
+{ 
+    core_dir_config *conf;
+    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
+						   &core_module); 
+
+    return conf->override; 
+} 
+
+API_EXPORT(const char *) ap_auth_type(request_rec *r)
+{
+    core_dir_config *conf;
+
+    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
+						   &core_module); 
+    return conf->ap_auth_type;
+}
+
+API_EXPORT(const char *) ap_auth_name(request_rec *r)
+{
+    core_dir_config *conf;
+
+    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
+						   &core_module); 
+    return conf->ap_auth_name;
+}
+
+API_EXPORT(const char *) ap_auth_nonce(request_rec *r)
+{
+    core_dir_config *conf;
+    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
+                                                   &core_module);
+    if (conf->ap_auth_nonce)
+       return conf->ap_auth_nonce;
+
+    /* Ideally we'd want to mix in some per-directory style
+     * information; as we are likely to want to detect replay
+     * across those boundaries and some randomness. But that
+     * is harder due to the adhoc nature of .htaccess memory
+     * structures, restarts and forks.
+     *
+     * But then again - you should use AuthDigestRealmSeed in your config
+     * file if you care. So the adhoc value should do.
+     */
+    return ap_psprintf(r->pool,"%pI%pp%pp%pp%pp",
+           &r->connection->local_addr.sin_addr,
+           (void *)ap_user_name,
+           (void *)ap_listeners,
+           (void *)ap_server_argv0,
+           (void *)ap_pid_fname);
+}
+
+API_EXPORT(const char *) ap_default_type(request_rec *r)
+{
+    core_dir_config *conf;
+
+    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
+						   &core_module); 
+    return conf->ap_default_type 
+               ? conf->ap_default_type 
+               : DEFAULT_CONTENT_TYPE;
+}
+
+API_EXPORT(const char *) ap_document_root(request_rec *r) /* Don't use this! */
+{
+    core_server_config *conf;
+
+    conf = (core_server_config *)ap_get_module_config(r->server->module_config,
+						      &core_module); 
+    return conf->ap_document_root;
+}
+
+API_EXPORT(const array_header *) ap_requires(request_rec *r)
+{
+    core_dir_config *conf;
+
+    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
+						   &core_module); 
+    return conf->ap_requires;
+}
+
+API_EXPORT(int) ap_satisfies(request_rec *r)
+{
+    core_dir_config *conf;
+
+    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
+						   &core_module);
+
+    return conf->satisfy;
+}
+
+/* Should probably just get rid of this... the only code that cares is
+ * part of the core anyway (and in fact, it isn't publicised to other
+ * modules).
+ */
+
+API_EXPORT(char *) ap_response_code_string(request_rec *r, int error_index)
+{
+    core_request_config *reqconf;
+    core_dir_config *dirconf;
+
+    /* prefer per-request settings, which are created by calls to
+     * ap_custom_response()
+     */
+    reqconf = (core_request_config *)ap_get_module_config(r->request_config,
+                                                          &core_module); 
+
+    if (reqconf != NULL &&
+        reqconf->response_code_strings != NULL &&
+        reqconf->response_code_strings[error_index] != NULL) {
+        return reqconf->response_code_strings[error_index];
+    }
+
+    /* check for string specified via ErrorDocument */
+    dirconf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
+                                                      &core_module);
+
+    if (dirconf->response_code_strings == NULL) {
+	return NULL;
+    }
+
+    return dirconf->response_code_strings[error_index];
+}
+
+
+/* Code from Harald Hanche-Olsen <hanche@imf.unit.no> */
+/* Note: the function returns its result in conn->double_reverse:
+ *       +1: forward lookup of the previously reverse-looked-up
+ *           hostname in conn->remote_host succeeded, and at
+ *           least one of its IP addresses matches the client.
+ *       -1: forward lookup of conn->remote_host failed, or
+ *           none of the addresses found matches the client connection
+ *           (possible DNS spoof in the reverse zone!)
+ *       If do_double_reverse() returns -1, then it also invalidates
+ *       conn->remote_host to prevent an invalid name from appearing
+ *       in the log files. Conn->remote_host is set to "", because
+ *       a setting of NULL would allow another reverse lookup,
+ *       depending on the flags given to ap_get_remote_host().
+ */
+static ap_inline void do_double_reverse (conn_rec *conn)
+{
+    struct hostent *hptr;
+
+    if (conn->double_reverse) {
+	/* already done */
+	return;
+    }
+    if (conn->remote_host == NULL || conn->remote_host[0] == '\0') {
+	/* single reverse failed, so don't bother */
+	conn->double_reverse = -1;
+        conn->remote_host = ""; /* prevent another lookup */
+	return;
+    }
+    hptr = gethostbyname(conn->remote_host);
+    if (hptr) {
+	char **haddr;
+
+	for (haddr = hptr->h_addr_list; *haddr; haddr++) {
+	    if (((struct in_addr *)(*haddr))->s_addr
+		== conn->remote_addr.sin_addr.s_addr) {
+		conn->double_reverse = 1;
+		return;
+	    }
+	}
+    }
+    conn->double_reverse = -1;
+    /* invalidate possible reverse-resolved hostname if forward lookup fails */
+    conn->remote_host = "";
+}
+
+API_EXPORT(const char *) ap_get_remote_host(conn_rec *conn, void *dir_config,
+					    int type)
+{
+    struct in_addr *iaddr;
+    struct hostent *hptr;
+    int hostname_lookups;
+    int old_stat = SERVER_DEAD;	/* we shouldn't ever be in this state */
+
+    /* If we haven't checked the host name, and we want to */
+    if (dir_config) {
+	hostname_lookups =
+	    ((core_dir_config *)ap_get_module_config(dir_config, &core_module))
+		->hostname_lookups;
+	if (hostname_lookups == HOSTNAME_LOOKUP_UNSET) {
+	    hostname_lookups = HOSTNAME_LOOKUP_OFF;
+	}
+    }
+    else {
+	/* the default */
+	hostname_lookups = HOSTNAME_LOOKUP_OFF;
+    }
+
+    if (type != REMOTE_NOLOOKUP
+	&& conn->remote_host == NULL
+	&& (type == REMOTE_DOUBLE_REV
+	    || hostname_lookups != HOSTNAME_LOOKUP_OFF)) {
+	old_stat = ap_update_child_status(conn->child_num, SERVER_BUSY_DNS,
+					  (request_rec*)NULL);
+	iaddr = &(conn->remote_addr.sin_addr);
+	hptr = gethostbyaddr((char *)iaddr, sizeof(struct in_addr), AF_INET);
+	if (hptr != NULL) {
+	    conn->remote_host = ap_pstrdup(conn->pool, (void *)hptr->h_name);
+	    ap_str_tolower(conn->remote_host);
+	   
+	    if (hostname_lookups == HOSTNAME_LOOKUP_DOUBLE) {
+		do_double_reverse(conn);
+	    }
+	}
+	/* if failed, set it to the NULL string to indicate error */
+	if (conn->remote_host == NULL) {
+	    conn->remote_host = "";
+	}
+    }
+    if (type == REMOTE_DOUBLE_REV) {
+	do_double_reverse(conn);
+	if (conn->double_reverse == -1) {
+	    return NULL;
+	}
+    }
+    if (old_stat != SERVER_DEAD) {
+	(void)ap_update_child_status(conn->child_num, old_stat,
+				     (request_rec*)NULL);
+    }
+
+/*
+ * Return the desired information; either the remote DNS name, if found,
+ * or either NULL (if the hostname was requested) or the IP address
+ * (if any identifier was requested).
+ */
+    if (conn->remote_host != NULL && conn->remote_host[0] != '\0') {
+	return conn->remote_host;
+    }
+    else {
+	if (type == REMOTE_HOST || type == REMOTE_DOUBLE_REV) {
+	    return NULL;
+	}
+	else {
+	    return conn->remote_ip;
+	}
+    }
+}
+
+API_EXPORT(const char *) ap_get_remote_logname(request_rec *r)
+{
+    core_dir_config *dir_conf;
+
+    if (r->connection->remote_logname != NULL) {
+	return r->connection->remote_logname;
+    }
+
+/* If we haven't checked the identity, and we want to */
+    dir_conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
+						       &core_module);
+
+    if (dir_conf->do_rfc1413 & 1) {
+	return ap_rfc1413(r->connection, r->server);
+    }
+    else {
+	return NULL;
+    }
+}
+
+/* There are two options regarding what the "name" of a server is.  The
+ * "canonical" name as defined by ServerName and Port, or the "client's
+ * name" as supplied by a possible Host: header or full URI.  We never
+ * trust the port passed in the client's headers, we always use the
+ * port of the actual socket.
+ *
+ * The DNS option to UseCanonicalName causes this routine to do a
+ * reverse lookup on the local IP address of the connectiona and use
+ * that for the ServerName. This makes its value more reliable while
+ * at the same time allowing Demon's magic virtual hosting to work.
+ * The assumption is that DNS lookups are sufficiently quick...
+ * -- fanf 1998-10-03
+ */
+API_EXPORT(const char *) ap_get_server_name(request_rec *r)
+{
+    conn_rec *conn = r->connection;
+    core_dir_config *d;
+
+    d = (core_dir_config *)ap_get_module_config(r->per_dir_config,
+						&core_module);
+
+    if (d->use_canonical_name == USE_CANONICAL_NAME_OFF) {
+        return r->hostname ? r->hostname : r->server->server_hostname;
+    }
+    if (d->use_canonical_name == USE_CANONICAL_NAME_DNS) {
+        if (conn->local_host == NULL) {
+	    struct in_addr *iaddr;
+	    struct hostent *hptr;
+            int old_stat;
+	    old_stat = ap_update_child_status(conn->child_num,
+					      SERVER_BUSY_DNS, r);
+	    iaddr = &(conn->local_addr.sin_addr);
+	    hptr = gethostbyaddr((char *)iaddr, sizeof(struct in_addr),
+				 AF_INET);
+	    if (hptr != NULL) {
+	        conn->local_host = ap_pstrdup(conn->pool,
+					      (void *)hptr->h_name);
+		ap_str_tolower(conn->local_host);
+	    }
+	    else {
+	        conn->local_host = ap_pstrdup(conn->pool,
+					      r->server->server_hostname);
+	    }
+	    (void) ap_update_child_status(conn->child_num, old_stat, r);
+	}
+	return conn->local_host;
+    }
+    /* default */
+    return r->server->server_hostname;
+}
+
+API_EXPORT(unsigned) ap_get_server_port(const request_rec *r)
+{
+    unsigned port;
+    unsigned cport = ntohs(r->connection->local_addr.sin_port);
+    core_dir_config *d =
+      (core_dir_config *)ap_get_module_config(r->per_dir_config, &core_module);
+    
+    if (d->use_canonical_name == USE_CANONICAL_NAME_OFF
+        || d->use_canonical_name == USE_CANONICAL_NAME_DNS) {
+        
+        /* With UseCanonicalName Off Apache will form self-referential
+         * URLs using the hostname and port supplied by the client if
+         * any are supplied (otherwise it will use the canonical name).
+         */
+        port = r->parsed_uri.port_str ? r->parsed_uri.port : 
+#ifdef UCN_OFF_HONOR_PHYSICAL_PORT
+          cport ? cport :
+#endif
+            r->server->port ? r->server->port :
+              ap_default_port(r);
+    } else { /* d->use_canonical_name == USE_CANONICAL_NAME_ON */
+        port = r->server->port ? r->server->port : 
+          cport ? cport :
+            ap_default_port(r);
+    }
+
+    /* default */
+    return port;
+}
+
+API_EXPORT(char *) ap_construct_url(pool *p, const char *uri,
+				    request_rec *r)
+{
+    unsigned port = ap_get_server_port(r);
+    const char *host = ap_get_server_name(r);
+
+    if (ap_is_default_port(port, r)) {
+	return ap_pstrcat(p, ap_http_method(r), "://", host, uri, NULL);
+    }
+    return ap_psprintf(p, "%s://%s:%u%s", ap_http_method(r), host, port, uri);
+}
+
+API_EXPORT(unsigned long) ap_get_limit_req_body(const request_rec *r)
+{
+    core_dir_config *d =
+      (core_dir_config *)ap_get_module_config(r->per_dir_config, &core_module);
+    
+    return d->limit_req_body;
+}
+
+#ifdef WIN32
+static char* get_interpreter_from_win32_registry(pool *p, const char* ext) 
+{
+    char extension_path[] = "SOFTWARE\\Classes\\";
+    char executable_path[] = "\\SHELL\\OPEN\\COMMAND";
+
+    HKEY hkeyOpen;
+    DWORD type;
+    int size;
+    int result;
+    char *keyName;
+    char *buffer;
+    char *s;
+
+    if (!ext)
+        return NULL;
+    /* 
+     * Future optimization:
+     * When the registry is successfully searched, store the interpreter
+     * string in a table to make subsequent look-ups faster
+     */
+
+    /* Open the key associated with the script extension */
+    keyName = ap_pstrcat(p, extension_path, ext, NULL);
+
+    result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, keyName, 0, KEY_QUERY_VALUE, 
+                          &hkeyOpen);
+
+    if (result != ERROR_SUCCESS) 
+        return NULL;
+
+    /* Read to NULL buffer to find value size */
+    size = 0;
+    result = RegQueryValueEx(hkeyOpen, "", NULL, &type, NULL, &size);
+
+    if (result == ERROR_SUCCESS) {
+        buffer = ap_palloc(p, size);
+        result = RegQueryValueEx(hkeyOpen, "", NULL, &type, buffer, &size);
+    }
+
+    RegCloseKey(hkeyOpen);
+
+    if (result != ERROR_SUCCESS)
+        return NULL;
+
+    /* Open the key associated with the interpreter path */
+    keyName = ap_pstrcat(p, extension_path, buffer, executable_path, NULL);
+
+    result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, keyName, 0, KEY_QUERY_VALUE, 
+                          &hkeyOpen);
+
+    if (result != ERROR_SUCCESS)
+        return NULL;
+
+    /* Read to NULL buffer to find value size */
+    size = 0;
+    result = RegQueryValueEx(hkeyOpen, "", 0, &type, NULL, &size);
+
+    if (result == ERROR_SUCCESS) {
+        buffer = ap_palloc(p, size);
+        result = RegQueryValueEx(hkeyOpen, "", 0, &type, buffer, &size);
+    }
+
+    RegCloseKey(hkeyOpen);
+
+    if (result != ERROR_SUCCESS)
+        return NULL;
+
+    /*
+     * The command entry may contain embedded %envvar% entries,
+     * e.g. %winsysdir%\somecommand.exe %1
+     *
+     * Resolve them here
+     */
+    size = ExpandEnvironmentStrings(buffer, NULL, 0);
+    if (size) {
+        s = ap_palloc(p, size);
+        if (ExpandEnvironmentStrings(buffer, s, size))
+            buffer = s;
+    }
+
+    /*
+     * The canonical way shell command entries are entered in the Win32 
+     * registry is as follows:
+     *   shell [options] "%1" [options] [%*]
+     * where
+     *   shell - full path name to interpreter or shell to run.
+     *           E.g., c:\usr\local\ntreskit\perl\bin\perl.exe
+     *   options - optional switches
+     *              E.g., /C or -w
+     *   "%1" - Place holder for file to run the shell against. 
+     *          Quoted for if long path names are accepted.
+     *          Not quoted if only short paths are acceptd
+     *
+     *   %* - additional arguments
+     *
+     * Effective in v. 1.3.15, the responsibility is the consumer's
+     * to make these substitutions.
+     */
+
+    return buffer;
+}
+
+API_EXPORT (file_type_e) ap_get_win32_interpreter(const  request_rec *r, 
+                                                  char** interpreter )
+{
+    HANDLE hFile;
+    DWORD nBytesRead;
+    BOOLEAN bResult;
+    char buffer[1024];
+    core_dir_config *d;
+    int i;
+    file_type_e fileType = eFileTypeUNKNOWN;
+    char *ext = NULL;
+    char *exename = NULL;
+
+    d = (core_dir_config *)ap_get_module_config(r->per_dir_config, 
+                                                &core_module);
+
+    /* Find the file extension */
+    exename = strrchr(r->filename, '/');
+    if (!exename) {
+        exename = strrchr(r->filename, '\\');
+    }
+    if (!exename) {
+        exename = r->filename;
+    }
+    else {
+        exename++;
+    }
+    ext = strrchr(exename, '.');
+
+    if (ext && (!strcasecmp(ext,".bat") || !strcasecmp(ext,".cmd"))) 
+    {
+        char *p, *shellcmd = getenv("COMSPEC");
+        if (!shellcmd)
+            return eFileTypeUNKNOWN;
+        p = strchr(shellcmd, '\0');
+        if ((p - shellcmd >= 11) && !strcasecmp(p - 11, "command.com")) 
+        {
+            /* Command.com doesn't like long paths, doesn't do .cmd
+             */
+            if (!strcasecmp(ext,".cmd"))
+                return eFileTypeUNKNOWN;
+            *interpreter = ap_pstrcat(r->pool, "\"", shellcmd, "\" /C %1", NULL);
+            return eCommandShell16;
+        }
+        else {
+            /* Assume any other likes long paths, and knows .cmd,
+             * but the entire /c arg should be double quoted, e.g.
+             * "c:\path\cmd.exe" /c ""prog" "arg" "arg""
+             */
+            *interpreter = ap_pstrcat(r->pool, "\"", shellcmd, "\" /C \"\"%1\" %*\"", NULL);
+            return eCommandShell32;
+        }
+    }
+
+    /* If the file has an extension and it is not .com and not .exe and
+     * we've been instructed to search the registry, then do it!
+     */
+    if (ext && strcasecmp(ext,".exe") && strcasecmp(ext,".com") &&
+        d->script_interpreter_source == INTERPRETER_SOURCE_REGISTRY) {
+         /* Check the registry */
+        *interpreter = get_interpreter_from_win32_registry(r->pool, ext);
+        if (*interpreter)
+            return eFileTypeSCRIPT;
+        else {
+            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, r->server,
+             "ScriptInterpreterSource config directive set to \"registry\".\n\t"
+             "Registry was searched but interpreter not found. Trying the shebang line.");
+        }
+    }        
+
+    /* Need to peek into the file figure out what it really is... */
+    hFile = CreateFile(r->filename, GENERIC_READ, FILE_SHARE_READ, NULL,
+                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
+    if (hFile == INVALID_HANDLE_VALUE) {
+        return eFileTypeUNKNOWN;
+    }
+    bResult = ReadFile(hFile, (void*) &buffer, sizeof(buffer) - 1, 
+                       &nBytesRead, NULL);
+    if (!bResult || (nBytesRead == 0)) {
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
+                      "ReadFile(%s) failed", r->filename);
+        CloseHandle(hFile);
+        return eFileTypeUNKNOWN;
+    }
+    CloseHandle(hFile);
+    buffer[nBytesRead] = '\0';
+
+    /* Script or executable, that is the question... */
+    if ((buffer[0] == '#') && (buffer[1] == '!')) {
+        /* Assuming file is a script since it starts with a shebang */
+        fileType = eFileTypeSCRIPT;
+        for (i = 2; i < (sizeof(buffer) - 1); i++) {
+            if ((buffer[i] == '\r')
+                || (buffer[i] == '\n')) {
+                break;
+            }
+        }
+        buffer[i] = '\0';
+        for (i = 2; buffer[i] == ' ' ; ++i)
+            ;
+        *interpreter = ap_pstrdup(r->pool, buffer + i ); 
+    }
+    else {
+        /* Not a script, is it an executable? */
+        IMAGE_DOS_HEADER *hdr = (IMAGE_DOS_HEADER*)buffer;    
+        if ((nBytesRead >= sizeof(IMAGE_DOS_HEADER)) && (hdr->e_magic == IMAGE_DOS_SIGNATURE)) {
+            if (hdr->e_lfarlc < 0x40)
+                fileType = eFileTypeEXE16;
+            else
+                fileType = eFileTypeEXE32;
+        }
+        else
+            fileType = eFileTypeUNKNOWN;
+    }
+
+    return fileType;
+}
+#endif
+
+/*****************************************************************
+ *
+ * Commands... this module handles almost all of the NCSA httpd.conf
+ * commands, but most of the old srm.conf is in the the modules.
+ */
+
+static const char end_directory_section[] = "</Directory>";
+static const char end_directorymatch_section[] = "</DirectoryMatch>";
+static const char end_location_section[] = "</Location>";
+static const char end_locationmatch_section[] = "</LocationMatch>";
+static const char end_files_section[] = "</Files>";
+static const char end_filesmatch_section[] = "</FilesMatch>";
+static const char end_virtualhost_section[] = "</VirtualHost>";
+static const char end_ifmodule_section[] = "</IfModule>";
+static const char end_ifdefine_section[] = "</IfDefine>";
+
+
+API_EXPORT(const char *) ap_check_cmd_context(cmd_parms *cmd,
+					      unsigned forbidden)
+{
+    const char *gt = (cmd->cmd->name[0] == '<'
+		      && cmd->cmd->name[strlen(cmd->cmd->name)-1] != '>')
+                         ? ">" : "";
+
+    if ((forbidden & NOT_IN_VIRTUALHOST) && cmd->server->is_virtual) {
+	return ap_pstrcat(cmd->pool, cmd->cmd->name, gt,
+			  " cannot occur within <VirtualHost> section", NULL);
+    }
+
+    if ((forbidden & NOT_IN_LIMIT) && cmd->limited != -1) {
+	return ap_pstrcat(cmd->pool, cmd->cmd->name, gt,
+			  " cannot occur within <Limit> section", NULL);
+    }
+
+    if ((forbidden & NOT_IN_DIR_LOC_FILE) == NOT_IN_DIR_LOC_FILE
+	&& cmd->path != NULL) {
+	return ap_pstrcat(cmd->pool, cmd->cmd->name, gt,
+			  " cannot occur within <Directory/Location/Files> "
+			  "section", NULL);
+    }
+    
+    if (((forbidden & NOT_IN_DIRECTORY)
+	 && (cmd->end_token == end_directory_section
+	     || cmd->end_token == end_directorymatch_section)) 
+	|| ((forbidden & NOT_IN_LOCATION)
+	    && (cmd->end_token == end_location_section
+		|| cmd->end_token == end_locationmatch_section)) 
+	|| ((forbidden & NOT_IN_FILES)
+	    && (cmd->end_token == end_files_section
+		|| cmd->end_token == end_filesmatch_section))) {
+	return ap_pstrcat(cmd->pool, cmd->cmd->name, gt,
+			  " cannot occur within <", cmd->end_token+2,
+			  " section", NULL);
+    }
+
+    return NULL;
+}
+
+static const char *set_access_name(cmd_parms *cmd, void *dummy, char *arg)
+{
+    void *sconf = cmd->server->module_config;
+    core_server_config *conf = ap_get_module_config(sconf, &core_module);
+
+    const char *err = ap_check_cmd_context(cmd,
+					   NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
+    if (err != NULL) {
+        return err;
+    }
+
+    conf->access_name = ap_pstrdup(cmd->pool, arg);
+    return NULL;
+}
+
+#ifdef GPROF
+static const char *set_gprof_dir(cmd_parms *cmd, void *dummy, char *arg)
+{
+    void *sconf = cmd->server->module_config;
+    core_server_config *conf = ap_get_module_config(sconf, &core_module);
+
+    const char *err = ap_check_cmd_context(cmd,
+					   NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
+    if (err != NULL) {
+        return err;
+    }
+
+    conf->gprof_dir = ap_pstrdup(cmd->pool, arg);
+    return NULL;
+}
+#endif /*GPROF*/
+
+static const char *set_add_default_charset(cmd_parms *cmd, 
+	core_dir_config *d, char *arg)
+{
+    const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
+    if (err != NULL) {
+        return err;
+    }
+    if (!strcasecmp(arg, "Off")) {
+       d->add_default_charset = ADD_DEFAULT_CHARSET_OFF;
+    }
+    else if (!strcasecmp(arg, "On")) {
+       d->add_default_charset = ADD_DEFAULT_CHARSET_ON;
+       d->add_default_charset_name = DEFAULT_ADD_DEFAULT_CHARSET_NAME;
+    }
+    else {
+       d->add_default_charset = ADD_DEFAULT_CHARSET_ON;
+       d->add_default_charset_name = arg;
+    }
+    return NULL;
+}
+static const char *set_accept_mutex(cmd_parms *cmd, void *dummy, char *arg)
+{
+	return ap_init_mutex_method(arg);
+}
+
+static const char *set_document_root(cmd_parms *cmd, void *dummy, char *arg)
+{
+    void *sconf = cmd->server->module_config;
+    core_server_config *conf = ap_get_module_config(sconf, &core_module);
+  
+    const char *err = ap_check_cmd_context(cmd,
+					   NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
+    if (err != NULL) {
+        return err;
+    }
+
+    arg = ap_os_canonical_filename(cmd->pool, arg);
+    if (ap_configtestonly && ap_docrootcheck && !ap_is_directory(arg)) {
+	if (cmd->server->is_virtual) {
+	    fprintf(stderr, "Warning: DocumentRoot [%s] does not exist\n",
+		    arg);
+	}
+	else {
+	    return "DocumentRoot must be a directory";
+	}
+    }
+    
+    conf->ap_document_root = arg;
+    return NULL;
+}
+
+API_EXPORT(void) ap_custom_response(request_rec *r, int status, char *string)
+{
+    core_request_config *reqconf =
+	ap_get_module_config(r->request_config, &core_module);
+    int idx;
+
+    if (reqconf == NULL) {
+        reqconf = (core_request_config *)ap_pcalloc(r->pool,
+                                                    sizeof(core_request_config));
+        ap_set_module_config(r->request_config, &core_module, reqconf);
+    }
+    
+    if (reqconf->response_code_strings == NULL) {
+        reqconf->response_code_strings = 
+	    ap_pcalloc(r->pool,
+                       sizeof(reqconf->response_code_strings) * 
+                       RESPONSE_CODES);
+    }
+
+    idx = ap_index_of_response(status);
+
+    reqconf->response_code_strings[idx] = 
+       ((ap_is_url(string) || (*string == '/')) && (*string != '"')) ? 
+       ap_pstrdup(r->pool, string) : ap_pstrcat(r->pool, "\"", string, NULL);
+}
+
+static const char *set_error_document(cmd_parms *cmd, core_dir_config *conf,
+				      char *line)
+{
+    int error_number, index_number, idx500;
+    char *w;
+                
+    const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
+    if (err != NULL) {
+        return err;
+    }
+
+    /* 1st parameter should be a 3 digit number, which we recognize;
+     * convert it into an array index
+     */
+  
+    w = ap_getword_conf_nc(cmd->pool, &line);
+    error_number = atoi(w);
+
+    idx500 = ap_index_of_response(HTTP_INTERNAL_SERVER_ERROR);
+
+    if (error_number == HTTP_INTERNAL_SERVER_ERROR) {
+        index_number = idx500;
+    }
+    else if ((index_number = ap_index_of_response(error_number)) == idx500) {
+        return ap_pstrcat(cmd->pool, "Unsupported HTTP response code ",
+			  w, NULL);
+    }
+
+    /* The entry should be ignored if it is a full URL for a 401 error */
+
+    if (error_number == 401 &&
+	line[0] != '/' && line[0] != '"') { /* Ignore it... */
+	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, cmd->server,
+		     "cannot use a full URL in a 401 ErrorDocument "
+		     "directive --- ignoring!");
+    }
+    else { /* Store it... */
+    	if (conf->response_code_strings == NULL) {
+	    conf->response_code_strings =
+		ap_pcalloc(cmd->pool,
+			   sizeof(*conf->response_code_strings) * RESPONSE_CODES);
+        }
+        conf->response_code_strings[index_number] = ap_pstrdup(cmd->pool, line);
+    }   
+
+    return NULL;
+}
+
+/* access.conf commands...
+ *
+ * The *only* thing that can appear in access.conf at top level is a
+ * <Directory> section.  NB we need to have a way to cut the srm_command_loop
+ * invoked by dirsection (i.e., <Directory>) short when </Directory> is seen.
+ * We do that by returning an error, which dirsection itself recognizes and
+ * discards as harmless.  Cheesy, but it works.
+ */
+
+static const char *set_override(cmd_parms *cmd, core_dir_config *d,
+				const char *l)
+{
+    char *w;
+  
+    const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
+    if (err != NULL) {
+        return err;
+    }
+
+    d->override = OR_NONE;
+    while (l[0]) {
+        w = ap_getword_conf(cmd->pool, &l);
+	if (!strcasecmp(w, "Limit")) {
+	    d->override |= OR_LIMIT;
+	}
+	else if (!strcasecmp(w, "Options")) {
+	    d->override |= OR_OPTIONS;
+	}
+	else if (!strcasecmp(w, "FileInfo")) {
+            d->override |= OR_FILEINFO;
+	}
+	else if (!strcasecmp(w, "AuthConfig")) {
+	    d->override |= OR_AUTHCFG;
+	}
+	else if (!strcasecmp(w, "Indexes")) {
+            d->override |= OR_INDEXES;
+	}
+	else if (!strcasecmp(w, "None")) {
+	    d->override = OR_NONE;
+	}
+	else if (!strcasecmp(w, "All")) {
+	    d->override = OR_ALL;
+	}
+	else {
+	    return ap_pstrcat(cmd->pool, "Illegal override option ", w, NULL);
+	}
+	d->override &= ~OR_UNSET;
+    }
+
+    return NULL;
+}
+
+static const char *set_options(cmd_parms *cmd, core_dir_config *d,
+			       const char *l)
+{
+    allow_options_t opt;
+    int first = 1;
+    char action;
+
+    while (l[0]) {
+        char *w = ap_getword_conf(cmd->pool, &l);
+	action = '\0';
+
+	if (*w == '+' || *w == '-') {
+	    action = *(w++);
+	}
+	else if (first) {
+  	    d->opts = OPT_NONE;
+            first = 0;
+        }
+	    
+	if (!strcasecmp(w, "Indexes")) {
+	    opt = OPT_INDEXES;
+	}
+	else if (!strcasecmp(w, "Includes")) {
+	    opt = OPT_INCLUDES;
+	}
+	else if (!strcasecmp(w, "IncludesNOEXEC")) {
+	    opt = (OPT_INCLUDES | OPT_INCNOEXEC);
+	}
+	else if (!strcasecmp(w, "FollowSymLinks")) {
+	    opt = OPT_SYM_LINKS;
+	}
+	else if (!strcasecmp(w, "SymLinksIfOwnerMatch")) {
+	    opt = OPT_SYM_OWNER;
+	}
+	else if (!strcasecmp(w, "execCGI")) {
+	    opt = OPT_EXECCGI;
+	}
+	else if (!strcasecmp(w, "MultiViews")) {
+	    opt = OPT_MULTI;
+	}
+	else if (!strcasecmp(w, "RunScripts")) { /* AI backcompat. Yuck */
+	    opt = OPT_MULTI|OPT_EXECCGI;
+	}
+	else if (!strcasecmp(w, "None")) {
+	    opt = OPT_NONE;
+	}
+	else if (!strcasecmp(w, "All")) {
+	    opt = OPT_ALL;
+	}
+	else {
+	    return ap_pstrcat(cmd->pool, "Illegal option ", w, NULL);
+	}
+
+	/* we ensure the invariant (d->opts_add & d->opts_remove) == 0 */
+	if (action == '-') {
+	    d->opts_remove |= opt;
+	    d->opts_add &= ~opt;
+	    d->opts &= ~opt;
+	}
+	else if (action == '+') {
+	    d->opts_add |= opt;
+	    d->opts_remove &= ~opt;
+	    d->opts |= opt;
+	}
+	else {
+	    d->opts |= opt;
+	}
+    }
+
+    return NULL;
+}
+
+static const char *satisfy(cmd_parms *cmd, core_dir_config *c, char *arg)
+{
+    if (!strcasecmp(arg, "all")) {
+        c->satisfy = SATISFY_ALL;
+    }
+    else if (!strcasecmp(arg, "any")) {
+        c->satisfy = SATISFY_ANY;
+    }
+    else {
+        return "Satisfy either 'any' or 'all'.";
+    }
+    return NULL;
+}
+
+static const char *require(cmd_parms *cmd, core_dir_config *c, char *arg)
+{
+    require_line *r;
+  
+    if (!c->ap_requires) {
+        c->ap_requires = ap_make_array(cmd->pool, 2, sizeof(require_line));
+    }
+    r = (require_line *)ap_push_array(c->ap_requires);
+    r->requirement = ap_pstrdup(cmd->pool, arg);
+    r->method_mask = cmd->limited;
+    return NULL;
+}
+
+CORE_EXPORT_NONSTD(const char *) ap_limit_section(cmd_parms *cmd, void *dummy,
+						  const char *arg)
+{
+    const char *limited_methods = ap_getword(cmd->pool, &arg, '>');
+    void *tog = cmd->cmd->cmd_data;
+    int limited = 0;
+  
+    const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
+    if (err != NULL) {
+        return err;
+    }
+
+    /* XXX: NB: Currently, we have no way of checking
+     * whether <Limit> or <LimitExcept> sections are closed properly.
+     * (If we would add a srm_command_loop() here we might...)
+     */
+    
+    while (limited_methods[0]) {
+        char *method = ap_getword_conf(cmd->pool, &limited_methods);
+        int  methnum = ap_method_number_of(method);
+
+        if (methnum == M_TRACE && !tog) {
+            return "TRACE cannot be controlled by <Limit>";
+        }
+        else if (methnum == M_INVALID) {
+            return ap_pstrcat(cmd->pool, "unknown method \"", method,
+                              "\" in <Limit", tog ? "Except>" : ">", NULL);
+        }
+        else {
+            limited |= (1 << methnum);
+        }
+    }
+
+    /* Killing two features with one function,
+     * if (tog == NULL) <Limit>, else <LimitExcept>
+     */
+    cmd->limited = tog ? ~limited : limited;
+    return NULL;
+}
+
+static const char *endlimit_section(cmd_parms *cmd, void *dummy, void *dummy2)
+{
+    void *tog = cmd->cmd->cmd_data;
+
+    if (cmd->limited == -1) {
+        return tog ? "</LimitExcept> unexpected" : "</Limit> unexpected";
+    }
+    
+    cmd->limited = -1;
+    return NULL;
+}
+
+/*
+ * When a section is not closed properly when end-of-file is reached,
+ * then an error message should be printed:
+ */
+static const char *missing_endsection(cmd_parms *cmd, int nest)
+{
+    if (nest < 2) {
+	return ap_psprintf(cmd->pool, "Missing %s directive at end-of-file",
+			   cmd->end_token);
+    }
+    return ap_psprintf(cmd->pool, "%d missing %s directives at end-of-file",
+		       nest, cmd->end_token);
+}
+
+/* We use this in <DirectoryMatch> and <FilesMatch>, to ensure that 
+ * people don't get bitten by wrong-cased regex matches
+ */
+
+#ifdef WIN32
+#define USE_ICASE REG_ICASE
+#else
+#define USE_ICASE 0
+#endif
+
+static const char *end_nested_section(cmd_parms *cmd, void *dummy)
+{
+    if (cmd->end_token == NULL) {
+        return ap_pstrcat(cmd->pool, cmd->cmd->name,
+			  " without matching <", cmd->cmd->name + 2, 
+			  " section", NULL);
+    }
+    /*
+     * This '!=' may look weird on a string comparison, but it's correct --
+     * it's been set up so that checking for two pointers to the same datum
+     * is valid here.  And faster.
+     */
+    if (cmd->cmd->name != cmd->end_token) {
+	return ap_pstrcat(cmd->pool, "Expected ", cmd->end_token, " but saw ",
+			  cmd->cmd->name, NULL);
+    }
+    return cmd->end_token;
+}
+
+/*
+ * Report a missing-'>' syntax error.
+ */
+static char *unclosed_directive(cmd_parms *cmd)
+{
+    return ap_pstrcat(cmd->pool, cmd->cmd->name,
+		      "> directive missing closing '>'", NULL);
+}
+
+static const char *dirsection(cmd_parms *cmd, void *dummy, const char *arg)
+{
+    const char *errmsg;
+    char *endp = strrchr(arg, '>');
+    int old_overrides = cmd->override;
+    char *old_path = cmd->path;
+    core_dir_config *conf;
+    void *new_dir_conf = ap_create_per_dir_config(cmd->pool);
+    regex_t *r = NULL;
+    const char *old_end_token;
+    const command_rec *thiscmd = cmd->cmd;
+
+    const char *err = ap_check_cmd_context(cmd,
+					   NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
+    if (err != NULL) {
+        return err;
+    }
+
+    if (endp == NULL) {
+	return unclosed_directive(cmd);
+    }
+
+    *endp = '\0';
+
+    cmd->path = ap_getword_conf(cmd->pool, &arg);
+    cmd->override = OR_ALL|ACCESS_CONF;
+
+    if (thiscmd->cmd_data) { /* <DirectoryMatch> */
+        r = ap_pregcomp(cmd->pool, cmd->path, REG_EXTENDED|USE_ICASE);
+        if (!r) {
+            return "Regex could not be compiled";
+        }
+    }
+    else if (!strcmp(cmd->path, "~")) {
+        cmd->path = ap_getword_conf(cmd->pool, &arg);
+        r = ap_pregcomp(cmd->pool, cmd->path, REG_EXTENDED|USE_ICASE);
+        if (!r) {
+            return "Regex could not be compiled";
+        }
+    }
+#if defined(HAVE_DRIVE_LETTERS) || defined(NETWARE)
+    else if (strcmp(cmd->path, "/") == 0) {
+        /* Treat 'default' path / as an inalienable root */
+        cmd->path = ap_pstrdup(cmd->pool, cmd->path);
+    }
+#endif
+#if defined(HAVE_UNC_PATHS)
+    else if (strcmp(cmd->path, "//") == 0) {
+        /* Treat UNC path // as an inalienable root */
+        cmd->path = ap_pstrdup(cmd->pool, cmd->path);
+    }
+#endif
+    else {
+	/* Ensure that the pathname is canonical */
+	cmd->path = ap_os_canonical_filename(cmd->pool, cmd->path);
+    }
+
+    old_end_token = cmd->end_token;
+    cmd->end_token = thiscmd->cmd_data ? end_directorymatch_section : end_directory_section;
+    errmsg = ap_srm_command_loop(cmd, new_dir_conf);
+    if (errmsg == NULL) {
+	errmsg = missing_endsection(cmd, 1);
+    }
+    cmd->end_token = old_end_token;
+    if (errmsg != (thiscmd->cmd_data 
+		       ? end_directorymatch_section 
+		   : end_directory_section)) {
+	return errmsg;
+    }
+
+    conf = (core_dir_config *)ap_get_module_config(new_dir_conf, &core_module);
+    conf->r = r;
+
+    ap_add_per_dir_conf(cmd->server, new_dir_conf);
+
+    if (*arg != '\0') {
+	return ap_pstrcat(cmd->pool, "Multiple ", thiscmd->name,
+			  "> arguments not (yet) supported.", NULL);
+    }
+
+    cmd->path = old_path;
+    cmd->override = old_overrides;
+
+    return NULL;
+}
+
+static const char *urlsection(cmd_parms *cmd, void *dummy, const char *arg)
+{
+    const char *errmsg;
+    char *endp = strrchr(arg, '>');
+    int old_overrides = cmd->override;
+    char *old_path = cmd->path;
+    core_dir_config *conf;
+    regex_t *r = NULL;
+    const char *old_end_token;
+    const command_rec *thiscmd = cmd->cmd;
+
+    void *new_url_conf = ap_create_per_dir_config(cmd->pool);
+
+    const char *err = ap_check_cmd_context(cmd,
+					   NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
+    if (err != NULL) {
+        return err;
+    }
+
+    if (endp == NULL) {
+	return unclosed_directive(cmd);
+    }
+
+    *endp = '\0';
+
+    cmd->path = ap_getword_conf(cmd->pool, &arg);
+    cmd->override = OR_ALL|ACCESS_CONF;
+
+    if (thiscmd->cmd_data) { /* <LocationMatch> */
+        r = ap_pregcomp(cmd->pool, cmd->path, REG_EXTENDED);
+        if (!r) {
+            return "Regex could not be compiled";
+        }
+    }
+    else if (!strcmp(cmd->path, "~")) {
+        cmd->path = ap_getword_conf(cmd->pool, &arg);
+        r = ap_pregcomp(cmd->pool, cmd->path, REG_EXTENDED);
+        if (!r) {
+            return "Regex could not be compiled";
+        }
+    }
+
+    old_end_token = cmd->end_token;
+    cmd->end_token = thiscmd->cmd_data ? end_locationmatch_section
+                                       : end_location_section;
+    errmsg = ap_srm_command_loop(cmd, new_url_conf);
+    if (errmsg == NULL) {
+	errmsg = missing_endsection(cmd, 1);
+    }
+    cmd->end_token = old_end_token;
+    if (errmsg != (thiscmd->cmd_data 
+		       ? end_locationmatch_section 
+		       : end_location_section)) {
+	return errmsg;
+    }
+
+    conf = (core_dir_config *)ap_get_module_config(new_url_conf, &core_module);
+    conf->d = ap_pstrdup(cmd->pool, cmd->path);	/* No mangling, please */
+    conf->d_is_fnmatch = ap_is_fnmatch(conf->d) != 0;
+    conf->r = r;
+
+    ap_add_per_url_conf(cmd->server, new_url_conf);
+    
+    if (*arg != '\0') {
+	return ap_pstrcat(cmd->pool, "Multiple ", thiscmd->name,
+			  "> arguments not (yet) supported.", NULL);
+    }
+
+    cmd->path = old_path;
+    cmd->override = old_overrides;
+
+    return NULL;
+}
+
+static const char *filesection(cmd_parms *cmd, core_dir_config *c,
+			       const char *arg)
+{
+    const char *errmsg;
+    char *endp = strrchr(arg, '>');
+    int old_overrides = cmd->override;
+    char *old_path = cmd->path;
+    core_dir_config *conf;
+    regex_t *r = NULL;
+    const char *old_end_token;
+    const command_rec *thiscmd = cmd->cmd;
+
+    void *new_file_conf = ap_create_per_dir_config(cmd->pool);
+
+    const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT|NOT_IN_LOCATION);
+    if (err != NULL) {
+        return err;
+    }
+
+    if (endp == NULL) {
+	return unclosed_directive(cmd);
+    }
+
+    *endp = '\0';
+
+    cmd->path = ap_getword_conf(cmd->pool, &arg);
+    /* Only if not an .htaccess file */
+    if (!old_path) {
+	cmd->override = OR_ALL|ACCESS_CONF;
+    }
+
+    if (thiscmd->cmd_data) { /* <FilesMatch> */
+        r = ap_pregcomp(cmd->pool, cmd->path, REG_EXTENDED|USE_ICASE);
+        if (!r) {
+            return "Regex could not be compiled";
+        }
+    }
+    else if (!strcmp(cmd->path, "~")) {
+        cmd->path = ap_getword_conf(cmd->pool, &arg);
+        r = ap_pregcomp(cmd->pool, cmd->path, REG_EXTENDED|USE_ICASE);
+        if (!r) {
+            return "Regex could not be compiled";
+        }
+    }
+    else {
+	/* Ensure that the pathname is canonical */
+	cmd->path = ap_os_canonical_filename(cmd->pool, cmd->path);
+    }
+
+    old_end_token = cmd->end_token;
+    cmd->end_token = thiscmd->cmd_data ? end_filesmatch_section : end_files_section;
+    errmsg = ap_srm_command_loop(cmd, new_file_conf);
+    if (errmsg == NULL) {
+	errmsg = missing_endsection(cmd, 1);
+    }
+    cmd->end_token = old_end_token;
+    if (errmsg != (thiscmd->cmd_data 
+		       ? end_filesmatch_section 
+		   : end_files_section)) {
+	return errmsg;
+    }
+
+    conf = (core_dir_config *)ap_get_module_config(new_file_conf,
+						   &core_module);
+    conf->d = cmd->path;
+    conf->d_is_fnmatch = ap_is_fnmatch(conf->d) != 0;
+    conf->r = r;
+
+    ap_add_file_conf(c, new_file_conf);
+
+    if (*arg != '\0') {
+	return ap_pstrcat(cmd->pool, "Multiple ", thiscmd->name,
+			  "> arguments not (yet) supported.", NULL);
+    }
+
+    cmd->path = old_path;
+    cmd->override = old_overrides;
+
+    return NULL;
+}
+
+/* XXX: NB: Currently, we have no way of checking
+ * whether <IfModule> sections are closed properly.
+ * Extra (redundant, unpaired) </IfModule> directives are
+ * simply silently ignored.
+ */
+static const char *end_ifmod(cmd_parms *cmd, void *dummy)
+{
+    return NULL;
+}
+
+static const char *start_ifmod(cmd_parms *cmd, void *dummy, char *arg)
+{
+    char *endp = strrchr(arg, '>');
+    char l[MAX_STRING_LEN];
+    int not = (arg[0] == '!');
+    module *found;
+    int nest = 1;
+
+    if (endp == NULL) {
+	return unclosed_directive(cmd);
+    }
+
+    *endp = '\0';
+
+    if (not) {
+        arg++;
+    }
+
+    found = ap_find_linked_module(arg);
+
+    if ((!not && found) || (not && !found)) {
+        return NULL;
+    }
+
+    while (nest && !(ap_cfg_getline(l, MAX_STRING_LEN, cmd->config_file))) {
+        if (!strncasecmp(l, "<IfModule", 9)) {
+	    nest++;
+	}
+	if (!strcasecmp(l, "</IfModule>")) {
+	  nest--;
+	}
+    }
+
+    if (nest) {
+	cmd->end_token = end_ifmodule_section;
+	return missing_endsection(cmd, nest);
+    }
+    return NULL;
+}
+
+API_EXPORT(int) ap_exists_config_define(char *name)
+{
+    char **defines;
+    int i;
+
+    defines = (char **)ap_server_config_defines->elts;
+    for (i = 0; i < ap_server_config_defines->nelts; i++) {
+        if (strcmp(defines[i], name) == 0) {
+            return 1;
+	}
+    }
+    return 0;
+}
+
+static const char *end_ifdefine(cmd_parms *cmd, void *dummy) 
+{
+    return NULL;
+}
+
+static const char *start_ifdefine(cmd_parms *cmd, void *dummy, char *arg)
+{
+    char *endp;
+    char l[MAX_STRING_LEN];
+    int defined;
+    int not = 0;
+    int nest = 1;
+
+    endp = strrchr(arg, '>');
+    if (endp == NULL) {
+	return unclosed_directive(cmd);
+    }
+
+    *endp = '\0';
+
+    if (arg[0] == '!') {
+        not = 1;
+	arg++;
+    }
+
+    defined = ap_exists_config_define(arg);
+
+    if ((!not && defined) || (not && !defined)) {
+	return NULL;
+    }
+
+    while (nest && !(ap_cfg_getline(l, MAX_STRING_LEN, cmd->config_file))) {
+        if (!strncasecmp(l, "<IfDefine", 9)) {
+	    nest++;
+	}
+	if (!strcasecmp(l, "</IfDefine>")) {
+	    nest--;
+	}
+    }
+    if (nest) {
+	cmd->end_token = end_ifdefine_section;
+	return missing_endsection(cmd, nest);
+    }
+    return NULL;
+}
+
+/* httpd.conf commands... beginning with the <VirtualHost> business */
+
+static const char *virtualhost_section(cmd_parms *cmd, void *dummy, char *arg)
+{
+    server_rec *main_server = cmd->server, *s;
+    const char *errmsg;
+    char *endp = strrchr(arg, '>');
+    pool *p = cmd->pool, *ptemp = cmd->temp_pool;
+    const char *old_end_token;
+
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) {
+        return err;
+    }
+
+    if (endp == NULL) {
+	return unclosed_directive(cmd);
+    }
+
+    *endp = '\0';
+    
+    /* FIXME: There's another feature waiting to happen here -- since you
+	can now put multiple addresses/names on a single <VirtualHost>
+	you might want to use it to group common definitions and then
+	define other "subhosts" with their individual differences.  But
+	personally I'd rather just do it with a macro preprocessor. -djg */
+    if (main_server->is_virtual) {
+	return "<VirtualHost> doesn't nest!";
+    }
+    
+    errmsg = ap_init_virtual_host(p, arg, main_server, &s);
+    if (errmsg) {
+	return errmsg;
+    }
+
+    s->next = main_server->next;
+    main_server->next = s;
+
+    s->defn_name = cmd->config_file->name;
+    s->defn_line_number = cmd->config_file->line_number;
+
+    old_end_token = cmd->end_token;
+    cmd->end_token = end_virtualhost_section;
+    cmd->server = s;
+    errmsg = ap_srm_command_loop(cmd, s->lookup_defaults);
+    cmd->server = main_server;
+    if (errmsg == NULL) {
+	errmsg = missing_endsection(cmd, 1);
+    }
+    cmd->end_token = old_end_token;
+
+    if (s->srm_confname) {
+	ap_process_resource_config(s, s->srm_confname, p, ptemp);
+    }
+
+    if (s->access_confname) {
+	ap_process_resource_config(s, s->access_confname, p, ptemp);
+    }
+    
+    if (errmsg == end_virtualhost_section) {
+	return NULL;
+    }
+    return errmsg;
+}
+
+static const char *set_server_alias(cmd_parms *cmd, void *dummy,
+				    const char *arg)
+{
+    if (!cmd->server->names) {
+	return "ServerAlias only used in <VirtualHost>";
+    }
+    while (*arg) {
+	char **item, *name = ap_getword_conf(cmd->pool, &arg);
+	if (ap_is_matchexp(name)) {
+	    item = (char **)ap_push_array(cmd->server->wild_names);
+	}
+	else {
+	    item = (char **)ap_push_array(cmd->server->names);
+	}
+	*item = name;
+    }
+    return NULL;
+}
+
+static const char *add_module_command(cmd_parms *cmd, void *dummy, char *arg)
+{
+    module *modp;
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) {
+        return err;
+    }
+
+    for (modp = top_module; modp; modp = modp->next) {
+        if (modp->name != NULL && strcmp(modp->name, arg) == 0) {
+            ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, cmd->server,
+                          "module %s is already added, skipping", arg);
+            return NULL;
+        }
+    }
+
+    if (!ap_add_named_module(arg)) {
+	return ap_pstrcat(cmd->pool, "Cannot add module via name '", arg, 
+			  "': not in list of loaded modules", NULL);
+    }
+    return NULL;
+}
+
+static const char *clear_module_list_command(cmd_parms *cmd, void *dummy)
+{
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) {
+        return err;
+    }
+
+    ap_clear_module_list();
+    return NULL;
+}
+
+static const char *set_server_string_slot(cmd_parms *cmd, void *dummy,
+					  char *arg)
+{
+    /* This one's pretty generic... */
+  
+    int offset = (int)(long)cmd->info;
+    char *struct_ptr = (char *)cmd->server;
+    
+    const char *err = ap_check_cmd_context(cmd, 
+					   NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
+    if (err != NULL) {
+        return err;
+    }
+
+    *(char **)(struct_ptr + offset) = arg;
+    return NULL;
+}
+
+static const char *server_type(cmd_parms *cmd, void *dummy, char *arg)
+{
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) {
+        return err;
+    }
+
+    if (!strcasecmp(arg, "inetd")) {
+        ap_standalone = 0;
+    }
+    else if (!strcasecmp(arg, "standalone")) {
+        ap_standalone = 1;
+    }
+    else {
+        return "ServerType must be either 'inetd' or 'standalone'";
+    }
+
+    return NULL;
+}
+
+static const char *server_port(cmd_parms *cmd, void *dummy, char *arg)
+{
+    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
+    int port;
+
+    if (err != NULL) {
+	return err;
+    }
+    port = atoi(arg);
+    if (port <= 0 || port >= 65536) { /* 65536 == 1<<16 */
+	return ap_pstrcat(cmd->temp_pool, "The port number \"", arg, 
+			  "\" is outside the appropriate range "
+			  "(i.e., 1..65535).", NULL);
+    }
+    cmd->server->port = port;
+    return NULL;
+}
+
+static const char *set_signature_flag(cmd_parms *cmd, core_dir_config *d, 
+				      char *arg)
+{
+    const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
+    if (err != NULL) {
+        return err;
+    }
+
+    if (strcasecmp(arg, "On") == 0) {
+	d->server_signature = srv_sig_on;
+    }
+    else if (strcasecmp(arg, "Off") == 0) {
+        d->server_signature = srv_sig_off;
+    }
+    else if (strcasecmp(arg, "EMail") == 0) {
+	d->server_signature = srv_sig_withmail;
+    }
+    else {
+	return "ServerSignature: use one of: off | on | email";
+    }
+    return NULL;
+}
+
+static const char *set_send_buffer_size(cmd_parms *cmd, void *dummy, char *arg)
+{
+    int s = atoi(arg);
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) {
+        return err;
+    }
+
+    if (s < 512 && s != 0) {
+        return "SendBufferSize must be >= 512 bytes, or 0 for system default.";
+    }
+    cmd->server->send_buffer_size = s;
+    return NULL;
+}
+
+static const char *set_user(cmd_parms *cmd, void *dummy, char *arg)
+{
+#ifdef WIN32
+    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, cmd->server,
+		 "User directive has no affect on Win32");
+    cmd->server->server_uid = ap_user_id = 1;
+#else
+    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
+    if (err != NULL) {
+        return err;
+    }
+
+    if (!cmd->server->is_virtual) {
+	ap_user_name = arg;
+	cmd->server->server_uid = ap_user_id = ap_uname2id(arg);
+    }
+    else {
+        if (ap_suexec_enabled) {
+	    cmd->server->server_uid = ap_uname2id(arg);
+	}
+	else {
+	    cmd->server->server_uid = ap_user_id;
+	    fprintf(stderr,
+		    "ERROR: User directive in <VirtualHost> "
+		    "requires SUEXEC wrapper.\n");
+	    exit (1);
+	}
+    }
+#if !defined (BIG_SECURITY_HOLE) && !defined (OS2)
+    if (cmd->server->server_uid == 0) {
+	fprintf(stderr,
+		"Error:\tApache has not been designed to serve pages while\n"
+		"\trunning as root.  There are known race conditions that\n"
+		"\twill allow any local user to read any file on the system.\n"
+		"\tIf you still desire to serve pages as root then\n"
+		"\tadd -DBIG_SECURITY_HOLE to the EXTRA_CFLAGS line in your\n"
+		"\tsrc/Configuration file and rebuild the server.  It is\n"
+		"\tstrongly suggested that you instead modify the User\n"
+		"\tdirective in your httpd.conf file to list a non-root\n"
+		"\tuser.\n");
+	exit (1);
+    }
+#endif
+#endif /* WIN32 */
+
+    return NULL;
+}
+
+static const char *set_group(cmd_parms *cmd, void *dummy, char *arg)
+{
+    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
+    if (err != NULL) {
+        return err;
+    }
+
+    if (!cmd->server->is_virtual) {
+	cmd->server->server_gid = ap_group_id = ap_gname2id(arg);
+    }
+    else {
+        if (ap_suexec_enabled) {
+	    cmd->server->server_gid = ap_gname2id(arg);
+	}
+	else {
+	    cmd->server->server_gid = ap_group_id;
+	    fprintf(stderr,
+		    "ERROR: Group directive in <VirtualHost> requires "
+		    "SUEXEC wrapper.\n");
+	    exit (1);
+	}
+    }
+
+    return NULL;
+}
+
+static const char *set_server_root(cmd_parms *cmd, void *dummy, char *arg) 
+{
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+
+    if (err != NULL) {
+        return err;
+    }
+
+    arg = ap_os_canonical_filename(cmd->pool, arg);
+
+    if (!ap_is_directory(arg)) {
+        return "ServerRoot must be a valid directory";
+    }
+    /* ServerRoot is never '/' terminated */
+    while (strlen(ap_server_root) > 1 && ap_server_root[strlen(ap_server_root)-1] == '/')
+        ap_server_root[strlen(ap_server_root)-1] = '\0';
+    ap_cpystrn(ap_server_root, arg,
+	       sizeof(ap_server_root));
+    return NULL;
+}
+
+static const char *set_timeout(cmd_parms *cmd, void *dummy, char *arg)
+{
+    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
+    if (err != NULL) {
+        return err;
+    }
+
+    cmd->server->timeout = atoi(arg);
+    return NULL;
+}
+
+static const char *set_keep_alive_timeout(cmd_parms *cmd, void *dummy,
+					  char *arg)
+{
+    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
+    if (err != NULL) {
+        return err;
+    }
+
+    cmd->server->keep_alive_timeout = atoi(arg);
+    return NULL;
+}
+
+static const char *set_keep_alive(cmd_parms *cmd, void *dummy, char *arg) 
+{
+    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
+    if (err != NULL) {
+        return err;
+    }
+
+    /* We've changed it to On/Off, but used to use numbers
+     * so we accept anything but "Off" or "0" as "On"
+     */
+    if (!strcasecmp(arg, "off") || !strcmp(arg, "0")) {
+	cmd->server->keep_alive = 0;
+    }
+    else {
+	cmd->server->keep_alive = 1;
+    }
+    return NULL;
+}
+
+static const char *set_keep_alive_max(cmd_parms *cmd, void *dummy, char *arg) 
+{
+    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
+    if (err != NULL) {
+        return err;
+    }
+
+    cmd->server->keep_alive_max = atoi(arg);
+    return NULL;
+}
+
+#ifdef AP_ENABLE_EXCEPTION_HOOK
+static const char *set_exception_hook(cmd_parms *cmd, void *dummy, char *arg) 
+{
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) {
+        return err;
+    }
+
+    if (cmd->server->is_virtual) {
+	return "EnableExceptionHook directive not allowed in <VirtualHost>";
+    }
+
+    if (strcasecmp(arg, "on") == 0) {
+        ap_exception_hook_enabled = 1;
+    }
+    else if (strcasecmp(arg, "off") == 0) {
+        ap_exception_hook_enabled = 0;
+    }
+    else {
+        return "parameter must be 'on' or 'off'";
+    }
+
+    return NULL;
+}
+#endif /* AP_ENABLE_EXCEPTION_HOOK */
+
+static const char *set_pidfile(cmd_parms *cmd, void *dummy, char *arg) 
+{
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) {
+        return err;
+    }
+
+    if (cmd->server->is_virtual) {
+	return "PidFile directive not allowed in <VirtualHost>";
+    }
+    ap_pid_fname = arg;
+    return NULL;
+}
+
+static const char *set_scoreboard(cmd_parms *cmd, void *dummy, char *arg) 
+{
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) {
+        return err;
+    }
+
+    ap_scoreboard_fname = arg;
+    return NULL;
+}
+
+static const char *set_lockfile(cmd_parms *cmd, void *dummy, char *arg) 
+{
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) {
+        return err;
+    }
+
+    ap_lock_fname = arg;
+    return NULL;
+}
+
+static const char *set_idcheck(cmd_parms *cmd, core_dir_config *d, int arg) 
+{
+    const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
+    if (err != NULL) {
+        return err;
+    }
+
+    d->do_rfc1413 = arg != 0;
+    return NULL;
+}
+
+static const char *set_hostname_lookups(cmd_parms *cmd, core_dir_config *d,
+					char *arg)
+{
+    const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
+    if (err != NULL) {
+        return err;
+    }
+
+    if (!strcasecmp(arg, "on")) {
+	d->hostname_lookups = HOSTNAME_LOOKUP_ON;
+    }
+    else if (!strcasecmp(arg, "off")) {
+	d->hostname_lookups = HOSTNAME_LOOKUP_OFF;
+    }
+    else if (!strcasecmp(arg, "double")) {
+	d->hostname_lookups = HOSTNAME_LOOKUP_DOUBLE;
+    }
+    else {
+	return "parameter must be 'on', 'off', or 'double'";
+    }
+    return NULL;
+}
+
+static const char *set_serverpath(cmd_parms *cmd, void *dummy, char *arg) 
+{
+    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
+    if (err != NULL) {
+        return err;
+    }
+
+    cmd->server->path = arg;
+    cmd->server->pathlen = strlen(arg);
+    return NULL;
+}
+
+static const char *set_content_md5(cmd_parms *cmd, core_dir_config *d, int arg)
+{
+    const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
+    if (err != NULL) {
+        return err;
+    }
+
+    d->content_md5 = arg != 0;
+    return NULL;
+}
+
+static const char *set_use_canonical_name(cmd_parms *cmd, core_dir_config *d, 
+					  char *arg)
+{
+    const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
+    if (err != NULL) {
+	return err;
+    }
+
+    if (strcasecmp(arg, "on") == 0) {
+        d->use_canonical_name = USE_CANONICAL_NAME_ON;
+    }
+    else if (strcasecmp(arg, "off") == 0) {
+        d->use_canonical_name = USE_CANONICAL_NAME_OFF;
+    }
+    else if (strcasecmp(arg, "dns") == 0) {
+        d->use_canonical_name = USE_CANONICAL_NAME_DNS;
+    }
+    else {
+        return "parameter must be 'on', 'off', or 'dns'";
+    }
+    return NULL;
+}
+
+static const char *set_daemons_to_start(cmd_parms *cmd, void *dummy, char *arg) 
+{
+#ifdef WIN32
+    fprintf(stderr, "WARNING: StartServers has no effect on Win32\n");
+#elif defined(NETWARE)
+    fprintf(stderr, "WARNING: StartServers has no effect on NetWare\n");
+#else
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) {
+        return err;
+    }
+
+    ap_daemons_to_start = atoi(arg);
+#endif
+    return NULL;
+}
+
+static const char *set_min_free_servers(cmd_parms *cmd, void *dummy, char *arg)
+{
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) {
+        return err;
+    }
+
+    ap_daemons_min_free = atoi(arg);
+    if (ap_daemons_min_free <= 0) {
+       fprintf(stderr, "WARNING: detected MinSpareServers set to non-positive.\n");
+       fprintf(stderr, "Resetting to 1 to avoid almost certain Apache failure.\n");
+       fprintf(stderr, "Please read the documentation.\n");
+       ap_daemons_min_free = 1;
+    }
+       
+    return NULL;
+}
+
+static const char *set_max_free_servers(cmd_parms *cmd, void *dummy, char *arg)
+{
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) {
+        return err;
+    }
+
+    ap_daemons_max_free = atoi(arg);
+    return NULL;
+}
+
+static const char *set_server_limit (cmd_parms *cmd, void *dummy, char *arg) 
+{
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) {
+        return err;
+    }
+
+    ap_daemons_limit = atoi(arg);
+    if (ap_daemons_limit > HARD_SERVER_LIMIT) {
+       fprintf(stderr, "WARNING: MaxClients of %d exceeds compile time limit "
+           "of %d servers,\n", ap_daemons_limit, HARD_SERVER_LIMIT);
+       fprintf(stderr, " lowering MaxClients to %d.  To increase, please "
+           "see the\n", HARD_SERVER_LIMIT);
+       fprintf(stderr, " HARD_SERVER_LIMIT define in src/include/httpd.h.\n");
+       ap_daemons_limit = HARD_SERVER_LIMIT;
+    } 
+    else if (ap_daemons_limit < 1) {
+	fprintf(stderr, "WARNING: Require MaxClients > 0, setting to 1\n");
+	ap_daemons_limit = 1;
+    }
+    return NULL;
+}
+
+static const char *set_max_requests(cmd_parms *cmd, void *dummy, char *arg) 
+{
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) {
+        return err;
+    }
+
+    ap_max_requests_per_child = atoi(arg);
+    return NULL;
+}
+
+static const char *set_threads(cmd_parms *cmd, void *dummy, char *arg) {
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) {
+        return err;
+    }
+
+    ap_threads_per_child = atoi(arg);
+    if (ap_threads_per_child > HARD_SERVER_LIMIT) {
+        fprintf(stderr, "WARNING: ThreadsPerChild of %d exceeds compile time limit "
+                "of %d threads,\n", ap_threads_per_child, HARD_SERVER_LIMIT);
+        fprintf(stderr, " lowering ThreadsPerChild to %d.  To increase, please "
+                "see the\n", HARD_SERVER_LIMIT);
+        fprintf(stderr, " HARD_SERVER_LIMIT define in src/include/httpd.h.\n");
+        ap_threads_per_child = HARD_SERVER_LIMIT;
+    } 
+    else if (ap_threads_per_child < 1) {
+	fprintf(stderr, "WARNING: Require ThreadsPerChild > 0, setting to 1\n");
+	ap_threads_per_child = 1;
+    }
+
+    return NULL;
+}
+
+static const char *set_excess_requests(cmd_parms *cmd, void *dummy, char *arg) 
+{
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) {
+        return err;
+    }
+
+    ap_excess_requests_per_child = atoi(arg);
+    return NULL;
+}
+
+
+#if defined(RLIMIT_CPU) || defined(RLIMIT_DATA) || defined(RLIMIT_VMEM) || defined(RLIMIT_NPROC) || defined(RLIMIT_AS)
+static void set_rlimit(cmd_parms *cmd, struct rlimit **plimit, const char *arg,
+                       const char * arg2, int type)
+{
+    char *str;
+    struct rlimit *limit;
+    /* If your platform doesn't define rlim_t then typedef it in ap_config.h */
+    rlim_t cur = 0;
+    rlim_t max = 0;
+
+    *plimit = (struct rlimit *)ap_pcalloc(cmd->pool, sizeof(**plimit));
+    limit = *plimit;
+    if ((getrlimit(type, limit)) != 0)	{
+	*plimit = NULL;
+	ap_log_error(APLOG_MARK, APLOG_ERR, cmd->server,
+		     "%s: getrlimit failed", cmd->cmd->name);
+	return;
+    }
+
+    if ((str = ap_getword_conf(cmd->pool, &arg))) {
+	if (!strcasecmp(str, "max")) {
+	    cur = limit->rlim_max;
+	}
+	else {
+	    cur = atol(str);
+	}
+    }
+    else {
+	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, cmd->server,
+		     "Invalid parameters for %s", cmd->cmd->name);
+	return;
+    }
+    
+    if (arg2 && (str = ap_getword_conf(cmd->pool, &arg2))) {
+	max = atol(str);
+    }
+
+    /* if we aren't running as root, cannot increase max */
+    if (geteuid()) {
+	limit->rlim_cur = cur;
+	if (max) {
+	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, cmd->server,
+			 "Must be uid 0 to raise maximum %s", cmd->cmd->name);
+	}
+    }
+    else {
+        if (cur) {
+	    limit->rlim_cur = cur;
+	}
+        if (max) {
+	    limit->rlim_max = max;
+	}
+    }
+}
+#endif
+
+#if !defined (RLIMIT_CPU) || !(defined (RLIMIT_DATA) || defined (RLIMIT_VMEM) || defined(RLIMIT_AS)) || !defined (RLIMIT_NPROC)
+static const char *no_set_limit(cmd_parms *cmd, core_dir_config *conf,
+				char *arg, char *arg2)
+{
+    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, cmd->server,
+		"%s not supported on this platform", cmd->cmd->name);
+    return NULL;
+}
+#endif
+
+#ifdef RLIMIT_CPU
+static const char *set_limit_cpu(cmd_parms *cmd, core_dir_config *conf, 
+				 char *arg, char *arg2)
+{
+    set_rlimit(cmd, &conf->limit_cpu, arg, arg2, RLIMIT_CPU);
+    return NULL;
+}
+#endif
+
+#if defined (RLIMIT_DATA) || defined (RLIMIT_VMEM) || defined(RLIMIT_AS)
+static const char *set_limit_mem(cmd_parms *cmd, core_dir_config *conf, 
+				 char *arg, char * arg2)
+{
+#if defined(RLIMIT_AS)
+    set_rlimit(cmd, &conf->limit_mem, arg, arg2 ,RLIMIT_AS);
+#elif defined(RLIMIT_DATA)
+    set_rlimit(cmd, &conf->limit_mem, arg, arg2, RLIMIT_DATA);
+#elif defined(RLIMIT_VMEM)
+    set_rlimit(cmd, &conf->limit_mem, arg, arg2, RLIMIT_VMEM);
+#endif
+    return NULL;
+}
+#endif
+
+#ifdef RLIMIT_NPROC
+static const char *set_limit_nproc(cmd_parms *cmd, core_dir_config *conf,  
+				   char *arg, char * arg2)
+{
+    set_rlimit(cmd, &conf->limit_nproc, arg, arg2, RLIMIT_NPROC);
+    return NULL;
+}
+#endif
+
+static const char *set_bind_address(cmd_parms *cmd, void *dummy, char *arg) 
+{
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) {
+        return err;
+    }
+
+    ap_bind_address.s_addr = ap_get_virthost_addr(arg, NULL);
+    return NULL;
+}
+
+#ifdef NETWARE
+static const char *set_threadstacksize(cmd_parms *cmd, void *dummy, char *stacksize)
+{
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) {
+        return err;
+    }
+    
+    ap_thread_stack_size = atoi(stacksize);    
+    return NULL;
+}
+#endif
+
+/* Though the AcceptFilter functionality is not available across
+ * all platforms - we still allow the config directive to appear
+ * on all platforms and do intentionally not tie it to the compile
+ * time flag SO_ACCEPTFILTER. This makes configuration files significantly
+ * more portable; especially as an <IfModule http_core.c> or some
+ * other construct is not possible.
+ */
+static const char *set_acceptfilter(cmd_parms *cmd, void *dummy, int flag)
+{
+#ifdef SO_ACCEPTFILTER
+    ap_acceptfilter = flag;
+#endif
+    return NULL;
+}
+
+static const char *set_listener(cmd_parms *cmd, void *dummy, char *ips)
+{
+    listen_rec *new;
+    char *ports, *endptr;
+    long port;
+    
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) {
+        return err;
+    }
+
+    ports = strchr(ips, ':');
+    if (ports != NULL) {
+	if (ports == ips) {
+	    return "Missing IP address";
+	}
+	else if (ports[1] == '\0') {
+	    return "Address must end in :<port-number>";
+	}
+	*(ports++) = '\0';
+    }
+    else {
+	ports = ips;
+    }
+
+    new=ap_pcalloc(cmd->pool, sizeof(listen_rec));
+    new->local_addr.sin_family = AF_INET;
+    if (ports == ips) { /* no address */
+	new->local_addr.sin_addr.s_addr = htonl(INADDR_ANY);
+    }
+    else {
+	new->local_addr.sin_addr.s_addr = ap_get_virthost_addr(ips, NULL);
+    }
+    errno = 0; /* clear errno before calling strtol */
+    port = ap_strtol(ports, &endptr, 10);
+    if (errno /* some sort of error */
+       || (endptr && *endptr) /* make sure no trailing characters */
+       || port < 1 || port > 65535) /* underflow/overflow */
+    {
+	return "Missing, invalid, or non-numeric port";
+    }
+    new->local_addr.sin_port = htons((unsigned short)port);
+    new->fd = -1;
+    new->used = 0;
+    new->next = ap_listeners;
+    ap_listeners = new;
+    return NULL;
+}
+
+static const char *set_listenbacklog(cmd_parms *cmd, void *dummy, char *arg) 
+{
+    int b;
+
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) {
+        return err;
+    }
+
+    b = atoi(arg);
+    if (b < 1) {
+        return "ListenBacklog must be > 0";
+    }
+    ap_listenbacklog = b;
+    return NULL;
+}
+
+static const char *set_coredumpdir (cmd_parms *cmd, void *dummy, char *arg) 
+{
+    struct stat finfo;
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) {
+        return err;
+    }
+
+    arg = ap_server_root_relative(cmd->pool, arg);
+    if ((stat(arg, &finfo) == -1) || !S_ISDIR(finfo.st_mode)) {
+	return ap_pstrcat(cmd->pool, "CoreDumpDirectory ", arg, 
+			  " does not exist or is not a directory", NULL);
+    }
+    ap_cpystrn(ap_coredump_dir, arg, sizeof(ap_coredump_dir));
+    ap_coredump_dir_configured = 1;
+    return NULL;
+}
+
+static const char *include_config (cmd_parms *cmd, void *dummy, char *name)
+{
+    name = ap_server_root_relative(cmd->pool, name);
+    
+    ap_process_resource_config(cmd->server, name, cmd->pool, cmd->temp_pool);
+
+    return NULL;
+}
+
+static const char *set_loglevel(cmd_parms *cmd, void *dummy, const char *arg) 
+{
+    char *str;
+    
+    const char *err = ap_check_cmd_context(cmd,
+					   NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
+    if (err != NULL) {
+        return err;
+    }
+
+    if ((str = ap_getword_conf(cmd->pool, &arg))) {
+        if (!strcasecmp(str, "emerg")) {
+	    cmd->server->loglevel = APLOG_EMERG;
+	}
+	else if (!strcasecmp(str, "alert")) {
+	    cmd->server->loglevel = APLOG_ALERT;
+	}
+	else if (!strcasecmp(str, "crit")) {
+	    cmd->server->loglevel = APLOG_CRIT;
+	}
+	else if (!strcasecmp(str, "error")) {
+	    cmd->server->loglevel = APLOG_ERR;
+	}
+	else if (!strcasecmp(str, "warn")) {
+	    cmd->server->loglevel = APLOG_WARNING;
+	}
+	else if (!strcasecmp(str, "notice")) {
+	    cmd->server->loglevel = APLOG_NOTICE;
+	}
+	else if (!strcasecmp(str, "info")) {
+	    cmd->server->loglevel = APLOG_INFO;
+	}
+	else if (!strcasecmp(str, "debug")) {
+	    cmd->server->loglevel = APLOG_DEBUG;
+	}
+	else {
+            return "LogLevel requires level keyword: one of "
+	           "emerg/alert/crit/error/warn/notice/info/debug";
+	}
+    }
+    else {
+        return "LogLevel requires level keyword";
+    }
+
+    return NULL;
+}
+
+API_EXPORT(const char *) ap_psignature(const char *prefix, request_rec *r)
+{
+    char sport[20];
+    core_dir_config *conf;
+
+    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
+						   &core_module);
+    if ((conf->server_signature == srv_sig_off)
+	    || (conf->server_signature == srv_sig_unset)) {
+	return "";
+    }
+
+    ap_snprintf(sport, sizeof sport, "%u", (unsigned) ap_get_server_port(r));
+
+    if (conf->server_signature == srv_sig_withmail) {
+	return ap_pstrcat(r->pool, prefix, "<ADDRESS>" SERVER_BASEVERSION
+			  " Server at <A HREF=\"mailto:",
+			  r->server->server_admin, "\">",
+			  ap_escape_html(r->pool, ap_get_server_name(r)), 
+			  "</A> Port ", sport,
+			  "</ADDRESS>\n", NULL);
+    }
+    return ap_pstrcat(r->pool, prefix, "<ADDRESS>" SERVER_BASEVERSION
+		      " Server at ", 
+		      ap_escape_html(r->pool, ap_get_server_name(r)), 
+		      " Port ", sport,
+		      "</ADDRESS>\n", NULL);
+}
+
+/*
+ * Load an authorisation realm into our location configuration, applying the
+ * usual rules that apply to realms.
+ */
+static const char *set_authname(cmd_parms *cmd, void *mconfig, char *word1)
+{
+    core_dir_config *aconfig = (core_dir_config *)mconfig;
+
+    aconfig->ap_auth_name = ap_escape_quotes(cmd->pool, word1);
+    return NULL;
+}
+
+/*
+ * Load an authorisation nonce into our location configuration, and
+ * force it to be in the 0-9/A-Z realm.
+ */
+static const char *set_authnonce (cmd_parms *cmd, void *mconfig, char *word1)
+{
+    core_dir_config *aconfig = (core_dir_config *)mconfig;
+    size_t i;
+
+    aconfig->ap_auth_nonce = ap_escape_quotes(cmd->pool, word1);
+
+    if (strlen(aconfig->ap_auth_nonce) > 510)
+       return "AuthDigestRealmSeed length limited to 510 chars for browser compatibility";
+
+    for(i=0;i<strlen(aconfig->ap_auth_nonce );i++)
+       if (!ap_isalnum(aconfig->ap_auth_nonce [i]))
+         return "AuthDigestRealmSeed limited to 0-9 and A-Z range for browser compatibility";
+
+    return NULL;
+}
+
+
+#ifdef _OSD_POSIX /* BS2000 Logon Passwd file */
+static const char *set_bs2000_account(cmd_parms *cmd, void *dummy, char *name)
+{
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) {
+        return err;
+    }
+
+    return os_set_account(cmd->pool, name);
+}
+#endif /*_OSD_POSIX*/
+
+static const char *set_protocol_req_check(cmd_parms *cmd,
+                                              core_dir_config *d, int arg) 
+{
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) {
+        return err;
+    }
+
+    ap_protocol_req_check = arg != 0;
+    return NULL;
+}
+
+static const char *set_change_shmem_uid(cmd_parms *cmd,
+                                              core_dir_config *d, int arg) 
+{
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) {
+        return err;
+    }
+
+    ap_change_shmem_uid = arg != 0;
+    return NULL;
+}
+
+/*
+ * Handle a request to include the server's OS platform in the Server
+ * response header field (the ServerTokens directive).  Unfortunately
+ * this requires a new global in order to communicate the setting back to
+ * http_main so it can insert the information in the right place in the
+ * string.
+ */
+static const char *set_serv_tokens(cmd_parms *cmd, void *dummy, char *arg) 
+{
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) {
+        return err;
+    }
+
+    if (!strcasecmp(arg, "OS")) {
+        ap_server_tokens = SrvTk_OS;
+    }
+    else if (!strcasecmp(arg, "Min") || !strcasecmp(arg, "Minimal")) {
+        ap_server_tokens = SrvTk_MIN;
+    }
+    else if (!strcasecmp(arg, "Full")) {
+        ap_server_tokens = SrvTk_FULL;
+    }
+    else if (!strcasecmp(arg, "Prod") || !strcasecmp(arg, "ProductOnly")) {
+        ap_server_tokens = SrvTk_PRODUCT_ONLY;
+    }
+    else {
+	return ap_pstrcat(cmd->pool, "Unrecognised ServerTokens keyword: ",
+			  arg, NULL);
+    }
+    return NULL;
+}
+
+static const char *set_limit_req_line(cmd_parms *cmd, void *dummy, char *arg)
+{
+    const char *err = ap_check_cmd_context(cmd,
+                                           NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
+    int lim;
+
+    if (err != NULL) {
+        return err;
+    }
+    lim = atoi(arg);
+    if (lim < 0) {
+        return ap_pstrcat(cmd->temp_pool, "LimitRequestLine \"", arg, 
+                          "\" must be a non-negative integer", NULL);
+    }
+    if (lim > DEFAULT_LIMIT_REQUEST_LINE) {
+        return ap_psprintf(cmd->temp_pool, "LimitRequestLine \"%s\" "
+                           "must not exceed the precompiled maximum of %d",
+                           arg, DEFAULT_LIMIT_REQUEST_LINE);
+    }
+    cmd->server->limit_req_line = lim;
+    return NULL;
+}
+
+static const char *set_limit_req_fieldsize(cmd_parms *cmd, void *dummy,
+                                           char *arg)
+{
+    const char *err = ap_check_cmd_context(cmd,
+                                           NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
+    int lim;
+
+    if (err != NULL) {
+        return err;
+    }
+    lim = atoi(arg);
+    if (lim < 0) {
+        return ap_pstrcat(cmd->temp_pool, "LimitRequestFieldsize \"", arg, 
+                          "\" must be a non-negative integer (0 = no limit)",
+                          NULL);
+    }
+    if (lim > DEFAULT_LIMIT_REQUEST_FIELDSIZE) {
+        return ap_psprintf(cmd->temp_pool, "LimitRequestFieldsize \"%s\" "
+                          "must not exceed the precompiled maximum of %d",
+                           arg, DEFAULT_LIMIT_REQUEST_FIELDSIZE);
+    }
+    cmd->server->limit_req_fieldsize = lim;
+    return NULL;
+}
+
+static const char *set_limit_req_fields(cmd_parms *cmd, void *dummy, char *arg)
+{
+    const char *err = ap_check_cmd_context(cmd,
+                                           NOT_IN_DIR_LOC_FILE|NOT_IN_LIMIT);
+    int lim;
+
+    if (err != NULL) {
+        return err;
+    }
+    lim = atoi(arg);
+    if (lim < 0) {
+        return ap_pstrcat(cmd->temp_pool, "LimitRequestFields \"", arg, 
+                          "\" must be a non-negative integer (0 = no limit)",
+                          NULL);
+    }
+    cmd->server->limit_req_fields = lim;
+    return NULL;
+}
+
+static const char *set_limit_req_body(cmd_parms *cmd, core_dir_config *conf,
+                                      char *arg) 
+{
+    const char *err = ap_check_cmd_context(cmd, NOT_IN_LIMIT);
+    if (err != NULL) {
+        return err;
+    }
+
+    /* WTF: If strtoul is not portable, then write a replacement.
+     *      Instead we have an idiotic define in httpd.h that prevents
+     *      it from being used even when it is available. Sheesh.
+     */
+    conf->limit_req_body = (unsigned long)ap_strtol(arg, (char **)NULL, 10);
+    return NULL;
+}
+
+#ifdef WIN32
+static const char *set_interpreter_source(cmd_parms *cmd, core_dir_config *d,
+                                                char *arg)
+{
+    if (!strcasecmp(arg, "registry")) {
+        d->script_interpreter_source = INTERPRETER_SOURCE_REGISTRY;
+    } else if (!strcasecmp(arg, "script")) {
+        d->script_interpreter_source = INTERPRETER_SOURCE_SHEBANG;
+    } else {
+        return ap_pstrcat(cmd->temp_pool, "ScriptInterpreterSource \"", arg, 
+                          "\" must be \"registry\" or \"script\"",
+                          NULL);
+    }
+    return NULL;
+}
+#endif
+
+static const char *set_cgi_command_args(cmd_parms *cmd,
+                                              void *mconfig,
+                                              int arg)
+{
+    core_dir_config *cfg = (core_dir_config *)mconfig;
+    cfg->cgi_command_args = arg ? AP_FLAG_ON : AP_FLAG_OFF;
+    return NULL;
+}
+
+#ifdef CHARSET_EBCDIC
+
+typedef struct {
+  char conv_out[2];
+  char conv_in[2];
+} parsed_conf_t;
+
+/* Check for conversion syntax:  { On | Off } [ = { In | Out | InOut } ] */
+static parsed_conf_t *
+parse_on_off_in_out(pool *p, char *arg)
+{
+    static parsed_conf_t ret = { { conv_Unset, '\0' }, { conv_Unset, '\0' } };
+    char *onoff = ap_getword_nc(p, &arg, '=');
+    int in = 0, out = 0, inout = 0;
+    char conv_val;
+
+    /* Check for valid syntax:  { On | Off } [ = { In | Out | InOut } ] */
+    if (strcasecmp(onoff, "On") == 0)
+        conv_val = conv_On;
+    else if (strcasecmp(onoff, "Off") == 0)
+        conv_val = conv_Off;
+    else
+        return NULL;
+
+    /* Check the syntax, and at the same time assign the test results */
+    if (!(inout = (*arg == '\0')) &&
+        !(in = (strcasecmp(arg, "In") == 0)) &&
+        !(out = (strcasecmp(arg, "Out") == 0)) &&
+        !(inout = (strcasecmp(arg, "InOut") == 0))) {
+        /* Invalid string, not conforming to syntax! */
+        return NULL;
+    }
+
+    ret.conv_in[0]  = (in || inout)  ? conv_val : conv_Unset;
+    ret.conv_out[0] = (out || inout) ? conv_val : conv_Unset;
+
+    return &ret;
+}
+
+
+/* Handle the EBCDICConvert directive:
+ *   EBCDICConvert {On|Off}[={In|Out|InOut}] ext ...
+ */
+static const char *
+add_conversion_by_ext(cmd_parms *cmd, core_dir_config *m,
+		      char *onoff, char *ext)
+{
+    parsed_conf_t *onoff_code = parse_on_off_in_out(cmd->pool, onoff);
+
+    if (onoff_code == NULL)
+        return "Invalid syntax: use EBCDICConvert {On|Off}[={In|Out|InOut}] ext [...]";
+
+    if (*ext == '.')
+        ++ext;
+
+    if (*onoff_code->conv_in != conv_Unset)
+	ap_table_addn(m->ebcdicconversion_by_ext_in, ext,
+		      ap_pstrndup(cmd->pool, onoff_code->conv_in, 1));
+    if (*onoff_code->conv_out != conv_Unset)
+	ap_table_addn(m->ebcdicconversion_by_ext_out, ext,
+		      ap_pstrndup(cmd->pool, onoff_code->conv_out, 1));
+
+    return NULL;
+}
+
+
+/* Handle the EBCDICConvertByType directive:
+ *   EBCDICConvertByType {On|Off}[={In|Out|InOut}] mimetype ...
+ */
+static const char *
+add_conversion_by_type(cmd_parms *cmd, core_dir_config *m,
+		       char *onoff, char *type)
+{
+    parsed_conf_t *onoff_code = parse_on_off_in_out(cmd->pool, onoff);
+
+    if (onoff_code == NULL)
+        return "Invalid syntax: use EBCDICConvertByType {On|Off}[={In|Out|InOut}] mimetype [...]";
+
+    if (*onoff_code->conv_in != conv_Unset)
+	ap_table_addn(m->ebcdicconversion_by_type_in, type,
+		      ap_pstrndup(cmd->pool, onoff_code->conv_in, 1));
+    if (*onoff_code->conv_out != conv_Unset)
+	ap_table_addn(m->ebcdicconversion_by_type_out, type,
+		      ap_pstrndup(cmd->pool, onoff_code->conv_out, 1));
+
+    return NULL;
+}
+
+
+/* Handle the EBCDICKludge directive:
+ *   EBCDICKludge {On|Off}
+ */
+#ifdef LEGACY_KLUDGE
+static const char *
+set_x_ascii_kludge(cmd_parms *cmd, core_dir_config *m, int arg)
+{
+    m->x_ascii_magic_kludge = arg;
+
+    return NULL;
+}
+#endif
+
+#if ADD_EBCDICCONVERT_DEBUG_HEADER
+/* Handle the EBCDICDebugHeader directive:
+ *   EBCDICDebugHeader {On|Off}
+ */
+static const char *
+set_debug_header(cmd_parms *cmd, core_dir_config *m, int arg)
+{
+    m->ebcdicconversion_debug_header = arg;
+
+    return NULL;
+}
+#endif
+#endif /* CHARSET_EBCDIC */
+
+/*
+ * Note what data should be used when forming file ETag values.
+ * It would be nicer to do this as an ITERATE, but then we couldn't
+ * remember the +/- state properly.
+ */
+static const char *set_etag_bits(cmd_parms *cmd, void *mconfig,
+                                 const char *args_p)
+{
+    core_dir_config *cfg;
+    etag_components_t bit;
+    char action;
+    char *token;
+    const char *args;
+    int valid;
+    int first;
+    int explicit;
+
+    cfg = (core_dir_config *) mconfig;
+
+    args = args_p;
+    first = 1;
+    explicit = 0;
+    while (args[0] != '\0') {
+        action = '*';
+        bit = ETAG_UNSET;
+        valid = 1;
+        token = ap_getword_conf(cmd->pool, &args);
+        if ((*token == '+') || (*token == '-')) {
+            action = *token;
+            token++;
+        }
+        else {
+            /*
+             * The occurrence of an absolute setting wipes
+             * out any previous relative ones.  The first such
+             * occurrence forgets any inherited ones, too.
+             */
+            if (first) {
+                cfg->etag_bits = ETAG_UNSET;
+                cfg->etag_add = ETAG_UNSET;
+                cfg->etag_remove = ETAG_UNSET;
+                first = 0;
+            }
+        }
+
+        if (strcasecmp(token, "None") == 0) {
+            if (action != '*') {
+                valid = 0;
+            }
+            else {
+                cfg->etag_bits = bit = ETAG_NONE;
+                explicit = 1;
+            }
+        }
+        else if (strcasecmp(token, "All") == 0) {
+            if (action != '*') {
+                valid = 0;
+            }
+            else {
+                explicit = 1;
+                cfg->etag_bits = bit = ETAG_ALL;
+            }
+        }
+        else if (strcasecmp(token, "Size") == 0) {
+            bit = ETAG_SIZE;
+        }
+        else if ((strcasecmp(token, "LMTime") == 0)
+                 || (strcasecmp(token, "MTime") == 0)
+                 || (strcasecmp(token, "LastModified") == 0)) {
+            bit = ETAG_MTIME;
+        }
+        else if (strcasecmp(token, "INode") == 0) {
+            bit = ETAG_INODE;
+        }
+        else {
+            return ap_pstrcat(cmd->pool, "Unknown keyword '",
+                              token, "' for ", cmd->cmd->name,
+                              " directive", NULL);
+        }
+
+        if (! valid) {
+            return ap_pstrcat(cmd->pool, cmd->cmd->name, " keyword '",
+                              token, "' cannot be used with '+' or '-'",
+                              NULL);
+        }
+
+        if (action == '+') {
+            /*
+             * Make sure it's in the 'add' list and absent from the
+             * 'subtract' list.
+             */
+            cfg->etag_add |= bit;
+            cfg->etag_remove &= (~ bit);
+        }
+        else if (action == '-') {
+            cfg->etag_remove |= bit;
+            cfg->etag_add &= (~ bit);
+        }
+        else {
+            /*
+             * Non-relative values wipe out any + or - values
+             * accumulated so far.
+             */
+            cfg->etag_bits |= bit;
+            cfg->etag_add = ETAG_UNSET;
+            cfg->etag_remove = ETAG_UNSET;
+            explicit = 1;
+        }
+    }
+
+    /*
+     * Any setting at all will clear the 'None' and 'Unset' bits.
+     */
+
+    if (cfg->etag_add != ETAG_UNSET) {
+        cfg->etag_add &= (~ ETAG_UNSET);
+    }
+    if (cfg->etag_remove != ETAG_UNSET) {
+        cfg->etag_remove &= (~ ETAG_UNSET);
+    }
+    if (explicit) {
+        cfg->etag_bits &= (~ ETAG_UNSET);
+        if ((cfg->etag_bits & ETAG_NONE) != ETAG_NONE) {
+            cfg->etag_bits &= (~ ETAG_NONE);
+        }
+    }
+    return NULL;
+}
+
+static const char *set_recursion_limit(cmd_parms *cmd, void *dummy,
+                                       const char *arg1, const char *arg2)
+{
+    core_server_config *conf = ap_get_module_config(cmd->server->module_config,
+                                                    &core_module);
+    int limit = atoi(arg1);
+
+    if (limit < 0) {
+        return "The redirect recursion limit cannot be less than zero.";
+    }
+    if (limit && limit < 4) {
+        ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, cmd->server,
+                     "Limiting internal redirects to very low numbers may "
+                     "cause normal requests to fail.");
+    }
+
+    conf->redirect_limit = limit;
+
+    if (arg2) {
+        limit = atoi(arg2);
+
+        if (limit < 0) {
+            return "The subrequest recursion limit cannot be less than zero.";
+        }
+        if (limit && limit < 4) {
+            ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, cmd->server,
+                         "Limiting the subrequest depth to a very low level may"
+                         " cause normal requests to fail.");
+        }
+    }
+
+    conf->subreq_limit = limit;
+    conf->recursion_limit_set = 1;
+
+    return NULL;
+}
+
+static void log_backtrace(const request_rec *r)
+{
+    const request_rec *top = r;
+
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r,
+                  "r->uri = %s", r->uri ? r->uri : "(unexpectedly NULL)");
+
+    while (top && (top->prev || top->main)) {
+        if (top->prev) {
+            top = top->prev;
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r,
+                          "redirected from r->uri = %s",
+                          top->uri ? top->uri : "(unexpectedly NULL)");
+        }
+
+        if (!top->prev && top->main) {
+            top = top->main;
+            ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r,
+                          "subrequested from r->uri = %s",
+                          top->uri ? top->uri : "(unexpectedly NULL)");
+        }
+    }
+}
+
+/*
+ * check whether redirect limit is reached
+ */
+API_EXPORT(int) ap_is_recursion_limit_exceeded(const request_rec *r)
+{
+    core_server_config *conf = ap_get_module_config(r->server->module_config,
+                                                    &core_module);
+    const request_rec *top = r;
+    int redirects = 0, subreqs = 0;
+    int rlimit = conf->recursion_limit_set
+                 ? conf->redirect_limit
+                 : AP_DEFAULT_MAX_INTERNAL_REDIRECTS;
+    int slimit = conf->recursion_limit_set
+                 ? conf->subreq_limit
+                 : AP_DEFAULT_MAX_SUBREQ_DEPTH;
+
+    /* fast exit (unlimited) */
+    if (!rlimit && !slimit) {
+        return 0;
+    }
+
+    while (top->prev || top->main) {
+        if (top->prev) {
+            if (rlimit && ++redirects >= rlimit) {
+                /* uuh, too much. */
+                ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, r,
+                              "Request exceeded the limit of %d internal "
+                              "redirects due to probable configuration error. "
+                              "Use 'LimitInternalRecursion' to increase the "
+                              "limit if necessary. Use 'LogLevel debug' to get "
+                              "a backtrace.", rlimit);
+
+                /* post backtrace */
+                log_backtrace(r);
+
+                /* return failure */
+                return 1;
+            }
+
+            top = top->prev;
+        }
+
+        if (!top->prev && top->main) {
+            if (slimit && ++subreqs >= slimit) {
+                /* uuh, too much. */
+                ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, r,
+                              "Request exceeded the limit of %d subrequest "
+                              "nesting levels due to probable confguration "
+                              "error. Use 'LimitInternalRecursion' to increase "
+                              "the limit if necessary. Use 'LogLevel debug' to "
+                              "get a backtrace.", slimit);
+
+                /* post backtrace */
+                log_backtrace(r);
+
+                /* return failure */
+                return 1;
+            }
+
+            top = top->main;
+        }
+    }
+
+    /* recursion state: ok */
+    return 0;
+}
+
+/* Note --- ErrorDocument will now work from .htaccess files.  
+ * The AllowOverride of Fileinfo allows webmasters to turn it off
+ */
+
+static const command_rec core_cmds[] = {
+
+/* Old access config file commands */
+
+{ "<Directory", dirsection, NULL, RSRC_CONF, RAW_ARGS,
+  "Container for directives affecting resources located in the specified "
+  "directories" },
+{ end_directory_section, end_nested_section, NULL, ACCESS_CONF, NO_ARGS,
+  "Marks end of <Directory>" },
+{ "<Location", urlsection, NULL, RSRC_CONF, RAW_ARGS,
+  "Container for directives affecting resources accessed through the "
+  "specified URL paths" },
+{ end_location_section, end_nested_section, NULL, ACCESS_CONF, NO_ARGS,
+  "Marks end of <Location>" },
+{ "<VirtualHost", virtualhost_section, NULL, RSRC_CONF, RAW_ARGS,
+  "Container to map directives to a particular virtual host, takes one or "
+  "more host addresses" },
+{ end_virtualhost_section, end_nested_section, NULL, RSRC_CONF, NO_ARGS,
+  "Marks end of <VirtualHost>" },
+{ "<Files", filesection, NULL, OR_ALL, RAW_ARGS, "Container for directives "
+  "affecting files matching specified patterns" },
+{ end_files_section, end_nested_section, NULL, OR_ALL, NO_ARGS,
+  "Marks end of <Files>" },
+{ "<Limit", ap_limit_section, NULL, OR_ALL, RAW_ARGS, "Container for "
+  "authentication directives when accessed using specified HTTP methods" },
+{ "</Limit>", endlimit_section, NULL, OR_ALL, NO_ARGS,
+  "Marks end of <Limit>" },
+{ "<LimitExcept", ap_limit_section, (void*)1, OR_ALL, RAW_ARGS,
+  "Container for authentication directives to be applied when any HTTP "
+  "method other than those specified is used to access the resource" },
+{ "</LimitExcept>", endlimit_section, (void*)1, OR_ALL, NO_ARGS,
+  "Marks end of <LimitExcept>" },
+{ "<IfModule", start_ifmod, NULL, OR_ALL, TAKE1,
+  "Container for directives based on existance of specified modules" },
+{ end_ifmodule_section, end_ifmod, NULL, OR_ALL, NO_ARGS,
+  "Marks end of <IfModule>" },
+{ "<IfDefine", start_ifdefine, NULL, OR_ALL, TAKE1,
+  "Container for directives based on existance of command line defines" },
+{ end_ifdefine_section, end_ifdefine, NULL, OR_ALL, NO_ARGS,
+  "Marks end of <IfDefine>" },
+{ "<DirectoryMatch", dirsection, (void*)1, RSRC_CONF, RAW_ARGS,
+  "Container for directives affecting resources located in the "
+  "specified directories" },
+{ end_directorymatch_section, end_nested_section, NULL, ACCESS_CONF, NO_ARGS,
+  "Marks end of <DirectoryMatch>" },
+{ "<LocationMatch", urlsection, (void*)1, RSRC_CONF, RAW_ARGS,
+  "Container for directives affecting resources accessed through the "
+  "specified URL paths" },
+{ end_locationmatch_section, end_nested_section, NULL, ACCESS_CONF, NO_ARGS,
+  "Marks end of <LocationMatch>" },
+{ "<FilesMatch", filesection, (void*)1, OR_ALL, RAW_ARGS,
+  "Container for directives affecting files matching specified patterns" },
+{ end_filesmatch_section, end_nested_section, NULL, OR_ALL, NO_ARGS,
+  "Marks end of <FilesMatch>" },
+{ "AuthType", ap_set_string_slot,
+  (void*)XtOffsetOf(core_dir_config, ap_auth_type), OR_AUTHCFG, TAKE1,
+  "An HTTP authorization type (e.g., \"Basic\")" },
+{ "AuthName", set_authname, NULL, OR_AUTHCFG, TAKE1,
+  "The authentication realm (e.g. \"Members Only\")" },
+{ "AuthDigestRealmSeed", set_authnonce, NULL, OR_AUTHCFG, TAKE1,
+  "An authentication token which should be different for each logical realm. "\
+  "A random value or the servers IP may be a good choise.\n" },
+{ "Require", require, NULL, OR_AUTHCFG, RAW_ARGS,
+  "Selects which authenticated users or groups may access a protected space" },
+{ "Satisfy", satisfy, NULL, OR_AUTHCFG, TAKE1,
+  "access policy if both allow and require used ('all' or 'any')" },    
+#ifdef GPROF
+{ "GprofDir", set_gprof_dir, NULL, RSRC_CONF, TAKE1,
+  "Directory to plop gmon.out files" },
+#endif
+{ "AddDefaultCharset", set_add_default_charset, NULL, OR_FILEINFO, 
+  TAKE1, "The name of the default charset to add to any Content-Type without one or 'Off' to disable" },
+
+/* Old resource config file commands */
+  
+{ "AccessFileName", set_access_name, NULL, RSRC_CONF, RAW_ARGS,
+  "Name(s) of per-directory config files (default: .htaccess)" },
+{ "DocumentRoot", set_document_root, NULL, RSRC_CONF, TAKE1,
+  "Root directory of the document tree"  },
+{ "ErrorDocument", set_error_document, NULL, OR_FILEINFO, RAW_ARGS,
+  "Change responses for HTTP errors" },
+{ "AllowOverride", set_override, NULL, ACCESS_CONF, RAW_ARGS,
+  "Controls what groups of directives can be configured by per-directory "
+  "config files" },
+{ "Options", set_options, NULL, OR_OPTIONS, RAW_ARGS,
+  "Set a number of attributes for a given directory" },
+{ "DefaultType", ap_set_string_slot,
+  (void*)XtOffsetOf (core_dir_config, ap_default_type),
+  OR_FILEINFO, TAKE1, "the default MIME type for untypable files" },
+
+/* Old server config file commands */
+
+{ "ServerType", server_type, NULL, RSRC_CONF, TAKE1,
+  "'inetd' or 'standalone'"},
+{ "Port", server_port, NULL, RSRC_CONF, TAKE1, "A TCP port number"},
+{ "HostnameLookups", set_hostname_lookups, NULL, ACCESS_CONF|RSRC_CONF, TAKE1,
+  "\"on\" to enable, \"off\" to disable reverse DNS lookups, or \"double\" to "
+  "enable double-reverse DNS lookups" },
+{ "User", set_user, NULL, RSRC_CONF, TAKE1,
+  "Effective user id for this server"},
+{ "Group", set_group, NULL, RSRC_CONF, TAKE1,
+  "Effective group id for this server"},
+{ "ServerAdmin", set_server_string_slot,
+  (void *)XtOffsetOf (server_rec, server_admin), RSRC_CONF, TAKE1,
+  "The email address of the server administrator" },
+{ "ServerName", set_server_string_slot,
+  (void *)XtOffsetOf (server_rec, server_hostname), RSRC_CONF, TAKE1,
+  "The hostname of the server" },
+{ "ServerSignature", set_signature_flag, NULL, OR_ALL, TAKE1,
+  "En-/disable server signature (on|off|email)" },
+{ "ServerRoot", set_server_root, NULL, RSRC_CONF, TAKE1,
+  "Common directory of server-related files (logs, confs, etc.)" },
+{ "ErrorLog", set_server_string_slot,
+  (void *)XtOffsetOf (server_rec, error_fname), RSRC_CONF, TAKE1,
+  "The filename of the error log" },
+{ "PidFile", set_pidfile, NULL, RSRC_CONF, TAKE1,
+    "A file for logging the server process ID"},
+{ "ScoreBoardFile", set_scoreboard, NULL, RSRC_CONF, TAKE1,
+    "A file for Apache to maintain runtime process management information"},
+{ "LockFile", set_lockfile, NULL, RSRC_CONF, TAKE1,
+    "The lockfile used when Apache needs to lock the accept() call"},
+{ "AccessConfig", set_server_string_slot,
+  (void *)XtOffsetOf (server_rec, access_confname), RSRC_CONF, TAKE1,
+  "The filename of the access config file" },
+{ "ResourceConfig", set_server_string_slot,
+  (void *)XtOffsetOf (server_rec, srm_confname), RSRC_CONF, TAKE1,
+  "The filename of the resource config file" },
+{ "ServerAlias", set_server_alias, NULL, RSRC_CONF, RAW_ARGS,
+  "A name or names alternately used to access the server" },
+{ "ServerPath", set_serverpath, NULL, RSRC_CONF, TAKE1,
+  "The pathname the server can be reached at" },
+{ "Timeout", set_timeout, NULL, RSRC_CONF, TAKE1, "Timeout duration (sec)" },
+{ "KeepAliveTimeout", set_keep_alive_timeout, NULL, RSRC_CONF, TAKE1,
+  "Keep-Alive timeout duration (sec)"},
+{ "MaxKeepAliveRequests", set_keep_alive_max, NULL, RSRC_CONF, TAKE1,
+  "Maximum number of Keep-Alive requests per connection, or 0 for infinite" },
+{ "KeepAlive", set_keep_alive, NULL, RSRC_CONF, TAKE1,
+  "Whether persistent connections should be On or Off" },
+{ "IdentityCheck", set_idcheck, NULL, RSRC_CONF|ACCESS_CONF, FLAG,
+  "Enable identd (RFC 1413) user lookups - SLOW" },
+{ "ContentDigest", set_content_md5, NULL, OR_OPTIONS,
+  FLAG, "whether or not to send a Content-MD5 header with each request" },
+{ "UseCanonicalName", set_use_canonical_name, NULL,
+  RSRC_CONF|ACCESS_CONF, TAKE1,
+  "How to work out the ServerName : Port when constructing URLs" },
+{ "StartServers", set_daemons_to_start, NULL, RSRC_CONF, TAKE1,
+  "Number of child processes launched at server startup" },
+{ "MinSpareServers", set_min_free_servers, NULL, RSRC_CONF, TAKE1,
+  "Minimum number of idle children, to handle request spikes" },
+{ "MaxSpareServers", set_max_free_servers, NULL, RSRC_CONF, TAKE1,
+  "Maximum number of idle children" },
+{ "MaxServers", set_max_free_servers, NULL, RSRC_CONF, TAKE1,
+  "Deprecated equivalent to MaxSpareServers" },
+{ "ServersSafetyLimit", set_server_limit, NULL, RSRC_CONF, TAKE1,
+  "Deprecated equivalent to MaxClients" },
+{ "MaxClients", set_server_limit, NULL, RSRC_CONF, TAKE1,
+  "Maximum number of children alive at the same time" },
+{ "MaxRequestsPerChild", set_max_requests, NULL, RSRC_CONF, TAKE1,
+  "Maximum number of requests a particular child serves before dying." },
+{ "RLimitCPU",
+#ifdef RLIMIT_CPU
+  set_limit_cpu, (void*)XtOffsetOf(core_dir_config, limit_cpu),
+#else
+  no_set_limit, NULL,
+#endif
+  OR_ALL, TAKE12, "Soft/hard limits for max CPU usage in seconds" },
+{ "RLimitMEM",
+#if defined (RLIMIT_DATA) || defined (RLIMIT_VMEM) || defined (RLIMIT_AS)
+  set_limit_mem, (void*)XtOffsetOf(core_dir_config, limit_mem),
+#else
+  no_set_limit, NULL,
+#endif
+  OR_ALL, TAKE12, "Soft/hard limits for max memory usage per process" },
+{ "RLimitNPROC",
+#ifdef RLIMIT_NPROC
+  set_limit_nproc, (void*)XtOffsetOf(core_dir_config, limit_nproc),
+#else
+  no_set_limit, NULL,
+#endif
+   OR_ALL, TAKE12, "soft/hard limits for max number of processes per uid" },
+{ "BindAddress", set_bind_address, NULL, RSRC_CONF, TAKE1,
+  "'*', a numeric IP address, or the name of a host with a unique IP address"},
+#ifdef NETWARE
+{ "ThreadStackSize", set_threadstacksize, NULL, RSRC_CONF, TAKE1,
+  "Stack size each created thread will use."},
+#endif
+{ "Listen", set_listener, NULL, RSRC_CONF, TAKE1,
+  "A port number or a numeric IP address and a port number"},
+{ "SendBufferSize", set_send_buffer_size, NULL, RSRC_CONF, TAKE1,
+  "Send buffer size in bytes"},
+{ "AddModule", add_module_command, NULL, RSRC_CONF, ITERATE,
+  "The name of a module" },
+{ "ClearModuleList", clear_module_list_command, NULL, RSRC_CONF, NO_ARGS, 
+  NULL },
+{ "ThreadsPerChild", set_threads, NULL, RSRC_CONF, TAKE1,
+  "Number of threads a child creates" },
+{ "ExcessRequestsPerChild", set_excess_requests, NULL, RSRC_CONF, TAKE1,
+  "Maximum number of requests a particular child serves after it is ready "
+  "to die." },
+{ "ListenBacklog", set_listenbacklog, NULL, RSRC_CONF, TAKE1,
+  "Maximum length of the queue of pending connections, as used by listen(2)" },
+{ "AcceptFilter", set_acceptfilter, NULL, RSRC_CONF, FLAG,
+  "Switch AcceptFiltering on/off (default is "
+#ifdef AP_ACCEPTFILTER_OFF
+	"off"
+#else
+	"on"
+#endif
+	")."
+#ifndef SO_ACCEPTFILTER
+	"This feature is currently not compiled in; so this directive "
+	"is ignored."
+#endif
+   },
+{ "CoreDumpDirectory", set_coredumpdir, NULL, RSRC_CONF, TAKE1,
+  "The location of the directory Apache changes to before dumping core" },
+{ "Include", include_config, NULL, (RSRC_CONF | ACCESS_CONF), TAKE1,
+  "Name of the config file to be included" },
+{ "LogLevel", set_loglevel, NULL, RSRC_CONF, TAKE1,
+  "Level of verbosity in error logging" },
+{ "NameVirtualHost", ap_set_name_virtual_host, NULL, RSRC_CONF, TAKE1,
+  "A numeric IP address:port, or the name of a host" },
+#ifdef _OSD_POSIX
+{ "BS2000Account", set_bs2000_account, NULL, RSRC_CONF, TAKE1,
+  "Name of server User's bs2000 logon account name" },
+#endif
+#ifdef WIN32
+{ "ScriptInterpreterSource", set_interpreter_source, NULL, OR_FILEINFO, TAKE1,
+  "Where to find interpreter to run Win32 scripts - Registry or Script (shebang line)" },
+#endif
+{ "CGICommandArgs", set_cgi_command_args, NULL, OR_OPTIONS, FLAG,
+  "Allow or Disallow CGI requests to pass args on the command line" },
+{ "ServerTokens", set_serv_tokens, NULL, RSRC_CONF, TAKE1,
+  "Tokens displayed in the Server: header - Min[imal], OS, Prod[uctOnly], Full" },
+{ "LimitRequestLine", set_limit_req_line, NULL, RSRC_CONF, TAKE1,
+  "Limit on maximum size of an HTTP request line"},
+{ "LimitRequestFieldsize", set_limit_req_fieldsize, NULL, RSRC_CONF, TAKE1,
+  "Limit on maximum size of an HTTP request header field"},
+{ "LimitRequestFields", set_limit_req_fields, NULL, RSRC_CONF, TAKE1,
+  "Limit (0 = unlimited) on max number of header fields in a request message"},
+{ "LimitRequestBody", set_limit_req_body,
+  (void*)XtOffsetOf(core_dir_config, limit_req_body),
+  OR_ALL, TAKE1,
+  "Limit (in bytes) on maximum size of request message body" },
+{ "ProtocolReqCheck", set_protocol_req_check, NULL, RSRC_CONF, FLAG,
+  "Enable strict checking of Protocol type in requests" },
+{ "ShmemUIDisUser", set_change_shmem_uid, NULL, RSRC_CONF, FLAG,
+  "Enable the setting of SysV shared memory scoreboard uid/gid to User/Group" },
+{ "AcceptMutex", set_accept_mutex, NULL, RSRC_CONF, TAKE1,
+  "Serialized Accept Mutex; the methods " 
+#ifdef HAVE_USLOCK_SERIALIZED_ACCEPT
+    "'uslock' "                           
+#endif
+#ifdef HAVE_PTHREAD_SERIALIZED_ACCEPT
+    "'pthread' "
+#endif
+#ifdef HAVE_SYSVSEM_SERIALIZED_ACCEPT
+    "'sysvsem' "
+#endif
+#ifdef HAVE_FCNTL_SERIALIZED_ACCEPT
+    "'fcntl' "
+#endif
+#ifdef HAVE_FLOCK_SERIALIZED_ACCEPT
+    "'flock' "
+#endif
+#ifdef HAVE_OS2SEM_SERIALIZED_ACCEPT
+    "'os2sem' "
+#endif
+#ifdef HAVE_TPF_CORE_SERIALIZED_ACCEPT
+    "'tpfcore' "
+#endif
+#ifdef HAVE_BEOS_SERIALIZED_ACCEPT
+    "'beos_sem' "
+#endif
+#ifdef HAVE_NONE_SERIALIZED_ACCEPT
+    "'none' "
+#endif
+    "are compiled in"
+},
+#ifdef AP_ENABLE_EXCEPTION_HOOK
+{ "EnableExceptionHook", set_exception_hook, NULL, RSRC_CONF, TAKE1,
+  "Controls whether exception hook may be called after a crash" },
+#endif
+
+/* EBCDIC Conversion directives: */
+#ifdef CHARSET_EBCDIC
+{ "EBCDICConvert", add_conversion_by_ext, NULL, OR_FILEINFO, ITERATE2,
+    "{On|Off}[={In|Out|InOut}] followed by one or more file extensions" },
+{ "EBCDICConvertByType", add_conversion_by_type, NULL, OR_FILEINFO, ITERATE2,
+    "{On|Off}[={In|Out|InOut}] followed by one or more MIME types" },
+#ifdef LEGACY_KLUDGE
+{ "EBCDICKludge", set_x_ascii_kludge, NULL, OR_FILEINFO, FLAG,
+    "'On': enable or default='Off': disable the old text/x-ascii-mimetype kludge" },
+#endif
+#if ADD_EBCDICCONVERT_DEBUG_HEADER
+{ "EBCDICDebugHeader", set_debug_header, NULL, OR_FILEINFO, FLAG,
+    "'On': enable or default='Off': disable the EBCDIC Debugging MIME Header" },
+#endif
+#endif /* CHARSET_EBCDIC */
+
+{ "FileETag", set_etag_bits, NULL, OR_FILEINFO, RAW_ARGS,
+  "Specify components used to construct a file's ETag"},
+
+{ "LimitInternalRecursion", set_recursion_limit, NULL, RSRC_CONF, TAKE12,
+  "maximum recursion depth of internal redirects and subrequests"},
+
+{ NULL }
+};
+
+/*****************************************************************
+ *
+ * Core handlers for various phases of server operation...
+ */
+
+static int core_translate(request_rec *r)
+{
+    void *sconf = r->server->module_config;
+    core_server_config *conf = ap_get_module_config(sconf, &core_module);
+  
+    if (r->proxyreq != NOT_PROXY) {
+        return HTTP_FORBIDDEN;
+    }
+    if ((r->uri[0] != '/') && strcmp(r->uri, "*")) {
+	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+		     "Invalid URI in request %s", r->the_request);
+	return BAD_REQUEST;
+    }
+    
+    if (r->server->path 
+	&& !strncmp(r->uri, r->server->path, r->server->pathlen)
+	&& (r->server->path[r->server->pathlen - 1] == '/'
+	    || r->uri[r->server->pathlen] == '/'
+	    || r->uri[r->server->pathlen] == '\0')) {
+        r->filename = ap_pstrcat(r->pool, conf->ap_document_root,
+				 (r->uri + r->server->pathlen), NULL);
+    }
+    else {
+	/*
+         * Make sure that we do not mess up the translation by adding two
+         * /'s in a row.  This happens under windows when the document
+         * root ends with a /
+         */
+        if ((conf->ap_document_root[strlen(conf->ap_document_root)-1] == '/')
+	    && (*(r->uri) == '/')) {
+	    r->filename = ap_pstrcat(r->pool, conf->ap_document_root, r->uri+1,
+				     NULL);
+	}
+	else {
+	    r->filename = ap_pstrcat(r->pool, conf->ap_document_root, r->uri,
+				     NULL);
+	}
+    }
+
+    return OK;
+}
+
+static int do_nothing(request_rec *r) { return OK; }
+
+#ifdef CHARSET_EBCDIC
+struct do_mime_match_parms {
+    request_rec *request;     /* [In] current request_rec */
+    int direction;            /* [In] determine conversion for: dir_In|dir_Out */
+    const char *content_type; /* [In] Content-Type (dir_In: from MIME Header, else r->content_type) */
+    int match_found;          /* [Out] nonzero if a match was found */
+    int conv;                 /* [Out] conversion setting if match was found */
+};
+
+
+/* This routine is called for each mime type configured by the
+ * EBCDICConvertByType directive.
+ */
+static int
+do_mime_match(void *rec, const char *key, const char *val)
+{
+    int conv = (val[0] == conv_On);
+    const char *content_type;
+#if ADD_EBCDICCONVERT_DEBUG_HEADER
+    request_rec *r = ((struct do_mime_match_parms *) rec)->request;
+#endif
+
+    ((struct do_mime_match_parms *) rec)->match_found = 0;
+    ((struct do_mime_match_parms *) rec)->conv = conv_Unset;
+
+    content_type = ((struct do_mime_match_parms *) rec)->content_type;
+
+    /* If no type set: no need to continue */
+    if (content_type == NULL)
+        return 0;
+
+    /* If the MIME type matches, set the conversion flag appropriately */
+    if ((ap_is_matchexp(key) && ap_strcasecmp_match(content_type, key) == 0)
+        || (strcasecmp(key, content_type) == 0)) {
+
+        ((struct do_mime_match_parms *) rec)->match_found = 1;
+        ((struct do_mime_match_parms *) rec)->conv = conv;
+
+#if ADD_EBCDICCONVERT_DEBUG_HEADER
+	ap_table_setn(r->headers_out,
+               ((((struct do_mime_match_parms *) rec)->direction) == dir_In)
+		      ? "X-EBCDIC-Debug-In" : "X-EBCDIC-Debug-Out",
+                       ap_psprintf(r->pool, "EBCDICConversionByType %s %s",
+                                   conv ? "On" : "Off",
+                                   key));
+#endif
+
+        /* the mime type scan stops at the first  match. */
+        return 0;
+    }
+
+    return 1;
+}
+
+static void
+ap_checkconv_dir(request_rec *r, const char **pType, int dir)
+{
+    core_dir_config *conf =
+    (core_dir_config *) ap_get_module_config(r->per_dir_config, &core_module);
+    table *conv_by_ext, *conv_by_type;
+    const char *type, *conversion;
+    char *ext;
+    int conv_valid = 0, conv;
+
+    conv_by_ext  = (dir == dir_In) ? conf->ebcdicconversion_by_ext_in  : conf->ebcdicconversion_by_ext_out;
+    conv_by_type = (dir == dir_In) ? conf->ebcdicconversion_by_type_in : conf->ebcdicconversion_by_type_out;
+
+    type = (*pType == NULL) ? ap_default_type(r) : *pType;
+
+    /* Pseudo "loop" which is executed once only, with break's at individual steps */
+    do {
+        /* Step 0: directories result in redirections or in directory listings.
+	 * Both are EBCDIC text documents.
+	 * @@@ Should we check for the handler instead?
+	 */
+        if (S_ISDIR(r->finfo.st_mode) && dir == dir_Out) {
+            conv = conv_valid = 1;
+            break;
+        }
+
+        /* 1st step: check the binding on file extension. This allows us to
+         * override the conversion default based on a specific name.
+         * For instance, the following would allow some HTML files
+         * to be converted (.html) and others passed unconverted (.ahtml):
+         *     AddType text/html .html .ahtml
+         *     EBCDICConvert Off .ahtml
+         * For uploads, this assumes that the destination file name
+	 * has the correct extension. That may not be true for, e.g.,
+	 * Netscape Communicator roaming profile uploads!
+         */
+        if (r->filename && !ap_is_empty_table(conv_by_ext)) {
+            const char *fn = strrchr(r->filename, '/');
+
+            if (fn == NULL)
+                fn = r->filename;
+
+            /* Parse filename extension */
+            if ((ext = strrchr(fn, '.')) != NULL) {
+                ++ext;
+
+                /* Check for Content-Type */
+                if ((conversion = ap_table_get(conv_by_ext, ext)) != NULL) {
+
+#if ADD_EBCDICCONVERT_DEBUG_HEADER
+		    if (conf->ebcdicconversion_debug_header)
+		        ap_table_setn(r->headers_out,
+				      (dir == dir_In) ? "X-EBCDIC-Debug-In" : "X-EBCDIC-Debug-Out",
+				      ap_psprintf(r->pool, "EBCDICConversion %s .%s",
+						  (conversion[0] == conv_On) ? "On" : "Off",
+						  ext));
+#endif
+
+                    conv = (conversion[0] == conv_On);
+                    conv_valid = 1;
+                    break;
+                }
+            }
+        }
+
+
+        /* 2nd step: test for the old "legacy kludge", that is, a default
+         * conversion=on for text/?* message/?* multipart/?* and the possibility
+         * to override the text/?* conversion with a definition like
+         *    AddType text/x-ascii-plain .atxt
+         *    AddType text/x-ascii-html  .ahtml
+         * where the "x-ascii-" would be removed and the conversion switched
+         * off.
+         * This step must be performed prior to testing wildcard MIME types
+         * like text/?* by the EBCDICConvertByType directive.
+         */
+#ifdef LEGACY_KLUDGE
+        /* This fallback is only used when enabled (default=off) */
+        if (conf->x_ascii_magic_kludge) {
+            char *magic;
+
+            /* If the mime type of a document is set to
+             * "text/x-ascii-anything", it gets changed to
+             * "text/anything" here and the conversion is forced to off
+             * ("binary" or ASCII documents).
+             */
+            if (*pType != NULL
+                && (magic = strstr(*pType, "/x-ascii-")) != NULL) {
+
+#if ADD_EBCDICCONVERT_DEBUG_HEADER
+		if (conf->ebcdicconversion_debug_header)
+		    ap_table_setn(r->headers_out,
+				  (dir == dir_In) ? "X-EBCDIC-Debug-In" : "X-EBCDIC-Debug-Out",
+				  ap_psprintf(r->pool, "EBCDICKludge On (and type is: %s, thus no conversion)",
+					      *pType));
+#endif
+
+                /* the mime type scan stops at the first  match. */
+                magic[1] = '\0';        /* overwrite 'x' */
+
+                /* Fix MIME type: strip out the magic "x-ascii-" substring */
+                *pType = ap_pstrcat(r->pool, *pType, &magic[9], NULL);
+
+                magic[1] = 'x'; /* restore 'x' in old string (just in case) */
+
+                /* Switch conversion to BINARY */
+                conv = 0;       /* do NOT convert this document */
+                conv_valid = 1;
+                break;
+            }
+        }
+#endif /*LEGACY_KLUDGE */
+
+
+        /* 3rd step: check whether a generic conversion was defined for a MIME type,
+         * like in
+         *    EBCDICConvertByType  On  model/vrml application/postscript text/?*
+         */
+        if (!ap_is_empty_table(conv_by_type)) {
+            struct do_mime_match_parms do_par;
+
+            do_par.request = r;
+            do_par.direction = dir;
+	    do_par.content_type = type;
+
+            ap_table_do(do_mime_match, (void *) &do_par, conv_by_type, NULL);
+
+            if ((conv_valid = do_par.match_found) != 0) {
+                conv = do_par.conv;
+                break;
+            }
+        }
+        else /* If no conversion by type was configured, use the default: */
+        {
+            /*
+             * As a final step, mime types starting with "text/", "message/" or
+             * "multipart/" imply a conversion, while all the rest is
+             * delivered unconverted (i.e., binary, e.g. application/octet-stream).
+             */
+
+            /* If no content type is set then treat it as text (conversion=on) */
+            conv =
+                (type == NULL) ||
+                (strncasecmp(type, "text/", 5) == 0) ||
+                (strncasecmp(type, "message/", 8) == 0) ||
+                (strncasecmp(type, "multipart/", 10) == 0) ||
+                (strcasecmp(type, "application/x-www-form-urlencoded") == 0);
+
+#if ADD_EBCDICCONVERT_DEBUG_HEADER
+		if (conf->ebcdicconversion_debug_header)
+		    ap_table_setn(r->headers_out,
+				  (dir == dir_In) ? "X-EBCDIC-Debug-In" : "X-EBCDIC-Debug-Out",
+				  ap_psprintf(r->pool,
+					      "No EBCDICConversion configured (and type is: %s, "
+					      "=> guessed conversion = %s)",
+					      type, conv ? "On" : "Off"));
+#endif
+            conv_valid = 1;
+            break;
+        }
+    } while (0);
+
+    if (conv_valid) {
+        if (dir == dir_In)
+            r->ebcdic.conv_in = conv;
+        else
+            r->ebcdic.conv_out = conv;
+    }
+}
+
+/* This function determines the conversion for uploads (PUT/POST): */
+API_EXPORT(int)
+ap_checkconv_in(request_rec *r)
+{
+    const char *typep;
+
+    /* If nothing is being sent as input anyway, we don't bother about conversion */
+    /* (see ap_should_client_block())*/
+    if (r->read_length || (!r->read_chunked && (r->remaining <= 0)))
+        return r->ebcdic.conv_in;
+
+    typep = ap_table_get(r->headers_in, "Content-Type");
+    ap_checkconv_dir(r, &typep, dir_In);
+
+    return r->ebcdic.conv_in;
+}
+
+
+/* Backward compatibility function */
+API_EXPORT(int)
+ap_checkconv(request_rec *r)
+{
+    ap_checkconv_dir(r, &r->content_type, dir_Out);
+    return r->ebcdic.conv_out;
+}
+
+#endif /* CHARSET_EBCDIC */
+
+
+#ifdef USE_MMAP_FILES
+struct mmap_rec {
+    void *mm;
+    size_t length;
+};
+
+static void mmap_cleanup(void *mmv)
+{
+    struct mmap_rec *mmd = mmv;
+
+    if (munmap(mmd->mm, mmd->length) == -1) {
+        ap_log_error(APLOG_MARK, APLOG_ERR, NULL,
+                     "Failed to munmap memory of length %ld at 0x%lx",
+                     (long) mmd->length, (long) mmd->mm);
+    }
+}
+#endif
+
+/*
+ * Default handler for MIME types without other handlers.  Only GET
+ * and OPTIONS at this point... anyone who wants to write a generic
+ * handler for PUT or POST is free to do so, but it seems unwise to provide
+ * any defaults yet... So, for now, we assume that this will always be
+ * the last handler called and return 405 or 501.
+ */
+
+static int default_handler(request_rec *r)
+{
+    core_dir_config *d =
+      (core_dir_config *)ap_get_module_config(r->per_dir_config, &core_module);
+    int rangestatus, errstatus;
+    FILE *f;
+#ifdef USE_MMAP_FILES
+    caddr_t mm;
+#endif
+
+    /* This handler has no use for a request body (yet), but we still
+     * need to read and discard it if the client sent one.
+     */
+    if ((errstatus = ap_discard_request_body(r)) != OK) {
+        return errstatus;
+    }
+
+    r->allowed |= (1 << M_GET) | (1 << M_OPTIONS);
+
+    if (r->method_number == M_INVALID) {
+	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+		    "Invalid method in request %s",
+		    ap_escape_logitem(r->pool, r->the_request));
+	return NOT_IMPLEMENTED;
+    }
+    if (r->method_number == M_OPTIONS) {
+        return ap_send_http_options(r);
+    }
+    if (r->method_number == M_PUT) {
+        return METHOD_NOT_ALLOWED;
+    }
+
+    if (r->finfo.st_mode == 0 || (r->path_info && *r->path_info)) {
+	ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, r,
+		      "File does not exist: %s",r->path_info ?
+		      ap_pstrcat(r->pool, r->filename, r->path_info, NULL)
+		      : r->filename);
+	return HTTP_NOT_FOUND;
+    }
+    if (r->method_number != M_GET) {
+        return METHOD_NOT_ALLOWED;
+    }
+	
+#if defined(OS2) || defined(WIN32) || defined(NETWARE) || defined(CYGWIN)
+    /* Need binary mode for OS/2 */
+    f = ap_pfopen(r->pool, r->filename, "rb");
+#else
+    f = ap_pfopen(r->pool, r->filename, "r");
+#endif
+
+    if (f == NULL) {
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
+		     "file permissions deny server access: %s", r->filename);
+        return FORBIDDEN;
+    }
+	
+    ap_update_mtime(r, r->finfo.st_mtime);
+    ap_set_last_modified(r);
+    ap_set_etag(r);
+    ap_table_setn(r->headers_out, "Accept-Ranges", "bytes");
+    if (((errstatus = ap_meets_conditions(r)) != OK)
+	|| (errstatus = ap_set_content_length(r, r->finfo.st_size))) {
+        return errstatus;
+    }
+
+#ifdef USE_MMAP_FILES
+    ap_block_alarms();
+    if ((r->finfo.st_size >= MMAP_THRESHOLD)
+	&& (r->finfo.st_size < MMAP_LIMIT)
+	&& (!r->header_only || (d->content_md5 & 1))) {
+	/* we need to protect ourselves in case we die while we've got the
+ 	 * file mmapped */
+	mm = mmap(NULL, r->finfo.st_size, PROT_READ, MAP_PRIVATE,
+		  fileno(f), 0);
+	if (mm == (caddr_t)-1) {
+	    ap_log_rerror(APLOG_MARK, APLOG_CRIT, r,
+			 "default_handler: mmap failed: %s", r->filename);
+	}
+    }
+    else {
+	mm = (caddr_t)-1;
+    }
+
+    if (mm == (caddr_t)-1) {
+	ap_unblock_alarms();
+#endif
+
+#ifdef CHARSET_EBCDIC
+	if (d->content_md5 & 1) {
+	    ap_table_setn(r->headers_out, "Content-MD5",
+			  ap_md5digest(r->pool, f, r->ebcdic.conv_out));
+	}
+#else
+	if (d->content_md5 & 1) {
+	    ap_table_setn(r->headers_out, "Content-MD5",
+			  ap_md5digest(r->pool, f));
+	}
+#endif /* CHARSET_EBCDIC */
+
+	rangestatus = ap_set_byterange(r);
+
+	ap_send_http_header(r);
+	
+	if (!r->header_only) {
+	    if (!rangestatus) {
+		ap_send_fd(f, r);
+	    }
+	    else {
+		long offset, length;
+		while (ap_each_byterange(r, &offset, &length)) {
+		    /*
+		     * Non zero returns are more portable than checking
+		     * for a return of -1.
+		     */
+		    if (fseek(f, offset, SEEK_SET)) {
+			ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
+			      "Failed to fseek for byterange (%ld, %ld): %s",
+			      offset, length, r->filename);
+		    }
+		    else {
+			ap_send_fd_length(f, r, length);
+		    }
+		}
+	    }
+	}
+
+#ifdef USE_MMAP_FILES
+    }
+    else {
+	struct mmap_rec *mmd;
+
+	mmd = ap_palloc(r->pool, sizeof(*mmd));
+	mmd->mm = mm;
+	mmd->length = r->finfo.st_size;
+	ap_register_cleanup(r->pool, (void *)mmd, mmap_cleanup, mmap_cleanup);
+	ap_unblock_alarms();
+
+	if (d->content_md5 & 1) {
+	    AP_MD5_CTX context;
+	    
+	    ap_MD5Init(&context);
+	    ap_MD5Update(&context, (void *)mm, (unsigned int)r->finfo.st_size);
+	    ap_table_setn(r->headers_out, "Content-MD5",
+			  ap_md5contextTo64(r->pool, &context));
+	}
+
+	rangestatus = ap_set_byterange(r);
+	ap_send_http_header(r);
+	
+	if (!r->header_only) {
+	    if (!rangestatus) {
+		ap_send_mmap(mm, r, 0, r->finfo.st_size);
+	    }
+	    else {
+		long offset, length;
+		while (ap_each_byterange(r, &offset, &length)) {
+		    ap_send_mmap(mm, r, offset, length);
+		}
+	    }
+	}
+    }
+#endif
+
+    ap_pfclose(r->pool, f);
+    return OK;
+}
+
+static const handler_rec core_handlers[] = {
+{ "*/*", default_handler },
+{ "default-handler", default_handler },
+{ NULL, NULL }
+};
+
+API_VAR_EXPORT module core_module = {
+    STANDARD_MODULE_STUFF,
+    NULL,			/* initializer */
+    create_core_dir_config,	/* create per-directory config structure */
+    merge_core_dir_configs,	/* merge per-directory config structures */
+    create_core_server_config,	/* create per-server config structure */
+    merge_core_server_configs,	/* merge per-server config structures */
+    core_cmds,			/* command table */
+    core_handlers,		/* handlers */
+    core_translate,		/* translate_handler */
+    NULL,			/* check_user_id */
+    NULL,			/* check auth */
+    do_nothing,			/* check access */
+    do_nothing,			/* type_checker */
+    NULL,			/* pre-run fixups */
+    NULL,			/* logger */
+    NULL,			/* header parser */
+    NULL,			/* child_init */
+    NULL,			/* child_exit */
+    NULL			/* post_read_request */
+};
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/main/http_main.c apache_1.3.33/src/main/http_main.c
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/main/http_main.c	Thu Sep 16 01:45:17 2004
+++ apache_1.3.33/src/main/http_main.c	Mon Jul 18 15:22:25 2005
@@ -242,6 +242,9 @@
 
 int ap_dump_settings = 0;
 API_VAR_EXPORT int ap_extended_status = 0;
+#ifdef EAPI
+API_VAR_EXPORT ap_ctx *ap_global_ctx;
+#endif /* EAPI */
 
 /*
  * The max child slot ever assigned, preserved across restarts.  Necessary
@@ -435,6 +438,30 @@
     }
 }
 
+#ifdef EAPI
+API_EXPORT(void) ap_add_config_define(const char *define)
+{
+    char **var;
+    var = (char **)ap_push_array(ap_server_config_defines);
+    *var = ap_pstrdup(pcommands, define);
+    return;
+}
+
+/*
+ * Invoke the `close_connection' hook of modules to let them do
+ * some connection dependent actions before we close it.
+ */
+static void ap_call_close_connection_hook(conn_rec *c)
+{
+    module *m;
+    for (m = top_module; m != NULL; m = m->next)
+        if (m->magic == MODULE_MAGIC_COOKIE_EAPI)
+            if (m->close_connection != NULL)
+                (*m->close_connection)(c);
+    return;
+}
+#endif /* EAPI */
+
 #ifndef NETWARE
 static APACHE_TLS int volatile exit_after_unblock = 0;
 #endif
@@ -1541,6 +1568,10 @@
 	    ap_log_transaction(log_req);
 	}
 
+#ifdef EAPI
+	ap_call_close_connection_hook(save_req->connection);
+#endif /* EAPI */
+
 	ap_bsetflag(save_req->connection->client, B_EOUT, 1);
 	ap_bclose(save_req->connection->client);
 	
@@ -1549,6 +1580,9 @@
         ap_longjmp(jmpbuffer, 1);
     }
     else {			/* abort the connection */
+#ifdef EAPI
+	ap_call_close_connection_hook(current_conn);
+#endif /* EAPI */
 	ap_bsetflag(current_conn->client, B_EOUT, 1);
 	ap_bclose(current_conn->client);
 	current_conn->aborted = 1;
@@ -1851,10 +1885,16 @@
     /* Send any leftover data to the client, but never try to again */
 
     if (ap_bflush(r->connection->client) == -1) {
+#ifdef EAPI
+	ap_call_close_connection_hook(r->connection);
+#endif /* EAPI */
 	ap_kill_timeout(r);
 	ap_bclose(r->connection->client);
 	return;
     }
+#ifdef EAPI
+    ap_call_close_connection_hook(r->connection);
+#endif /* EAPI */
     ap_bsetflag(r->connection->client, B_EOUT, 1);
 
     /* Close our half of the connection --- send the client a FIN */
@@ -2553,6 +2593,9 @@
     /* Clear the pool - including any registered cleanups */
     ap_destroy_pool(pglobal);
 #endif
+#ifdef EAPI
+    ap_kill_alloc_shared();
+#endif
     exit(code);
 }
 
@@ -3443,6 +3486,7 @@
         RAISE_SIGSTOP(DETACH);
     }
 #endif
+#define NO_SETSID /* setsid seems to be broken somewhere */
 #ifndef NO_SETSID
     if ((pgrp = setsid()) == -1) {
 	perror("setsid");
@@ -3472,7 +3516,7 @@
         exit(1);
     }
 #else
-    if ((pgrp = setpgrp(getpid(), 0)) == -1) {
+    if ((pgrp = setpgrp()) == -1) {
 	perror("setpgrp");
 	fprintf(stderr, "%s: setpgrp failed\n", ap_server_argv0);
 	exit(1);
@@ -3623,6 +3667,24 @@
     conn->remote_addr = *remaddr;
     conn->remote_ip = ap_pstrdup(conn->pool,
 			      inet_ntoa(conn->remote_addr.sin_addr));
+#ifdef EAPI
+    conn->ctx = ap_ctx_new(conn->pool);
+#endif /* EAPI */
+
+#ifdef EAPI
+    /*
+     * Invoke the `new_connection' hook of modules to let them do
+     * some connection dependent actions before we go on with
+     * processing the request on this connection.
+     */
+    {
+        module *m;
+        for (m = top_module; m != NULL; m = m->next)
+            if (m->magic == MODULE_MAGIC_COOKIE_EAPI)
+                if (m->new_connection != NULL)
+                    (*m->new_connection)(conn);
+    }
+#endif /* EAPI */
 
     return conn;
 }
@@ -4133,6 +4195,15 @@
     printf("Server's Module Magic Number: %u:%u\n",
 	   MODULE_MAGIC_NUMBER_MAJOR, MODULE_MAGIC_NUMBER_MINOR);
     printf("Server compiled with....\n");
+#ifdef EAPI
+    printf(" -D EAPI\n");
+#endif
+#ifdef EAPI_MM
+    printf(" -D EAPI_MM\n");
+#ifdef EAPI_MM_CORE_PATH
+    printf(" -D EAPI_MM_CORE_PATH=\"" EAPI_MM_CORE_PATH "\"\n");
+#endif
+#endif
 #ifdef TPF
     show_os_specific_compile_settings();
 #endif
@@ -4307,6 +4378,22 @@
     ap_server_pre_read_config  = ap_make_array(pcommands, 1, sizeof(char *));
     ap_server_post_read_config = ap_make_array(pcommands, 1, sizeof(char *));
     ap_server_config_defines   = ap_make_array(pcommands, 1, sizeof(char *));
+
+#ifdef EAPI
+    ap_hook_init();
+    ap_hook_configure("ap::buff::read", 
+                      AP_HOOK_SIG4(int,ptr,ptr,int), AP_HOOK_TOPMOST);
+    ap_hook_configure("ap::buff::write",  
+                      AP_HOOK_SIG4(int,ptr,ptr,int), AP_HOOK_TOPMOST);
+    ap_hook_configure("ap::buff::writev",  
+                      AP_HOOK_SIG4(int,ptr,ptr,int), AP_HOOK_TOPMOST);
+    ap_hook_configure("ap::buff::sendwithtimeout", 
+                      AP_HOOK_SIG4(int,ptr,ptr,int), AP_HOOK_TOPMOST);
+    ap_hook_configure("ap::buff::recvwithtimeout", 
+                      AP_HOOK_SIG4(int,ptr,ptr,int), AP_HOOK_TOPMOST);
+
+    ap_global_ctx = ap_ctx_new(NULL);
+#endif /* EAPI */
 }
 
 #ifndef MULTITHREAD
@@ -4808,6 +4895,9 @@
 
 	    ap_sync_scoreboard_image();
 	    if (ap_scoreboard_image->global.running_generation != ap_my_generation) {
+#ifdef EAPI
+		ap_call_close_connection_hook(current_conn);
+#endif /* EAPI */
 		ap_bclose(conn_io);
 		clean_child_exit(0);
 	    }
@@ -4836,6 +4926,9 @@
 	 */
 
 #ifdef NO_LINGCLOSE
+#ifdef EAPI
+	ap_call_close_connection_hook(current_conn);
+#endif /* EAPI */
 	ap_bclose(conn_io);	/* just close it */
 #else
 	if (r && r->connection
@@ -4846,6 +4939,9 @@
 	    lingering_close(r);
 	}
 	else {
+#ifdef EAPI
+	    ap_call_close_connection_hook(current_conn);
+#endif /* EAPI */
 	    ap_bsetflag(conn_io, B_EOUT, 1);
 	    ap_bclose(conn_io);
 	}
@@ -5629,16 +5725,31 @@
 	    usage(argv[0]);
 	}
     }
+#ifdef EAPI
+    ap_init_alloc_shared(TRUE);
+#endif
 
     ap_suexec_enabled = init_suexec();
     server_conf = ap_read_config(pconf, ptrans, ap_server_confname);
 
+#ifdef EAPI
+    ap_init_alloc_shared(FALSE);
+#endif
+
     if (ap_configtestonly) {
         fprintf(stderr, "Syntax OK\n");
+#ifdef EAPI
+        clean_parent_exit(0);
+#else
         exit(0);
+#endif
     }
     if (ap_dump_settings) {
+#ifdef EAPI
+        clean_parent_exit(0);
+#else
         exit(0);
+#endif
     }
 
     child_timeouts = !ap_standalone || one_process;
@@ -5786,6 +5897,10 @@
 	    ap_destroy_pool(r->pool);
 	}
 
+#ifdef EAPI
+	ap_call_close_connection_hook(conn);
+#endif /* EAPI */
+
 	ap_bclose(cio);
     }
     exit(0);
@@ -6162,6 +6277,9 @@
 	ap_kill_cleanups_for_socket(ptrans, csd);
 
 #ifdef NO_LINGCLOSE
+#ifdef EAPI
+	ap_call_close_connection_hook(current_conn);
+#endif /* EAPI */
 	ap_bclose(conn_io);	/* just close it */
 #else
 	if (r && r->connection
@@ -6172,6 +6290,9 @@
 	    lingering_close(r);
 	}
 	else {
+#ifdef EAPI
+	    ap_call_close_connection_hook(current_conn);
+#endif /* EAPI */
 	    ap_bsetflag(conn_io, B_EOUT, 1);
 	    ap_bclose(conn_io);
 	}
@@ -7747,6 +7868,10 @@
     if (!conf_specified)
         ap_cpystrn(ap_server_confname, SERVER_CONFIG_FILE, sizeof(ap_server_confname));
 
+#ifdef EAPI
+    ap_init_alloc_shared(TRUE);
+#endif
+
     if (!ap_os_is_path_absolute(ap_server_confname))
         ap_cpystrn(ap_server_confname,
                    ap_server_root_relative(pcommands, ap_server_confname),
@@ -7786,6 +7911,9 @@
     }
 #else /* ndef WIN32 */
     server_conf = ap_read_config(pconf, ptrans, ap_server_confname);
+#endif
+#ifdef EAPI
+    ap_init_alloc_shared(FALSE);
 #endif
 
     if (ap_configtestonly) {
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/main/http_main.c.orig apache_1.3.33/src/main/http_main.c.orig
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/main/http_main.c.orig	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/main/http_main.c.orig	Mon Jul 18 15:22:19 2005
@@ -0,0 +1,8109 @@
+/* Copyright 1999-2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * httpd.c: simple http daemon for answering WWW file requests
+ *
+ * 
+ * 03-21-93  Rob McCool wrote original code (up to NCSA HTTPd 1.3)
+ * 
+ * 03-06-95  blong
+ *  changed server number for child-alone processes to 0 and changed name
+ *   of processes
+ *
+ * 03-10-95  blong
+ *      Added numerous speed hacks proposed by Robert S. Thau (rst@ai.mit.edu) 
+ *      including set group before fork, and call gettime before to fork
+ *      to set up libraries.
+ *
+ * 04-14-95  rst / rh
+ *      Brandon's code snarfed from NCSA 1.4, but tinkered to work with the
+ *      Apache server, and also to have child processes do accept() directly.
+ *
+ * April-July '95 rst
+ *      Extensive rework for Apache.
+ */
+
+#ifndef SHARED_CORE_BOOTSTRAP
+#ifndef SHARED_CORE_TIESTATIC
+
+#ifdef SHARED_CORE
+#define REALMAIN ap_main
+int ap_main(int argc, char *argv[]);
+#else
+#define REALMAIN main
+#endif
+
+#define CORE_PRIVATE
+
+#include "httpd.h"
+#include "http_main.h"
+#include "http_log.h"
+#include "http_config.h"	/* for read_config */
+#include "http_protocol.h"	/* for read_request */
+#include "http_request.h"	/* for process_request */
+#include "http_conf_globals.h"
+#include "http_core.h"		/* for get_remote_host */
+#include "http_vhost.h"
+#include "util_script.h"	/* to force util_script.c linking */
+#include "util_uri.h"
+#include "scoreboard.h"
+#include "multithread.h"
+#include <sys/stat.h>
+#ifdef USE_SHMGET_SCOREBOARD
+#include <sys/types.h>
+#include <sys/ipc.h>
+#include <sys/shm.h>
+#endif
+#ifdef SecureWare
+#include <sys/security.h>
+#include <sys/audit.h>
+#include <prot.h>
+#endif
+#ifdef WIN32
+#include "../os/win32/getopt.h"
+#elif !defined(BEOS) && !defined(TPF) && !defined(NETWARE) && !defined(OS390) && !defined(CYGWIN)
+#include <netinet/tcp.h>
+#endif
+#ifdef HAVE_BSTRING_H
+#include <bstring.h>		/* for IRIX, FD_SET calls bzero() */
+#endif
+#ifdef HAVE_SET_DUMPABLE /* certain levels of Linux */
+#include <sys/prctl.h>
+#endif
+
+#ifdef MULTITHREAD
+/* special debug stuff -- PCS */
+
+/* Set this non-zero if you are prepared to put up with more than one log entry per second */
+#define SEVERELY_VERBOSE	    0
+
+  /* APD1() to APD5() are macros to help us debug. They can either
+   * log to the screen or the error_log file. In release builds, these
+   * macros do nothing. In debug builds, they send messages at priority
+   * "debug" to the error log file, or if DEBUG_TO_CONSOLE is defined,
+   * to the console.
+   */
+
+# ifdef _DEBUG
+#  ifndef DEBUG_TO_CONSOLE
+#   define APD1(a) ap_log_error(APLOG_MARK,APLOG_DEBUG|APLOG_NOERRNO,server_conf,a)
+#   define APD2(a,b) ap_log_error(APLOG_MARK,APLOG_DEBUG|APLOG_NOERRNO,server_conf,a,b)
+#   define APD3(a,b,c) ap_log_error(APLOG_MARK,APLOG_DEBUG|APLOG_NOERRNO,server_conf,a,b,c)
+#   define APD4(a,b,c,d) ap_log_error(APLOG_MARK,APLOG_DEBUG|APLOG_NOERRNO,server_conf,a,b,c,d)
+#   define APD5(a,b,c,d,e) ap_log_error(APLOG_MARK,APLOG_DEBUG|APLOG_NOERRNO,server_conf,a,b,c,d,e)
+#  else
+#   define APD1(a) printf("%s\n",a)
+#   define APD2(a,b) do { printf(a,b);putchar('\n'); } while(0);
+#   define APD3(a,b,c) do { printf(a,b,c);putchar('\n'); } while(0);
+#   define APD4(a,b,c,d) do { printf(a,b,c,d);putchar('\n'); } while(0);
+#   define APD5(a,b,c,d,e) do { printf(a,b,c,d,e);putchar('\n'); } while(0);
+#  endif
+# else /* !_DEBUG */
+#  define APD1(a) 
+#  define APD2(a,b) 
+#  define APD3(a,b,c) 
+#  define APD4(a,b,c,d) 
+#  define APD5(a,b,c,d,e) 
+# endif /* _DEBUG */
+#endif /* MULTITHREAD */
+
+/* This next function is never used. It is here to ensure that if we
+ * make all the modules into shared libraries that core httpd still
+ * includes the full Apache API. Without this function the objects in
+ * main/util_script.c would not be linked into a minimal httpd.
+ * And the extra prototype is to make gcc -Wmissing-prototypes quiet.
+ */
+API_EXPORT(void) ap_force_library_loading(void);
+API_EXPORT(void) ap_force_library_loading(void) {
+    ap_add_cgi_vars(NULL);
+}
+
+#include "explain.h"
+
+#if !defined(max)
+#define max(a,b)        (a > b ? a : b)
+#endif
+
+#ifdef WIN32
+#include "../os/win32/service.h"
+#include "../os/win32/registry.h"
+#define DEFAULTSERVICENAME "Apache"
+#define PATHSEPARATOR '\\'
+#else
+#define PATHSEPARATOR '/'
+#endif
+
+
+#ifdef MINT
+long _stksize = 32768;
+#endif
+
+#ifdef USE_OS2_SCOREBOARD
+    /* Add MMAP style functionality to OS/2 */
+#define INCL_DOSMEMMGR
+#define INCL_DOSEXCEPTIONS
+#define INCL_DOSSEMAPHORES
+#include <os2.h>
+#include <umalloc.h>
+#include <stdio.h>
+caddr_t create_shared_heap(const char *, size_t);
+caddr_t get_shared_heap(const char *);
+#endif
+
+DEF_Explain
+
+/* Defining GPROF when compiling uses the moncontrol() function to
+ * disable gprof profiling in the parent, and enable it only for
+ * request processing in children (or in one_process mode).  It's
+ * absolutely required to get useful gprof results under linux
+ * because the profile itimers and such are disabled across a
+ * fork().  It's probably useful elsewhere as well.
+ */
+#ifdef GPROF
+extern void moncontrol(int);
+#define MONCONTROL(x) moncontrol(x)
+#else
+#define MONCONTROL(x)
+#endif
+
+#ifndef MULTITHREAD
+/* this just need to be anything non-NULL */
+void *ap_dummy_mutex = &ap_dummy_mutex;
+#endif
+
+/*
+ * Actual definitions of config globals... here because this is
+ * for the most part the only code that acts on 'em.  (Hmmm... mod_main.c?)
+ */
+#ifdef NETWARE
+BOOL ap_main_finished = FALSE;
+unsigned int ap_thread_stack_size = 65536;
+#endif
+int ap_thread_count = 0;
+API_VAR_EXPORT int ap_standalone=0;
+API_VAR_EXPORT int ap_configtestonly=0;
+int ap_docrootcheck=1;
+API_VAR_EXPORT uid_t ap_user_id=0;
+API_VAR_EXPORT char *ap_user_name=NULL;
+API_VAR_EXPORT gid_t ap_group_id=0;
+#ifdef MULTIPLE_GROUPS
+gid_t group_id_list[NGROUPS_MAX];
+#endif
+API_VAR_EXPORT int ap_max_requests_per_child=0;
+API_VAR_EXPORT int ap_threads_per_child=0;
+API_VAR_EXPORT int ap_excess_requests_per_child=0;
+API_VAR_EXPORT char *ap_pid_fname=NULL;
+API_VAR_EXPORT char *ap_scoreboard_fname=NULL;
+API_VAR_EXPORT char *ap_lock_fname=NULL;
+API_VAR_EXPORT char *ap_server_argv0=NULL;
+API_VAR_EXPORT struct in_addr ap_bind_address={0};
+API_VAR_EXPORT int ap_daemons_to_start=0;
+API_VAR_EXPORT int ap_daemons_min_free=0;
+API_VAR_EXPORT int ap_daemons_max_free=0;
+API_VAR_EXPORT int ap_daemons_limit=0;
+API_VAR_EXPORT time_t ap_restart_time=0;
+API_VAR_EXPORT int ap_suexec_enabled = 0;
+API_VAR_EXPORT int ap_listenbacklog=0;
+#ifdef AP_ENABLE_EXCEPTION_HOOK
+int ap_exception_hook_enabled=0;
+#endif
+
+struct accept_mutex_methods_s {
+    void (*child_init)(pool *p);
+    void (*init)(pool *p);
+    void (*on)(void);
+    void (*off)(void);
+    char *name;
+};
+typedef struct accept_mutex_methods_s accept_mutex_methods_s;
+accept_mutex_methods_s *amutex;
+
+#ifdef SO_ACCEPTFILTER
+int ap_acceptfilter =
+#ifdef AP_ACCEPTFILTER_OFF
+	0;
+#else
+	1;
+#endif
+#endif
+
+int ap_dump_settings = 0;
+API_VAR_EXPORT int ap_extended_status = 0;
+
+/*
+ * The max child slot ever assigned, preserved across restarts.  Necessary
+ * to deal with MaxClients changes across SIGUSR1 restarts.  We use this
+ * value to optimize routines that have to scan the entire scoreboard.
+ */
+static int max_daemons_limit = -1;
+
+/*
+ * During config time, listeners is treated as a NULL-terminated list.
+ * child_main previously would start at the beginning of the list each time
+ * through the loop, so a socket early on in the list could easily starve out
+ * sockets later on in the list.  The solution is to start at the listener
+ * after the last one processed.  But to do that fast/easily in child_main it's
+ * way more convenient for listeners to be a ring that loops back on itself.
+ * The routine setup_listeners() is called after config time to both open up
+ * the sockets and to turn the NULL-terminated list into a ring that loops back
+ * on itself.
+ *
+ * head_listener is used by each child to keep track of what they consider
+ * to be the "start" of the ring.  It is also set by make_child to ensure
+ * that new children also don't starve any sockets.
+ *
+ * Note that listeners != NULL is ensured by read_config().
+ */
+listen_rec *ap_listeners=NULL;
+static listen_rec *head_listener;
+
+API_VAR_EXPORT char ap_server_root[MAX_STRING_LEN]="";
+API_VAR_EXPORT char ap_server_confname[MAX_STRING_LEN]="";
+API_VAR_EXPORT char ap_coredump_dir[MAX_STRING_LEN]="";
+int ap_coredump_dir_configured=0;
+
+API_VAR_EXPORT array_header *ap_server_pre_read_config=NULL;
+API_VAR_EXPORT array_header *ap_server_post_read_config=NULL;
+API_VAR_EXPORT array_header *ap_server_config_defines=NULL;
+
+/* *Non*-shared http_main globals... */
+
+static server_rec *server_conf;
+#ifndef NETWARE
+static JMP_BUF APACHE_TLS jmpbuffer;
+#endif
+static int sd;
+static fd_set listenfds;
+static int listenmaxfd;
+#ifndef NETWARE
+static pid_t pgrp;
+#endif
+
+/* one_process --- debugging mode variable; can be set from the command line
+ * with the -X flag.  If set, this gets you the child_main loop running
+ * in the process which originally started up (no detach, no make_child),
+ * which is a pretty nice debugging environment.  (You'll get a SIGHUP
+ * early in standalone_main; just continue through.  This is the server
+ * trying to kill off any child processes which it might have lying
+ * around --- Apache doesn't keep track of their pids, it just sends
+ * SIGHUP to the process group, ignoring it in the root process.
+ * Continue through and you'll be fine.).
+ */
+
+static int one_process = 0;
+
+static int do_detach = 1;
+
+/* set if timeouts are to be handled by the children and not by the parent.
+ * i.e. child_timeouts = !standalone || one_process.
+ */
+#ifndef NETWARE
+static int child_timeouts;
+#endif
+
+#ifdef DEBUG_SIGSTOP
+int raise_sigstop_flags;
+#endif
+
+#ifndef NO_OTHER_CHILD
+/* used to maintain list of children which aren't part of the scoreboard */
+typedef struct other_child_rec other_child_rec;
+struct other_child_rec {
+    other_child_rec *next;
+    int pid;
+    void (*maintenance) (int, void *, ap_wait_t);
+    void *data;
+    int write_fd;
+};
+static other_child_rec *other_children;
+#endif
+
+static pool *pglobal;		/* Global pool */
+static pool *pconf;		/* Pool for config stuff */
+static pool *plog;		/* Pool for error-logging files */
+static pool *ptrans;		/* Pool for per-transaction stuff */
+static pool *pchild;		/* Pool for httpd child stuff */
+static pool *pmutex;            /* Pool for accept mutex in child */
+static pool *pcommands;	/* Pool for -C and -c switches */
+
+#ifndef NETWARE
+static int APACHE_TLS my_pid;	/* it seems silly to call getpid all the time */
+#endif
+#ifndef MULTITHREAD
+static int my_child_num;
+#endif
+
+#ifdef TPF
+pid_t tpf_parent_pid;
+int tpf_child = 0;
+char tpf_server_name[INETD_SERVNAME_LENGTH+1];
+char tpf_mutex_key[TPF_MUTEX_KEY_SIZE];
+#endif /* TPF */
+
+scoreboard *ap_scoreboard_image = NULL;
+
+/*
+ * Pieces for managing the contents of the Server response header
+ * field.
+ */
+static char *server_version = NULL;
+static int version_locked = 0;
+
+/* Global, alas, so http_core can talk to us */
+enum server_token_type ap_server_tokens = SrvTk_FULL;
+
+/* Also global, for http_core and http_protocol */
+API_VAR_EXPORT int ap_protocol_req_check = 1;
+
+API_VAR_EXPORT int ap_change_shmem_uid = 0;
+
+/*
+ * This routine is called when the pconf pool is vacuumed.  It resets the
+ * server version string to a known value and [re]enables modifications
+ * (which are disabled by configuration completion). 
+ */
+static void reset_version(void *dummy)
+{
+    version_locked = 0;
+    ap_server_tokens = SrvTk_FULL;
+    server_version = NULL;
+}
+
+API_EXPORT(const char *) ap_get_server_version(void)
+{
+    return (server_version ? server_version : SERVER_BASEVERSION);
+}
+
+API_EXPORT(void) ap_add_version_component(const char *component)
+{
+    if (! version_locked) {
+        /*
+         * If the version string is null, register our cleanup to reset the
+         * pointer on pool destruction. We also know that, if NULL,
+	 * we are adding the original SERVER_BASEVERSION string.
+         */
+        if (server_version == NULL) {
+	    ap_register_cleanup(pconf, NULL, (void (*)(void *))reset_version, 
+				ap_null_cleanup);
+	    server_version = ap_pstrdup(pconf, component);
+	}
+	else {
+	    /*
+	     * Tack the given component identifier to the end of
+	     * the existing string.
+	     */
+	    server_version = ap_pstrcat(pconf, server_version, " ",
+					component, NULL);
+	}
+    }
+}
+
+/*
+ * This routine adds the real server base identity to the version string,
+ * and then locks out changes until the next reconfig.
+ */
+static void ap_set_version(void)
+{
+    if (ap_server_tokens == SrvTk_PRODUCT_ONLY) {
+	ap_add_version_component(SERVER_PRODUCT);
+    }
+    else if (ap_server_tokens == SrvTk_MIN) {
+	ap_add_version_component(SERVER_BASEVERSION);
+    }
+    else {
+	ap_add_version_component(SERVER_BASEVERSION " (" PLATFORM ")");
+    }
+    /*
+     * Lock the server_version string if we're not displaying
+     * the full set of tokens
+     */
+    if (ap_server_tokens != SrvTk_FULL) {
+	version_locked++;
+    }
+}
+
+#ifndef NETWARE
+static APACHE_TLS int volatile exit_after_unblock = 0;
+#endif
+
+#ifdef GPROF
+/* 
+ * change directory for gprof to plop the gmon.out file
+ * configure in httpd.conf:
+ * GprofDir logs/   -> $ServerRoot/logs/gmon.out
+ * GprofDir logs/%  -> $ServerRoot/logs/gprof.$pid/gmon.out
+ */
+static void chdir_for_gprof(void)
+{
+    core_server_config *sconf = 
+	ap_get_module_config(server_conf->module_config, &core_module);    
+    char *dir = sconf->gprof_dir;
+
+    if(dir) {
+	char buf[512];
+	int len = strlen(sconf->gprof_dir) - 1;
+	if(*(dir + len) == '%') {
+	    dir[len] = '\0';
+	    ap_snprintf(buf, sizeof(buf), "%sgprof.%d", dir, (int)getpid());
+	} 
+	dir = ap_server_root_relative(pconf, buf[0] ? buf : dir);
+	if(mkdir(dir, 0755) < 0 && errno != EEXIST) {
+	    ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
+			 "gprof: error creating directory %s", dir);
+	}
+    }
+    else {
+	dir = ap_server_root_relative(pconf, "logs");
+    }
+
+    chdir(dir);
+}
+#else
+#define chdir_for_gprof()
+#endif
+
+/* a clean exit from a child with proper cleanup */
+static void clean_child_exit(int code) __attribute__ ((noreturn));
+static void clean_child_exit(int code)
+{
+    if (pchild) {
+        /* make sure the accept mutex is released before calling child
+         * exit hooks and cleanups...  otherwise, modules can segfault
+         * in such code and, depending on the mutex mechanism, leave
+         * the server deadlocked...  even if the module doesn't segfault,
+         * if it performs extensive processing it can temporarily prevent
+         * the server from accepting new connections
+         */
+        ap_clear_pool(pmutex);
+	ap_child_exit_modules(pchild, server_conf);
+	ap_destroy_pool(pchild);
+    }
+    chdir_for_gprof();
+    exit(code);
+}
+
+/*
+ * Start of accept() mutex fluff:
+ *  Concept: Each method has it's own distinct set of mutex functions,
+ *   which it shoves in a nice struct for us. We then pick
+ *   which struct to use. We tell Apache which methods we
+ *   support via HAVE_FOO_SERIALIZED_ACCEPT. We can
+ *   specify the default via USE_FOO_SERIALIZED_ACCEPT
+ *   (this pre-1.3.21 builds which use that at the command-
+ *   line during builds work as expected). Without a set
+ *   method, we pick the 1st from the following order:
+ *   uslock, pthread, sysvsem, fcntl, flock, os2sem, tpfcore and none.
+ */
+
+#if defined(HAVE_FCNTL_SERIALIZED_ACCEPT) || defined(HAVE_FLOCK_SERIALIZED_ACCEPT)
+static void expand_lock_fname(pool *p)
+{
+    /* XXXX possibly bogus cast */
+    ap_lock_fname = ap_psprintf(p, "%s.%lu",
+	ap_server_root_relative(p, ap_lock_fname), (unsigned long)getpid());
+}
+#endif
+
+#if defined (HAVE_USLOCK_SERIALIZED_ACCEPT)
+#include <ulocks.h>
+static ulock_t uslock = NULL;
+
+#define accept_mutex_child_init_uslock(x)
+
+static void accept_mutex_init_uslock(pool *p)
+{
+    ptrdiff_t old;
+    usptr_t *us;
+
+
+    /* default is 8, allocate enough for all the children plus the parent */
+    if ((old = usconfig(CONF_INITUSERS, HARD_SERVER_LIMIT + 1)) == -1) {
+	perror("usconfig(CONF_INITUSERS)");
+	exit(-1);
+    }
+
+    if ((old = usconfig(CONF_LOCKTYPE, US_NODEBUG)) == -1) {
+	perror("usconfig(CONF_LOCKTYPE)");
+	exit(-1);
+    }
+    if ((old = usconfig(CONF_ARENATYPE, US_SHAREDONLY)) == -1) {
+	perror("usconfig(CONF_ARENATYPE)");
+	exit(-1);
+    }
+    if ((us = usinit("/dev/zero")) == NULL) {
+	perror("usinit");
+	exit(-1);
+    }
+
+    if ((uslock = usnewlock(us)) == NULL) {
+	perror("usnewlock");
+	exit(-1);
+    }
+}
+
+static void accept_mutex_on_uslock(void)
+{
+    switch (ussetlock(uslock)) {
+    case 1:
+	/* got lock */
+	break;
+    case 0:
+	fprintf(stderr, "didn't get lock\n");
+	clean_child_exit(APEXIT_CHILDFATAL);
+    case -1:
+	perror("ussetlock");
+	clean_child_exit(APEXIT_CHILDFATAL);
+    }
+}
+
+static void accept_mutex_off_uslock(void)
+{
+    if (usunsetlock(uslock) == -1) {
+	perror("usunsetlock");
+	clean_child_exit(APEXIT_CHILDFATAL);
+    }
+}
+
+accept_mutex_methods_s accept_mutex_uslock_s = {
+    NULL,
+    accept_mutex_init_uslock,
+    accept_mutex_on_uslock,
+    accept_mutex_off_uslock,
+    "uslock"
+};
+#endif
+
+#if defined (HAVE_PTHREAD_SERIALIZED_ACCEPT)
+
+/* This code probably only works on Solaris ... but it works really fast
+ * on Solaris.  Note that pthread mutexes are *NOT* released when a task
+ * dies ... the task has to free it itself.  So we block signals and
+ * try to be nice about releasing the mutex.
+ */
+
+#include <pthread.h>
+
+static pthread_mutex_t *accept_mutex = (void *)(caddr_t) -1;
+static int have_accept_mutex;
+static sigset_t accept_block_mask;
+static sigset_t accept_previous_mask;
+
+static void accept_mutex_child_cleanup_pthread(void *foo)
+{
+    if (accept_mutex != (void *)(caddr_t)-1
+	&& have_accept_mutex) {
+	pthread_mutex_unlock(accept_mutex);
+    }
+}
+
+static void accept_mutex_child_init_pthread(pool *p)
+{
+    ap_register_cleanup(p, NULL, accept_mutex_child_cleanup_pthread, ap_null_cleanup);
+}
+
+static void accept_mutex_cleanup_pthread(void *foo)
+{
+    if (accept_mutex != (void *)(caddr_t)-1
+	&& munmap((caddr_t) accept_mutex, sizeof(*accept_mutex))) {
+	perror("munmap");
+    }
+    accept_mutex = (void *)(caddr_t)-1;
+}
+
+/* remove_sync_sigs() is from APR 0.9.4
+ *
+ * It is invalid to block synchronous signals, as such signals must
+ * be delivered on the thread that generated the original error
+ * (e.g., invalid storage reference).  Blocking them interferes
+ * with proper recovery.
+ */
+static void remove_sync_sigs(sigset_t *sig_mask)
+{
+#ifdef SIGABRT
+    sigdelset(sig_mask, SIGABRT);
+#endif
+#ifdef SIGBUS
+    sigdelset(sig_mask, SIGBUS);
+#endif
+#ifdef SIGEMT
+    sigdelset(sig_mask, SIGEMT);
+#endif
+#ifdef SIGFPE
+    sigdelset(sig_mask, SIGFPE);
+#endif
+#ifdef SIGILL
+    sigdelset(sig_mask, SIGILL);
+#endif
+#ifdef SIGIOT
+    sigdelset(sig_mask, SIGIOT);
+#endif
+#ifdef SIGPIPE
+    sigdelset(sig_mask, SIGPIPE);
+#endif
+#ifdef SIGSEGV
+    sigdelset(sig_mask, SIGSEGV);
+#endif
+#ifdef SIGSYS
+    sigdelset(sig_mask, SIGSYS);
+#endif
+#ifdef SIGTRAP
+    sigdelset(sig_mask, SIGTRAP);
+#endif
+
+/* APR logic to remove SIGUSR2 not copied */
+}
+
+static void accept_mutex_init_pthread(pool *p)
+{
+    pthread_mutexattr_t mattr;
+    int fd;
+
+    fd = open("/dev/zero", O_RDWR);
+    if (fd == -1) {
+	perror("open(/dev/zero)");
+	exit(APEXIT_INIT);
+    }
+    accept_mutex = (pthread_mutex_t *) mmap((caddr_t) 0, sizeof(*accept_mutex),
+				 PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+    if (accept_mutex == (void *) (caddr_t) - 1) {
+	perror("mmap /dev/zero");
+	exit(APEXIT_INIT);
+    }
+    close(fd);
+    if ((errno = pthread_mutexattr_init(&mattr))) {
+	perror("pthread_mutexattr_init");
+	exit(APEXIT_INIT);
+    }
+#if !defined(CYGWIN)
+    /* Cygwin has problems with this pthread call claiming that these 
+     * are "Invalid arguements", Stipe Tolj <tolj@wapme-systems.de>
+     */
+    if ((errno = pthread_mutexattr_setpshared(&mattr,
+						PTHREAD_PROCESS_SHARED))) {
+	perror("pthread_mutexattr_setpshared");
+	exit(APEXIT_INIT);
+    }
+#endif
+    if ((errno = pthread_mutex_init(accept_mutex, &mattr))) {
+	perror("pthread_mutex_init");
+	exit(APEXIT_INIT);
+    }
+    sigfillset(&accept_block_mask);
+    sigdelset(&accept_block_mask, SIGHUP);
+    sigdelset(&accept_block_mask, SIGTERM);
+    sigdelset(&accept_block_mask, SIGUSR1);
+    remove_sync_sigs(&accept_block_mask);
+    ap_register_cleanup(p, NULL, accept_mutex_cleanup_pthread, ap_null_cleanup);
+}
+
+static void accept_mutex_on_pthread(void)
+{
+    int err;
+
+    if (sigprocmask(SIG_BLOCK, &accept_block_mask, &accept_previous_mask)) {
+	perror("sigprocmask(SIG_BLOCK)");
+	clean_child_exit(APEXIT_CHILDFATAL);
+    }
+    /* We need to block alarms here, since if we get killed *right* after 
+     * locking the mutex, have_accept_mutex will not be set, and our
+     * child cleanup will not work.
+     */
+    ap_block_alarms();
+    if ((err = pthread_mutex_lock(accept_mutex))) {
+	errno = err;
+	perror("pthread_mutex_lock");
+	clean_child_exit(APEXIT_CHILDFATAL);
+    }
+    have_accept_mutex = 1;
+    ap_unblock_alarms();
+}
+
+static void accept_mutex_off_pthread(void)
+{
+    int err;
+
+    /* Have to block alarms here, or else we might have a double-unlock, which
+     * is possible with pthread mutexes, since they are designed to be fast,
+     * and hence not necessarily make checks for ownership or multiple unlocks.
+     */
+    ap_block_alarms(); 
+    if ((err = pthread_mutex_unlock(accept_mutex))) {
+	errno = err;
+	perror("pthread_mutex_unlock");
+	clean_child_exit(APEXIT_CHILDFATAL);
+    }
+    have_accept_mutex = 0;
+    ap_unblock_alarms();
+    if (sigprocmask(SIG_SETMASK, &accept_previous_mask, NULL)) {
+	perror("sigprocmask(SIG_SETMASK)");
+	clean_child_exit(1);
+    }
+}
+
+accept_mutex_methods_s accept_mutex_pthread_s = {
+    accept_mutex_child_init_pthread,
+    accept_mutex_init_pthread,
+    accept_mutex_on_pthread,
+    accept_mutex_off_pthread,
+    "pthread"
+};
+#endif
+
+#if defined (HAVE_SYSVSEM_SERIALIZED_ACCEPT)
+
+#include <sys/types.h>
+#include <sys/ipc.h>
+#include <sys/sem.h>
+
+#ifdef NEED_UNION_SEMUN
+union semun {
+    int val;
+    struct semid_ds *buf;
+    ushort *array;
+};
+
+#endif
+
+static int sem_id = -1;
+static struct sembuf op_on;
+static struct sembuf op_off;
+
+/* We get a random semaphore ... the lame sysv semaphore interface
+ * means we have to be sure to clean this up or else we'll leak
+ * semaphores.
+ */
+static void accept_mutex_cleanup_sysvsem(void *foo)
+{
+    union semun ick;
+
+    if (sem_id < 0)
+	return;
+    /* this is ignored anyhow */
+    ick.val = 0;
+    semctl(sem_id, 0, IPC_RMID, ick);
+}
+
+#define accept_mutex_child_init_sysvsem(x)
+
+static void accept_mutex_init_sysvsem(pool *p)
+{
+    union semun ick;
+    struct semid_ds buf;
+
+    /* acquire the semaphore */
+    sem_id = semget(IPC_PRIVATE, 1, IPC_CREAT | 0600);
+    if (sem_id < 0) {
+	perror("semget");
+	exit(APEXIT_INIT);
+    }
+    ick.val = 1;
+    if (semctl(sem_id, 0, SETVAL, ick) < 0) {
+	perror("semctl(SETVAL)");
+	exit(APEXIT_INIT);
+    }
+    if (!getuid()) {
+	/* restrict it to use only by the appropriate user_id ... not that this
+	 * stops CGIs from acquiring it and dinking around with it.
+	 */
+	buf.sem_perm.uid = ap_user_id;
+	buf.sem_perm.gid = ap_group_id;
+	buf.sem_perm.mode = 0600;
+	ick.buf = &buf;
+	if (semctl(sem_id, 0, IPC_SET, ick) < 0) {
+	    perror("semctl(IPC_SET)");
+	    exit(APEXIT_INIT);
+	}
+    }
+    ap_register_cleanup(p, NULL, accept_mutex_cleanup_sysvsem, ap_null_cleanup);
+
+    /* pre-initialize these */
+    op_on.sem_num = 0;
+    op_on.sem_op = -1;
+    op_on.sem_flg = SEM_UNDO;
+    op_off.sem_num = 0;
+    op_off.sem_op = 1;
+    op_off.sem_flg = SEM_UNDO;
+}
+
+static void accept_mutex_on_sysvsem(void)
+{
+    while (semop(sem_id, &op_on, 1) < 0) {
+	if (errno != EINTR) {
+	    perror("accept_mutex_on");
+	    clean_child_exit(APEXIT_CHILDFATAL);
+	}
+    }
+}
+
+static void accept_mutex_off_sysvsem(void)
+{
+    while (semop(sem_id, &op_off, 1) < 0) {
+	if (errno != EINTR) {
+	    perror("accept_mutex_off");
+	    clean_child_exit(APEXIT_CHILDFATAL);
+	}
+    }
+}
+
+accept_mutex_methods_s accept_mutex_sysvsem_s = {
+    NULL,
+    accept_mutex_init_sysvsem,
+    accept_mutex_on_sysvsem,
+    accept_mutex_off_sysvsem,
+    "sysvsem"
+};
+#endif
+
+#if defined(HAVE_FCNTL_SERIALIZED_ACCEPT)
+static struct flock lock_it;
+static struct flock unlock_it;
+
+static int lock_fd = -1;
+
+#define accept_mutex_child_init_fcntl(x)
+
+/*
+ * Initialize mutex lock.
+ * Must be safe to call this on a restart.
+ */
+static void accept_mutex_init_fcntl(pool *p)
+{
+
+    lock_it.l_whence = SEEK_SET;	/* from current point */
+    lock_it.l_start = 0;		/* -"- */
+    lock_it.l_len = 0;			/* until end of file */
+    lock_it.l_type = F_WRLCK;		/* set exclusive/write lock */
+    lock_it.l_pid = 0;			/* pid not actually interesting */
+    unlock_it.l_whence = SEEK_SET;	/* from current point */
+    unlock_it.l_start = 0;		/* -"- */
+    unlock_it.l_len = 0;		/* until end of file */
+    unlock_it.l_type = F_UNLCK;		/* set exclusive/write lock */
+    unlock_it.l_pid = 0;		/* pid not actually interesting */
+
+    expand_lock_fname(p);
+    lock_fd = ap_popenf_ex(p, ap_lock_fname, O_CREAT | O_WRONLY | O_EXCL, 0644, 1);
+    if (lock_fd == -1) {
+	perror("open");
+	fprintf(stderr, "Cannot open lock file: %s\n", ap_lock_fname);
+	exit(APEXIT_INIT);
+    }
+    unlink(ap_lock_fname);
+}
+
+static void accept_mutex_on_fcntl(void)
+{
+    int ret;
+
+    while ((ret = fcntl(lock_fd, F_SETLKW, &lock_it)) < 0 && errno == EINTR) {
+	/* nop */
+    }
+
+    if (ret < 0) {
+	ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf,
+		    "fcntl: F_SETLKW: Error getting accept lock, exiting!  "
+		    "Perhaps you need to use the LockFile directive to place "
+		    "your lock file on a local disk!");
+	clean_child_exit(APEXIT_CHILDFATAL);
+    }
+}
+
+static void accept_mutex_off_fcntl(void)
+{
+    int ret;
+
+    while ((ret = fcntl(lock_fd, F_SETLKW, &unlock_it)) < 0 && errno == EINTR) {
+	/* nop */
+    }
+    if (ret < 0) {
+	ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf,
+		    "fcntl: F_SETLKW: Error freeing accept lock, exiting!  "
+		    "Perhaps you need to use the LockFile directive to place "
+		    "your lock file on a local disk!");
+	clean_child_exit(APEXIT_CHILDFATAL);
+    }
+}
+
+accept_mutex_methods_s accept_mutex_fcntl_s = {
+    NULL,
+    accept_mutex_init_fcntl,
+    accept_mutex_on_fcntl,
+    accept_mutex_off_fcntl,
+    "fcntl"
+};
+#endif
+
+#if defined(HAVE_FLOCK_SERIALIZED_ACCEPT)
+
+static int flock_fd = -1;
+
+static void accept_mutex_cleanup_flock(void *foo)
+{
+    unlink(ap_lock_fname);
+}
+
+/*
+ * Initialize mutex lock.
+ * Done by each child at it's birth
+ */
+static void accept_mutex_child_init_flock(pool *p)
+{
+
+    flock_fd = ap_popenf_ex(p, ap_lock_fname, O_WRONLY, 0600, 1);
+    if (flock_fd == -1) {
+	ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf,
+		    "Child cannot open lock file: %s", ap_lock_fname);
+	clean_child_exit(APEXIT_CHILDINIT);
+    }
+}
+
+/*
+ * Initialize mutex lock.
+ * Must be safe to call this on a restart.
+ */
+static void accept_mutex_init_flock(pool *p)
+{
+    expand_lock_fname(p);
+    unlink(ap_lock_fname);
+    flock_fd = ap_popenf_ex(p, ap_lock_fname, O_CREAT | O_WRONLY | O_EXCL, 0600, 1);
+    if (flock_fd == -1) {
+	ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf,
+		    "Parent cannot open lock file: %s", ap_lock_fname);
+	exit(APEXIT_INIT);
+    }
+    ap_register_cleanup(p, NULL, accept_mutex_cleanup_flock, ap_null_cleanup);
+}
+
+static void accept_mutex_on_flock(void)
+{
+    int ret;
+
+    while ((ret = flock(flock_fd, LOCK_EX)) < 0 && errno == EINTR)
+	continue;
+
+    if (ret < 0) {
+	ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf,
+		    "flock: LOCK_EX: Error getting accept lock. Exiting!");
+	clean_child_exit(APEXIT_CHILDFATAL);
+    }
+}
+
+static void accept_mutex_off_flock(void)
+{
+    if (flock(flock_fd, LOCK_UN) < 0) {
+	ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf,
+		    "flock: LOCK_UN: Error freeing accept lock. Exiting!");
+	clean_child_exit(APEXIT_CHILDFATAL);
+    }
+}
+
+accept_mutex_methods_s accept_mutex_flock_s = {
+    accept_mutex_child_init_flock,
+    accept_mutex_init_flock,
+    accept_mutex_on_flock,
+    accept_mutex_off_flock,
+    "flock"
+};
+#endif
+
+#if defined(HAVE_OS2SEM_SERIALIZED_ACCEPT)
+
+static HMTX lock_sem = -1;
+
+static void accept_mutex_cleanup_os2sem(void *foo)
+{
+    DosReleaseMutexSem(lock_sem);
+    DosCloseMutexSem(lock_sem);
+}
+
+/*
+ * Initialize mutex lock.
+ * Done by each child at it's birth
+ */
+static void accept_mutex_child_init_os2sem(pool *p)
+{
+    int rc = DosOpenMutexSem(NULL, &lock_sem);
+
+    if (rc != 0) {
+	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_EMERG, server_conf,
+		    "Child cannot open lock semaphore, rc=%d", rc);
+	clean_child_exit(APEXIT_CHILDINIT);
+    } else {
+        ap_register_cleanup(p, NULL, accept_mutex_cleanup_os2sem, ap_null_cleanup);
+    }
+}
+
+/*
+ * Initialize mutex lock.
+ * Must be safe to call this on a restart.
+ */
+static void accept_mutex_init_os2sem(pool *p)
+{
+    int rc = DosCreateMutexSem(NULL, &lock_sem, DC_SEM_SHARED, FALSE);
+
+    if (rc != 0) {
+	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_EMERG, server_conf,
+		    "Parent cannot create lock semaphore, rc=%d", rc);
+	exit(APEXIT_INIT);
+    }
+
+    ap_register_cleanup(p, NULL, accept_mutex_cleanup_os2sem, ap_null_cleanup);
+}
+
+static void accept_mutex_on_os2sem(void)
+{
+    int rc = DosRequestMutexSem(lock_sem, SEM_INDEFINITE_WAIT);
+
+    if (rc != 0) {
+	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_EMERG, server_conf,
+		    "OS2SEM: Error %d getting accept lock. Exiting!", rc);
+	clean_child_exit(APEXIT_CHILDFATAL);
+    }
+}
+
+static void accept_mutex_off_os2sem(void)
+{
+    int rc = DosReleaseMutexSem(lock_sem);
+    
+    if (rc != 0) {
+	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_EMERG, server_conf,
+		    "OS2SEM: Error %d freeing accept lock. Exiting!", rc);
+	clean_child_exit(APEXIT_CHILDFATAL);
+    }
+}
+
+accept_mutex_methods_s accept_mutex_os2sem_s = {
+    accept_mutex_child_init_os2sem,
+    accept_mutex_init_os2sem,
+    accept_mutex_on_os2sem,
+    accept_mutex_off_os2sem,
+    "os2sem"
+};
+#endif
+
+#if defined(HAVE_TPF_CORE_SERIALIZED_ACCEPT)
+
+static int tpf_core_held;
+
+static void accept_mutex_cleanup_tpfcore(void *foo)
+{
+    if(tpf_core_held)
+        deqc(tpf_mutex_key, QUAL_S);
+}
+
+#define accept_mutex_init_tpfcore(x)
+
+static void accept_mutex_child_init_tpfcore(pool *p)
+{
+    ap_register_cleanup(p, NULL, accept_mutex_cleanup_tpfcore, ap_null_cleanup);
+    tpf_core_held = 0;
+}
+
+static void accept_mutex_on_tpfcore(void)
+{
+    enqc(tpf_mutex_key, ENQ_WAIT, 0, QUAL_S);
+    tpf_core_held = 1;
+    ap_check_signals();
+}
+
+static void accept_mutex_off_tpfcore(void)
+{
+    deqc(tpf_mutex_key, QUAL_S);
+    tpf_core_held = 0;
+    ap_check_signals();
+}
+
+accept_mutex_methods_s accept_mutex_tpfcore_s = {
+    accept_mutex_child_init_tpfcore,
+    NULL,
+    accept_mutex_on_tpfcore,
+    accept_mutex_off_tpfcore,
+    "tpfcore"
+};
+#endif
+
+#ifdef HAVE_BEOS_SERIALIZED_ACCEPT
+static sem_id _sem = -1;
+static int  locked = 0;
+
+static void accept_mutex_child_cleanup_beos(void *foo)
+{
+    if (_sem > 0 && locked)
+        release_sem(_sem);
+}
+
+static void accept_mutex_child_init_beos(pool *p)
+{
+    ap_register_cleanup(p, NULL, accept_mutex_child_cleanup_beos, ap_null_cleanup);
+    locked = 0;
+}
+
+static void accept_mutex_cleanup_beos(void *foo)
+{
+    if (_sem > 0)
+        delete_sem(_sem);
+}
+
+static void accept_mutex_init_beos(pool *p)
+{
+    _sem = create_sem(1, "httpd_accept");
+    if (_sem < 0) {
+        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_EMERG, server_conf,
+                    "Parent cannot create lock semaphore, sem=%ld", _sem);
+        exit(APEXIT_INIT);
+    }
+
+    ap_register_cleanup(p, NULL, accept_mutex_cleanup_beos, ap_null_cleanup);
+}                                                                                                        
+void accept_mutex_on_beos(void)
+{
+    if (locked == 0) {
+        if (acquire_sem(_sem) == B_OK)
+            locked = 1;
+    }
+}
+
+static void accept_mutex_off_beos(void)
+{
+    if (locked == 1) {
+        if (release_sem(_sem) == B_OK)
+            locked = 0; 
+    }
+}
+
+accept_mutex_methods_s accept_mutex_beos_s = {
+    accept_mutex_child_init_beos,
+    accept_mutex_init_beos,
+    accept_mutex_on_beos,
+    accept_mutex_off_beos,
+    "beos_sem"
+};
+#endif /* HAVE_BEOS_SERIALIZED_ACCEPT */
+
+
+/* Generally, HAVE_NONE_SERIALIZED_ACCEPT simply won't work but
+ * for testing purposes, here it is... */
+#if defined HAVE_NONE_SERIALIZED_ACCEPT
+#if !defined(MULTITHREAD)
+/* Multithreaded systems don't complete between processes for
+ * the sockets. */
+#define NO_SERIALIZED_ACCEPT
+#endif 
+
+accept_mutex_methods_s accept_mutex_none_s = {
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    "none"
+};
+#endif
+
+#define AP_FPTR1(x,y)	{ if (x) ((* x)(y)); }
+#define AP_FPTR0(x)	{ if (x) ((* x)()); }
+
+#define accept_mutex_child_init(x) 	AP_FPTR1(amutex->child_init,x)
+#define accept_mutex_init(x) 		AP_FPTR1(amutex->init,x)
+#define accept_mutex_off() 		AP_FPTR0(amutex->off)
+#define accept_mutex_on() 		AP_FPTR0(amutex->on)
+
+char *ap_default_mutex_method(void)
+{
+    char *t;
+#if defined USE_USLOCK_SERIALIZED_ACCEPT
+    t = "uslock";
+#elif defined USE_PTHREAD_SERIALIZED_ACCEPT
+    t = "pthread";
+#elif defined USE_SYSVSEM_SERIALIZED_ACCEPT
+    t = "sysvsem";
+#elif defined USE_FCNTL_SERIALIZED_ACCEPT
+    t = "fcntl";
+#elif defined USE_FLOCK_SERIALIZED_ACCEPT
+    t = "flock";
+#elif defined USE_OS2SEM_SERIALIZED_ACCEPT
+    t = "os2sem";
+#elif defined USE_TPF_CORE_SERIALIZED_ACCEPT
+    t = "tpfcore";
+#elif defined USE_BEOS_SERIALIZED_ACCEPT
+    t = "beos_sem";
+#elif defined USE_NONE_SERIALIZED_ACCEPT
+    t = "none";
+#else
+    t = "default";
+#endif
+#if defined HAVE_USLOCK_SERIALIZED_ACCEPT
+    if ((!(strcasecmp(t,"default"))) || (!(strcasecmp(t,"uslock"))))
+    	return "uslock";
+#endif
+#if defined HAVE_PTHREAD_SERIALIZED_ACCEPT
+    if ((!(strcasecmp(t,"default"))) || (!(strcasecmp(t,"pthread"))))
+    	return "pthread";
+#endif
+#if defined HAVE_SYSVSEM_SERIALIZED_ACCEPT
+    if ((!(strcasecmp(t,"default"))) || (!(strcasecmp(t,"sysvsem"))))
+    	return "sysvsem";
+#endif
+#if defined HAVE_FCNTL_SERIALIZED_ACCEPT
+    if ((!(strcasecmp(t,"default"))) || (!(strcasecmp(t,"fcntl"))))
+    	return "fcntl";
+#endif
+#if defined HAVE_FLOCK_SERIALIZED_ACCEPT
+    if ((!(strcasecmp(t,"default"))) || (!(strcasecmp(t,"flock"))))
+    	return "flock";
+#endif
+#if defined HAVE_OS2SEM_SERIALIZED_ACCEPT
+    if ((!(strcasecmp(t,"default"))) || (!(strcasecmp(t,"os2sem"))))
+    	return "os2sem";
+#endif
+#if defined HAVE_TPF_CORE_SERIALIZED_ACCEPT
+    if ((!(strcasecmp(t,"default"))) || (!(strcasecmp(t,"tpfcore"))))
+    	return "tpfcore";
+#endif
+#if defined HAVE_BEOS_SERIALIZED_ACCEPT
+    if ((!(strcasecmp(t,"default"))) || (!(strcasecmp(t,"beos_sem"))))
+        return "beos_sem";
+#endif
+#if defined HAVE_NONE_SERIALIZED_ACCEPT
+    if ((!(strcasecmp(t,"default"))) || (!(strcasecmp(t,"none"))))
+    	return "none";
+#endif
+
+    fprintf(stderr, "No default accept serialization known!!\n");
+    exit(APEXIT_INIT);
+    /*NOTREACHED */
+    return "unknown";
+}
+
+char *ap_init_mutex_method(char *t)
+{
+    if (!(strcasecmp(t,"default")))
+	t = ap_default_mutex_method();
+
+#if defined HAVE_USLOCK_SERIALIZED_ACCEPT
+    if (!(strcasecmp(t,"uslock"))) {
+    	amutex = &accept_mutex_uslock_s;
+    } else 
+#endif
+#if defined HAVE_PTHREAD_SERIALIZED_ACCEPT
+    if (!(strcasecmp(t,"pthread"))) {
+    	amutex = &accept_mutex_pthread_s;
+    } else 
+#endif
+#if defined HAVE_SYSVSEM_SERIALIZED_ACCEPT
+    if (!(strcasecmp(t,"sysvsem"))) {
+    	amutex = &accept_mutex_sysvsem_s;
+    } else 
+#endif
+#if defined HAVE_FCNTL_SERIALIZED_ACCEPT
+    if (!(strcasecmp(t,"fcntl"))) {
+    	amutex = &accept_mutex_fcntl_s;
+    } else
+#endif
+#if defined HAVE_FLOCK_SERIALIZED_ACCEPT
+    if (!(strcasecmp(t,"flock"))) {
+    	amutex = &accept_mutex_flock_s;
+    } else 
+#endif
+#if defined HAVE_OS2SEM_SERIALIZED_ACCEPT
+    if (!(strcasecmp(t,"os2sem"))) {
+    	amutex = &accept_mutex_os2sem_s;
+    } else 
+#endif
+#if defined HAVE_TPF_CORE_SERIALIZED_ACCEPT
+    if (!(strcasecmp(t,"tpfcore"))) {
+    	amutex = &accept_mutex_tpfcore_s;
+    } else 
+#endif
+#if defined HAVE_BEOS_SERIALIZED_ACCEPT
+    if (!(strcasecmp(t,"beos_sem"))) {
+        amutex = &accept_mutex_beos_s;
+    } else
+#endif
+#if defined HAVE_NONE_SERIALIZED_ACCEPT
+    if (!(strcasecmp(t,"none"))) {
+    	amutex = &accept_mutex_none_s;
+    } else
+#endif
+    {
+/* Ignore this directive on Windows */
+#ifndef WIN32
+    if (server_conf) {
+        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, server_conf,
+                    "Requested serialization method '%s' not available",t);
+        exit(APEXIT_INIT);
+    } else {
+        fprintf(stderr, "Requested serialization method '%s' not available\n", t);
+        exit(APEXIT_INIT);
+    }
+#endif
+    }
+    return NULL;
+}
+
+/* On some architectures it's safe to do unserialized accept()s in the single
+ * Listen case.  But it's never safe to do it in the case where there's
+ * multiple Listen statements.  Define SINGLE_LISTEN_UNSERIALIZED_ACCEPT
+ * when it's safe in the single Listen case.
+ */
+#ifdef SINGLE_LISTEN_UNSERIALIZED_ACCEPT
+#define SAFE_ACCEPT(stmt) do {if(ap_listeners->next != ap_listeners) {stmt;}} while(0)
+#else
+#define SAFE_ACCEPT(stmt) do {stmt;} while(0)
+#endif
+
+static void usage(char *bin)
+{
+    char pad[MAX_STRING_LEN];
+    unsigned i;
+
+    for (i = 0; i < strlen(bin); i++)
+	pad[i] = ' ';
+    pad[i] = '\0';
+#ifdef WIN32
+    fprintf(stderr, "Usage: %s [-D name] [-d directory] [-f file] [-n service]\n", bin);
+    fprintf(stderr, "       %s [-C \"directive\"] [-c \"directive\"] [-k signal]\n", pad);
+    fprintf(stderr, "       %s [-v] [-V] [-h] [-l] [-L] [-S] [-t] [-T]\n", pad);
+#else /* !WIN32 */
+#ifdef SHARED_CORE
+    fprintf(stderr, "Usage: %s [-R directory] [-D name] [-d directory] [-f file]\n", bin);
+#else
+    fprintf(stderr, "Usage: %s [-D name] [-d directory] [-f file]\n", bin);
+#endif
+    fprintf(stderr, "       %s [-C \"directive\"] [-c \"directive\"]\n", pad);
+    fprintf(stderr, "       %s [-v] [-V] [-h] [-l] [-L] [-S] [-t] [-T] [-F]\n", pad);
+    fprintf(stderr, "Options:\n");
+#ifdef SHARED_CORE
+    fprintf(stderr, "  -R directory     : specify an alternate location for shared object files\n");
+#endif
+#endif /* !WIN32 */
+    fprintf(stderr, "  -D name          : define a name for use in <IfDefine name> directives\n");
+    fprintf(stderr, "  -d directory     : specify an alternate initial ServerRoot\n");
+    fprintf(stderr, "  -f file          : specify an alternate ServerConfigFile\n");
+    fprintf(stderr, "  -C \"directive\"   : process directive before reading config files\n");
+    fprintf(stderr, "  -c \"directive\"   : process directive after  reading config files\n");
+    fprintf(stderr, "  -v               : show version number\n");
+    fprintf(stderr, "  -V               : show compile settings\n");
+    fprintf(stderr, "  -h               : list available command line options (this page)\n");
+    fprintf(stderr, "  -l               : list compiled-in modules\n");
+    fprintf(stderr, "  -L               : list available configuration directives\n");
+    fprintf(stderr, "  -S               : show parsed settings (currently only vhost settings)\n");
+#ifdef NETWARE
+    fprintf(stderr, "  -e               : force the display of configuration file errors to the logger screen\n");
+    fprintf(stderr, "  -s               : load Apache without a screen\n");
+#endif
+    fprintf(stderr, "  -t               : run syntax check for config files (with docroot check)\n");
+    fprintf(stderr, "  -T               : run syntax check for config files (without docroot check)\n");
+#ifndef WIN32
+    fprintf(stderr, "  -F               : run main process in foreground, for process supervisors\n");
+#endif
+#ifdef WIN32
+    fprintf(stderr, "  -n name          : name the Apache service for -k options below;\n");
+    fprintf(stderr, "  -k stop|shutdown : tell running Apache to shutdown\n");
+    fprintf(stderr, "  -k restart       : tell running Apache to do a graceful restart\n");
+    fprintf(stderr, "  -k start         : tell Apache to start\n");
+    fprintf(stderr, "  -k install   | -i: install an Apache service\n");
+    fprintf(stderr, "  -k config        : reconfigure an installed Apache service\n");
+    fprintf(stderr, "  -k uninstall | -u: uninstall an Apache service\n");
+    fprintf(stderr, "  -W service       : after -k config|install; Apache starts after 'service'\n");
+    fprintf(stderr, "  -w               : holds the window open for 30 seconds for fatal errors.\n");
+#endif
+
+#if defined(NETWARE)
+    clean_parent_exit(0);
+#else
+    exit(1);
+#endif
+}
+
+
+
+#ifdef NETWARE
+/* Thread Storage Data */
+typedef struct _TSD {
+    conn_rec*		current_conn;
+    int 			alarms_blocked;
+    int				alarm_pending;
+    request_rec*	timeout_req;
+    char*			timeout_name;
+    JMP_BUF			jmpbuffer;
+    int				exit_after_unblock;
+    void 			(*alarm_fn) (int);
+    unsigned int 	alarm_expiry_time;
+} TSD;
+
+static TSD Tsd;
+
+void init_tsd()
+{    
+    int *thread_ptr;
+
+    memset(&Tsd, 0, sizeof(TSD));
+    thread_ptr = __get_thread_data_area_ptr();
+    *thread_ptr = (int) &Tsd;
+}
+
+#define get_tsd            TSD* tsd = (TSD*) Thread_Data_Area;
+#define current_conn       tsd->current_conn
+#define alarms_blocked     tsd->alarms_blocked
+#define alarm_pending      tsd->alarm_pending
+#define timeout_req        tsd->timeout_req
+#define timeout_name       tsd->timeout_name
+#define jmpbuffer          tsd->jmpbuffer
+#define exit_after_unblock tsd->exit_after_unblock
+#define alarm_fn           tsd->alarm_fn
+#define alarm_expiry_time  tsd->alarm_expiry_time
+
+#else
+/*****************************************************************
+ *
+ * Timeout handling.  DISTINCTLY not thread-safe, but all this stuff
+ * has to change for threads anyway.  Note that this code allows only
+ * one timeout in progress at a time...
+ */
+
+static APACHE_TLS conn_rec *volatile current_conn;
+static APACHE_TLS request_rec *volatile timeout_req;
+static APACHE_TLS const char *volatile timeout_name = NULL;
+static APACHE_TLS int volatile alarms_blocked = 0;
+static APACHE_TLS int volatile alarm_pending = 0;
+#endif
+
+
+static void timeout(int sig)
+{
+    void *dirconf;
+#ifdef NETWARE
+    get_tsd
+#endif    
+    if (alarms_blocked) {
+	alarm_pending = 1;
+	return;
+    }
+    if (exit_after_unblock) {
+	clean_child_exit(0);
+    }
+
+    if (!current_conn) {
+	ap_longjmp(jmpbuffer, 1);
+    }
+
+    if (timeout_req != NULL)
+	dirconf = timeout_req->per_dir_config;
+    else
+	dirconf = current_conn->server->lookup_defaults;
+    if (!current_conn->keptalive) {
+	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO,
+		     current_conn->server, "[client %s] %s timed out",
+		     current_conn->remote_ip,
+		     timeout_name ? timeout_name : "request");
+    }
+
+    if (timeout_req) {
+	/* Someone has asked for this transaction to just be aborted
+	 * if it times out...
+	 */
+	request_rec *log_req = timeout_req;
+	request_rec *save_req = timeout_req;
+
+	/* avoid looping... if ap_log_transaction started another
+	 * timer (say via rfc1413.c) we could loop...
+	 */
+	timeout_req = NULL;
+
+	while (log_req->main || log_req->prev) {
+#ifdef NETWARE
+            ThreadSwitch();
+#endif
+	    /* Get back to original request... */
+	    if (log_req->main)
+		log_req = log_req->main;
+	    else
+		log_req = log_req->prev;
+	}
+
+	if (!current_conn->keptalive) {
+	    /* in some cases we come here before setting the time */
+	    if (log_req->request_time == 0) {
+                log_req->request_time = time(NULL);
+	    }
+	    ap_log_transaction(log_req);
+	}
+
+	ap_bsetflag(save_req->connection->client, B_EOUT, 1);
+	ap_bclose(save_req->connection->client);
+	
+	if (!ap_standalone)
+	    exit(0);
+        ap_longjmp(jmpbuffer, 1);
+    }
+    else {			/* abort the connection */
+	ap_bsetflag(current_conn->client, B_EOUT, 1);
+	ap_bclose(current_conn->client);
+	current_conn->aborted = 1;
+    }
+}
+
+
+#ifndef TPF
+/*
+ * These two called from alloc.c to protect its critical sections...
+ * Note that they can nest (as when destroying the sub_pools of a pool
+ * which is itself being cleared); we have to support that here.
+ */
+
+API_EXPORT(void) ap_block_alarms(void)
+{
+#ifdef NETWARE
+    get_tsd
+#endif
+    ++alarms_blocked;
+}
+
+API_EXPORT(void) ap_unblock_alarms(void)
+{
+#ifdef NETWARE
+    get_tsd
+#endif
+    --alarms_blocked;
+    if (alarms_blocked == 0) {
+	if (exit_after_unblock) {
+	    /* We have a couple race conditions to deal with here, we can't
+	     * allow a timeout that comes in this small interval to allow
+	     * the child to jump back to the main loop.  Instead we block
+	     * alarms again, and then note that exit_after_unblock is
+	     * being dealt with.  We choose this way to solve this so that
+	     * the common path through unblock_alarms() is really short.
+	     */
+	    ++alarms_blocked;
+	    exit_after_unblock = 0;
+	    clean_child_exit(0);
+	}
+	if (alarm_pending) {
+	    alarm_pending = 0;
+	    timeout(0);
+	}
+    }
+}
+#endif /* TPF */
+
+#ifndef NETWARE
+static APACHE_TLS void (*volatile alarm_fn) (int) = NULL;
+#endif
+#if defined(WIN32) || defined(CYGWIN_WINSOCK) 
+static APACHE_TLS unsigned int alarm_expiry_time = 0;
+#endif /* WIN32 */
+
+#if !defined(WIN32)  && !defined(NETWARE)
+static void alrm_handler(int sig)
+{
+    if (alarm_fn) {
+	(*alarm_fn) (sig);
+    }
+}
+#endif
+
+API_EXPORT(unsigned int) ap_set_callback_and_alarm(void (*fn) (int), int x)
+{
+    unsigned int old;
+
+#if defined(WIN32) || defined(NETWARE)
+    time_t now = time(NULL);
+#ifdef NETWARE
+    get_tsd
+#endif
+    old = alarm_expiry_time;
+
+    if (old)
+	old -= now;
+    if (x == 0) {
+	alarm_fn = NULL;
+	alarm_expiry_time = 0;
+    }
+    else {
+	alarm_fn = fn;
+	alarm_expiry_time = now + x;
+    }
+#else
+    if (alarm_fn && x && fn != alarm_fn) {
+	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_DEBUG, NULL,
+	    "ap_set_callback_and_alarm: possible nested timer!");
+    }
+    alarm_fn = fn;
+#ifndef OPTIMIZE_TIMEOUTS
+    old = alarm(x);
+#else
+    if (child_timeouts) {
+	old = alarm(x);
+    }
+    else {
+	/* Just note the timeout in our scoreboard, no need to call the system.
+	 * We also note that the virtual time has gone forward.
+	 */
+	ap_check_signals();
+	old = ap_scoreboard_image->servers[my_child_num].timeout_len;
+	ap_scoreboard_image->servers[my_child_num].timeout_len = x;
+	++ap_scoreboard_image->servers[my_child_num].cur_vtime;
+    }
+#endif
+#endif
+    return (old);
+}
+
+
+#if defined(WIN32) || defined(NETWARE) || defined(CYGWIN_WINSOCK) 
+API_EXPORT(int) ap_check_alarm(void)
+{
+#ifdef NETWARE
+    get_tsd
+#endif
+    if (alarm_expiry_time) {
+	unsigned int t;
+
+	t = time(NULL);
+	if (t >= alarm_expiry_time) {
+	    alarm_expiry_time = 0;
+	    (*alarm_fn) (0);
+	    return (-1);
+	}
+	else {
+	    return (alarm_expiry_time - t);
+	}
+    }
+    else
+	return (0);
+}
+#endif /* WIN32 */
+
+
+
+/* reset_timeout (request_rec *) resets the timeout in effect,
+ * as long as it hasn't expired already.
+ */
+
+API_EXPORT(void) ap_reset_timeout(request_rec *r)
+{
+    int i;
+#ifdef NETWARE
+    get_tsd
+#endif
+    if (timeout_name) {		/* timeout has been set */
+	i = ap_set_callback_and_alarm(alarm_fn, r->server->timeout);
+	if (i == 0)		/* timeout already expired, so set it back to 0 */
+	    ap_set_callback_and_alarm(alarm_fn, 0);
+    }
+}
+
+
+
+
+API_EXPORT(void) ap_keepalive_timeout(char *name, request_rec *r)
+{
+    unsigned int to;
+#ifdef NETWARE
+    get_tsd
+#endif
+    timeout_req = r;
+    timeout_name = name;
+    if (r->connection->keptalive)
+	to = r->server->keep_alive_timeout;
+    else
+	to = r->server->timeout;
+    ap_set_callback_and_alarm(timeout, to);
+}
+
+API_EXPORT(void) ap_hard_timeout(char *name, request_rec *r)
+{
+#ifdef NETWARE
+    get_tsd
+#endif
+    timeout_req = r;
+    timeout_name = name;
+    ap_set_callback_and_alarm(timeout, r->server->timeout);
+}
+
+API_EXPORT(void) ap_soft_timeout(char *name, request_rec *r)
+{
+#ifdef NETWARE
+    get_tsd
+#endif
+    timeout_name = name;
+    ap_set_callback_and_alarm(timeout, r->server->timeout);
+}
+
+API_EXPORT(void) ap_kill_timeout(request_rec *dummy)
+{
+#ifdef NETWARE
+    get_tsd
+#endif
+    ap_check_signals();
+    ap_set_callback_and_alarm(NULL, 0);
+    timeout_req = NULL;
+    timeout_name = NULL;
+}
+
+
+/*
+ * More machine-dependent networking gooo... on some systems,
+ * you've got to be *really* sure that all the packets are acknowledged
+ * before closing the connection, since the client will not be able
+ * to see the last response if their TCP buffer is flushed by a RST
+ * packet from us, which is what the server's TCP stack will send
+ * if it receives any request data after closing the connection.
+ *
+ * In an ideal world, this function would be accomplished by simply
+ * setting the socket option SO_LINGER and handling it within the
+ * server's TCP stack while the process continues on to the next request.
+ * Unfortunately, it seems that most (if not all) operating systems
+ * block the server process on close() when SO_LINGER is used.
+ * For those that don't, see USE_SO_LINGER below.  For the rest,
+ * we have created a home-brew lingering_close.
+ *
+ * Many operating systems tend to block, puke, or otherwise mishandle
+ * calls to shutdown only half of the connection.  You should define
+ * NO_LINGCLOSE in ap_config.h if such is the case for your system.
+ */
+#ifndef MAX_SECS_TO_LINGER
+#define MAX_SECS_TO_LINGER 30
+#endif
+
+#ifdef USE_SO_LINGER
+#define NO_LINGCLOSE		/* The two lingering options are exclusive */
+
+static void sock_enable_linger(int s)
+{
+    struct linger li;
+
+    li.l_onoff = 1;
+    li.l_linger = MAX_SECS_TO_LINGER;
+
+    if (setsockopt(s, SOL_SOCKET, SO_LINGER,
+		   (char *) &li, sizeof(struct linger)) < 0) {
+	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf,
+	            "setsockopt: (SO_LINGER)");
+	/* not a fatal error */
+    }
+}
+
+#else
+#define sock_enable_linger(s)	/* NOOP */
+#endif /* USE_SO_LINGER */
+
+#ifndef NO_LINGCLOSE
+
+/* Special version of timeout for lingering_close */
+
+static void lingerout(int sig)
+{
+#ifdef NETWARE
+    get_tsd
+#endif
+    if (alarms_blocked) {
+	alarm_pending = 1;
+	return;
+    }
+
+    if (!current_conn) {
+	ap_longjmp(jmpbuffer, 1);
+    }
+    ap_bsetflag(current_conn->client, B_EOUT, 1);
+    current_conn->aborted = 1;
+}
+
+static void linger_timeout(void)
+{
+#ifdef NETWARE
+    get_tsd
+#endif
+    timeout_name = "lingering close";
+    ap_set_callback_and_alarm(lingerout, MAX_SECS_TO_LINGER);
+}
+
+/* Since many clients will abort a connection instead of closing it,
+ * attempting to log an error message from this routine will only
+ * confuse the webmaster.  There doesn't seem to be any portable way to
+ * distinguish between a dropped connection and something that might be
+ * worth logging.
+ */
+static void lingering_close(request_rec *r)
+{
+    char dummybuf[512];
+    struct timeval tv;
+    fd_set lfds;
+    int select_rv;
+    int lsd;
+
+    /* Prevent a slow-drip client from holding us here indefinitely */
+
+    linger_timeout();
+
+    /* Send any leftover data to the client, but never try to again */
+
+    if (ap_bflush(r->connection->client) == -1) {
+	ap_kill_timeout(r);
+	ap_bclose(r->connection->client);
+	return;
+    }
+    ap_bsetflag(r->connection->client, B_EOUT, 1);
+
+    /* Close our half of the connection --- send the client a FIN */
+
+    lsd = r->connection->client->fd;
+
+    if ((shutdown(lsd, 1) != 0) || r->connection->aborted) {
+	ap_kill_timeout(r);
+	ap_bclose(r->connection->client);
+	return;
+    }
+
+    /* Set up to wait for readable data on socket... */
+
+    FD_ZERO(&lfds);
+
+    /* Wait for readable data or error condition on socket;
+     * slurp up any data that arrives...  We exit when we go for an
+     * interval of tv length without getting any more data, get an error
+     * from select(), get an error or EOF on a read, or the timer expires.
+     */
+
+    do {
+	/* We use a 2 second timeout because current (Feb 97) browsers
+	 * fail to close a connection after the server closes it.  Thus,
+	 * to avoid keeping the child busy, we are only lingering long enough
+	 * for a client that is actively sending data on a connection.
+	 * This should be sufficient unless the connection is massively
+	 * losing packets, in which case we might have missed the RST anyway.
+	 * These parameters are reset on each pass, since they might be
+	 * changed by select.
+	 */
+#ifdef NETWARE
+        ThreadSwitch();
+#endif
+
+	FD_SET(lsd, &lfds);
+	tv.tv_sec = 2;
+	tv.tv_usec = 0;
+
+	select_rv = ap_select(lsd + 1, &lfds, NULL, NULL, &tv);
+
+    } while ((select_rv > 0) &&
+#if defined(WIN32) || defined(NETWARE)
+             (recv(lsd, dummybuf, sizeof(dummybuf), 0) > 0));
+#else
+             (read(lsd, dummybuf, sizeof(dummybuf)) > 0));
+#endif
+
+    /* Should now have seen final ack.  Safe to finally kill socket */
+
+    ap_bclose(r->connection->client);
+
+    ap_kill_timeout(r);
+}
+#endif /* ndef NO_LINGCLOSE */
+
+/*****************************************************************
+ * dealing with other children
+ */
+
+#ifndef NO_OTHER_CHILD
+API_EXPORT(void) ap_register_other_child(int pid,
+		       void (*maintenance) (int reason, void *, ap_wait_t status),
+			  void *data, int write_fd)
+{
+    other_child_rec *ocr;
+
+    ocr = ap_palloc(pconf, sizeof(*ocr));
+    ocr->pid = pid;
+    ocr->maintenance = maintenance;
+    ocr->data = data;
+    ocr->write_fd = write_fd;
+    ocr->next = other_children;
+    other_children = ocr;
+}
+
+/* note that since this can be called by a maintenance function while we're
+ * scanning the other_children list, all scanners should protect themself
+ * by loading ocr->next before calling any maintenance function.
+ */
+API_EXPORT(void) ap_unregister_other_child(void *data)
+{
+    other_child_rec **pocr, *nocr;
+
+    for (pocr = &other_children; *pocr; pocr = &(*pocr)->next) {
+	if ((*pocr)->data == data) {
+	    nocr = (*pocr)->next;
+	    (*(*pocr)->maintenance) (OC_REASON_UNREGISTER, (*pocr)->data, (ap_wait_t)-1);
+	    *pocr = nocr;
+	    /* XXX: um, well we've just wasted some space in pconf ? */
+	    return;
+	}
+    }
+}
+
+/* test to ensure that the write_fds are all still writable, otherwise
+ * invoke the maintenance functions as appropriate */
+static void probe_writable_fds(void)
+{
+    fd_set writable_fds;
+    int fd_max;
+    other_child_rec *ocr, *nocr;
+    struct timeval tv;
+    int rc;
+
+    if (other_children == NULL)
+	return;
+
+    fd_max = 0;
+    FD_ZERO(&writable_fds);
+    do {
+	for (ocr = other_children; ocr; ocr = ocr->next) {
+	    if (ocr->write_fd == -1)
+		continue;
+	    FD_SET(ocr->write_fd, &writable_fds);
+	    if (ocr->write_fd > fd_max) {
+		fd_max = ocr->write_fd;
+	    }
+	}
+	if (fd_max == 0)
+	    return;
+
+	tv.tv_sec = 0;
+	tv.tv_usec = 0;
+	rc = ap_select(fd_max + 1, NULL, &writable_fds, NULL, &tv);
+    } while (rc == -1 && errno == EINTR);
+
+    if (rc == -1) {
+	/* XXX: uhh this could be really bad, we could have a bad file
+	 * descriptor due to a bug in one of the maintenance routines */
+	ap_log_unixerr("probe_writable_fds", "select",
+		    "could not probe writable fds", server_conf);
+	return;
+    }
+    if (rc == 0)
+	return;
+
+    for (ocr = other_children; ocr; ocr = nocr) {
+	nocr = ocr->next;
+	if (ocr->write_fd == -1)
+	    continue;
+	if (FD_ISSET(ocr->write_fd, &writable_fds))
+	    continue;
+	(*ocr->maintenance) (OC_REASON_UNWRITABLE, ocr->data, (ap_wait_t)-1);
+    }
+}
+
+/* possibly reap an other_child, return 0 if yes, -1 if not */
+static int reap_other_child(int pid, ap_wait_t status)
+{
+    other_child_rec *ocr, *nocr;
+
+    for (ocr = other_children; ocr; ocr = nocr) {
+	nocr = ocr->next;
+	if (ocr->pid != pid)
+	    continue;
+	ocr->pid = -1;
+	(*ocr->maintenance) (OC_REASON_DEATH, ocr->data, status);
+	return 0;
+    }
+    return -1;
+}
+#endif
+
+/*****************************************************************
+ *
+ * Dealing with the scoreboard... a lot of these variables are global
+ * only to avoid getting clobbered by the longjmp() that happens when
+ * a hard timeout expires...
+ *
+ * We begin with routines which deal with the file itself... 
+ */
+
+#ifdef MULTITHREAD
+/*
+ * In the multithreaded mode, have multiple threads - not multiple
+ * processes that need to talk to each other. Just use a simple
+ * malloc. But let the routines that follow, think that you have
+ * shared memory (so they use memcpy etc.)
+ */
+
+static void reinit_scoreboard(pool *p)
+{
+    ap_assert(!ap_scoreboard_image);
+    ap_scoreboard_image = (scoreboard *) malloc(SCOREBOARD_SIZE);
+    if (ap_scoreboard_image == NULL) {
+	fprintf(stderr, "Ouch!  Out of memory reiniting scoreboard!\n");
+    }
+    memset(ap_scoreboard_image, 0, SCOREBOARD_SIZE);
+}
+
+void cleanup_scoreboard(void)
+{
+    ap_assert(ap_scoreboard_image);
+    free(ap_scoreboard_image);
+    ap_scoreboard_image = NULL;
+}
+
+API_EXPORT(void) ap_sync_scoreboard_image(void)
+{
+}
+
+
+#else /* MULTITHREAD */
+#if defined(USE_OS2_SCOREBOARD)
+
+/* The next two routines are used to access shared memory under OS/2.  */
+/* This requires EMX v09c to be installed.                           */
+
+caddr_t create_shared_heap(const char *name, size_t size)
+{
+    ULONG rc;
+    void *mem;
+    Heap_t h;
+
+    rc = DosAllocSharedMem(&mem, name, size,
+			   PAG_COMMIT | PAG_READ | PAG_WRITE);
+    if (rc != 0)
+	return NULL;
+    h = _ucreate(mem, size, !_BLOCK_CLEAN, _HEAP_REGULAR | _HEAP_SHARED,
+		 NULL, NULL);
+    if (h == NULL)
+	DosFreeMem(mem);
+    return (caddr_t) h;
+}
+
+caddr_t get_shared_heap(const char *Name)
+{
+
+    PVOID BaseAddress;		/* Pointer to the base address of
+				   the shared memory object */
+    ULONG AttributeFlags;	/* Flags describing characteristics
+				   of the shared memory object */
+    APIRET rc;			/* Return code */
+
+    /* Request read and write access to */
+    /*   the shared memory object       */
+    AttributeFlags = PAG_WRITE | PAG_READ;
+
+    rc = DosGetNamedSharedMem(&BaseAddress, Name, AttributeFlags);
+
+    if (rc != 0) {
+	printf("DosGetNamedSharedMem error: return code = %ld", rc);
+	return 0;
+    }
+
+    return BaseAddress;
+}
+
+static void setup_shared_mem(pool *p)
+{
+    caddr_t m;
+
+    int rc;
+
+    m = (caddr_t) create_shared_heap("\\SHAREMEM\\SCOREBOARD", SCOREBOARD_SIZE);
+    if (m == 0) {
+	fprintf(stderr, "%s: Could not create OS/2 Shared memory pool.\n",
+		ap_server_argv0);
+	exit(APEXIT_INIT);
+    }
+
+    rc = _uopen((Heap_t) m);
+    if (rc != 0) {
+	fprintf(stderr,
+		"%s: Could not uopen() newly created OS/2 Shared memory pool.\n",
+		ap_server_argv0);
+    }
+    ap_scoreboard_image = (scoreboard *) m;
+    ap_scoreboard_image->global.running_generation = 0;
+}
+
+static void reopen_scoreboard(pool *p)
+{
+    caddr_t m;
+    int rc;
+
+    m = (caddr_t) get_shared_heap("\\SHAREMEM\\SCOREBOARD");
+    if (m == 0) {
+	fprintf(stderr, "%s: Could not find existing OS/2 Shared memory pool.\n",
+		ap_server_argv0);
+	exit(APEXIT_INIT);
+    }
+
+    rc = _uopen((Heap_t) m);
+    ap_scoreboard_image = (scoreboard *) m;
+}
+
+#elif defined(USE_POSIX_SCOREBOARD)
+#include <sys/mman.h>
+/* 
+ * POSIX 1003.4 style
+ *
+ * Note 1: 
+ * As of version 4.23A, shared memory in QNX must reside under /dev/shmem,
+ * where no subdirectories allowed.
+ *
+ * POSIX shm_open() and shm_unlink() will take care about this issue,
+ * but to avoid confusion, I suggest to redefine scoreboard file name
+ * in httpd.conf to cut "logs/" from it. With default setup actual name
+ * will be "/dev/shmem/logs.apache_status". 
+ * 
+ * If something went wrong and Apache did not unlinked this object upon
+ * exit, you can remove it manually, using "rm -f" command.
+ * 
+ * Note 2:
+ * <sys/mman.h> in QNX defines MAP_ANON, but current implementation 
+ * does NOT support BSD style anonymous mapping. So, the order of 
+ * conditional compilation is important: 
+ * this #ifdef section must be ABOVE the next one (BSD style).
+ *
+ * I tested this stuff and it works fine for me, but if it provides 
+ * trouble for you, just comment out USE_MMAP_SCOREBOARD in QNX section
+ * of ap_config.h
+ *
+ * June 5, 1997, 
+ * Igor N. Kovalenko -- infoh@mail.wplus.net
+ */
+
+static void cleanup_shared_mem(void *d)
+{
+    shm_unlink(ap_scoreboard_fname);
+}
+
+static void setup_shared_mem(pool *p)
+{
+    char buf[512];
+    caddr_t m;
+    int fd;
+
+    fd = shm_open(ap_scoreboard_fname, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);
+    if (fd == -1) {
+	ap_snprintf(buf, sizeof(buf), "%s: could not open(create) scoreboard",
+		    ap_server_argv0);
+	perror(buf);
+	exit(APEXIT_INIT);
+    }
+    if (ltrunc(fd, (off_t) SCOREBOARD_SIZE, SEEK_SET) == -1) {
+	ap_snprintf(buf, sizeof(buf), "%s: could not ltrunc scoreboard",
+		    ap_server_argv0);
+	perror(buf);
+	shm_unlink(ap_scoreboard_fname);
+	exit(APEXIT_INIT);
+    }
+    if ((m = (caddr_t) mmap((caddr_t) 0,
+			    (size_t) SCOREBOARD_SIZE, PROT_READ | PROT_WRITE,
+			    MAP_SHARED, fd, (off_t) 0)) == (caddr_t) - 1) {
+	ap_snprintf(buf, sizeof(buf), "%s: cannot mmap scoreboard",
+		    ap_server_argv0);
+	perror(buf);
+	shm_unlink(ap_scoreboard_fname);
+	exit(APEXIT_INIT);
+    }
+    close(fd);
+    ap_register_cleanup(p, NULL, cleanup_shared_mem, ap_null_cleanup);
+    ap_scoreboard_image = (scoreboard *) m;
+    ap_scoreboard_image->global.running_generation = 0;
+}
+
+static void reopen_scoreboard(pool *p)
+{
+}
+
+#elif defined(USE_MMAP_SCOREBOARD)
+
+static void setup_shared_mem(pool *p)
+{
+    caddr_t m;
+
+#if defined(MAP_ANON)
+/* BSD style */
+#ifdef CONVEXOS11
+    /*
+     * 9-Aug-97 - Jeff Venters (venters@convex.hp.com)
+     * ConvexOS maps address space as follows:
+     *   0x00000000 - 0x7fffffff : Kernel
+     *   0x80000000 - 0xffffffff : User
+     * Start mmapped area 1GB above start of text.
+     *
+     * Also, the length requires a pointer as the actual length is
+     * returned (rounded up to a page boundary).
+     */
+    {
+	unsigned len = SCOREBOARD_SIZE;
+
+	m = mmap((caddr_t) 0xC0000000, &len,
+		 PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, NOFD, 0);
+    }
+#elif defined(MAP_TMPFILE)
+    {
+	char mfile[] = "/tmp/apache_shmem_XXXX";
+	int fd = mkstemp(mfile);
+	if (fd == -1) {
+	    perror("open");
+	    fprintf(stderr, "%s: Could not open %s\n", ap_server_argv0, mfile);
+	    exit(APEXIT_INIT);
+	}
+	m = mmap((caddr_t) 0, SCOREBOARD_SIZE,
+		PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+	if (m == (caddr_t) - 1) {
+	    perror("mmap");
+	    fprintf(stderr, "%s: Could not mmap %s\n", ap_server_argv0, mfile);
+	    exit(APEXIT_INIT);
+	}
+	close(fd);
+	unlink(mfile);
+    }
+#else
+    m = mmap((caddr_t) 0, SCOREBOARD_SIZE,
+	     PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, -1, 0);
+#endif
+    if (m == (caddr_t) - 1) {
+	perror("mmap");
+	fprintf(stderr, "%s: Could not mmap memory\n", ap_server_argv0);
+	exit(APEXIT_INIT);
+    }
+#else
+/* Sun style */
+    int fd;
+
+    fd = open("/dev/zero", O_RDWR);
+    if (fd == -1) {
+	perror("open");
+	fprintf(stderr, "%s: Could not open /dev/zero\n", ap_server_argv0);
+	exit(APEXIT_INIT);
+    }
+    m = mmap((caddr_t) 0, SCOREBOARD_SIZE,
+	     PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+    if (m == (caddr_t) - 1) {
+	perror("mmap");
+	fprintf(stderr, "%s: Could not mmap /dev/zero\n", ap_server_argv0);
+	exit(APEXIT_INIT);
+    }
+    close(fd);
+#endif
+    ap_scoreboard_image = (scoreboard *) m;
+    ap_scoreboard_image->global.running_generation = 0;
+}
+
+static void reopen_scoreboard(pool *p)
+{
+}
+
+#elif defined(USE_SHMGET_SCOREBOARD)
+static key_t shmkey = IPC_PRIVATE;
+static int shmid = -1;
+
+static void setup_shared_mem(pool *p)
+{
+    struct shmid_ds shmbuf;
+#ifdef MOVEBREAK
+    char *obrk;
+#endif
+
+    if ((shmid = shmget(shmkey, SCOREBOARD_SIZE, IPC_CREAT | SHM_R | SHM_W)) == -1) {
+#ifdef LINUX
+	if (errno == ENOSYS) {
+	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_EMERG, server_conf,
+			 "Your kernel was built without CONFIG_SYSVIPC\n"
+			 "%s: Please consult the Apache FAQ for details",
+			 ap_server_argv0);
+	}
+#endif
+	ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf,
+                     "could not call shmget");
+	exit(APEXIT_INIT);
+    }
+
+    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, server_conf,
+		"created shared memory segment #%d", shmid);
+
+#ifdef MOVEBREAK
+    /*
+     * Some SysV systems place the shared segment WAY too close
+     * to the dynamic memory break point (sbrk(0)). This severely
+     * limits the use of malloc/sbrk in the program since sbrk will
+     * refuse to move past that point.
+     *
+     * To get around this, we move the break point "way up there",
+     * attach the segment and then move break back down. Ugly
+     */
+    if ((obrk = sbrk(MOVEBREAK)) == (char *) -1) {
+	ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
+	    "sbrk() could not move break");
+    }
+#endif
+
+#define BADSHMAT	((scoreboard *)(-1))
+    if ((ap_scoreboard_image = (scoreboard *) shmat(shmid, 0, 0)) == BADSHMAT) {
+	ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf, "shmat error");
+	/*
+	 * We exit below, after we try to remove the segment
+	 */
+    }
+    /* only worry about permissions if we attached the segment
+       and we want/need to change the uid/gid */
+    else if (ap_change_shmem_uid) {
+	if (shmctl(shmid, IPC_STAT, &shmbuf) != 0) {
+	    ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
+		"shmctl() could not stat segment #%d", shmid);
+	}
+	else {
+	    shmbuf.shm_perm.uid = ap_user_id;
+	    shmbuf.shm_perm.gid = ap_group_id;
+	    if (shmctl(shmid, IPC_SET, &shmbuf) != 0) {
+		ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
+		    "shmctl() could not set segment #%d", shmid);
+	    }
+	}
+    }
+    /*
+     * We must avoid leaving segments in the kernel's
+     * (small) tables.
+     */
+    if (shmctl(shmid, IPC_RMID, NULL) != 0) {
+	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf,
+		"shmctl: IPC_RMID: could not remove shared memory segment #%d",
+		shmid);
+    }
+    if (ap_scoreboard_image == BADSHMAT)	/* now bailout */
+	exit(APEXIT_INIT);
+
+#ifdef MOVEBREAK
+    if (obrk == (char *) -1)
+	return;			/* nothing else to do */
+    if (sbrk(-(MOVEBREAK)) == (char *) -1) {
+	ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
+	    "sbrk() could not move break back");
+    }
+#endif
+    ap_scoreboard_image->global.running_generation = 0;
+}
+
+static void reopen_scoreboard(pool *p)
+{
+}
+
+#else
+#define SCOREBOARD_FILE
+static scoreboard _scoreboard_image;
+static int scoreboard_fd = -1;
+
+/* XXX: things are seriously screwed if we ever have to do a partial
+ * read or write ... we could get a corrupted scoreboard
+ */
+static int force_write(int fd, void *buffer, int bufsz)
+{
+    int rv, orig_sz = bufsz;
+
+    do {
+	rv = write(fd, buffer, bufsz);
+	if (rv > 0) {
+	    buffer = (char *) buffer + rv;
+	    bufsz -= rv;
+	}
+    } while ((rv > 0 && bufsz > 0) || (rv == -1 && errno == EINTR));
+
+    return rv < 0 ? rv : orig_sz - bufsz;
+}
+
+static int force_read(int fd, void *buffer, int bufsz)
+{
+    int rv, orig_sz = bufsz;
+
+    do {
+	rv = read(fd, buffer, bufsz);
+	if (rv > 0) {
+	    buffer = (char *) buffer + rv;
+	    bufsz -= rv;
+	}
+    } while ((rv > 0 && bufsz > 0) || (rv == -1 && errno == EINTR));
+
+    return rv < 0 ? rv : orig_sz - bufsz;
+}
+
+static void cleanup_scoreboard_file(void *foo)
+{
+    unlink(ap_scoreboard_fname);
+}
+
+void reopen_scoreboard(pool *p)
+{
+    if (scoreboard_fd != -1)
+	ap_pclosef(p, scoreboard_fd);
+
+#ifdef TPF
+    ap_scoreboard_fname = ap_server_root_relative(p, ap_scoreboard_fname);
+#endif /* TPF */
+    scoreboard_fd = ap_popenf_ex(p, ap_scoreboard_fname, O_CREAT | O_BINARY | O_RDWR, 0666, 1);
+    if (scoreboard_fd == -1) {
+	perror(ap_scoreboard_fname);
+	fprintf(stderr, "Cannot open scoreboard file:\n");
+	clean_child_exit(1);
+    }
+}
+#endif
+
+/* Called by parent process */
+static void reinit_scoreboard(pool *p)
+{
+    int running_gen = 0;
+    if (ap_scoreboard_image)
+	running_gen = ap_scoreboard_image->global.running_generation;
+
+#ifndef SCOREBOARD_FILE
+    if (ap_scoreboard_image == NULL) {
+	setup_shared_mem(p);
+    }
+    memset(ap_scoreboard_image, 0, SCOREBOARD_SIZE);
+    ap_scoreboard_image->global.running_generation = running_gen;
+#else
+    ap_scoreboard_image = &_scoreboard_image;
+    ap_scoreboard_fname = ap_server_root_relative(p, ap_scoreboard_fname);
+
+    scoreboard_fd = ap_popenf_ex(p, ap_scoreboard_fname, O_CREAT | O_BINARY | O_RDWR, 0644, 1);
+    if (scoreboard_fd == -1) {
+	perror(ap_scoreboard_fname);
+	fprintf(stderr, "Cannot open scoreboard file:\n");
+	exit(APEXIT_INIT);
+    }
+    ap_register_cleanup(p, NULL, cleanup_scoreboard_file, ap_null_cleanup);
+
+    memset((char *) ap_scoreboard_image, 0, sizeof(*ap_scoreboard_image));
+    ap_scoreboard_image->global.running_generation = running_gen;
+    force_write(scoreboard_fd, ap_scoreboard_image, sizeof(*ap_scoreboard_image));
+#endif
+}
+
+/* Routines called to deal with the scoreboard image
+ * --- note that we do *not* need write locks, since update_child_status
+ * only updates a *single* record in place, and only one process writes to
+ * a given scoreboard slot at a time (either the child process owning that
+ * slot, or the parent, noting that the child has died).
+ *
+ * As a final note --- setting the score entry to getpid() is always safe,
+ * since when the parent is writing an entry, it's only noting SERVER_DEAD
+ * anyway.
+ */
+
+ap_inline void ap_sync_scoreboard_image(void)
+{
+#ifdef SCOREBOARD_FILE
+    lseek(scoreboard_fd, 0L, 0);
+    force_read(scoreboard_fd, ap_scoreboard_image, sizeof(*ap_scoreboard_image));
+#endif
+}
+
+#endif /* MULTITHREAD */
+
+API_EXPORT(int) ap_exists_scoreboard_image(void)
+{
+    return (ap_scoreboard_image ? 1 : 0);
+}
+
+static ap_inline void put_scoreboard_info(int child_num,
+				       short_score *new_score_rec)
+{
+#ifdef SCOREBOARD_FILE
+    lseek(scoreboard_fd, (long) child_num * sizeof(short_score), 0);
+    force_write(scoreboard_fd, new_score_rec, sizeof(short_score));
+#endif
+}
+
+/* a clean exit from the parent with proper cleanup */
+#ifdef NETWARE
+void clean_shutdown_on_exit(void)
+{
+    if (!ap_main_finished) {
+        AMCSocketCleanup();
+        ap_destroy_pool(pcommands);    
+        free(ap_loaded_modules);    
+        ap_cleanup_method_ptrs();    
+        ap_destroy_pool(pglobal);
+        ap_cleanup_alloc();
+        ap_main_finished = TRUE;
+    }
+}
+
+void clean_parent_exit(int code) __attribute__((noreturn));
+void clean_parent_exit(int code)
+#else
+static void clean_parent_exit(int code) __attribute__((noreturn));
+static void clean_parent_exit(int code)
+#endif
+{
+#ifdef NETWARE
+    AMCSocketCleanup();
+    ap_destroy_pool(pcommands);    
+    free(ap_loaded_modules);    
+    ap_cleanup_method_ptrs();    
+    ap_destroy_pool(pglobal);
+    ap_cleanup_alloc();
+    ap_main_finished = TRUE;
+#else
+    /* Clear the pool - including any registered cleanups */
+    ap_destroy_pool(pglobal);
+#endif
+    exit(code);
+}
+
+API_EXPORT(int) ap_update_child_status(int child_num, int status, request_rec *r)
+{
+    int old_status;
+    short_score *ss;
+
+    if (child_num < 0)
+	return -1;
+
+    ap_check_signals();
+
+    ap_sync_scoreboard_image();
+    ss = &ap_scoreboard_image->servers[child_num];
+    old_status = ss->status;
+    ss->status = status;
+#ifdef NETWARE
+    ap_scoreboard_image->parent[child_num].pid = GetThreadID();
+#endif
+
+#ifdef OPTIMIZE_TIMEOUTS
+    ++ss->cur_vtime;
+#endif
+
+    if (ap_extended_status) {
+#ifndef OPTIMIZE_TIMEOUTS
+	ss->last_used = time(NULL);
+#endif
+	if (status == SERVER_READY || status == SERVER_DEAD) {
+	    /*
+	     * Reset individual counters
+	     */
+	    if (status == SERVER_DEAD) {
+		ss->my_access_count = 0L;
+		ss->my_bytes_served = 0L;
+	    }
+	    ss->conn_count = (unsigned short) 0;
+	    ss->conn_bytes = (unsigned long) 0;
+	}
+        else if (status == SERVER_STARTING) {
+            /* clean out the start_time so that mod_status will print Req=0 */
+            /* Use memset to be independent from the type (struct timeval vs. clock_t) */
+            memset (&ss->start_time, '\0', sizeof ss->start_time);
+        }
+	if (r) {
+	    conn_rec *c = r->connection;
+	    ap_cpystrn(ss->client, ap_get_remote_host(c, r->per_dir_config,
+				  REMOTE_NOLOOKUP), sizeof(ss->client));
+	    if (r->the_request == NULL) {
+		    ap_cpystrn(ss->request, "NULL", sizeof(ss->request));
+	    } else if (r->parsed_uri.password == NULL) {
+		    ap_cpystrn(ss->request, r->the_request, sizeof(ss->request));
+	    } else {
+		/* Don't reveal the password in the server-status view */
+		    ap_cpystrn(ss->request, ap_pstrcat(r->pool, r->method, " ",
+					       ap_unparse_uri_components(r->pool, &r->parsed_uri, UNP_OMITPASSWORD),
+					       r->assbackwards ? NULL : " ", r->protocol, NULL),
+				       sizeof(ss->request));
+	    }
+	    ss->vhostrec =  r->server;
+	}
+    }
+    if (status == SERVER_STARTING && r == NULL) {
+	/* clean up the slot's vhostrec pointer (maybe re-used)
+	 * and mark the slot as belonging to a new generation.
+	 */
+	ss->vhostrec = NULL;
+	ap_scoreboard_image->parent[child_num].generation = ap_my_generation;
+#ifdef SCOREBOARD_FILE
+	lseek(scoreboard_fd, XtOffsetOf(scoreboard, parent[child_num]), 0);
+	force_write(scoreboard_fd, &ap_scoreboard_image->parent[child_num],
+	    sizeof(parent_score));
+#endif
+    }
+    put_scoreboard_info(child_num, ss);
+
+    return old_status;
+}
+
+static void update_scoreboard_global(void)
+{
+#ifdef SCOREBOARD_FILE
+    lseek(scoreboard_fd,
+	  (char *) &ap_scoreboard_image->global -(char *) ap_scoreboard_image, 0);
+    force_write(scoreboard_fd, &ap_scoreboard_image->global,
+		sizeof ap_scoreboard_image->global);
+#endif
+}
+
+void ap_time_process_request(int child_num, int status)
+{
+    short_score *ss;
+#if defined(NO_GETTIMEOFDAY) && !defined(NO_TIMES)
+    struct tms tms_blk;
+#endif
+
+    if (child_num < 0)
+	return;
+
+    ap_sync_scoreboard_image();
+    ss = &ap_scoreboard_image->servers[child_num];
+
+    if (status == START_PREQUEST) {
+#if defined(NO_GETTIMEOFDAY)
+#ifndef NO_TIMES
+	if ((ss->start_time = times(&tms_blk)) == -1)
+#endif /* NO_TIMES */
+	    ss->start_time = (clock_t) 0;
+#else
+	if (gettimeofday(&ss->start_time, (struct timezone *) 0) < 0)
+	    ss->start_time.tv_sec =
+		ss->start_time.tv_usec = 0L;
+#endif
+    }
+    else if (status == STOP_PREQUEST) {
+#if defined(NO_GETTIMEOFDAY)
+#ifndef NO_TIMES
+	if ((ss->stop_time = times(&tms_blk)) == -1)
+#endif
+	    ss->stop_time = ss->start_time = (clock_t) 0;
+#else
+	if (gettimeofday(&ss->stop_time, (struct timezone *) 0) < 0)
+	    ss->stop_time.tv_sec =
+		ss->stop_time.tv_usec =
+		ss->start_time.tv_sec =
+		ss->start_time.tv_usec = 0L;
+#endif
+
+    }
+
+    put_scoreboard_info(child_num, ss);
+}
+
+static void increment_counts(int child_num, request_rec *r)
+{
+    long int bs = 0;
+    short_score *ss;
+
+    ap_sync_scoreboard_image();
+    ss = &ap_scoreboard_image->servers[child_num];
+
+    if (r->sent_bodyct)
+	ap_bgetopt(r->connection->client, BO_BYTECT, &bs);
+
+#ifndef NO_TIMES
+    times(&ss->times);
+#endif
+    ss->access_count++;
+    ss->my_access_count++;
+    ss->conn_count++;
+    ss->bytes_served += (unsigned long) bs;
+    ss->my_bytes_served += (unsigned long) bs;
+    ss->conn_bytes += (unsigned long) bs;
+
+    put_scoreboard_info(child_num, ss);
+}
+
+static int find_child_by_pid(int pid)
+{
+    int i;
+
+    for (i = 0; i < max_daemons_limit; ++i)
+	if (ap_scoreboard_image->parent[i].pid == pid)
+	    return i;
+
+    return -1;
+}
+
+static void reclaim_child_processes(int terminate)
+{
+#ifndef MULTITHREAD
+    int i, status;
+    long int waittime = 1024 * 16;	/* in usecs */
+    struct timeval tv;
+    int waitret, tries;
+    int not_dead_yet;
+    int ret;
+#ifndef NO_OTHER_CHILD
+    other_child_rec *ocr, *nocr;
+#endif
+
+    ap_sync_scoreboard_image();
+
+    for (tries = terminate ? 4 : 1; tries <= 12; ++tries) {
+	/* don't want to hold up progress any more than 
+	 * necessary, but we need to allow children a few moments to exit.
+	 * Set delay with an exponential backoff. NOTE: if we get
+ 	 * interupted, we'll wait longer than expected...
+	 */
+	tv.tv_sec = waittime / 1000000;
+	tv.tv_usec = waittime % 1000000;
+	waittime = waittime * 4;
+	do {
+	    ret = ap_select(0, NULL, NULL, NULL, &tv);
+	} while (ret == -1 && errno == EINTR);
+
+	/* now see who is done */
+	not_dead_yet = 0;
+	for (i = 0; i < max_daemons_limit; ++i) {
+	    int pid = ap_scoreboard_image->parent[i].pid;
+
+	    if (pid == my_pid || pid == 0)
+		continue;
+
+	    waitret = waitpid(pid, &status, WNOHANG);
+	    if (waitret == pid || waitret == -1) {
+		ap_scoreboard_image->parent[i].pid = 0;
+		continue;
+	    }
+	    ++not_dead_yet;
+	    switch (tries) {
+	    case 1:     /*  16ms */
+	    case 2:     /*  82ms */
+		break;
+	    case 3:     /* 344ms */
+		/* perhaps it missed the SIGHUP, lets try again */
+		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING,
+			    server_conf,
+		    "child process %d did not exit, sending another SIGHUP",
+			    pid);
+		kill(pid, SIGHUP);
+		waittime = 1024 * 16;
+		break;
+	    case 4:     /*  16ms */
+	    case 5:     /*  82ms */
+	    case 6:     /* 344ms */
+		break;
+	    case 7:     /* 1.4sec */
+		/* ok, now it's being annoying */
+		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING,
+			    server_conf,
+		   "child process %d still did not exit, sending a SIGTERM",
+			    pid);
+		kill(pid, SIGTERM);
+		break;
+	    case 8:     /*  6 sec */
+		/* die child scum */
+		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, server_conf,
+		   "child process %d still did not exit, sending a SIGKILL",
+			    pid);
+		kill(pid, SIGKILL);
+		waittime = 1024 * 16; /* give them some time to die */
+		break;
+	    case 9:     /*   6 sec */
+	    case 10:    /* 6.1 sec */
+	    case 11:    /* 6.4 sec */
+		break;
+	    case 12:    /* 7.4 sec */
+		/* gave it our best shot, but alas...  If this really 
+		 * is a child we are trying to kill and it really hasn't
+		 * exited, we will likely fail to bind to the port
+		 * after the restart.
+		 */
+		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, server_conf,
+			    "could not make child process %d exit, "
+			    "attempting to continue anyway", pid);
+		break;
+	    }
+	}
+#ifndef NO_OTHER_CHILD
+	for (ocr = other_children; ocr; ocr = nocr) {
+	    nocr = ocr->next;
+	    if (ocr->pid == -1)
+		continue;
+
+	    waitret = waitpid(ocr->pid, &status, WNOHANG);
+	    if (waitret == ocr->pid) {
+		ocr->pid = -1;
+		(*ocr->maintenance) (OC_REASON_RESTART, ocr->data, (ap_wait_t)status);
+	    }
+	    else if (waitret == 0) {
+		(*ocr->maintenance) (OC_REASON_RESTART, ocr->data, (ap_wait_t)-1);
+		++not_dead_yet;
+	    }
+	    else if (waitret == -1) {
+		/* uh what the heck? they didn't call unregister? */
+		ocr->pid = -1;
+		(*ocr->maintenance) (OC_REASON_LOST, ocr->data, (ap_wait_t)-1);
+	    }
+	}
+#endif
+	if (!not_dead_yet) {
+	    /* nothing left to wait for */
+	    break;
+	}
+    }
+#endif /* ndef MULTITHREAD */
+}
+
+
+#if defined(NEED_WAITPID)
+/*
+   Systems without a real waitpid sometimes lose a child's exit while waiting
+   for another.  Search through the scoreboard for missing children.
+ */
+int reap_children(ap_wait_t *status)
+{
+    int n, pid;
+
+    for (n = 0; n < max_daemons_limit; ++n) {
+        ap_sync_scoreboard_image();
+	if (ap_scoreboard_image->servers[n].status != SERVER_DEAD &&
+		kill((pid = ap_scoreboard_image->parent[n].pid), 0) == -1) {
+	    ap_update_child_status(n, SERVER_DEAD, NULL);
+	    /* just mark it as having a successful exit status */
+	    bzero((char *) status, sizeof(ap_wait_t));
+	    return(pid);
+	}
+    }
+    return 0;
+}
+#endif
+
+/* Finally, this routine is used by the caretaker process to wait for
+ * a while...
+ */
+
+#ifndef NETWARE
+/* number of calls to wait_or_timeout between writable probes */
+#ifndef INTERVAL_OF_WRITABLE_PROBES
+#define INTERVAL_OF_WRITABLE_PROBES 10
+#endif
+static int wait_or_timeout_counter;
+
+static int wait_or_timeout(ap_wait_t *status)
+{
+#ifdef WIN32
+#define MAXWAITOBJ MAXIMUM_WAIT_OBJECTS
+    HANDLE h[MAXWAITOBJ];
+    int e[MAXWAITOBJ];
+    int round, pi, hi, rv, err;
+    for (round = 0; round <= (HARD_SERVER_LIMIT - 1) / MAXWAITOBJ + 1; round++) {
+	hi = 0;
+	for (pi = round * MAXWAITOBJ;
+	     (pi < (round + 1) * MAXWAITOBJ) && (pi < HARD_SERVER_LIMIT);
+	     pi++) {
+	    if (ap_scoreboard_image->servers[pi].status != SERVER_DEAD) {
+		e[hi] = pi;
+		h[hi++] = (HANDLE) ap_scoreboard_image->parent[pi].pid;
+	    }
+
+	}
+	if (hi > 0) {
+	    rv = WaitForMultipleObjects(hi, h, FALSE, 10000);
+	    if (rv == -1)
+		err = GetLastError();
+	    if ((WAIT_OBJECT_0 <= (unsigned int) rv) && ((unsigned int) rv < (WAIT_OBJECT_0 + hi)))
+		return (ap_scoreboard_image->parent[e[rv - WAIT_OBJECT_0]].pid);
+	    else if ((WAIT_ABANDONED_0 <= (unsigned int) rv) && ((unsigned int) rv < (WAIT_ABANDONED_0 + hi)))
+		return (ap_scoreboard_image->parent[e[rv - WAIT_ABANDONED_0]].pid);
+
+	}
+    }
+    return (-1);
+#else /* WIN32 */
+    struct timeval tv;
+    int ret;
+
+    ++wait_or_timeout_counter;
+    if (wait_or_timeout_counter == INTERVAL_OF_WRITABLE_PROBES) {
+	wait_or_timeout_counter = 0;
+#ifndef NO_OTHER_CHILD
+	probe_writable_fds();
+#endif
+    }
+    ret = waitpid(-1, status, WNOHANG);
+    if (ret == -1 && errno == EINTR) {
+	return -1;
+    }
+    if (ret > 0) {
+	return ret;
+    }
+#ifdef NEED_WAITPID
+    if ((ret = reap_children(status)) > 0) {
+	return ret;
+    }
+#endif
+    tv.tv_sec = SCOREBOARD_MAINTENANCE_INTERVAL / 1000000;
+    tv.tv_usec = SCOREBOARD_MAINTENANCE_INTERVAL % 1000000;
+    ap_select(0, NULL, NULL, NULL, &tv);
+    return -1;
+#endif /* WIN32 */
+}
+#endif
+
+#if defined(NSIG)
+#define NumSIG NSIG
+#elif defined(_NSIG)
+#define NumSIG _NSIG
+#elif defined(__NSIG)
+#define NumSIG __NSIG
+#else
+#define NumSIG 32   /* for 1998's unixes, this is still a good assumption */
+#endif
+
+#ifdef SYS_SIGLIST /* platform has sys_siglist[] */
+#define INIT_SIGLIST()  /*nothing*/
+#else /* platform has no sys_siglist[], define our own */
+#define SYS_SIGLIST ap_sys_siglist
+#define INIT_SIGLIST() siglist_init();
+
+const char *ap_sys_siglist[NumSIG];
+
+static void siglist_init(void)
+{
+    int sig;
+
+    ap_sys_siglist[0] = "Signal 0";
+#ifdef SIGHUP
+    ap_sys_siglist[SIGHUP] = "Hangup";
+#endif
+#ifdef SIGINT
+    ap_sys_siglist[SIGINT] = "Interrupt";
+#endif
+#ifdef SIGQUIT
+    ap_sys_siglist[SIGQUIT] = "Quit";
+#endif
+#ifdef SIGILL
+    ap_sys_siglist[SIGILL] = "Illegal instruction";
+#endif
+#ifdef SIGTRAP
+    ap_sys_siglist[SIGTRAP] = "Trace/BPT trap";
+#endif
+#ifdef SIGIOT
+    ap_sys_siglist[SIGIOT] = "IOT instruction";
+#endif
+#ifdef SIGABRT
+    ap_sys_siglist[SIGABRT] = "Abort";
+#endif
+#ifdef SIGEMT
+    ap_sys_siglist[SIGEMT] = "Emulator trap";
+#endif
+#ifdef SIGFPE
+    ap_sys_siglist[SIGFPE] = "Arithmetic exception";
+#endif
+#ifdef SIGKILL
+    ap_sys_siglist[SIGKILL] = "Killed";
+#endif
+#ifdef SIGBUS
+    ap_sys_siglist[SIGBUS] = "Bus error";
+#endif
+#ifdef SIGSEGV
+    ap_sys_siglist[SIGSEGV] = "Segmentation fault";
+#endif
+#ifdef SIGSYS
+    ap_sys_siglist[SIGSYS] = "Bad system call";
+#endif
+#ifdef SIGPIPE
+    ap_sys_siglist[SIGPIPE] = "Broken pipe";
+#endif
+#ifdef SIGALRM
+    ap_sys_siglist[SIGALRM] = "Alarm clock";
+#endif
+#ifdef SIGTERM
+    ap_sys_siglist[SIGTERM] = "Terminated";
+#endif
+#ifdef SIGUSR1
+    ap_sys_siglist[SIGUSR1] = "User defined signal 1";
+#endif
+#ifdef SIGUSR2
+    ap_sys_siglist[SIGUSR2] = "User defined signal 2";
+#endif
+#ifdef SIGCLD
+    ap_sys_siglist[SIGCLD] = "Child status change";
+#endif
+#ifdef SIGCHLD
+    ap_sys_siglist[SIGCHLD] = "Child status change";
+#endif
+#ifdef SIGPWR
+    ap_sys_siglist[SIGPWR] = "Power-fail restart";
+#endif
+#ifdef SIGWINCH
+    ap_sys_siglist[SIGWINCH] = "Window changed";
+#endif
+#ifdef SIGURG
+    ap_sys_siglist[SIGURG] = "urgent socket condition";
+#endif
+#ifdef SIGPOLL
+    ap_sys_siglist[SIGPOLL] = "Pollable event occurred";
+#endif
+#ifdef SIGIO
+    ap_sys_siglist[SIGIO] = "socket I/O possible";
+#endif
+#ifdef SIGSTOP
+    ap_sys_siglist[SIGSTOP] = "Stopped (signal)";
+#endif
+#ifdef SIGTSTP
+    ap_sys_siglist[SIGTSTP] = "Stopped";
+#endif
+#ifdef SIGCONT
+    ap_sys_siglist[SIGCONT] = "Continued";
+#endif
+#ifdef SIGTTIN
+    ap_sys_siglist[SIGTTIN] = "Stopped (tty input)";
+#endif
+#ifdef SIGTTOU
+    ap_sys_siglist[SIGTTOU] = "Stopped (tty output)";
+#endif
+#ifdef SIGVTALRM
+    ap_sys_siglist[SIGVTALRM] = "virtual timer expired";
+#endif
+#ifdef SIGPROF
+    ap_sys_siglist[SIGPROF] = "profiling timer expired";
+#endif
+#ifdef SIGXCPU
+    ap_sys_siglist[SIGXCPU] = "exceeded cpu limit";
+#endif
+#ifdef SIGXFSZ
+    ap_sys_siglist[SIGXFSZ] = "exceeded file size limit";
+#endif
+    for (sig=0; sig < sizeof(ap_sys_siglist)/sizeof(ap_sys_siglist[0]); ++sig)
+        if (ap_sys_siglist[sig] == NULL)
+            ap_sys_siglist[sig] = "";
+}
+#endif /* platform has sys_siglist[] */
+
+#ifdef AP_ENABLE_EXCEPTION_HOOK
+typedef struct except_hook_t {
+    struct except_hook_t *next;
+    void (*fn)(ap_exception_info_t *);
+} except_hook_t;
+
+static except_hook_t *except_hooks;
+
+static void except_hook_cleanup(void *ignored)
+{
+    except_hooks = NULL;
+}
+
+API_EXPORT(int) ap_add_fatal_exception_hook(void (*fn)(ap_exception_info_t *))
+{
+    except_hook_t *new;
+
+    ap_assert(pconf);
+
+    if (!ap_exception_hook_enabled) {
+        return 1;
+    }
+
+    new = ap_palloc(pconf, sizeof(except_hook_t));
+    new->next = except_hooks;
+    new->fn = fn;
+    except_hooks = new;
+
+    return 0;
+}
+
+static void run_fatal_exception_hook(int sig)
+{
+    except_hook_t *cur_hook = except_hooks;
+    ap_exception_info_t ei = {0};
+
+    if (ap_exception_hook_enabled &&
+        geteuid() != 0) {
+        ei.sig = sig;
+        ei.pid = getpid();
+
+        while (cur_hook) {
+            cur_hook->fn(&ei);
+            cur_hook = cur_hook->next;
+        }
+    }
+}
+#endif /* AP_ENABLE_EXCEPTION_HOOK */
+
+/* handle all varieties of core dumping signals */
+static void sig_coredump(int sig)
+{
+    chdir(ap_coredump_dir);
+    signal(sig, SIG_DFL);
+#ifdef AP_ENABLE_EXCEPTION_HOOK
+    run_fatal_exception_hook(sig);
+#endif
+#if !defined(WIN32) && !defined(NETWARE)
+    kill(getpid(), sig);
+#else
+    raise(sig);
+#endif
+    /* At this point we've got sig blocked, because we're still inside
+     * the signal handler.  When we leave the signal handler it will
+     * be unblocked, and we'll take the signal... and coredump or whatever
+     * is appropriate for this particular Unix.  In addition the parent
+     * will see the real signal we received -- whereas if we called
+     * abort() here, the parent would only see SIGABRT.
+     */
+}
+
+/*****************************************************************
+ * Connection structures and accounting...
+ */
+
+static void just_die(int sig)
+{				/* SIGHUP to child process??? */
+    /* if alarms are blocked we have to wait to die otherwise we might
+     * end up with corruption in alloc.c's internal structures */
+#ifdef NETWARE
+    get_tsd
+#endif
+    if (alarms_blocked) {
+	exit_after_unblock = 1;
+    }
+    else {
+	clean_child_exit(0);
+    }
+}
+
+static int volatile usr1_just_die = 1;
+static int volatile deferred_die;
+
+static void usr1_handler(int sig)
+{
+    if (usr1_just_die) {
+	just_die(sig);
+    }
+    deferred_die = 1;
+}
+
+/* volatile just in case */
+static int volatile shutdown_pending;
+static int volatile restart_pending;
+static int volatile is_graceful;
+API_VAR_EXPORT ap_generation_t volatile ap_my_generation=0;
+
+#ifdef WIN32
+/*
+ * Signalling Apache on NT.
+ *
+ * Under Unix, Apache can be told to shutdown or restart by sending various
+ * signals (HUP, USR, TERM). On NT we don't have easy access to signals, so
+ * we use "events" instead. The parent apache process goes into a loop
+ * where it waits forever for a set of events. Two of those events are
+ * called
+ *
+ *    apPID_shutdown
+ *    apPID_restart
+ *
+ * (where PID is the PID of the apache parent process). When one of these
+ * is signalled, the Apache parent performs the appropriate action. The events
+ * can become signalled through internal Apache methods (e.g. if the child
+ * finds a fatal error and needs to kill its parent), via the service
+ * control manager (the control thread will signal the shutdown event when
+ * requested to stop the Apache service), from the -k Apache command line,
+ * or from any external program which finds the Apache PID from the
+ * httpd.pid file.
+ *
+ * The signal_parent() function, below, is used to signal one of these events.
+ * It can be called by any child or parent process, since it does not
+ * rely on global variables.
+ *
+ * On entry, type gives the event to signal. 0 means shutdown, 1 means 
+ * graceful restart.
+ */
+
+static void signal_parent(int type)
+{
+    HANDLE e;
+    char *signal_name;
+    extern char signal_shutdown_name[];
+    extern char signal_restart_name[];
+
+    /* after updating the shutdown_pending or restart flags, we need
+     * to wake up the parent process so it can see the changes. The
+     * parent will normally be waiting for either a child process
+     * to die, or for a signal on the "spache-signal" event. So set the
+     * "apache-signal" event here.
+     */
+
+    /* XXX: This is no good, can't we please die in -X mode :-? */
+    if (one_process) {
+	return;
+    }
+
+    switch(type) {
+    case 0: signal_name = signal_shutdown_name; break;
+    case 1: signal_name = signal_restart_name; break;
+    default: return;
+    }
+
+    APD2("signal_parent signalling event \"%s\"", signal_name);
+
+    e = OpenEvent(EVENT_ALL_ACCESS, FALSE, signal_name);
+    if (!e) {
+	/* Um, problem, can't signal the parent, which means we can't
+	 * signal ourselves to die. Ignore for now...
+	 */
+	ap_log_error(APLOG_MARK, APLOG_EMERG|APLOG_WIN32ERROR, server_conf,
+	    "OpenEvent on %s event", signal_name);
+	return;
+    }
+    if (SetEvent(e) == 0) {
+	/* Same problem as above */
+	ap_log_error(APLOG_MARK, APLOG_EMERG|APLOG_WIN32ERROR, server_conf,
+	    "SetEvent on %s event", signal_name);
+	CloseHandle(e);
+	return;
+    }
+    CloseHandle(e);
+}
+#endif
+
+/*
+ * ap_start_shutdown() and ap_start_restart(), below, are a first stab at
+ * functions to initiate shutdown or restart without relying on signals. 
+ * Previously this was initiated in sig_term() and restart() signal handlers, 
+ * but we want to be able to start a shutdown/restart from other sources --
+ * e.g. on Win32, from the service manager. Now the service manager can
+ * call ap_start_shutdown() or ap_start_restart() as appropiate.  Note that
+ * these functions can also be called by the child processes, since global
+ * variables are no longer used to pass on the required action to the parent.
+ */
+
+API_EXPORT(void) ap_start_shutdown(void)
+{
+#ifndef WIN32
+    if (shutdown_pending == 1) {
+	/* Um, is this _probably_ not an error, if the user has
+	 * tried to do a shutdown twice quickly, so we won't
+	 * worry about reporting it.
+	 */
+	return;
+    }
+    shutdown_pending = 1;
+#else
+    signal_parent(0);	    /* get the parent process to wake up */
+#endif
+}
+
+/* do a graceful restart if graceful == 1 */
+API_EXPORT(void) ap_start_restart(int graceful)
+{
+#ifndef WIN32
+    if (restart_pending == 1) {
+	/* Probably not an error - don't bother reporting it */
+	return;
+    }
+    restart_pending = 1;
+    is_graceful = graceful;
+#else
+    signal_parent(1);	    /* get the parent process to wake up */
+#endif /* WIN32 */
+}
+
+static void sig_term(int sig)
+{
+    ap_start_shutdown();
+}
+
+static void restart(int sig)
+{
+#ifdef TPF
+    signal(sig, restart);
+#endif
+#if !defined (WIN32) && !defined(NETWARE)
+    ap_start_restart(sig == SIGUSR1);
+#else
+    ap_start_restart(1);
+#endif
+}
+
+static void set_signals(void)
+{
+#ifndef NO_USE_SIGACTION
+    struct sigaction sa;
+
+    sigemptyset(&sa.sa_mask);
+    sa.sa_flags = 0;
+
+    if (!one_process) {
+	sa.sa_handler = sig_coredump;
+#if defined(SA_ONESHOT)
+	sa.sa_flags = SA_ONESHOT;
+#elif defined(SA_RESETHAND)
+	sa.sa_flags = SA_RESETHAND;
+#endif
+	if (sigaction(SIGSEGV, &sa, NULL) < 0)
+	    ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGSEGV)");
+#ifdef SIGBUS
+	if (sigaction(SIGBUS, &sa, NULL) < 0)
+	    ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGBUS)");
+#endif
+#ifdef SIGABORT
+	if (sigaction(SIGABORT, &sa, NULL) < 0)
+	    ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGABORT)");
+#endif
+#ifdef SIGABRT
+	if (sigaction(SIGABRT, &sa, NULL) < 0)
+	    ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGABRT)");
+#endif
+#ifdef SIGILL
+	if (sigaction(SIGILL, &sa, NULL) < 0)
+	    ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGILL)");
+#endif
+	sa.sa_flags = 0;
+    }
+    sa.sa_handler = sig_term;
+    if (sigaction(SIGTERM, &sa, NULL) < 0)
+	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGTERM)");
+#ifdef SIGINT
+    if (sigaction(SIGINT, &sa, NULL) < 0)
+        ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGINT)");
+#endif
+#ifdef SIGXCPU
+    sa.sa_handler = SIG_DFL;
+    if (sigaction(SIGXCPU, &sa, NULL) < 0)
+	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGXCPU)");
+#endif
+#ifdef SIGXFSZ
+    sa.sa_handler = SIG_DFL;
+    if (sigaction(SIGXFSZ, &sa, NULL) < 0)
+	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGXFSZ)");
+#endif
+#ifdef SIGPIPE
+    sa.sa_handler = SIG_IGN;
+    if (sigaction(SIGPIPE, &sa, NULL) < 0)
+	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGPIPE)");
+#endif
+
+    /* we want to ignore HUPs and USR1 while we're busy processing one */
+    sigaddset(&sa.sa_mask, SIGHUP);
+    sigaddset(&sa.sa_mask, SIGUSR1);
+    sa.sa_handler = restart;
+    if (sigaction(SIGHUP, &sa, NULL) < 0)
+	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGHUP)");
+    if (sigaction(SIGUSR1, &sa, NULL) < 0)
+	ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "sigaction(SIGUSR1)");
+#else
+    if (!one_process) {
+	signal(SIGSEGV, sig_coredump);
+#ifdef SIGBUS
+	signal(SIGBUS, sig_coredump);
+#endif /* SIGBUS */
+#ifdef SIGABORT
+	signal(SIGABORT, sig_coredump);
+#endif /* SIGABORT */
+#ifdef SIGABRT
+	signal(SIGABRT, sig_coredump);
+#endif /* SIGABRT */
+#ifdef SIGILL
+	signal(SIGILL, sig_coredump);
+#endif /* SIGILL */
+#ifdef SIGXCPU
+	signal(SIGXCPU, SIG_DFL);
+#endif /* SIGXCPU */
+#ifdef SIGXFSZ
+	signal(SIGXFSZ, SIG_DFL);
+#endif /* SIGXFSZ */
+    }
+#ifndef NETWARE
+    signal(SIGTERM, sig_term);
+#endif
+#ifdef SIGHUP
+    signal(SIGHUP, restart);
+#endif /* SIGHUP */
+#ifdef SIGUSR1
+    signal(SIGUSR1, restart);
+#endif /* SIGUSR1 */
+#ifdef SIGPIPE
+    signal(SIGPIPE, SIG_IGN);
+#endif /* SIGPIPE */
+
+#endif
+}
+
+
+/*****************************************************************
+ * Here follows a long bunch of generic server bookkeeping stuff...
+ */
+
+static void detach(void)
+{
+#if !defined(WIN32) && !defined(NETWARE)
+    int x;
+
+    chdir("/");
+#if !defined(MPE) && !defined(OS2) && !defined(TPF) && !defined(BEOS) && \
+    !defined(BONE)
+/* Don't detach for MPE because child processes can't survive the death of
+   the parent. */
+    if (do_detach) {
+        if ((x = fork()) > 0)
+            exit(0);
+        else if (x == -1) {
+            perror("fork");
+	    fprintf(stderr, "%s: unable to fork new process\n", ap_server_argv0);
+	    exit(1);
+        }
+        RAISE_SIGSTOP(DETACH);
+    }
+#endif
+#define NO_SETSID /* setsid seems to be broken somewhere */
+#ifndef NO_SETSID
+    if ((pgrp = setsid()) == -1) {
+	perror("setsid");
+	fprintf(stderr, "%s: setsid failed\n", ap_server_argv0);
+	if (!do_detach) 
+	    fprintf(stderr, "setsid() failed probably because you aren't "
+		"running under a process management tool like daemontools\n");
+	exit(1);
+    }
+#elif defined(NEXT) || defined(NEWSOS)
+    if (setpgrp(0, getpid()) == -1 || (pgrp = getpgrp(0)) == -1) {
+	perror("setpgrp");
+	fprintf(stderr, "%s: setpgrp or getpgrp failed\n", ap_server_argv0);
+	exit(1);
+    }
+#elif defined(OS2) || defined(TPF)
+    /* OS/2 and TPF don't support process group IDs */
+    pgrp = getpid();
+#elif defined(MPE)
+    /* MPE uses negative pid for process group */
+    pgrp = -getpid();
+#elif defined(CYGWIN)
+    /* Cygwin does not take any argument for setpgrp() */
+    if ((pgrp = setpgrp()) == -1) {
+        perror("setpgrp");
+        fprintf(stderr, "%s: setpgrp failed\n", ap_server_argv0);
+        exit(1);
+    }
+#else
+    if ((pgrp = setpgrp()) == -1) {
+	perror("setpgrp");
+	fprintf(stderr, "%s: setpgrp failed\n", ap_server_argv0);
+	exit(1);
+    }
+#endif
+
+    /* close out the standard file descriptors */
+    if (freopen("/dev/null", "r", stdin) == NULL) {
+	fprintf(stderr, "%s: unable to replace stdin with /dev/null: %s\n",
+		ap_server_argv0, strerror(errno));
+	/* continue anyhow -- note we can't close out descriptor 0 because we
+	 * have nothing to replace it with, and if we didn't have a descriptor
+	 * 0 the next file would be created with that value ... leading to
+	 * havoc.
+	 */
+    }
+    if (freopen("/dev/null", "w", stdout) == NULL) {
+	fprintf(stderr, "%s: unable to replace stdout with /dev/null: %s\n",
+		ap_server_argv0, strerror(errno));
+    }
+    /* stderr is a tricky one, we really want it to be the error_log,
+     * but we haven't opened that yet.  So leave it alone for now and it'll
+     * be reopened moments later.
+     */
+#endif /* ndef WIN32 */
+}
+
+/* Set group privileges.
+ *
+ * Note that we use the username as set in the config files, rather than
+ * the lookup of to uid --- the same uid may have multiple passwd entries,
+ * with different sets of groups for each.
+ */
+
+static void set_group_privs(void)
+{
+#if !defined(WIN32) && !defined(NETWARE) && !defined(BEOS) && !defined(BONE)
+    if (!geteuid()) {
+	char *name;
+
+	/* Get username if passed as a uid */
+
+	if (ap_user_name[0] == '#') {
+	    struct passwd *ent;
+	    uid_t uid = atoi(&ap_user_name[1]);
+
+	    if ((ent = getpwuid(uid)) == NULL) {
+		ap_log_error(APLOG_MARK, APLOG_ALERT, server_conf,
+			 "getpwuid: couldn't determine user name from uid %u, "
+			 "you probably need to modify the User directive",
+			 (unsigned)uid);
+		clean_child_exit(APEXIT_CHILDFATAL);
+	    }
+
+	    name = ent->pw_name;
+	}
+	else
+	    name = ap_user_name;
+
+#if !defined(OS2) && !defined(TPF)
+	/* OS/2 and TPF don't support groups. */
+
+	/*
+	 * Set the GID before initgroups(), since on some platforms
+	 * setgid() is known to zap the group list.
+	 */
+#ifdef MPE
+	GETPRIVMODE();
+#endif
+	if (setgid(ap_group_id) == -1) {
+#ifdef MPE
+	    GETUSERMODE();
+#endif
+	    ap_log_error(APLOG_MARK, APLOG_ALERT, server_conf,
+			"setgid: unable to set group id to Group %u",
+			(unsigned)ap_group_id);
+	    clean_child_exit(APEXIT_CHILDFATAL);
+	}
+#ifdef MPE
+	GETUSERMODE();
+#endif
+
+	/* Reset `groups' attributes. */
+
+	if (initgroups(name, ap_group_id) == -1) {
+	    ap_log_error(APLOG_MARK, APLOG_ALERT, server_conf,
+			"initgroups: unable to set groups for User %s "
+			"and Group %u", name, (unsigned)ap_group_id);
+	    clean_child_exit(APEXIT_CHILDFATAL);
+	}
+#ifdef MULTIPLE_GROUPS
+	if (getgroups(NGROUPS_MAX, group_id_list) == -1) {
+	    ap_log_error(APLOG_MARK, APLOG_ALERT, server_conf,
+			"getgroups: unable to get group list");
+	    clean_child_exit(APEXIT_CHILDFATAL);
+	}
+#endif /* MULTIPLE_GROUPS */
+#endif /* !defined(OS2) && !defined(TPF) */
+    }
+#endif /* !defined(WIN32) && !defined(NETWARE) && !defined(BEOS) */
+}
+
+/* check to see if we have the 'suexec' setuid wrapper installed */
+static int init_suexec(void)
+{
+    int result = 0;
+
+#if !defined(WIN32) && !defined(NETWARE) && !defined(TPF)
+    struct stat wrapper;
+
+    if ((stat(SUEXEC_BIN, &wrapper)) != 0) {
+	result = 0;
+    }
+    else if ((wrapper.st_mode & S_ISUID) && (wrapper.st_uid == 0)) {
+	result = 1;
+    }
+#endif /* ndef WIN32 */
+    return result;
+}
+
+/*****************************************************************
+ * Connection structures and accounting...
+ */
+
+
+static conn_rec *new_connection(pool *p, server_rec *server, BUFF *inout,
+			     const struct sockaddr_in *remaddr,
+			     const struct sockaddr_in *saddr,
+			     int child_num)
+{
+    conn_rec *conn = (conn_rec *) ap_pcalloc(p, sizeof(conn_rec));
+
+    /* Got a connection structure, so initialize what fields we can
+     * (the rest are zeroed out by pcalloc).
+     */
+
+    conn->child_num = child_num;
+
+    conn->pool = p;
+    conn->local_addr = *saddr;
+    conn->local_ip = ap_pstrdup(conn->pool,
+				inet_ntoa(conn->local_addr.sin_addr));
+    conn->server = server; /* just a guess for now */
+    ap_update_vhost_given_ip(conn);
+    conn->base_server = conn->server;
+    conn->client = inout;
+
+    conn->remote_addr = *remaddr;
+    conn->remote_ip = ap_pstrdup(conn->pool,
+			      inet_ntoa(conn->remote_addr.sin_addr));
+
+    return conn;
+}
+
+#if defined(TCP_NODELAY) && !defined(MPE) && !defined(TPF)
+static void sock_disable_nagle(int s, struct sockaddr_in *sin_client)
+{
+    /* The Nagle algorithm says that we should delay sending partial
+     * packets in hopes of getting more data.  We don't want to do
+     * this; we are not telnet.  There are bad interactions between
+     * persistent connections and Nagle's algorithm that have very severe
+     * performance penalties.  (Failing to disable Nagle is not much of a
+     * problem with simple HTTP.)
+     *
+     * In spite of these problems, failure here is not a shooting offense.
+     */
+    int just_say_no = 1;
+
+    if (setsockopt(s, IPPROTO_TCP, TCP_NODELAY, (char *) &just_say_no,
+		   sizeof(int)) < 0) {
+#ifdef NETWARE
+        errno = WSAGetLastError();
+#endif
+        if (sin_client) {
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, server_conf,
+                         "setsockopt: (TCP_NODELAY), client %pA probably "
+                         "dropped the connection", &sin_client->sin_addr);
+        }
+        else {
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, server_conf,
+                         "setsockopt: (TCP_NODELAY)");
+        }
+    }
+}
+
+#else
+#define sock_disable_nagle(s, c)	/* NOOP */
+#endif
+
+static int make_sock(pool *p, const struct sockaddr_in *server)
+{
+    int s;
+    int one = 1;
+    char addr[512];
+
+    if (server->sin_addr.s_addr != htonl(INADDR_ANY))
+	ap_snprintf(addr, sizeof(addr), "address %s port %d",
+		inet_ntoa(server->sin_addr), ntohs(server->sin_port));
+    else
+	ap_snprintf(addr, sizeof(addr), "port %d", ntohs(server->sin_port));
+
+    /* note that because we're about to slack we don't use psocket */
+    ap_block_alarms();
+    if ((s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == -1) {
+	    ap_log_error(APLOG_MARK, APLOG_CRIT, server_conf,
+		    "make_sock: failed to get a socket for %s", addr);
+
+	    ap_unblock_alarms();
+	    exit(1);
+    }
+
+    /* Solaris (probably versions 2.4, 2.5, and 2.5.1 with various levels
+     * of tcp patches) has some really weird bugs where if you dup the
+     * socket now it breaks things across SIGHUP restarts.  It'll either
+     * be unable to bind, or it won't respond.
+     */
+#if defined (SOLARIS2) && SOLARIS2 < 260
+#define WORKAROUND_SOLARIS_BUG
+#endif
+
+    /* PR#1282 Unixware 1.x appears to have the same problem as solaris */
+#if defined (UW) && UW < 200
+#define WORKAROUND_SOLARIS_BUG
+#endif
+
+    /* PR#1973 NCR SVR4 systems appear to have the same problem */
+#if defined (MPRAS)
+#define WORKAROUND_SOLARIS_BUG
+#endif
+
+#ifndef WORKAROUND_SOLARIS_BUG
+#ifndef BEOS /* this won't work for BeOS sockets!! */
+    s = ap_slack(s, AP_SLACK_HIGH);
+#endif
+
+    ap_note_cleanups_for_socket_ex(p, s, 1);	/* arrange to close on exec or restart */
+#ifdef TPF
+    os_note_additional_cleanups(p, s);
+#endif /* TPF */
+#endif
+
+    if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char *) &one, sizeof(int)) < 0) {
+#ifndef _OSD_POSIX
+	ap_log_error(APLOG_MARK, APLOG_CRIT, server_conf,
+		    "make_sock: for %s, setsockopt: (SO_REUSEADDR)", addr);
+	closesocket(s);
+	ap_unblock_alarms();
+	exit(1);
+#endif /*_OSD_POSIX*/
+    }
+    one = 1;
+#if defined(SO_KEEPALIVE) && !defined(MPE)
+    if (setsockopt(s, SOL_SOCKET, SO_KEEPALIVE, (char *) &one, sizeof(int)) < 0) {
+	ap_log_error(APLOG_MARK, APLOG_CRIT, server_conf,
+		    "make_sock: for %s, setsockopt: (SO_KEEPALIVE)", addr);
+	closesocket(s);
+
+	ap_unblock_alarms();
+	exit(1);
+    }
+#endif
+
+    sock_disable_nagle(s, NULL);
+    sock_enable_linger(s);
+
+    /*
+     * To send data over high bandwidth-delay connections at full
+     * speed we must force the TCP window to open wide enough to keep the
+     * pipe full.  The default window size on many systems
+     * is only 4kB.  Cross-country WAN connections of 100ms
+     * at 1Mb/s are not impossible for well connected sites.
+     * If we assume 100ms cross-country latency,
+     * a 4kB buffer limits throughput to 40kB/s.
+     *
+     * To avoid this problem I've added the SendBufferSize directive
+     * to allow the web master to configure send buffer size.
+     *
+     * The trade-off of larger buffers is that more kernel memory
+     * is consumed.  YMMV, know your customers and your network!
+     *
+     * -John Heidemann <johnh@isi.edu> 25-Oct-96
+     *
+     * If no size is specified, use the kernel default.
+     */
+#ifndef BEOS			/* BeOS does not support SO_SNDBUF */
+    if (server_conf->send_buffer_size) {
+	if (setsockopt(s, SOL_SOCKET, SO_SNDBUF,
+		(char *) &server_conf->send_buffer_size, sizeof(int)) < 0) {
+	    ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf,
+			"make_sock: failed to set SendBufferSize for %s, "
+			"using default", addr);
+	    /* not a fatal error */
+	}
+    }
+#endif
+
+#ifdef MPE
+/* MPE requires CAP=PM and GETPRIVMODE to bind to ports less than 1024 */
+    if (ntohs(server->sin_port) < 1024)
+	GETPRIVMODE();
+#endif
+
+    if (bind(s, (struct sockaddr *) server, sizeof(struct sockaddr_in)) == -1) {
+	ap_log_error(APLOG_MARK, APLOG_CRIT, server_conf,
+	    "make_sock: could not bind to %s", addr);
+#ifdef MPE
+	if (ntohs(server->sin_port) < 1024)
+	    GETUSERMODE();
+#endif
+
+	closesocket(s);
+	ap_unblock_alarms();
+	exit(1);
+    }
+#ifdef MPE
+    if (ntohs(server->sin_port) < 1024)
+	GETUSERMODE();
+#endif
+
+    if (listen(s, ap_listenbacklog) == -1) {
+	ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
+	    "make_sock: unable to listen for connections on %s", addr);
+	closesocket(s);
+	ap_unblock_alarms();
+	exit(1);
+    }
+
+#ifdef SO_ACCEPTFILTER
+    if (ap_acceptfilter) {
+#ifndef ACCEPT_FILTER_NAME
+#define ACCEPT_FILTER_NAME "httpready"
+#ifdef __FreeBSD_version
+#if __FreeBSD_version < 411000 /* httpready broken before 4.1.1 */
+#undef ACCEPT_FILTER_NAME
+#define ACCEPT_FILTER_NAME "dataready"
+#endif
+#endif
+#endif /* ! ACCEPT_FILTER_NAME */
+	/*
+	 * See htdocs/manual/misc/perf-bsd44.html for a discussion of
+	 * how to enable this feature and various issues with it.
+	 */
+	struct accept_filter_arg af = {
+	    ACCEPT_FILTER_NAME, ""
+	};
+	if (setsockopt(s, SOL_SOCKET, SO_ACCEPTFILTER, &af, sizeof(af)) < 0) {
+            if (errno == ENOPROTOOPT) {
+	    	ap_log_error(APLOG_MARK, APLOG_INFO | APLOG_NOERRNO, server_conf,
+			 "socket option SO_ACCEPTFILTER unkown on this machine. Continuing.");
+	     } else {
+	    	ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_INFO, server_conf,
+			 "make_sock: for %s, setsockopt: (SO_ACCEPTFILTER)", addr);
+	     }
+	}
+    }
+#endif
+
+#ifdef WORKAROUND_SOLARIS_BUG
+    s = ap_slack(s, AP_SLACK_HIGH);
+
+    ap_note_cleanups_for_socket_ex(p, s, 1);	/* arrange to close on exec or restart */
+#endif
+    ap_unblock_alarms();
+
+#ifdef CHECK_FD_SETSIZE
+    /* protect various fd_sets */
+    if (s >= FD_SETSIZE) {
+	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, NULL,
+	    "make_sock: problem listening on %s, filedescriptor (%u) "
+	    "larger than FD_SETSIZE (%u) "
+	    "found, you probably need to rebuild Apache with a "
+	    "larger FD_SETSIZE", addr, s, FD_SETSIZE);
+	closesocket(s);
+	exit(1);
+    }
+#endif
+
+    return s;
+}
+
+
+/*
+ * During a restart we keep track of the old listeners here, so that we
+ * can re-use the sockets.  We have to do this because we won't be able
+ * to re-open the sockets ("Address already in use").
+ *
+ * Unlike the listeners ring, old_listeners is a NULL terminated list.
+ *
+ * copy_listeners() makes the copy, find_listener() finds an old listener
+ * and close_unused_listener() cleans up whatever wasn't used.
+ */
+static listen_rec *old_listeners;
+
+/* unfortunately copy_listeners may be called before listeners is a ring */
+static void copy_listeners(pool *p)
+{
+    listen_rec *lr;
+
+    ap_assert(old_listeners == NULL);
+    if (ap_listeners == NULL) {
+	return;
+    }
+    lr = ap_listeners;
+    do {
+	listen_rec *nr = malloc(sizeof *nr);
+
+        if (nr == NULL) {
+            fprintf(stderr, "Ouch!  malloc failed in copy_listeners()\n");
+            exit(1);
+        }
+	*nr = *lr;
+	ap_kill_cleanups_for_socket(p, nr->fd);
+	nr->next = old_listeners;
+	ap_assert(!nr->used);
+	old_listeners = nr;
+	lr = lr->next;
+    } while (lr && lr != ap_listeners);
+}
+
+
+static int find_listener(listen_rec *lr)
+{
+    listen_rec *or;
+
+    for (or = old_listeners; or; or = or->next) {
+	if (!memcmp(&or->local_addr, &lr->local_addr, sizeof(or->local_addr))) {
+	    or->used = 1;
+	    return or->fd;
+	}
+    }
+    return -1;
+}
+
+
+static void close_unused_listeners(void)
+{
+    listen_rec *or, *next;
+
+    for (or = old_listeners; or; or = next) {
+	next = or->next;
+	if (!or->used)
+	    closesocket(or->fd);
+	free(or);
+    }
+    old_listeners = NULL;
+}
+
+#ifdef NONBLOCK_WHEN_MULTI_LISTEN
+/* retrieved from APR */
+static int soblock(int sd)
+{
+#ifdef NETWARE
+    u_long one = 0;
+
+    if (ioctlsocket(sd, FIONBIO, &one) == SOCKET_ERROR) {
+        return -1;
+    }
+#else
+#ifndef BEOS
+    int fd_flags;
+    
+    fd_flags = fcntl(sd, F_GETFL, 0);
+#if defined(O_NONBLOCK)
+    fd_flags &= ~O_NONBLOCK;
+#elif defined(O_NDELAY)
+    fd_flags &= ~O_NDELAY;
+#elif defined(FNDELAY)
+    fd_flags &= ~FNDELAY;
+#else
+#error Teach soblock() how to make a socket blocking on your platform.
+#endif
+    if (fcntl(sd, F_SETFL, fd_flags) == -1) {
+        return errno;
+    }
+#else
+    int on = 0;
+    if (setsockopt(sd, SOL_SOCKET, SO_NONBLOCK, &on, sizeof(int)) < 0)
+        return errno;
+#endif /* BEOS */
+#endif /* NETWARE */
+    return 0;
+}
+
+static int sononblock(int sd)
+{
+#ifdef NETWARE
+    u_long one = 1;
+
+    if (ioctlsocket(sd, FIONBIO, &one) == SOCKET_ERROR) {
+        return -1;
+    }
+#else
+#ifndef BEOS
+    int fd_flags;
+    
+    fd_flags = fcntl(sd, F_GETFL, 0);
+#if defined(O_NONBLOCK)
+    fd_flags |= O_NONBLOCK;
+#elif defined(O_NDELAY)
+    fd_flags |= O_NDELAY;
+#elif defined(FNDELAY)
+    fd_flags |= FNDELAY;
+#else
+#error Teach sononblock() how to make a socket non-blocking on your platform.
+#endif
+    if (fcntl(sd, F_SETFL, fd_flags) == -1) {
+        return errno;
+    }
+#else
+    int on = 1;
+    if (setsockopt(sd, SOL_SOCKET, SO_NONBLOCK, &on, sizeof(int)) < 0)
+        return errno;
+#endif /* BEOS */
+#endif /* NETWARE */
+    return 0;
+}
+#endif /* NONBLOCK_WHEN_MULTI_LISTEN */
+
+/* open sockets, and turn the listeners list into a singly linked ring */
+static void setup_listeners(pool *p)
+{
+    listen_rec *lr;
+    int fd;
+
+    listenmaxfd = -1;
+    FD_ZERO(&listenfds);
+    lr = ap_listeners;
+    for (;;) {
+	fd = find_listener(lr);
+	if (fd < 0) {
+	    fd = make_sock(p, &lr->local_addr);
+	}
+	else {
+	    ap_note_cleanups_for_socket_ex(p, fd, 1);
+	}
+	/* if we get here, (fd >= 0) && (fd < FD_SETSIZE) */
+	FD_SET(fd, &listenfds);
+	if (fd > listenmaxfd)
+	    listenmaxfd = fd;
+	lr->fd = fd;
+	if (lr->next == NULL)
+	    break;
+	lr = lr->next;
+    }
+    /* turn the list into a ring */
+    lr->next = ap_listeners;
+    head_listener = ap_listeners;
+    close_unused_listeners();
+
+#ifdef NONBLOCK_WHEN_MULTI_LISTEN
+    if (ap_listeners->next != ap_listeners) {
+        lr = ap_listeners;
+        do {
+            if (sononblock(lr->fd) < 0) {
+                ap_log_error(APLOG_MARK, APLOG_CRIT, NULL,
+                             "A listening socket could not be made non-blocking.");
+                exit(APEXIT_INIT);
+            }
+            lr = lr->next;
+        } while (lr != ap_listeners);
+    }
+    else {
+        /* we could be restarting with a single remaining listening
+         * socket, still in non-blocking state from a previous
+         * generation which had more listening sockets
+         */
+        if (soblock(ap_listeners->fd) < 0) {
+            ap_log_error(APLOG_MARK, APLOG_CRIT, NULL,
+                         "A listening socket could not be made blocking.");
+            exit(APEXIT_INIT);
+        }
+    }
+#endif /* NONBLOCK_WHEN_MULTI_LISTEN */
+    
+#ifdef NO_SERIALIZED_ACCEPT
+    /* warn them about the starvation problem if they're using multiple
+     * sockets
+     */
+    if (ap_listeners->next != ap_listeners) {
+	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_CRIT, NULL,
+		    "You cannot use multiple Listens safely on your system, "
+		    "proceeding anyway.  See src/PORTING, search for "
+		    "SERIALIZED_ACCEPT.");
+    }
+#endif
+}
+
+
+/*
+ * Find a listener which is ready for accept().  This advances the
+ * head_listener global.
+ */
+static ap_inline listen_rec *find_ready_listener(fd_set * main_fds)
+{
+    listen_rec *lr;
+
+    lr = head_listener;
+    do {
+	if (FD_ISSET(lr->fd, main_fds)) {
+	    head_listener = lr->next;
+	    return (lr);
+	}
+	lr = lr->next;
+    } while (lr != head_listener);
+    return NULL;
+}
+
+
+#if defined(WIN32) || defined(NETWARE)
+static int s_iInitCount = 0;
+
+static int AMCSocketInitialize(void)
+{
+    int iVersionRequested;
+    WSADATA wsaData;
+    int err;
+
+    if (s_iInitCount > 0) {
+	s_iInitCount++;
+	return (0);
+    }
+    else if (s_iInitCount < 0)
+	return (s_iInitCount);
+
+    /* s_iInitCount == 0. Do the initailization */
+    iVersionRequested = MAKEWORD(2, 0);
+    err = WSAStartup((WORD) iVersionRequested, &wsaData);
+    if (err) {
+        printf("WSAStartup failed with error %d\n", err);
+	s_iInitCount = -1;
+	return (s_iInitCount);
+    }
+
+    if (LOBYTE(wsaData.wVersion) != 2 ||
+	HIBYTE(wsaData.wVersion) != 0) {
+        printf("Apache requires Winsock 2. Please see the Apache FAQ for more information.\n");
+	s_iInitCount = -2;
+	WSACleanup();
+	return (s_iInitCount);
+    }
+    s_iInitCount++;
+    return (s_iInitCount);
+}
+
+
+static void AMCSocketCleanup(void)
+{
+    if (--s_iInitCount == 0)
+	WSACleanup();
+    return;
+}
+#endif
+
+static void show_compile_settings(void)
+{
+    printf("Server version: %s\n", ap_get_server_version());
+    printf("Server built:   %s\n", ap_get_server_built());
+    printf("Server's Module Magic Number: %u:%u\n",
+	   MODULE_MAGIC_NUMBER_MAJOR, MODULE_MAGIC_NUMBER_MINOR);
+    printf("Server compiled with....\n");
+#ifdef TPF
+    show_os_specific_compile_settings();
+#endif
+#ifdef BIG_SECURITY_HOLE
+    printf(" -D BIG_SECURITY_HOLE\n");
+#endif
+#ifdef SECURITY_HOLE_PASS_AUTHORIZATION
+    printf(" -D SECURITY_HOLE_PASS_AUTHORIZATION\n");
+#endif
+#ifdef HAVE_MMAP
+    printf(" -D HAVE_MMAP\n");
+#endif
+#ifdef HAVE_SHMGET
+    printf(" -D HAVE_SHMGET\n");
+#endif
+#ifdef USE_MMAP_SCOREBOARD
+    printf(" -D USE_MMAP_SCOREBOARD\n");
+#endif
+#ifdef USE_SHMGET_SCOREBOARD
+    printf(" -D USE_SHMGET_SCOREBOARD\n");
+#endif
+#ifdef USE_OS2_SCOREBOARD
+    printf(" -D USE_OS2_SCOREBOARD\n");
+#endif
+#ifdef USE_POSIX_SCOREBOARD
+    printf(" -D USE_POSIX_SCOREBOARD\n");
+#endif
+#ifdef USE_MMAP_FILES
+    printf(" -D USE_MMAP_FILES\n");
+#ifdef MMAP_SEGMENT_SIZE
+	printf(" -D MMAP_SEGMENT_SIZE=%ld\n",(long)MMAP_SEGMENT_SIZE);
+#endif
+#endif /*USE_MMAP_FILES*/
+#ifdef NO_WRITEV
+    printf(" -D NO_WRITEV\n");
+#endif
+#ifdef NO_LINGCLOSE
+    printf(" -D NO_LINGCLOSE\n");
+#endif
+#ifdef HAVE_FCNTL_SERIALIZED_ACCEPT
+    printf(" -D HAVE_FCNTL_SERIALIZED_ACCEPT\n");
+#endif
+#ifdef HAVE_FLOCK_SERIALIZED_ACCEPT
+    printf(" -D HAVE_FLOCK_SERIALIZED_ACCEPT\n");
+#endif
+#ifdef HAVE_USLOCK_SERIALIZED_ACCEPT
+    printf(" -D HAVE_USLOCK_SERIALIZED_ACCEPT\n");
+#endif
+#ifdef HAVE_SYSVSEM_SERIALIZED_ACCEPT
+    printf(" -D HAVE_SYSVSEM_SERIALIZED_ACCEPT\n");
+#endif
+#ifdef HAVE_PTHREAD_SERIALIZED_ACCEPT
+    printf(" -D HAVE_PTHREAD_SERIALIZED_ACCEPT\n");
+#endif
+#ifdef HAVE_OS2SEM_SERIALIZED_ACCEPT
+    printf(" -D HAVE_OS2SEM_SERIALIZED_ACCEPT\n");
+#endif
+#ifdef HAVE_TPF_CORE_SERIALIZED_ACCEPT
+    printf(" -D HAVE_TPF_CORE_SERIALIZED_ACCEPT\n");
+#endif
+#ifdef HAVE_BEOS_SERIALIZED_ACCEPT
+    printf(" -D HAVE_BEOS_SERIALIZED_ACCEPT\n");
+#endif  
+#ifdef HAVE_NONE_SERIALIZED_ACCEPT
+    printf(" -D HAVE_NONE_SERIALIZED_ACCEPT\n");
+#endif
+#ifdef SINGLE_LISTEN_UNSERIALIZED_ACCEPT
+    printf(" -D SINGLE_LISTEN_UNSERIALIZED_ACCEPT\n");
+#endif
+#ifdef NO_OTHER_CHILD
+    printf(" -D NO_OTHER_CHILD\n");
+#endif
+#ifdef NO_RELIABLE_PIPED_LOGS
+    printf(" -D NO_RELIABLE_PIPED_LOGS\n");
+#endif
+#ifdef BUFFERED_LOGS
+    printf(" -D BUFFERED_LOGS\n");
+#ifdef PIPE_BUF
+	printf(" -D PIPE_BUF=%ld\n",(long)PIPE_BUF);
+#endif
+#endif
+    printf(" -D DYNAMIC_MODULE_LIMIT=%ld\n",(long)DYNAMIC_MODULE_LIMIT);
+    printf(" -D HARD_SERVER_LIMIT=%ld\n",(long)HARD_SERVER_LIMIT);
+#ifdef MULTITHREAD
+    printf(" -D MULTITHREAD\n");
+#endif
+#ifdef CHARSET_EBCDIC
+    printf(" -D CHARSET_EBCDIC\n");
+#endif
+#ifdef NEED_HASHBANG_EMUL
+    printf(" -D NEED_HASHBANG_EMUL\n");
+#endif
+#ifdef SHARED_CORE
+    printf(" -D SHARED_CORE\n");
+#endif
+#ifdef SO_ACCEPTFILTER
+    printf(" -D SO_ACCEPTFILTER\n");
+    printf(" -D ACCEPT_FILTER_NAME=\"" ACCEPT_FILTER_NAME "\"\n");
+#endif
+#ifdef AP_ACCEPTFILTER_OFF
+    printf(" -D AP_ACCEPTFILTER_OFF\n");
+#endif
+#ifdef CYGWIN_WINSOCK 
+    printf(" -D CYGWIN_WINSOCK\n"); 
+#endif 
+
+/* This list displays the compiled-in default paths: */
+#ifdef HTTPD_ROOT
+    printf(" -D HTTPD_ROOT=\"" HTTPD_ROOT "\"\n");
+#endif
+#if defined(SUEXEC_BIN) && !defined(TPF)
+    printf(" -D SUEXEC_BIN=\"" SUEXEC_BIN "\"\n");
+#endif
+#if defined(SHARED_CORE) && defined(SHARED_CORE_DIR)
+    printf(" -D SHARED_CORE_DIR=\"" SHARED_CORE_DIR "\"\n");
+#endif
+#ifdef DEFAULT_PIDLOG
+    printf(" -D DEFAULT_PIDLOG=\"" DEFAULT_PIDLOG "\"\n");
+#endif
+#ifdef DEFAULT_SCOREBOARD
+    printf(" -D DEFAULT_SCOREBOARD=\"" DEFAULT_SCOREBOARD "\"\n");
+#endif
+#ifdef DEFAULT_LOCKFILE
+    printf(" -D DEFAULT_LOCKFILE=\"" DEFAULT_LOCKFILE "\"\n");
+#endif
+#ifdef DEFAULT_ERRORLOG
+    printf(" -D DEFAULT_ERRORLOG=\"" DEFAULT_ERRORLOG "\"\n");
+#endif
+#ifdef TYPES_CONFIG_FILE
+    printf(" -D TYPES_CONFIG_FILE=\"" TYPES_CONFIG_FILE "\"\n");
+#endif
+#ifdef SERVER_CONFIG_FILE
+    printf(" -D SERVER_CONFIG_FILE=\"" SERVER_CONFIG_FILE "\"\n");
+#endif
+#ifdef ACCESS_CONFIG_FILE
+    printf(" -D ACCESS_CONFIG_FILE=\"" ACCESS_CONFIG_FILE "\"\n");
+#endif
+#ifdef RESOURCE_CONFIG_FILE
+    printf(" -D RESOURCE_CONFIG_FILE=\"" RESOURCE_CONFIG_FILE "\"\n");
+#endif
+}
+
+
+/* Some init code that's common between win32 and unix... well actually
+ * some of it is #ifdef'd but was duplicated before anyhow.  This stuff
+ * is still a mess.
+ */
+static void common_init(void)
+{
+    INIT_SIGLIST()
+#ifdef AUX3
+    (void) set42sig();
+#endif
+
+#if defined(WIN32) || defined(NETWARE)
+    /* Initialize the stupid sockets */
+    AMCSocketInitialize();
+#endif /* WIN32 */
+
+    pglobal = ap_init_alloc();
+    pconf = ap_make_sub_pool(pglobal);
+#ifdef AP_ENABLE_EXCEPTION_HOOK
+    ap_register_cleanup(pconf, NULL, except_hook_cleanup, ap_null_cleanup);
+#endif
+    plog = ap_make_sub_pool(pglobal);
+    ptrans = ap_make_sub_pool(pconf);
+
+    ap_util_init();
+    ap_util_uri_init();
+
+    pcommands = ap_make_sub_pool(NULL);
+    ap_server_pre_read_config  = ap_make_array(pcommands, 1, sizeof(char *));
+    ap_server_post_read_config = ap_make_array(pcommands, 1, sizeof(char *));
+    ap_server_config_defines   = ap_make_array(pcommands, 1, sizeof(char *));
+}
+
+#ifndef MULTITHREAD
+/*****************************************************************
+ * Child process main loop.
+ * The following vars are static to avoid getting clobbered by longjmp();
+ * they are really private to child_main.
+ */
+
+static int srv;
+static int csd;
+static int dupped_csd;
+static int requests_this_child;
+static fd_set main_fds;
+
+API_EXPORT(void) ap_child_terminate(request_rec *r)
+{
+    r->connection->keepalive = 0;
+    requests_this_child = ap_max_requests_per_child = 1;
+}
+
+static void child_main(int child_num_arg)
+{
+    NET_SIZE_T clen;
+    struct sockaddr sa_server;
+    struct sockaddr sa_client;
+    listen_rec *lr;
+
+    /* All of initialization is a critical section, we don't care if we're
+     * told to HUP or USR1 before we're done initializing.  For example,
+     * we could be half way through child_init_modules() when a restart
+     * signal arrives, and we'd have no real way to recover gracefully
+     * and exit properly.
+     *
+     * I suppose a module could take forever to initialize, but that would
+     * be either a broken module, or a broken configuration (i.e. network
+     * problems, file locking problems, whatever). -djg
+     */
+    ap_block_alarms();
+
+    my_pid = getpid();
+    csd = -1;
+    dupped_csd = -1;
+    my_child_num = child_num_arg;
+    requests_this_child = 0;
+
+    /* Get a sub pool for global allocations in this child, so that
+     * we can have cleanups occur when the child exits.
+     */
+    pchild = ap_make_sub_pool(pconf);
+    /* associate accept mutex cleanup with a subpool of pchild so we can
+     * make sure the mutex is released before calling module code at
+     * termination
+     */
+    pmutex = ap_make_sub_pool(pchild);
+
+    /* needs to be done before we switch UIDs so we have permissions */
+    reopen_scoreboard(pchild);
+    SAFE_ACCEPT(accept_mutex_child_init(pmutex));
+
+    set_group_privs();
+#ifdef MPE
+    /* No such thing as root on MPE, so try to switch unconditionally */
+    GETPRIVMODE();
+    if (setuid(ap_user_id) == -1) {
+	GETUSERMODE();
+	ap_log_error(APLOG_MARK, APLOG_ALERT, server_conf,
+		    "setuid: unable to change to uid: %d", ap_user_id);
+	exit(1);
+    }
+    GETUSERMODE();
+#else
+    /* 
+     * Only try to switch if we're running as root
+     * In case of Cygwin we have the special super-user named SYSTEM
+     */
+#ifdef CYGWIN
+    if (getuid() == SYSTEM_UID && (
+#else
+    if (!geteuid() && (
+#endif
+#ifdef _OSD_POSIX
+	os_init_job_environment(server_conf, ap_user_name, one_process) != 0 || 
+#endif
+	setuid(ap_user_id) == -1)) {
+	ap_log_error(APLOG_MARK, APLOG_ALERT, server_conf,
+		    "setuid: unable to change to uid: %ld", (long) ap_user_id);
+	clean_child_exit(APEXIT_CHILDFATAL);
+    }
+#endif
+
+#ifdef HAVE_SET_DUMPABLE
+    if (ap_coredump_dir_configured) {
+        /* user set CoredumpDirectory, so they want to get core dumps
+         */
+        if (prctl(PR_SET_DUMPABLE, 1)) {
+            ap_log_error(APLOG_MARK, APLOG_ALERT, NULL,
+                         "set dumpable failed - this child will not coredump"
+                         " after software errors");
+        }
+    }
+#endif
+
+    ap_child_init_modules(pchild, server_conf);
+
+    /* done with the initialization critical section */
+    ap_unblock_alarms();
+
+    (void) ap_update_child_status(my_child_num, SERVER_READY, (request_rec *) NULL);
+
+    /*
+     * Setup the jump buffers so that we can return here after a timeout 
+     */
+    ap_setjmp(jmpbuffer);
+#ifndef OS2
+#ifdef SIGURG
+    signal(SIGURG, timeout);
+#endif
+#endif
+    signal(SIGALRM, alrm_handler);
+#ifdef TPF
+    signal(SIGHUP, just_die);
+    signal(SIGTERM, just_die);
+    signal(SIGUSR1, just_die);
+#endif /* TPF */
+
+#ifdef OS2
+/* Stop Ctrl-C/Ctrl-Break signals going to child processes */
+    {
+        unsigned long ulTimes;
+        DosSetSignalExceptionFocus(0, &ulTimes);
+    }
+#endif
+
+    while (1) {
+	BUFF *conn_io;
+	request_rec *r;
+
+	/* Prepare to receive a SIGUSR1 due to graceful restart so that
+	 * we can exit cleanly.  Since we're between connections right
+	 * now it's the right time to exit, but we might be blocked in a
+	 * system call when the graceful restart request is made. */
+	usr1_just_die = 1;
+	signal(SIGUSR1, usr1_handler);
+
+	/*
+	 * (Re)initialize this child to a pre-connection state.
+	 */
+
+	ap_kill_timeout(0);	/* Cancel any outstanding alarms. */
+	current_conn = NULL;
+
+	ap_clear_pool(ptrans);
+
+	ap_sync_scoreboard_image();
+	if (ap_scoreboard_image->global.running_generation != ap_my_generation) {
+	    clean_child_exit(0);
+	}
+
+#ifndef WIN32
+	if ((ap_max_requests_per_child > 0
+	     && requests_this_child++ >= ap_max_requests_per_child)) {
+	    clean_child_exit(0);
+	}
+#else
+	++requests_this_child;
+#endif
+
+	(void) ap_update_child_status(my_child_num, SERVER_READY, (request_rec *) NULL);
+
+	/*
+	 * Wait for an acceptable connection to arrive.
+	 */
+
+	/* Lock around "accept", if necessary */
+	SAFE_ACCEPT(accept_mutex_on());
+
+	for (;;) {
+	    if (ap_listeners->next != ap_listeners) {
+		/* more than one socket */
+		memcpy(&main_fds, &listenfds, sizeof(fd_set));
+		srv = ap_select(listenmaxfd + 1, &main_fds, NULL, NULL, NULL);
+
+		if (srv < 0 && errno != EINTR) {
+		    /* Single Unix documents select as returning errnos
+		     * EBADF, EINTR, and EINVAL... and in none of those
+		     * cases does it make sense to continue.  In fact
+		     * on Linux 2.0.x we seem to end up with EFAULT
+		     * occasionally, and we'd loop forever due to it.
+		     */
+		    ap_log_error(APLOG_MARK, APLOG_ERR, server_conf, "select: (listen)");
+		    clean_child_exit(1);
+		}
+
+		if (srv <= 0)
+		    continue;
+
+		lr = find_ready_listener(&main_fds);
+		if (lr == NULL)
+		    continue;
+		sd = lr->fd;
+	    }
+	    else {
+		/* only one socket, just pretend we did the other stuff */
+		sd = ap_listeners->fd;
+	    }
+
+	    /* if we accept() something we don't want to die, so we have to
+	     * defer the exit
+	     */
+	    deferred_die = 0;
+	    usr1_just_die = 0;
+	    for (;;) {
+		clen = sizeof(sa_client);
+		csd = ap_accept(sd, &sa_client, &clen);
+		if (csd >= 0 || errno != EINTR)
+		    break;
+		if (deferred_die) {
+		    /* we didn't get a socket, and we were told to die */
+		    clean_child_exit(0);
+		}
+	    }
+
+	    if (csd >= 0)
+		break;		/* We have a socket ready for reading */
+	    else {
+
+		/* Our old behaviour here was to continue after accept()
+		 * errors.  But this leads us into lots of troubles
+		 * because most of the errors are quite fatal.  For
+		 * example, EMFILE can be caused by slow descriptor
+		 * leaks (say in a 3rd party module, or libc).  It's
+		 * foolish for us to continue after an EMFILE.  We also
+		 * seem to tickle kernel bugs on some platforms which
+		 * lead to never-ending loops here.  So it seems best
+		 * to just exit in most cases.
+		 */
+                switch (errno) {
+
+#if defined(HPUX11) && defined(ENOBUFS)
+                    /* On HPUX 11.x, the 'ENOBUFS, No buffer space available'
+                     * error occures because the accept() cannot complete.
+                     * You will not see ENOBUFS at 10.20 because the kernel
+                     * hides any occurrence from being returned from user space.
+                     * ENOBUFS at 11.0 TCP/IP is quite possible, and could
+                     * occur intermittently. As a work-around, we are going to
+                     * ingnore ENOBUFS.
+                     */
+                case ENOBUFS:
+#endif
+
+#ifdef EPROTO
+		    /* EPROTO on certain older kernels really means
+		     * ECONNABORTED, so we need to ignore it for them.
+		     * See discussion in new-httpd archives nh.9701
+		     * search for EPROTO.
+		     *
+		     * Also see nh.9603, search for EPROTO:
+		     * There is potentially a bug in Solaris 2.x x<6,
+		     * and other boxes that implement tcp sockets in
+		     * userland (i.e. on top of STREAMS).  On these
+		     * systems, EPROTO can actually result in a fatal
+		     * loop.  See PR#981 for example.  It's hard to
+		     * handle both uses of EPROTO.
+		     */
+                case EPROTO:
+#endif
+#ifdef ECONNABORTED
+                case ECONNABORTED:
+#endif
+		    /* Linux generates the rest of these, other tcp
+		     * stacks (i.e. bsd) tend to hide them behind
+		     * getsockopt() interfaces.  They occur when
+		     * the net goes sour or the client disconnects
+		     * after the three-way handshake has been done
+		     * in the kernel but before userland has picked
+		     * up the socket.
+		     */
+#ifdef ECONNRESET
+                case ECONNRESET:
+#endif
+#ifdef ETIMEDOUT
+                case ETIMEDOUT:
+#endif
+#ifdef EHOSTUNREACH
+		case EHOSTUNREACH:
+#endif
+#ifdef ENETUNREACH
+		case ENETUNREACH:
+#endif
+                    /* EAGAIN/EWOULDBLOCK can be returned on BSD-derived
+                     * TCP stacks when the connection is aborted before
+                     * we call connect, but only because our listener
+                     * sockets are non-blocking (NONBLOCK_WHEN_MULTI_LISTEN)
+                     */
+#ifdef EAGAIN
+                case EAGAIN:
+#endif
+#ifdef EWOULDBLOCK
+#if !defined(EAGAIN) || EAGAIN != EWOULDBLOCK
+                case EWOULDBLOCK:
+#endif
+#endif
+                    break;
+#ifdef ENETDOWN
+		case ENETDOWN:
+		     /*
+		      * When the network layer has been shut down, there
+		      * is not much use in simply exiting: the parent
+		      * would simply re-create us (and we'd fail again).
+		      * Use the CHILDFATAL code to tear the server down.
+		      * @@@ Martin's idea for possible improvement:
+		      * A different approach would be to define
+		      * a new APEXIT_NETDOWN exit code, the reception
+		      * of which would make the parent shutdown all
+		      * children, then idle-loop until it detected that
+		      * the network is up again, and restart the children.
+		      * Ben Hyde noted that temporary ENETDOWN situations
+		      * occur in mobile IP.
+		      */
+		    ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf,
+			"accept: giving up.");
+		    clean_child_exit(APEXIT_CHILDFATAL);
+#endif /*ENETDOWN*/
+
+#ifdef TPF
+		case EINACT:
+                    ap_log_error(APLOG_MARK, APLOG_ALERT|APLOG_NOERRNO,
+                                 server_conf, "offload device inactive");
+                    clean_child_exit(APEXIT_CHILDFATAL); 
+		    break;
+		default:
+                    if (getppid() != 1) {
+                        ap_log_error(APLOG_MARK, APLOG_ALERT|APLOG_NOERRNO,
+                                     server_conf, "select/accept error (%u)",
+                                     errno);
+                    }
+		    clean_child_exit(APEXIT_CHILDFATAL);
+#else
+		default:
+		    ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
+				"accept: (client socket)");
+		    clean_child_exit(1);
+#endif
+		}
+	    }
+
+	    /* go around again, safe to die */
+	    usr1_just_die = 1;
+	    if (deferred_die) {
+		/* ok maybe not, see ya later */
+		clean_child_exit(0);
+	    }
+	    /* or maybe we missed a signal, you never know on systems
+	     * without reliable signals
+	     */
+	    ap_sync_scoreboard_image();
+	    if (ap_scoreboard_image->global.running_generation != ap_my_generation) {
+		clean_child_exit(0);
+	    }
+	}
+
+	SAFE_ACCEPT(accept_mutex_off());	/* unlock after "accept" */
+
+#ifdef TPF
+	if (csd == 0)                       /* 0 is invalid socket for TPF */
+	    continue;
+#endif
+
+	/* We've got a socket, let's at least process one request off the
+	 * socket before we accept a graceful restart request.
+	 */
+	signal(SIGUSR1, SIG_IGN);
+
+	ap_note_cleanups_for_socket_ex(ptrans, csd, 1);
+
+	/* protect various fd_sets */
+#ifdef CHECK_FD_SETSIZE
+	if (csd >= FD_SETSIZE) {
+	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, NULL,
+		"[csd] filedescriptor (%u) larger than FD_SETSIZE (%u) "
+		"found, you probably need to rebuild Apache with a "
+		"larger FD_SETSIZE", csd, FD_SETSIZE);
+	    continue;
+	}
+#endif
+
+	/*
+	 * We now have a connection, so set it up with the appropriate
+	 * socket options, file descriptors, and read/write buffers.
+	 */
+
+#ifdef NONBLOCK_WHEN_MULTI_LISTEN
+        /* This assumes that on this platform the non-blocking setting of
+         * a listening socket is inherited.  If that isn't the case,
+         * this is wasted effort.
+         */
+        if (ap_listeners != ap_listeners->next) {
+            if (soblock(csd) != 0) {
+                ap_log_error(APLOG_MARK, APLOG_CRIT, NULL,
+                             "couldn't make socket descriptor (%d) blocking again",
+                             csd);
+                continue;
+            }
+        }
+#endif /* NONBLOCK_WHEN_MULTI_LISTEN */
+
+	clen = sizeof(sa_server);
+	if (getsockname(csd, &sa_server, &clen) < 0) {
+	    ap_log_error(APLOG_MARK, APLOG_DEBUG, server_conf, 
+                         "getsockname, client %pA probably dropped the "
+                         "connection", 
+                         &((struct sockaddr_in *)&sa_client)->sin_addr);
+	    continue;
+	}
+
+	sock_disable_nagle(csd, (struct sockaddr_in *)&sa_client);
+
+	(void) ap_update_child_status(my_child_num, SERVER_BUSY_READ,
+				   (request_rec *) NULL);
+
+	conn_io = ap_bcreate(ptrans, B_RDWR | B_SOCKET);
+
+#ifdef B_SFIO
+	(void) sfdisc(conn_io->sf_in, SF_POPDISC);
+	sfdisc(conn_io->sf_in, bsfio_new(conn_io->pool, conn_io));
+	sfsetbuf(conn_io->sf_in, NULL, 0);
+
+	(void) sfdisc(conn_io->sf_out, SF_POPDISC);
+	sfdisc(conn_io->sf_out, bsfio_new(conn_io->pool, conn_io));
+	sfsetbuf(conn_io->sf_out, NULL, 0);
+#endif
+
+	dupped_csd = csd;
+#if defined(NEED_DUPPED_CSD)
+	if ((dupped_csd = dup(csd)) < 0) {
+	    ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
+			"dup: couldn't duplicate csd");
+	    dupped_csd = csd;	/* Oh well... */
+	}
+	ap_note_cleanups_for_socket_ex(ptrans, dupped_csd, 1);
+
+	/* protect various fd_sets */
+#ifdef CHECK_FD_SETSIZE
+	if (dupped_csd >= FD_SETSIZE) {
+	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, NULL,
+		"[dupped_csd] filedescriptor (%u) larger than FD_SETSIZE (%u) "
+		"found, you probably need to rebuild Apache with a "
+		"larger FD_SETSIZE", dupped_csd, FD_SETSIZE);
+	    continue;
+	}
+#endif
+#endif
+	ap_bpushfd(conn_io, csd, dupped_csd);
+
+	current_conn = new_connection(ptrans, server_conf, conn_io,
+				          (struct sockaddr_in *) &sa_client,
+				          (struct sockaddr_in *) &sa_server,
+				          my_child_num);
+
+	/*
+	 * Read and process each request found on our connection
+	 * until no requests are left or we decide to close.
+	 */
+
+	while ((r = ap_read_request(current_conn)) != NULL) {
+
+	    /* read_request_line has already done a
+	     * signal (SIGUSR1, SIG_IGN);
+	     */
+
+	    (void) ap_update_child_status(my_child_num, SERVER_BUSY_WRITE, r);
+
+	    /* process the request if it was read without error */
+
+	    if (r->status == HTTP_OK)
+		ap_process_request(r);
+
+	    if(ap_extended_status)
+		increment_counts(my_child_num, r);
+
+#ifdef TPF_HAVE_NSD
+            /* Update the TPF Network Services Database message counters */
+            tpf_tcpip_message_cnt(NSDB_INPUT_CNT,
+                ((struct sockaddr_in *)&sa_server)->sin_port,
+                NSDB_TCP_S, 1);
+
+            tpf_tcpip_message_cnt(NSDB_OUTPUT_CNT,
+                ((struct sockaddr_in *)&sa_server)->sin_port,
+                NSDB_TCP_S, 1);
+#endif /* TPF_HAVE_NSD */
+
+	    if (!current_conn->keepalive || current_conn->aborted)
+		break;
+
+	    ap_destroy_pool(r->pool);
+	    (void) ap_update_child_status(my_child_num, SERVER_BUSY_KEEPALIVE,
+				       (request_rec *) NULL);
+
+	    ap_sync_scoreboard_image();
+	    if (ap_scoreboard_image->global.running_generation != ap_my_generation) {
+		ap_bclose(conn_io);
+		clean_child_exit(0);
+	    }
+
+	    /* In case we get a graceful restart while we're blocked
+	     * waiting for the request.
+	     *
+	     * XXX: This isn't perfect, we might actually read the
+	     * request and then just die without saying anything to
+	     * the client.  This can be fixed by using deferred_die
+	     * but you have to teach buff.c about it so that it can handle
+	     * the EINTR properly.
+	     *
+	     * In practice though browsers (have to) expect keepalive
+	     * connections to close before receiving a response because
+	     * of network latencies and server timeouts.
+	     */
+	    usr1_just_die = 1;
+	    signal(SIGUSR1, usr1_handler);
+	}
+
+	/*
+	 * Close the connection, being careful to send out whatever is still
+	 * in our buffers.  If possible, try to avoid a hard close until the
+	 * client has ACKed our FIN and/or has stopped sending us data.
+	 */
+
+#ifdef NO_LINGCLOSE
+	ap_bclose(conn_io);	/* just close it */
+#else
+	if (r && r->connection
+	    && !r->connection->aborted
+	    && r->connection->client
+	    && (r->connection->client->fd >= 0)) {
+
+	    lingering_close(r);
+	}
+	else {
+	    ap_bsetflag(conn_io, B_EOUT, 1);
+	    ap_bclose(conn_io);
+	}
+#endif
+    }
+}
+
+#ifdef TPF
+static void reset_tpf_listeners(APACHE_TPF_INPUT *input_parms)
+{
+    int count;
+    listen_rec *lr;
+
+    count = 0;
+    listenmaxfd = -1;
+    FD_ZERO(&listenfds);
+    lr = ap_listeners;
+
+    for(;;) {
+        lr->fd = input_parms->listeners[count];
+        if(lr->fd >= 0) {
+            FD_SET(lr->fd, &listenfds);
+            if(lr->fd > listenmaxfd)
+                listenmaxfd = lr->fd;
+        }
+        if(lr->next == NULL)
+            break;
+        lr = lr->next;
+        count++;
+    }
+    lr->next = ap_listeners;
+    head_listener = ap_listeners;
+    close_unused_listeners();
+}
+
+#endif /* TPF */
+
+static int make_child(server_rec *s, int slot, time_t now)
+{
+    int pid;
+
+    if (slot + 1 > max_daemons_limit) {
+	max_daemons_limit = slot + 1;
+    }
+
+    if (one_process) {
+	signal(SIGHUP, just_die);
+	signal(SIGINT, just_die);
+#ifdef SIGQUIT
+	signal(SIGQUIT, SIG_DFL);
+#endif
+	signal(SIGTERM, just_die);
+	child_main(slot);
+    }
+
+    /* avoid starvation */
+    head_listener = head_listener->next;
+
+    Explain1("Starting new child in slot %d", slot);
+    (void) ap_update_child_status(slot, SERVER_STARTING, (request_rec *) NULL);
+
+
+#ifdef _OSD_POSIX
+    /* BS2000 requires a "special" version of fork() before a setuid() call */
+    if ((pid = os_fork(ap_user_name)) == -1) {
+#elif defined(TPF)
+    if ((pid = os_fork(s, slot)) == -1) {
+#else
+    if ((pid = fork()) == -1) {
+#endif
+	ap_log_error(APLOG_MARK, APLOG_ERR, s, "fork: Unable to fork new process");
+
+	/* fork didn't succeed. Fix the scoreboard or else
+	 * it will say SERVER_STARTING forever and ever
+	 */
+	(void) ap_update_child_status(slot, SERVER_DEAD, (request_rec *) NULL);
+
+	/* In case system resources are maxxed out, we don't want
+	   Apache running away with the CPU trying to fork over and
+	   over and over again. */
+	sleep(10);
+
+	return -1;
+    }
+
+    if (!pid) {
+#ifdef AIX_BIND_PROCESSOR
+/* by default AIX binds to a single processor
+ * this bit unbinds children which will then bind to another cpu
+ */
+#include <sys/processor.h>
+	int status = bindprocessor(BINDPROCESS, (int)getpid(), 
+				   PROCESSOR_CLASS_ANY);
+	if (status != OK) {
+	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, server_conf,
+			"processor unbind failed %d", status);
+	}
+#endif
+	RAISE_SIGSTOP(MAKE_CHILD);
+	MONCONTROL(1);
+	/* Disable the restart signal handlers and enable the just_die stuff.
+	 * Note that since restart() just notes that a restart has been
+	 * requested there's no race condition here.
+	 */
+	signal(SIGHUP, just_die);
+	signal(SIGUSR1, just_die);
+	signal(SIGTERM, just_die);
+	child_main(slot);
+    }
+
+#ifdef OPTIMIZE_TIMEOUTS
+    ap_scoreboard_image->parent[slot].last_rtime = now;
+#endif
+    ap_scoreboard_image->parent[slot].pid = pid;
+#ifdef SCOREBOARD_FILE
+    lseek(scoreboard_fd, XtOffsetOf(scoreboard, parent[slot]), 0);
+    force_write(scoreboard_fd, &ap_scoreboard_image->parent[slot],
+		sizeof(parent_score));
+#endif
+
+    return 0;
+}
+
+
+/* start up a bunch of children */
+static void startup_children(int number_to_start)
+{
+    int i;
+    time_t now = time(NULL);
+
+    for (i = 0; number_to_start && i < ap_daemons_limit; ++i) {
+	if (ap_scoreboard_image->servers[i].status != SERVER_DEAD) {
+	    continue;
+	}
+	if (make_child(server_conf, i, now) < 0) {
+	    break;
+	}
+	--number_to_start;
+    }
+}
+
+
+/*
+ * idle_spawn_rate is the number of children that will be spawned on the
+ * next maintenance cycle if there aren't enough idle servers.  It is
+ * doubled up to MAX_SPAWN_RATE, and reset only when a cycle goes by
+ * without the need to spawn.
+ */
+static int idle_spawn_rate = 1;
+#ifndef MAX_SPAWN_RATE
+#define MAX_SPAWN_RATE	(32)
+#endif
+static int hold_off_on_exponential_spawning;
+
+/*
+ * Define the signal that is used to kill off children if idle_count
+ * is greater then ap_daemons_max_free. Usually we will use SIGUSR1
+ * to gracefully shutdown, but unfortunatly some OS will need other 
+ * signals to ensure that the child process is terminated and the 
+ * scoreboard pool is not growing to infinity. Also set the signal we
+ * use to kill of childs that exceed timeout. This effect has been
+* seen at least on Cygwin 1.x. -- Stipe Tolj <tolj@wapme-systems.de>
+ */
+#if defined(CYGWIN)
+#define SIG_IDLE_KILL SIGKILL
+#define SIG_TIMEOUT_KILL SIGUSR2
+#else
+#define SIG_IDLE_KILL SIGUSR1
+#define SIG_TIMEOUT_KILL SIGALRM
+#endif
+
+static void perform_idle_server_maintenance(void)
+{
+    int i;
+    int to_kill;
+    int idle_count;
+    short_score *ss;
+    time_t now = time(NULL);
+    int free_length;
+    int free_slots[MAX_SPAWN_RATE];
+    int last_non_dead;
+    int total_non_dead;
+
+    /* initialize the free_list */
+    free_length = 0;
+
+    to_kill = -1;
+    idle_count = 0;
+    last_non_dead = -1;
+    total_non_dead = 0;
+
+    ap_sync_scoreboard_image();
+    for (i = 0; i < ap_daemons_limit; ++i) {
+	int status;
+
+	if (i >= max_daemons_limit && free_length == idle_spawn_rate)
+	    break;
+	ss = &ap_scoreboard_image->servers[i];
+	status = ss->status;
+	if (status == SERVER_DEAD) {
+	    /* try to keep children numbers as low as possible */
+	    if (free_length < idle_spawn_rate) {
+		free_slots[free_length] = i;
+		++free_length;
+	    }
+	}
+	else {
+	    /* We consider a starting server as idle because we started it
+	     * at least a cycle ago, and if it still hasn't finished starting
+	     * then we're just going to swamp things worse by forking more.
+	     * So we hopefully won't need to fork more if we count it.
+	     * This depends on the ordering of SERVER_READY and SERVER_STARTING.
+	     */
+	    if (status <= SERVER_READY) {
+		++ idle_count;
+		/* always kill the highest numbered child if we have to...
+		 * no really well thought out reason ... other than observing
+		 * the server behaviour under linux where lower numbered children
+		 * tend to service more hits (and hence are more likely to have
+		 * their data in cpu caches).
+		 */
+		to_kill = i;
+	    }
+
+	    ++total_non_dead;
+	    last_non_dead = i;
+#ifdef OPTIMIZE_TIMEOUTS
+	    if (ss->timeout_len) {
+		/* if it's a live server, with a live timeout then
+		 * start checking its timeout */
+		parent_score *ps = &ap_scoreboard_image->parent[i];
+		if (ss->cur_vtime != ps->last_vtime) {
+		    /* it has made progress, so update its last_rtime,
+		     * last_vtime */
+		    ps->last_rtime = now;
+		    ps->last_vtime = ss->cur_vtime;
+		}
+		else if (ps->last_rtime + ss->timeout_len < now) {
+		    /* no progress, and the timeout length has been exceeded */
+		    ss->timeout_len = 0;
+		    kill(ps->pid, SIG_TIMEOUT_KILL);
+		}
+	    }
+#endif
+	}
+    }
+    max_daemons_limit = last_non_dead + 1;
+    if (idle_count > ap_daemons_max_free) {
+	/* kill off one child... we use SIGUSR1 because that'll cause it to
+	 * shut down gracefully, in case it happened to pick up a request
+	 * while we were counting. Use the define SIG_IDLE_KILL to reflect
+	 * which signal should be used on the specific OS.
+	 */
+	kill(ap_scoreboard_image->parent[to_kill].pid, SIG_IDLE_KILL);
+	idle_spawn_rate = 1;
+#ifdef TPF
+        ap_update_child_status(to_kill, SERVER_DEAD, (request_rec *)NULL);
+#endif
+    }
+    else if (idle_count < ap_daemons_min_free) {
+	/* terminate the free list */
+	if (free_length == 0) {
+	    /* only report this condition once */
+	    static int reported = 0;
+
+	    if (!reported) {
+		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, server_conf,
+			    "server reached MaxClients setting, consider"
+			    " raising the MaxClients setting");
+		reported = 1;
+	    }
+	    idle_spawn_rate = 1;
+	}
+	else {
+	    if (idle_spawn_rate >= 8) {
+		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, server_conf,
+		    "server seems busy, (you may need "
+		    "to increase StartServers, or Min/MaxSpareServers), "
+		    "spawning %d children, there are %d idle, and "
+		    "%d total children", idle_spawn_rate,
+		    idle_count, total_non_dead);
+	    }
+	    for (i = 0; i < free_length; ++i) {
+#ifdef TPF
+        if(make_child(server_conf, free_slots[i], now) == -1) {
+            if(free_length == 1) {
+                shutdown_pending = 1;
+                ap_log_error(APLOG_MARK, APLOG_EMERG, server_conf,
+                "No active child processes: shutting down");
+            }
+        }
+#else
+		make_child(server_conf, free_slots[i], now);
+#endif /* TPF */
+	    }
+	    /* the next time around we want to spawn twice as many if this
+	     * wasn't good enough, but not if we've just done a graceful
+	     */
+	    if (hold_off_on_exponential_spawning) {
+		--hold_off_on_exponential_spawning;
+	    }
+	    else if (idle_spawn_rate < MAX_SPAWN_RATE) {
+		idle_spawn_rate *= 2;
+	    }
+	}
+    }
+    else {
+	idle_spawn_rate = 1;
+    }
+}
+
+
+static void process_child_status(int pid, ap_wait_t status)
+{
+    /* Child died... if it died due to a fatal error,
+	* we should simply bail out.
+	*/
+    if ((WIFEXITED(status)) &&
+	WEXITSTATUS(status) == APEXIT_CHILDFATAL) {
+        /* cleanup pid file -- it is useless after our exiting */
+        const char *pidfile = NULL;
+#ifdef TPF
+        /* safer on TPF to go through normal shutdown process */
+	if (!shutdown_pending) {
+		ap_log_error(APLOG_MARK, APLOG_ALERT|APLOG_NOERRNO, server_conf,
+			"Child %d returned a Fatal error... \n"
+			"Apache is shutting down!", pid);
+		shutdown_pending = 1;
+	}
+        return;
+#endif
+        pidfile = ap_server_root_relative (pconf, ap_pid_fname);
+        if ( pidfile != NULL && unlink(pidfile) == 0)
+            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO,
+                         server_conf,
+                         "removed PID file %s (pid=%ld)",
+                         pidfile, (long)getpid());
+	ap_log_error(APLOG_MARK, APLOG_ALERT|APLOG_NOERRNO, server_conf,
+			"Child %d returned a Fatal error... \n"
+			"Apache is exiting!",
+			pid);
+	exit(APEXIT_CHILDFATAL);
+    }
+    if (WIFSIGNALED(status)) {
+	switch (WTERMSIG(status)) {
+	case SIGTERM:
+	case SIGHUP:
+	case SIGUSR1:
+	case SIGKILL:
+	    break;
+	default:
+#ifdef SYS_SIGLIST
+#ifdef WCOREDUMP
+	    if (WCOREDUMP(status)) {
+		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE,
+			     server_conf,
+			     "child pid %d exit signal %s (%d), "
+			     "possible coredump in %s",
+			     pid, (WTERMSIG(status) >= NumSIG) ? "" : 
+			     SYS_SIGLIST[WTERMSIG(status)], WTERMSIG(status),
+			     ap_coredump_dir);
+	    }
+	    else {
+#endif
+		ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE,
+			     server_conf,
+			     "child pid %d exit signal %s (%d)", pid,
+			     SYS_SIGLIST[WTERMSIG(status)], WTERMSIG(status));
+#ifdef WCOREDUMP
+	    }
+#endif
+#else
+	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE,
+			 server_conf,
+			 "child pid %d exit signal %d",
+			 pid, WTERMSIG(status));
+#endif
+	}
+    }
+}
+
+
+/*****************************************************************
+ * Executive routines.
+ */
+
+#ifndef STANDALONE_MAIN
+#define STANDALONE_MAIN standalone_main
+
+static void standalone_main(int argc, char **argv)
+{
+    int remaining_children_to_start;
+
+#ifdef OS2
+    printf("%s \n", ap_get_server_version());
+#endif
+
+    ap_standalone = 1;
+
+    is_graceful = 0;
+
+    if (!one_process) {
+	detach();
+    }
+    else {
+	MONCONTROL(1);
+    }
+
+    my_pid = getpid();
+
+    do {
+	copy_listeners(pconf);
+	if (!is_graceful) {
+	    ap_restart_time = time(NULL);
+	}
+#ifdef SCOREBOARD_FILE
+	else if (scoreboard_fd != -1) {
+	    ap_kill_cleanup(pconf, NULL, cleanup_scoreboard_file);
+	    ap_kill_cleanups_for_fd(pconf, scoreboard_fd);
+	}
+#endif
+	ap_clear_pool(pconf);
+#ifdef AP_ENABLE_EXCEPTION_HOOK
+        ap_register_cleanup(pconf, NULL, except_hook_cleanup, ap_null_cleanup);
+#endif
+	ptrans = ap_make_sub_pool(pconf);
+
+	ap_init_mutex_method(ap_default_mutex_method());
+
+	server_conf = ap_read_config(pconf, ptrans, ap_server_confname);
+	setup_listeners(pconf);
+	ap_clear_pool(plog);
+	ap_open_logs(server_conf, plog);
+	ap_log_pid(pconf, ap_pid_fname);
+	ap_set_version();	/* create our server_version string */
+	ap_init_modules(pconf, server_conf);
+	version_locked++;	/* no more changes to server_version */
+	SAFE_ACCEPT(accept_mutex_init(pconf));
+	if (!is_graceful) {
+	    reinit_scoreboard(pconf);
+	}
+#ifdef SCOREBOARD_FILE
+	else {
+	    ap_scoreboard_fname = ap_server_root_relative(pconf, ap_scoreboard_fname);
+	    ap_note_cleanups_for_fd_ex(pconf, scoreboard_fd, 1); /* close on exec */
+	}
+#endif
+
+	set_signals();
+
+	if (ap_daemons_max_free < ap_daemons_min_free + 1)	/* Don't thrash... */
+	    ap_daemons_max_free = ap_daemons_min_free + 1;
+
+	/* If we're doing a graceful_restart then we're going to see a lot
+	 * of children exiting immediately when we get into the main loop
+	 * below (because we just sent them SIGUSR1).  This happens pretty
+	 * rapidly... and for each one that exits we'll start a new one until
+	 * we reach at least daemons_min_free.  But we may be permitted to
+	 * start more than that, so we'll just keep track of how many we're
+	 * supposed to start up without the 1 second penalty between each fork.
+	 */
+	remaining_children_to_start = ap_daemons_to_start;
+	if (remaining_children_to_start > ap_daemons_limit) {
+	    remaining_children_to_start = ap_daemons_limit;
+	}
+	if (!is_graceful) {
+	    startup_children(remaining_children_to_start);
+	    remaining_children_to_start = 0;
+	}
+	else {
+	    /* give the system some time to recover before kicking into
+	     * exponential mode */
+	    hold_off_on_exponential_spawning = 10;
+	}
+
+	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, server_conf,
+		    "%s configured -- resuming normal operations",
+		    ap_get_server_version());
+	if (ap_suexec_enabled) {
+	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, server_conf,
+		         "suEXEC mechanism enabled (wrapper: %s)", SUEXEC_BIN);
+	}
+	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, server_conf,
+		    "Server built: %s", ap_get_server_built());
+	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, server_conf,
+		    "Accept mutex: %s (Default: %s)",
+		     amutex->name, ap_default_mutex_method());
+	restart_pending = shutdown_pending = 0;
+
+	while (!restart_pending && !shutdown_pending) {
+	    int child_slot;
+	    ap_wait_t status;
+	    int pid = wait_or_timeout(&status);
+
+	    /* XXX: if it takes longer than 1 second for all our children
+	     * to start up and get into IDLE state then we may spawn an
+	     * extra child
+	     */
+#ifdef TPF
+            if (shutdown_pending += os_check_server(tpf_server_name)) {
+                break;
+            }
+#endif
+	    if (pid >= 0) {
+		process_child_status(pid, status);
+		/* non-fatal death... note that it's gone in the scoreboard. */
+		ap_sync_scoreboard_image();
+		child_slot = find_child_by_pid(pid);
+		Explain2("Reaping child %d slot %d", pid, child_slot);
+		if (child_slot >= 0) {
+		    (void) ap_update_child_status(child_slot, SERVER_DEAD,
+					       (request_rec *) NULL);
+		    if (remaining_children_to_start
+			&& child_slot < ap_daemons_limit) {
+			/* we're still doing a 1-for-1 replacement of dead
+			 * children with new children
+			 */
+			make_child(server_conf, child_slot, time(NULL));
+			--remaining_children_to_start;
+		    }
+#ifndef NO_OTHER_CHILD
+		}
+		else if (reap_other_child(pid, status) == 0) {
+		    /* handled */
+#endif
+		}
+		else if (is_graceful) {
+		    /* Great, we've probably just lost a slot in the
+		     * scoreboard.  Somehow we don't know about this
+		     * child.
+		     */
+		    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, server_conf,
+				"long lost child came home! (pid %d)", pid);
+		}
+		/* Don't perform idle maintenance when a child dies,
+		 * only do it when there's a timeout.  Remember only a
+		 * finite number of children can die, and it's pretty
+		 * pathological for a lot to die suddenly.
+		 */
+		continue;
+	    }
+	    else if (remaining_children_to_start) {
+		/* we hit a 1 second timeout in which none of the previous
+		 * generation of children needed to be reaped... so assume
+		 * they're all done, and pick up the slack if any is left.
+		 */
+		startup_children(remaining_children_to_start);
+		remaining_children_to_start = 0;
+		/* In any event we really shouldn't do the code below because
+		 * few of the servers we just started are in the IDLE state
+		 * yet, so we'd mistakenly create an extra server.
+		 */
+		continue;
+	    }
+
+	    perform_idle_server_maintenance();
+	}
+
+	if (shutdown_pending) {
+	    /* Time to gracefully shut down:
+	     * Kill child processes, tell them to call child_exit, etc...
+	     */
+	    if (ap_killpg(pgrp, SIGTERM) < 0) {
+		ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "killpg SIGTERM");
+	    }
+	    reclaim_child_processes(1);		/* Start with SIGTERM */
+
+	    /* cleanup pid file on normal shutdown */
+	    {
+		const char *pidfile = NULL;
+		pidfile = ap_server_root_relative (pconf, ap_pid_fname);
+		if ( pidfile != NULL && unlink(pidfile) == 0)
+		    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO,
+				 server_conf,
+				 "removed PID file %s (pid=%ld)",
+				 pidfile, (long)getpid());
+	    }
+
+	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, server_conf,
+			"caught SIGTERM, shutting down");
+	    clean_parent_exit(0);
+	}
+
+	/* we've been told to restart */
+	signal(SIGHUP, SIG_IGN);
+	signal(SIGUSR1, SIG_IGN);
+
+	if (one_process) {
+	    /* not worth thinking about */
+	    clean_parent_exit(0);
+	}
+
+	/* advance to the next generation */
+	/* XXX: we really need to make sure this new generation number isn't in
+	 * use by any of the children.
+	 */
+	++ap_my_generation;
+	ap_scoreboard_image->global.running_generation = ap_my_generation;
+	update_scoreboard_global();
+
+	if (is_graceful) {
+#ifndef SCOREBOARD_FILE
+	    int i;
+#endif
+	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, server_conf,
+			"SIGUSR1 received.  Doing graceful restart");
+
+	    /* kill off the idle ones */
+	    if (ap_killpg(pgrp, SIGUSR1) < 0) {
+		ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "killpg SIGUSR1");
+	    }
+#ifndef SCOREBOARD_FILE
+	    /* This is mostly for debugging... so that we know what is still
+	     * gracefully dealing with existing request.  But we can't really
+	     * do it if we're in a SCOREBOARD_FILE because it'll cause
+	     * corruption too easily.
+	     */
+	    ap_sync_scoreboard_image();
+	    for (i = 0; i < ap_daemons_limit; ++i) {
+		if (ap_scoreboard_image->servers[i].status != SERVER_DEAD) {
+		    ap_scoreboard_image->servers[i].status = SERVER_GRACEFUL;
+		}
+	    }
+#endif
+	}
+	else {
+	    /* Kill 'em off */
+	    if (ap_killpg(pgrp, SIGHUP) < 0) {
+		ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "killpg SIGHUP");
+	    }
+	    reclaim_child_processes(0);		/* Not when just starting up */
+	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_NOTICE, server_conf,
+			"SIGHUP received.  Attempting to restart");
+	}
+    } while (restart_pending);
+
+    /*add_common_vars(NULL);*/
+}				/* standalone_main */
+#else
+/* prototype */
+void STANDALONE_MAIN(int argc, char **argv);
+#endif /* STANDALONE_MAIN */
+
+extern char *optarg;
+extern int optind;
+
+/* Cygwin 1.x SHARED_CORE support needs REALMAIN to be declared as dllexport,
+ * so we can later while SHARED_CORE_BOOTSTRAP is compiled and linked see the 
+ * dllimport for it. -- Stipe Tolj <tolj@wapme-systems.de>
+ */
+
+#if defined(CYGWIN)
+__declspec(dllexport)  
+#endif
+
+int REALMAIN(int argc, char *argv[])
+{
+    int c;
+    int sock_in;
+    int sock_out;
+    char *s;
+    
+#ifdef SecureWare
+    if (set_auth_parameters(argc, argv) < 0)
+	perror("set_auth_parameters");
+    if (getluid() < 0)
+	if (setluid(getuid()) < 0)
+	    perror("setluid");
+    if (setreuid(0, 0) < 0)
+	perror("setreuid");
+#endif
+
+#ifdef SOCKS
+    SOCKSinit(argv[0]);
+#endif
+
+#ifdef TPF
+    EBW_AREA input_parms;
+    ecbptr()->ebrout = PRIMECRAS;
+    input_parms = * (EBW_AREA *)(&(ecbptr()->ebw000));
+#endif
+
+    MONCONTROL(0);
+
+    common_init();
+    
+    if ((s = strrchr(argv[0], PATHSEPARATOR)) != NULL) {
+	ap_server_argv0 = ++s;
+    }
+    else {
+	ap_server_argv0 = argv[0];
+    }
+    
+    ap_cpystrn(ap_server_root, HTTPD_ROOT, sizeof(ap_server_root));
+    ap_cpystrn(ap_server_confname, SERVER_CONFIG_FILE, sizeof(ap_server_confname));
+
+    ap_setup_prelinked_modules();
+
+    while ((c = getopt(argc, argv,
+				    "D:C:c:xXd:Ff:vVlLR:StTh"
+#ifdef DEBUG_SIGSTOP
+				    "Z:"
+#endif
+			)) != -1) {
+	char **new;
+	switch (c) {
+	case 'c':
+	    new = (char **)ap_push_array(ap_server_post_read_config);
+	    *new = ap_pstrdup(pcommands, optarg);
+	    break;
+	case 'C':
+	    new = (char **)ap_push_array(ap_server_pre_read_config);
+	    *new = ap_pstrdup(pcommands, optarg);
+	    break;
+	case 'D':
+	    new = (char **)ap_push_array(ap_server_config_defines);
+	    *new = ap_pstrdup(pcommands, optarg);
+	    break;
+	case 'd':
+	    ap_cpystrn(ap_server_root, optarg, sizeof(ap_server_root));
+	    break;
+	case 'F':
+	    do_detach = 0;
+	    break;
+	case 'f':
+	    ap_cpystrn(ap_server_confname, optarg, sizeof(ap_server_confname));
+	    break;
+	case 'v':
+	    ap_set_version();
+	    printf("Server version: %s\n", ap_get_server_version());
+	    printf("Server built:   %s\n", ap_get_server_built());
+	    exit(0);
+	case 'V':
+	    ap_set_version();
+	    show_compile_settings();
+	    exit(0);
+	case 'l':
+	    ap_suexec_enabled = init_suexec();
+	    ap_show_modules();
+	    exit(0);
+	case 'L':
+	    ap_show_directives();
+	    exit(0);
+	case 'X':
+	    ++one_process;	/* Weird debugging mode. */
+	    break;
+#ifdef TPF
+	case 'x':
+	    os_tpf_child(&input_parms.child);
+	    set_signals();
+	    break;
+#endif
+#ifdef DEBUG_SIGSTOP
+	case 'Z':
+	    raise_sigstop_flags = atoi(optarg);
+	    break;
+#endif
+#ifdef SHARED_CORE
+	case 'R':
+	    /* just ignore this option here, because it has only
+	     * effect when SHARED_CORE is used and then it was
+	     * already handled in the Shared Core Bootstrap
+	     * program.
+	     */
+	    break;
+#endif
+	case 'S':
+	    ap_dump_settings = 1;
+	    break;
+	case 't':
+	    ap_configtestonly = 1;
+	    ap_docrootcheck = 1;
+	    break;
+	case 'T':
+	    ap_configtestonly = 1;
+	    ap_docrootcheck = 0;
+	    break;
+	case 'h':
+	    usage(argv[0]);
+	case '?':
+	    usage(argv[0]);
+	}
+    }
+
+    ap_suexec_enabled = init_suexec();
+    server_conf = ap_read_config(pconf, ptrans, ap_server_confname);
+
+    if (ap_configtestonly) {
+        fprintf(stderr, "Syntax OK\n");
+        exit(0);
+    }
+    if (ap_dump_settings) {
+        exit(0);
+    }
+
+    child_timeouts = !ap_standalone || one_process;
+
+#ifdef BEOS
+    /* make sure we're running in single_process mode - Yuck! */
+    one_process = 1;
+#endif
+
+#ifndef TPF
+    if (ap_standalone) {
+	ap_open_logs(server_conf, plog);
+	ap_set_version();
+	ap_init_modules(pconf, server_conf);
+	version_locked++;
+	STANDALONE_MAIN(argc, argv);
+    }
+#else
+    if (!tpf_child) {
+        memcpy(tpf_server_name, input_parms.parent.servname,
+               INETD_SERVNAME_LENGTH);
+        tpf_server_name[INETD_SERVNAME_LENGTH + 1] = '\0';
+        sprintf(tpf_mutex_key, "%.*x", (int) TPF_MUTEX_KEY_SIZE - 1, getpid());
+        tpf_parent_pid = getppid();
+        ap_open_logs(server_conf, plog);
+        ap_tpf_zinet_checks(ap_standalone, tpf_server_name, server_conf);
+        ap_tpf_save_argv(argc, argv);    /* save argv parms for children */
+    }
+    if (ap_standalone) {
+        ap_set_version();
+        ap_init_modules(pconf, server_conf);
+        version_locked++;
+        if(tpf_child) {
+           server_conf->error_log = stderr;
+#ifdef HAVE_SYSLOG
+            /* if ErrorLog is syslog call ap_open_logs from the child since
+               syslog isn't redirected to stderr by the Apache parent */
+            if (strncasecmp(server_conf->error_fname, "syslog", 6) == 0) {
+               ap_open_logs(server_conf, plog);
+            }
+#endif /* HAVE_SYSLOG */
+            copy_listeners(pconf);
+            reset_tpf_listeners(&input_parms.child);
+#ifdef SCOREBOARD_FILE
+            ap_scoreboard_image = &_scoreboard_image;
+#else /* must be USE_SHMGET_SCOREBOARD */
+            ap_scoreboard_image =
+                (scoreboard *)input_parms.child.scoreboard_heap;
+#endif
+            ap_init_mutex_method(ap_default_mutex_method());
+            child_main(input_parms.child.slot);
+        }
+        else
+            STANDALONE_MAIN(argc, argv);
+    }
+#endif
+    else {
+	conn_rec *conn;
+	request_rec *r;
+	struct sockaddr sa_server, sa_client;
+	BUFF *cio;
+	NET_SIZE_T l;
+
+	ap_set_version();
+	/* Yes this is called twice. */
+	ap_init_modules(pconf, server_conf);
+	version_locked++;
+	ap_open_logs(server_conf, plog);
+	ap_init_modules(pconf, server_conf);
+	set_group_privs();
+
+#ifdef MPE
+	/* No such thing as root on MPE, so try to switch unconditionally */
+	GETPRIVMODE();
+	if (setuid(ap_user_id) == -1) {
+	    GETUSERMODE();
+	    ap_log_error(APLOG_MARK, APLOG_ALERT, server_conf,
+			"setuid: unable to change to uid: %d", ap_user_id);
+	    exit(1);
+	}
+	GETUSERMODE();
+#else
+    /* 
+     * Only try to switch if we're running as root
+     * In case of Cygwin we have the special super-user named SYSTEM
+     * with a pre-defined uid.
+     */
+#ifdef CYGWIN
+    if ((getuid() == SYSTEM_UID) && setuid(ap_user_id) == -1) {
+#else
+	if (!geteuid() && setuid(ap_user_id) == -1) {
+#endif
+	    ap_log_error(APLOG_MARK, APLOG_ALERT, server_conf,
+			"setuid: unable to change to uid: %ld",
+			(long) ap_user_id);
+	    exit(1);
+	}
+#endif
+	if (ap_setjmp(jmpbuffer)) {
+	    exit(0);
+	}
+
+#ifdef MPE
+/* HP MPE 5.5 inetd only passes the incoming socket as stdin (fd 0), whereas
+   HPUX inetd passes the incoming socket as stdin (fd 0) and stdout (fd 1).
+   Go figure.  SR 5003355016 has been submitted to request that the existing
+   functionality be documented, and then to enhance the functionality to be
+   like HPUX. */
+    sock_in = fileno(stdin);
+    sock_out = fileno(stdin);
+#else
+    sock_in = fileno(stdin);
+    sock_out = fileno(stdout);
+#endif
+
+	l = sizeof(sa_client);
+	if ((getpeername(sock_in, &sa_client, &l)) < 0) {
+/* get peername will fail if the input isn't a socket */
+	    perror("getpeername");
+	    memset(&sa_client, '\0', sizeof(sa_client));
+	}
+
+	l = sizeof(sa_server);
+	if (getsockname(sock_in, &sa_server, &l) < 0) {
+	    perror("getsockname");
+	    fprintf(stderr, "Error getting local address\n");
+	    exit(1);
+	}
+	server_conf->port = ntohs(((struct sockaddr_in *) &sa_server)->sin_port);
+	cio = ap_bcreate(ptrans, B_RDWR | B_SOCKET);
+        cio->fd = sock_out;
+        cio->fd_in = sock_in;
+	conn = new_connection(ptrans, server_conf, cio,
+			          (struct sockaddr_in *) &sa_client,
+			          (struct sockaddr_in *) &sa_server, -1);
+
+	while ((r = ap_read_request(conn)) != NULL) {
+
+	    if (r->status == HTTP_OK)
+		ap_process_request(r);
+
+	    if (!conn->keepalive || conn->aborted)
+		break;
+
+	    ap_destroy_pool(r->pool);
+	}
+
+	ap_bclose(cio);
+    }
+    exit(0);
+}
+
+#else /* ndef MULTITHREAD */
+
+
+/**********************************************************************
+ * Multithreaded implementation
+ *
+ * This code is fairly specific to Win32.
+ *
+ * The model used to handle requests is a set of threads. One "main"
+ * thread listens for new requests. When something becomes
+ * available, it does a select and places the newly available socket
+ * onto a list of "jobs" (add_job()). Then any one of a fixed number
+ * of "worker" threads takes the top job off the job list with
+ * remove_job() and handles that connection to completion. After
+ * the connection has finished the thread is free to take another
+ * job from the job list.
+ *
+ * In the code, the "main" thread is running within the worker_main()
+ * function. The first thing this function does is create the
+ * worker threads, which operate in the child_sub_main() function. The
+ * main thread then goes into a loop within worker_main() where they
+ * do a select() on the listening sockets. The select times out once
+ * per second so that the thread can check for an "exit" signal
+ * from the parent process (see below). If this signal is set, the 
+ * thread can exit, but only after it has accepted all incoming
+ * connections already in the listen queue (since Win32 appears
+ * to through away listened but unaccepted connections when a 
+ * process dies).
+ *
+ * Because the main and worker threads exist within a single process
+ * they are vulnerable to crashes or memory leaks (crashes can also
+ * be caused within modules, of course). There also needs to be a 
+ * mechanism to perform restarts and shutdowns. This is done by
+ * creating the main & worker threads within a subprocess. A
+ * main process (the "parent process") creates one (or more) 
+ * processes to do the work, then the parent sits around waiting
+ * for the working process to die, in which case it starts a new
+ * one. The parent process also handles restarts (by creating
+ * a new working process then signalling the previous working process 
+ * exit ) and shutdowns (by signalling the working process to exit).
+ * The parent process operates within the master_main() function. This
+ * process also handles requests from the service manager (NT only).
+ *
+ * Signalling between the parent and working process uses a Win32
+ * event. Each child has a unique name for the event, which is
+ * passed to it with the -Z argument when the child is spawned. The
+ * parent sets (signals) this event to tell the child to die.
+ * At present all children do a graceful die - they finish all
+ * current jobs _and_ empty the listen queue before they exit.
+ * A non-graceful die would need a second event. The -Z argument in
+ * the child is also used to create the shutdown and restart events,
+ * since the prefix (apPID) contains the parent process PID.
+ *
+ * The code below starts with functions at the lowest level -
+ * worker threads, and works up to the top level - the main()
+ * function of the parent process.
+ *
+ * The scoreboard (in process memory) contains details of the worker
+ * threads (within the active working process). There is no shared
+ * "scoreboard" between processes, since only one is ever active
+ * at once (or at most, two, when one has been told to shutdown but
+ * is processes outstanding requests, and a new one has been started).
+ * This is controlled by a "start_mutex" which ensures only one working
+ * process is active at once.
+ **********************************************************************/
+
+/* The code protected by #ifdef UNGRACEFUL_RESTARTS/#endif sections
+ * could implement a sort-of ungraceful restart for Win32. instead of
+ * graceful restarts. 
+ *
+ * However it does not work too well because it does not intercept a
+ * connection already in progress (in child_sub_main()). We'd have to
+ * get that to poll on the exit event. 
+ */
+
+/*
+ * Definition of jobs, shared by main and worker threads.
+ */
+
+typedef struct joblist_s {
+    struct joblist_s *next;
+    int sock;
+} joblist;
+
+/*
+ * Globals common to main and worker threads. This structure is not
+ * used by the parent process.
+ */
+
+typedef struct globals_s {
+#ifdef UNGRACEFUL_RESTART
+    HANDLE thread_exit_event;
+#else
+    int exit_now;
+#endif
+    semaphore *jobsemaphore;
+    joblist *jobhead;
+    joblist *jobtail;
+    mutex *jobmutex;
+    int jobcount;
+} globals;
+
+globals allowed_globals =
+{0, NULL, NULL, NULL, NULL, 0};
+
+/*
+ * add_job()/remove_job() - add or remove an accepted socket from the
+ * list of sockets connected to clients. allowed_globals.jobmutex protects
+ * against multiple concurrent access to the linked list of jobs.
+ */
+
+void add_job(int sock)
+{
+    joblist *new_job;
+    
+    ap_assert(allowed_globals.jobmutex);
+
+    /* TODO: If too many jobs in queue, sleep, check for problems */
+    ap_acquire_mutex(allowed_globals.jobmutex);
+    new_job = (joblist *) malloc(sizeof(joblist));
+    if (new_job == NULL) {
+	fprintf(stderr, "Ouch!  Out of memory in add_job()!\n");
+    }
+    new_job->next = NULL;
+    new_job->sock = sock;
+    if (allowed_globals.jobtail != NULL)
+	allowed_globals.jobtail->next = new_job;
+    allowed_globals.jobtail = new_job;
+    if (!allowed_globals.jobhead)
+	allowed_globals.jobhead = new_job;
+    allowed_globals.jobcount++;
+    release_semaphore(allowed_globals.jobsemaphore);
+    ap_release_mutex(allowed_globals.jobmutex);
+}
+
+int remove_job(int csd)
+{
+    static reported = 0;
+    static active_threads = 0;
+    joblist *job;
+    int sock;
+
+    /* Decline decrementing active_threads count on the first call
+     * to remove_job.  csd == -1 implies that this is the thread's
+     * first call to remove_job.
+     */
+    if (csd != -1) {
+        active_threads--;
+    }
+
+#ifdef UNGRACEFUL_RESTART
+    HANDLE hObjects[2];
+    int rv;
+
+    hObjects[0] = allowed_globals.jobsemaphore;
+    hObjects[1] = allowed_globals.thread_exit_event;
+
+    rv = WaitForMultipleObjects(2, hObjects, FALSE, INFINITE);
+    ap_assert(rv != WAIT_FAILED);
+    if (rv == WAIT_OBJECT_0 + 1) {
+	/* thread_exit_now */
+	APD1("thread got exit now event");
+	return -1;
+    }
+    /* must be semaphore */
+#else
+    acquire_semaphore(allowed_globals.jobsemaphore);
+#endif
+    ap_assert(allowed_globals.jobmutex);
+
+#ifdef UNGRACEFUL_RESTART
+    if (!allowed_globals.jobhead) {
+#else
+    ap_acquire_mutex(allowed_globals.jobmutex);
+    if (allowed_globals.exit_now && !allowed_globals.jobhead) {
+#endif
+	ap_release_mutex(allowed_globals.jobmutex);
+	return (-1);
+    }
+
+    job = allowed_globals.jobhead;
+    ap_assert(job);
+    allowed_globals.jobhead = job->next;
+    if (allowed_globals.jobhead == NULL)
+	allowed_globals.jobtail = NULL;
+
+    ap_release_mutex(allowed_globals.jobmutex);
+    sock = job->sock;
+    free(job);
+
+    /* If sock == -1 then the thread is about to exit so 
+     * don't count it as active.
+     */
+    if (sock != -1)
+        active_threads++;
+
+    if (!reported && (active_threads == ap_threads_per_child)) {
+        reported = 1;
+        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, server_conf,
+                     "Server ran out of threads to serve requests. Consider "
+                     "raising the ThreadsPerChild setting");
+    }
+    return (sock);
+}
+
+/*
+ * child_sub_main() - this is the main loop for the worker threads
+ *
+ * Each thread runs within this function. They wait within remove_job()
+ * for a job to become available, then handle all the requests on that
+ * connection until it is closed, then return to remove_job().
+ *
+ * The worker thread will exit when it removes a job which contains
+ * socket number -1. This provides a graceful thread exit, since
+ * it will never exit during a connection.
+ *
+ * This code in this function is basically equivalent to the child_main()
+ * from the multi-process (Unix) environment, except that we
+ *
+ *  - do not call child_init_modules (child init API phase)
+ *  - block in remove_job, and when unblocked we have an already
+ *    accepted socket, instead of blocking on a mutex or select().
+ */
+
+static void child_sub_main(int child_num)
+{
+    NET_SIZE_T clen;
+    struct sockaddr sa_server;
+    struct sockaddr sa_client;
+    pool *ptrans;
+    int requests_this_child = 0;
+    int csd = -1;
+    int dupped_csd = -1;
+    int srv = 0;
+
+#ifdef NETWARE
+    TSD* tsd = NULL;
+
+    while(tsd == NULL) {
+        tsd = (TSD*) Thread_Data_Area;
+        ThreadSwitchWithDelay();
+    }
+    init_name_space();
+#endif
+    ap_thread_count++;
+    ptrans = ap_make_sub_pool(pconf);
+
+    (void) ap_update_child_status(child_num, SERVER_READY, (request_rec *) NULL);
+
+    /*
+     * Setup the jump buffers so that we can return here after a timeout.
+     */
+#if defined(USE_LONGJMP)
+    setjmp(jmpbuffer);
+#else
+    sigsetjmp(jmpbuffer, 1);
+#endif
+#if defined(SIGURG)
+    signal(SIGURG, timeout);
+#endif
+
+#ifdef NETWARE
+    tsd = (TSD*) Thread_Data_Area;
+#endif
+
+    while (1) {
+	BUFF *conn_io;
+	request_rec *r;
+	
+#ifdef NETWARE
+        ThreadSwitch();
+#endif
+	/*
+	 * (Re)initialize this child to a pre-connection state.
+	 */
+	 
+	ap_set_callback_and_alarm(NULL, 0); /* Cancel any outstanding alarms */
+	timeout_req = NULL;                 /* No request in progress */
+	current_conn = NULL;
+	ap_clear_pool(ptrans);
+
+	(void) ap_update_child_status(child_num, SERVER_READY,
+	                              (request_rec *) NULL);
+
+	/* Get job from the job list. This will block until a job is ready.
+	 * If -1 is returned then the main thread wants us to exit.
+	 */
+	csd = remove_job(csd);
+	if (csd == -1)
+	    break;		/* time to exit */
+
+	requests_this_child++;
+
+	ap_note_cleanups_for_socket_ex(ptrans, csd, 1);
+
+	/*
+	 * We now have a connection, so set it up with the appropriate
+	 * socket options, file descriptors, and read/write buffers.
+	 */
+
+	clen = sizeof(sa_server);	
+	if (getsockname(csd, &sa_server, &clen) < 0) {
+	    ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, "getsockname");
+	    continue;
+	}
+	clen = sizeof(sa_client);
+	if ((getpeername(csd, &sa_client, &clen)) < 0) {
+	    /* get peername will fail if the input isn't a socket */
+	    perror("getpeername");
+	    memset(&sa_client, '\0', sizeof(sa_client));
+	}
+
+	sock_disable_nagle(csd, (struct sockaddr_in *)&sa_client);
+
+	(void) ap_update_child_status(child_num, SERVER_BUSY_READ,
+				   (request_rec *) NULL);
+
+	conn_io = ap_bcreate(ptrans, B_RDWR | B_SOCKET);
+	dupped_csd = csd;
+#if defined(NEED_DUPPED_CSD)
+	if ((dupped_csd = dup(csd)) < 0) {
+	    ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
+			"dup: couldn't duplicate csd");
+	    dupped_csd = csd;	/* Oh well... */
+	}
+	ap_note_cleanups_for_socket_ex(ptrans, dupped_csd, 1);
+#endif
+	ap_bpushfd(conn_io, csd, dupped_csd);
+
+	current_conn = new_connection(ptrans, server_conf, conn_io,
+				          (struct sockaddr_in *) &sa_client,
+				          (struct sockaddr_in *) &sa_server,
+				          child_num);
+				          
+	/*
+	 * Read and process each request found on our connection
+	 * until no requests are left or we decide to close.
+	 */
+	while ((r = ap_read_request(current_conn)) != NULL) {
+            (void) ap_update_child_status(child_num, SERVER_BUSY_WRITE, r);
+
+	    if (r->status == HTTP_OK)
+		ap_process_request(r);
+
+	    if (ap_extended_status)
+		increment_counts(child_num, r);
+	    if (!current_conn->keepalive || current_conn->aborted)
+		break;
+            /* If the server is shutting down, do not allow anymore requests 
+             * to be handled on the keepalive connection. Leave the thread 
+             * alive to drain the job queue. This check is particularly 
+             * important on the threaded server to allow the process to be 
+             * quickly taken down cleanly.
+             */
+            if (allowed_globals.exit_now)
+                break;
+	    ap_destroy_pool(r->pool);
+	    (void) ap_update_child_status(child_num, SERVER_BUSY_KEEPALIVE,
+				       (request_rec *) NULL);
+
+	    ap_sync_scoreboard_image();
+	}
+
+	/*
+	 * Close the connection, being careful to send out whatever is still
+	 * in our buffers.  If possible, try to avoid a hard close until the
+	 * client has ACKed our FIN and/or has stopped sending us data.
+	 */
+	ap_kill_cleanups_for_socket(ptrans, csd);
+
+#ifdef NO_LINGCLOSE
+	ap_bclose(conn_io);	/* just close it */
+#else
+	if (r && r->connection
+	    && !r->connection->aborted
+	    && r->connection->client
+	    && (r->connection->client->fd >= 0)) {
+
+	    lingering_close(r);
+	}
+	else {
+	    ap_bsetflag(conn_io, B_EOUT, 1);
+	    ap_bclose(conn_io);
+	}
+#endif
+    }
+    ap_destroy_pool(ptrans);
+    (void) ap_update_child_status(child_num, SERVER_DEAD, NULL);
+    
+    ap_thread_count--;
+}
+
+
+#ifdef NETWARE
+void child_main(void* child_num_arg)
+#else
+void child_main(int child_num_arg)
+#endif
+{
+    /*
+     * Only reason for this function, is to pass in
+     * arguments to child_sub_main() on its stack so
+     * that longjump doesn't try to corrupt its local
+     * variables and I don't need to make those
+     * damn variables static/global
+     */
+#ifdef NETWARE
+    TSD Tsd;
+    int *thread_ptr;
+    memset(&Tsd, 0, sizeof(TSD));
+    thread_ptr = __get_thread_data_area_ptr();
+    *thread_ptr = (int) &Tsd;
+	child_sub_main((int)child_num_arg);
+#else
+    child_sub_main(child_num_arg);
+#endif
+}
+
+
+
+void cleanup_thread(thread **handles, int *thread_cnt, int thread_to_clean)
+{
+    int i;
+
+    free_thread(handles[thread_to_clean]);
+    for (i = thread_to_clean; i < ((*thread_cnt) - 1); i++)
+	handles[i] = handles[i + 1];
+    (*thread_cnt)--;
+}
+#ifdef WIN32
+/*
+ * The Win32 call WaitForMultipleObjects will only allow you to wait for 
+ * a maximum of MAXIMUM_WAIT_OBJECTS (current 64).  Since the threading 
+ * model in the multithreaded version of apache wants to use this call, 
+ * we are restricted to a maximum of 64 threads.  This is a simplistic 
+ * routine that will increase this size.
+ */
+static DWORD wait_for_many_objects(DWORD nCount, CONST HANDLE *lpHandles, 
+                            DWORD dwSeconds)
+{
+    time_t tStopTime;
+    DWORD dwRet = WAIT_TIMEOUT;
+    DWORD dwIndex=0;
+    BOOL bFirst = TRUE;
+  
+    tStopTime = time(NULL) + dwSeconds;
+  
+    do {
+        if (!bFirst)
+            Sleep(1000);
+        else
+            bFirst = FALSE;
+          
+        for (dwIndex = 0; dwIndex * MAXIMUM_WAIT_OBJECTS < nCount; dwIndex++) {
+            dwRet = WaitForMultipleObjects(
+                        min(MAXIMUM_WAIT_OBJECTS, 
+                            nCount - (dwIndex * MAXIMUM_WAIT_OBJECTS)),
+                        lpHandles + (dwIndex * MAXIMUM_WAIT_OBJECTS), 
+                        0, 0);
+                                           
+            if (dwRet != WAIT_TIMEOUT) {                                          
+              break;
+            }
+        }
+    } while((time(NULL) < tStopTime) && (dwRet == WAIT_TIMEOUT));
+    
+    return dwRet;
+}
+#endif
+/*****************************************************************
+ * Executive routines.
+ */
+
+extern void main_control_server(void *); /* in hellop.c */
+
+event *exit_event;
+mutex *start_mutex;
+
+#define MAX_SIGNAL_NAME 30  /* Long enough for apPID_shutdown, where PID is an int */
+char signal_name_prefix[MAX_SIGNAL_NAME];
+char signal_restart_name[MAX_SIGNAL_NAME]; 
+char signal_shutdown_name[MAX_SIGNAL_NAME];
+
+#define MAX_SELECT_ERRORS 100
+
+/*
+ * Initialise the signal names, in the global variables signal_name_prefix, 
+ * signal_restart_name and signal_shutdown_name.
+ */
+
+void setup_signal_names(char *prefix)
+{
+    ap_snprintf(signal_name_prefix, sizeof(signal_name_prefix), prefix);    
+    ap_snprintf(signal_shutdown_name, sizeof(signal_shutdown_name), 
+	"%s_shutdown", signal_name_prefix);    
+    ap_snprintf(signal_restart_name, sizeof(signal_restart_name), 
+	"%s_restart", signal_name_prefix);    
+
+    APD2("signal prefix %s", signal_name_prefix);
+}
+
+#ifndef NETWARE
+static void setup_inherited_listeners(pool *p)
+{
+    HANDLE pipe;
+    listen_rec *lr;
+    int fd;
+    WSAPROTOCOL_INFO WSAProtocolInfo;
+    DWORD BytesRead;
+
+    /* Setup the listeners */
+    listenmaxfd = -1;
+    FD_ZERO(&listenfds);
+
+    /* Open the pipe to the parent process to receive the inherited socket
+     * data. The sockets have been set to listening in the parent process.
+     */
+    pipe = GetStdHandle(STD_INPUT_HANDLE);
+    for (lr = ap_listeners; lr; lr = lr->next) {
+        if (!ReadFile(pipe, &WSAProtocolInfo, sizeof(WSAPROTOCOL_INFO), 
+                      &BytesRead, (LPOVERLAPPED) NULL)) {
+            ap_log_error(APLOG_MARK, APLOG_WIN32ERROR|APLOG_CRIT, server_conf,
+                         "setup_inherited_listeners: Unable to read socket data from parent");
+            signal_parent(0);	/* tell parent to die */
+            exit(1);
+        }
+        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, server_conf,
+                         "BytesRead = %d WSAProtocolInfo = %x20", BytesRead, WSAProtocolInfo);
+        fd = WSASocket(FROM_PROTOCOL_INFO, FROM_PROTOCOL_INFO, FROM_PROTOCOL_INFO,
+                       &WSAProtocolInfo, 0, 0);
+        if (fd == INVALID_SOCKET) {
+            ap_log_error(APLOG_MARK, APLOG_WIN32ERROR|APLOG_CRIT, server_conf,
+                         "setup_inherited_listeners: WSASocket failed to open the inherited socket.");
+            signal_parent(0);	/* tell parent to die */
+            exit(1);
+        }
+        if (fd >= 0) {
+            FD_SET(fd, &listenfds);
+            if (fd > listenmaxfd)
+                listenmaxfd = fd;
+        }
+        ap_note_cleanups_for_socket_ex(p, fd, 1);
+        lr->fd = fd;
+        if (lr->next == NULL) {
+            /* turn the list into a ring */
+            lr->next = ap_listeners;
+            break;
+        }
+    }
+    head_listener = ap_listeners;
+    close_unused_listeners();
+    CloseHandle(pipe);
+    return;
+}
+#endif
+
+/*
+ * worker_main() is main loop for the child process. The loop in
+ * this function becomes the controlling thread for the actually working
+ * threads (which run in a loop in child_sub_main()).
+ */
+ 
+#ifdef NETWARE
+void worker_main(void)
+{
+    int nthreads;
+    fd_set main_fds;
+    int srv;
+    int clen;
+    int csd;
+    struct sockaddr_in sa_client;
+    thread **child_handles;
+    int rv;
+    int i;
+    struct timeval tv;
+    int my_pid;
+    int count_select_errors = 0;
+    pool *pchild;
+    module **m;    
+    listen_rec* lr;
+    
+
+    pchild = ap_make_sub_pool(pconf);
+
+    ap_standalone = 1;
+    sd = -1;
+    nthreads = ap_threads_per_child;
+    
+    if (nthreads <= 0)
+        nthreads = 40;
+	    
+    my_pid = getpid();
+
+    ++ap_my_generation;
+
+    copy_listeners(pconf);
+    ap_restart_time = time(NULL);
+
+    reinit_scoreboard(pconf);
+    setup_listeners(pconf);
+
+    if (listenmaxfd == -1) {
+        /* Help, no sockets were made, better log something and exit */
+        ap_log_error(APLOG_MARK, APLOG_CRIT|APLOG_NOERRNO, NULL,
+                     "No sockets were created for listening");
+        
+        ap_destroy_pool(pchild);
+        cleanup_scoreboard();
+        exit(1);
+    }
+    
+    set_signals();
+
+    /* Display listening ports */
+    printf("   Listening on port(s):");
+    lr = ap_listeners;
+    do {
+       printf(" %d", ntohs(lr->local_addr.sin_port));
+       lr = lr->next;
+    } while(lr && lr != ap_listeners);
+    
+    /* Display dynamic modules loaded */
+    printf("\n");    
+    for (m = ap_loaded_modules; *m != NULL; m++) {
+        if (((module*)*m)->dynamic_load_handle) {
+            printf("   Loaded dynamic module %s\n", ap_find_module_name(*m));
+        }
+    }
+
+    /*
+     * - Initialize allowed_globals
+     * - Create the thread table
+     * - Spawn off threads
+     * - Create listen socket set (done above)
+     * - loop {
+     *       wait for request
+     *       create new job
+     *   } while (!time to exit)
+     * - Close all listeners
+     * - Wait for all threads to complete
+     * - Exit
+     */
+
+    ap_child_init_modules(pconf, server_conf);
+    allowed_globals.jobmutex = ap_create_mutex(NULL);
+    allowed_globals.jobsemaphore = create_semaphore(0);
+
+    /* spawn off the threads */
+    child_handles = (thread *) malloc(nthreads * sizeof(int));
+    
+    for (i = 0; i < nthreads; i++) {
+        child_handles[i] = create_thread((void (*)(void *)) child_main, (void *) i);
+    }
+    
+    if (nthreads > max_daemons_limit) {
+        max_daemons_limit = nthreads;
+    }
+
+    while (1) {    
+        tv.tv_sec = 1;
+        tv.tv_usec = 0;
+        
+        ThreadSwitch();
+        
+        if (shutdown_pending)
+            break;
+            
+        memcpy(&main_fds, &listenfds, sizeof(fd_set));
+        srv = ap_select(listenmaxfd + 1, &main_fds, NULL, NULL, &tv);
+
+        if (srv == 0) {
+            count_select_errors = 0;    /* reset count of errors */
+            continue;
+        }
+        else if (srv == SOCKET_ERROR) {
+            if (h_errno != WSAEINTR) {
+                /* A "real" error occurred, log it and increment the count of
+                 * select errors. This count is used to ensure we don't go into
+                 * a busy loop of continuous errors.
+                 */
+                ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, 
+                             "select failed with errno %d", h_errno);
+                count_select_errors++;
+                if (count_select_errors > MAX_SELECT_ERRORS) {
+                    ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, server_conf,
+                                 "Too many errors in select loop. Child process exiting.");
+                    break;
+                }
+            }
+            continue;
+        } else {
+            listen_rec *lr;
+            
+            lr = find_ready_listener(&main_fds);
+	    
+            if (lr != NULL) {
+                sd = lr->fd;
+            }
+        }
+
+        do {
+            clen = sizeof(sa_client);
+            csd = accept(sd, (struct sockaddr *) &sa_client, &clen);
+            
+            if (csd == INVALID_SOCKET) {
+                csd = -1;
+            }
+        } while (csd < 0 && h_errno == WSAEINTR);
+	
+        if (csd == INVALID_SOCKET) {
+            if ((h_errno != WSAECONNABORTED) && (h_errno != WSAEWOULDBLOCK)) {
+                ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
+                             "accept: (client socket) failed with errno = %d",h_errno);
+            }
+        }
+        else {
+            u_long one = 0;
+
+            if (soblock(csd) != 0) {
+                ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
+                             "%d couldn't make socket descriptor (%d) blocking again.", h_errno, csd);
+                continue;
+            }
+            add_job(csd);
+        }
+    }
+
+    APD2("process PID %d exiting", my_pid);
+
+    /* Get ready to shutdown and exit */
+    allowed_globals.exit_now = 1;
+    
+    for (i = 0; i < nthreads; i++) {
+        add_job(-1);
+    }
+
+    APD2("process PID %d waiting for worker threads to exit", my_pid);
+    while(ap_thread_count)
+        ThreadSwitch();
+    
+    destroy_semaphore(allowed_globals.jobsemaphore);
+    ap_destroy_mutex(allowed_globals.jobmutex);
+    
+    ap_child_exit_modules(pconf, server_conf);
+    ap_destroy_pool(pchild);
+    free(child_handles);
+    cleanup_scoreboard();
+
+    APD2("process PID %d exited", my_pid);
+    clean_parent_exit(0);
+
+}
+#else
+void worker_main(void)
+{
+    int nthreads;
+    fd_set main_fds;
+    int srv;
+    int clen;
+    int csd;
+    struct sockaddr_in sa_client;
+    int total_jobs = 0;
+    thread **child_handles;
+    int rv;
+    time_t end_time;
+    int i;
+    struct timeval tv;
+    int wait_time = 1;
+    int max_jobs_per_exe;
+    int max_jobs_after_exit_request;
+    HANDLE hObjects[2];
+
+    int count_select_errors = 0;
+    pool *pchild;
+
+    pchild = ap_make_sub_pool(pconf);
+
+    ap_standalone = 1;
+    sd = -1;
+    nthreads = ap_threads_per_child;
+    max_jobs_after_exit_request = ap_excess_requests_per_child;
+    max_jobs_per_exe = ap_max_requests_per_child;
+    if (nthreads <= 0)
+	nthreads = 40;
+    if (max_jobs_per_exe <= 0)
+	max_jobs_per_exe = 0;
+    if (max_jobs_after_exit_request <= 0)
+	max_jobs_after_exit_request = max_jobs_per_exe / 10;
+
+    if (!one_process)
+	detach();
+
+    my_pid = getpid();
+
+    ++ap_my_generation;
+
+    copy_listeners(pconf);
+    ap_restart_time = time(NULL);
+
+    reinit_scoreboard(pconf);
+    
+    /*
+     * Wait until we have permission to start accepting connections.
+     * start_mutex is used to ensure that only one child ever
+     * goes into the listen/accept loop at once. Also wait on exit_event,
+     * in case we (this child) is told to die before we get a chance to
+     * serve any requests.
+     */
+    hObjects[0] = (HANDLE)start_mutex;
+    hObjects[1] = (HANDLE)exit_event;
+    rv = WaitForMultipleObjects(2, hObjects, FALSE, INFINITE);
+    if (rv == WAIT_FAILED) {
+	ap_log_error(APLOG_MARK,APLOG_ERR|APLOG_WIN32ERROR, server_conf,
+                     "Waiting for start_mutex or exit_event -- process will exit");
+
+	ap_destroy_pool(pchild);
+	cleanup_scoreboard();
+	exit(1);
+    }
+    if (rv == WAIT_OBJECT_0 + 1) {
+	/* exit event signalled - exit now */
+	ap_destroy_pool(pchild);
+	cleanup_scoreboard();
+	exit(0);
+    }
+    /* start_mutex obtained, continue into the select() loop */
+    if (one_process) {
+        setup_listeners(pconf);
+    } else {
+        /* Get listeners from the parent process */
+        setup_inherited_listeners(pconf);
+    }
+
+    if (listenmaxfd == -1) {
+	/* Help, no sockets were made, better log something and exit */
+	ap_log_error(APLOG_MARK, APLOG_CRIT|APLOG_NOERRNO, NULL,
+		    "No sockets were created for listening");
+
+	signal_parent(0);	/* tell parent to die */
+
+	ap_destroy_pool(pchild);
+	cleanup_scoreboard();
+	exit(1);
+    }
+    set_signals();
+
+    /*
+     * - Initialize allowed_globals
+     * - Create the thread table
+     * - Spawn off threads
+     * - Create listen socket set (done above)
+     * - loop {
+     *       wait for request
+     *       create new job
+     *   } while (!time to exit)
+     * - Close all listeners
+     * - Wait for all threads to complete
+     * - Exit
+     */
+
+    ap_child_init_modules(pconf, server_conf);
+
+    allowed_globals.jobsemaphore = create_semaphore(0);
+    allowed_globals.jobmutex = ap_create_mutex(NULL);
+
+    /* spawn off the threads */
+    child_handles = (thread *) alloca(nthreads * sizeof(int));
+    for (i = 0; i < nthreads; i++) {
+	child_handles[i] = create_thread((void (*)(void *)) child_main, (void *) i);
+        if (child_handles[i] == 0) {
+            ap_log_error(APLOG_MARK, APLOG_ERR, server_conf, 
+                         "create_thread rc = %d", errno);
+        }
+    }
+    if (nthreads > max_daemons_limit) {
+	max_daemons_limit = nthreads;
+    }
+
+    while (1) {
+        if (max_jobs_per_exe && (total_jobs > max_jobs_per_exe)) {
+            /* Reached MaxRequestsPerChild. Stop accepting new connections
+             * and signal the parent to start a new child process.
+             */
+            ap_start_restart(1);
+            break;
+	}
+        /* Always check for the exit event being signaled.
+         */
+        rv = WaitForSingleObject(exit_event, 0);
+        ap_assert((rv == WAIT_TIMEOUT) || (rv == WAIT_OBJECT_0));
+        if (rv == WAIT_OBJECT_0) {
+            APD1("child: exit event signalled, exiting");
+            break;
+        }
+
+	tv.tv_sec = wait_time;
+	tv.tv_usec = 0;
+	memcpy(&main_fds, &listenfds, sizeof(fd_set));
+
+	srv = ap_select(listenmaxfd + 1, &main_fds, NULL, NULL, &tv);
+
+        if (srv == 0) {
+            count_select_errors = 0;    /* reset count of errors */            
+            continue;
+        }
+	else if (srv == SOCKET_ERROR) {
+            if (h_errno != WSAEINTR) {
+                /* A "real" error occurred, log it and increment the count of
+                 * select errors. This count is used to ensure we don't go into
+                 * a busy loop of continuous errors.
+                 */
+                ap_log_error(APLOG_MARK, APLOG_WARNING, server_conf, 
+                             "select failed with errno %d", h_errno);
+                count_select_errors++;
+                if (count_select_errors > MAX_SELECT_ERRORS) {
+                    ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, server_conf,
+                                 "Too many errors in select loop. Child process exiting.");
+                    break;
+                }
+            }
+            continue;
+	} else {
+	    listen_rec *lr;
+
+	    lr = find_ready_listener(&main_fds);
+	    if (lr != NULL) {
+		sd = lr->fd;
+	    }
+	}
+	do {
+	    clen = sizeof(sa_client);
+	    csd = accept(sd, (struct sockaddr *) &sa_client, &clen);
+	    if (csd == INVALID_SOCKET) {
+		csd = -1;
+	    }
+	} while (csd < 0 && h_errno == WSAEINTR);
+
+	if (csd < 0) {
+	    if (h_errno != WSAECONNABORTED) {
+		ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
+                             "accept: (client socket) failed with errno = %d",h_errno);
+            }
+	}
+	else {
+	    add_job(csd);
+	    total_jobs++;
+	}
+    }
+
+    APD2("process PID %d exiting", my_pid);
+
+    /* Get ready to shutdown and exit */
+    allowed_globals.exit_now = 1;
+    ap_release_mutex(start_mutex);
+
+#ifdef UNGRACEFUL_RESTART
+    SetEvent(allowed_globals.thread_exit_event);
+#else
+    for (i = 0; i < nthreads; i++) {
+	add_job(-1);
+    }
+#endif
+
+    APD2("process PID %d waiting for worker threads to exit", my_pid);
+    /* Wait for all your children */
+    end_time = time(NULL) + 180;
+    while (nthreads) {
+        rv = wait_for_many_objects(nthreads, child_handles, 
+                                   end_time - time(NULL));
+	if (rv != WAIT_TIMEOUT) {
+	    rv = rv - WAIT_OBJECT_0;
+	    ap_assert((rv >= 0) && (rv < nthreads));
+	    cleanup_thread(child_handles, &nthreads, rv);
+	    continue;
+	}
+	break;
+    }
+
+    APD2("process PID %d killing remaining worker threads", my_pid);
+    for (i = 0; i < nthreads; i++) {
+	kill_thread(child_handles[i]);
+	free_thread(child_handles[i]);
+    }
+#ifdef UNGRACEFUL_RESTART
+    ap_assert(CloseHandle(allowed_globals.thread_exit_event));
+#endif
+    destroy_semaphore(allowed_globals.jobsemaphore);
+    ap_destroy_mutex(allowed_globals.jobmutex);
+
+    ap_child_exit_modules(pconf, server_conf);
+    ap_destroy_pool(pchild);
+
+    cleanup_scoreboard();
+
+    APD2("process PID %d exited", my_pid);
+    clean_parent_exit(0);
+}				/* standalone_main */
+
+/*
+ * Spawn a child Apache process. The child process has the command line arguments from
+ * argc and argv[], plus a -Z argument giving the name of an event. The child should
+ * open and poll or wait on this event. When it is signalled, the child should die.
+ * prefix is a prefix string for the event name.
+ * 
+ * The child_num argument on entry contains a serial number for this child (used to create
+ * a unique event name). On exit, this number will have been incremented by one, ready
+ * for the next call. 
+ *
+ * On exit, the value pointed to be *ev will contain the event created
+ * to signal the new child process.
+ *
+ * The return value is the handle to the child process if successful, else -1. If -1 is
+ * returned the error will already have been logged by ap_log_error().
+ */
+
+/**********************************************************************
+ * master_main - this is the parent (main) process. We create a
+ * child process to do the work, then sit around waiting for either
+ * the child to exit, or a restart or exit signal. If the child dies,
+ * we just respawn a new one. If we have a shutdown or graceful restart,
+ * tell the child to die when it is ready. If it is a non-graceful
+ * restart, force the child to die immediately.
+ **********************************************************************/
+
+#define MAX_PROCESSES 50 /* must be < MAX_WAIT_OBJECTS-1 */
+
+static void cleanup_process(HANDLE *handles, HANDLE *events, int position, int *processes)
+{
+    int i;
+    int handle = 0;
+
+    CloseHandle(handles[position]);
+    CloseHandle(events[position]);
+
+    handle = (int)handles[position];
+
+    for (i = position; i < (*processes)-1; i++) {
+	handles[i] = handles[i + 1];
+	events[i] = events[i + 1];
+    }
+    (*processes)--;
+
+    APD4("cleanup_processes: removed child in slot %d handle %d, max=%d", position, handle, *processes);
+}
+
+static int create_process(pool *p, HANDLE *handles, HANDLE *events, 
+                          int *processes, int *child_num, char *kill_event_name, int argc, char **argv)
+{
+
+    int rv, i;
+    HANDLE kill_event;
+    char buf[1024];
+    char exit_event_name[40]; /* apPID_C# */
+    char *pCommand;
+
+    STARTUPINFO si;           /* Filled in prior to call to CreateProcess */
+    PROCESS_INFORMATION pi;   /* filled in on call to CreateProces */
+    LPWSAPROTOCOL_INFO  lpWSAProtocolInfo;
+    listen_rec *lr;
+    DWORD BytesWritten;
+    HANDLE hPipeRead = NULL;
+    HANDLE hPipeWrite = NULL;
+    HANDLE hPipeWriteDup;
+    HANDLE hNullOutput = NULL;
+    HANDLE hShareError = NULL;
+    HANDLE hCurrentProcess;
+    SECURITY_ATTRIBUTES sa = {0};  
+
+    sa.nLength = sizeof(sa);
+    sa.bInheritHandle = TRUE;
+    sa.lpSecurityDescriptor = NULL;
+
+    /* Build the command line. Should look something like this:
+     * C:/apache/bin/apache.exe -Z exit_event -f ap_server_confname 
+     * First, get the path to the executable...
+     */
+    rv = GetModuleFileName(NULL, buf, sizeof(buf));
+    if (rv == sizeof(buf)) {
+        ap_log_error(APLOG_MARK, APLOG_WIN32ERROR | APLOG_CRIT, server_conf,
+                     "Parent: Path to Apache process too long");
+        return -1;
+    } else if (rv == 0) {
+        ap_log_error(APLOG_MARK, APLOG_WIN32ERROR | APLOG_CRIT, server_conf,
+                     "Parent: GetModuleFileName() returned NULL for current process.");
+        return -1;
+    }
+    
+    /* Create the exit event (apPID_C#). Parent signals this event to tell the
+     * child to exit 
+     */
+    ap_snprintf(exit_event_name, sizeof(exit_event_name), "%s_C%d", kill_event_name, ++(*child_num));
+    kill_event = CreateEvent(NULL, TRUE, FALSE, exit_event_name);
+    if (!kill_event) {
+        ap_log_error(APLOG_MARK, APLOG_WIN32ERROR | APLOG_CRIT, server_conf,
+                     "Parent: Could not create exit event for child process");
+        return -1;
+    }
+    
+	/* service children must be created with the -z option,
+	 * while console mode (interactive apache) children are created
+	 * with the -Z option
+	 */
+    pCommand = ap_psprintf(p, "\"%s\" -%c %s -f \"%s\"", buf, 
+		                   isProcessService() ? 'z' : 'Z',
+		                   exit_event_name, ap_server_confname);  
+
+    for (i = 1; i < argc; i++) {
+        if ((argv[i][0] == '-') && ((argv[i][1] == 'k') || (argv[i][1] == 'n')))
+            ++i;
+        else
+            pCommand = ap_pstrcat(p, pCommand, " \"", argv[i], "\"", NULL);
+    }
+
+    /* Create a pipe to send socket info to the child */
+    if (!CreatePipe(&hPipeRead, &hPipeWrite, &sa, 0)) {
+        ap_log_error(APLOG_MARK, APLOG_WIN32ERROR | APLOG_CRIT, server_conf,
+                     "Parent: Unable to create pipe to child process.\n");
+        return -1;
+    }
+
+    /* Open a null handle to soak info from the child */
+    hNullOutput = CreateFile("nul", GENERIC_READ | GENERIC_WRITE, 
+                             FILE_SHARE_READ | FILE_SHARE_WRITE, 
+                             &sa, OPEN_EXISTING, 0, NULL);
+    if (hNullOutput == INVALID_HANDLE_VALUE) {
+        ap_log_error(APLOG_MARK, APLOG_WIN32ERROR | APLOG_CRIT, server_conf,
+                     "Parent: Unable to create null output pipe for child process.\n");
+        return -1;
+    }
+
+    /* Child's initial stderr -> our main server error log (or, failing that, stderr) */
+    if (server_conf->error_log) {
+        hShareError = (HANDLE)_get_osfhandle(fileno(server_conf->error_log));
+        if (hShareError == INVALID_HANDLE_VALUE) {
+            hShareError = GetStdHandle(STD_ERROR_HANDLE);
+        }
+    }
+
+    hCurrentProcess = GetCurrentProcess();
+    if (DuplicateHandle(hCurrentProcess, hPipeWrite, hCurrentProcess,
+                        &hPipeWriteDup, 0, FALSE, DUPLICATE_SAME_ACCESS))
+    {
+        CloseHandle(hPipeWrite);
+        hPipeWrite = hPipeWriteDup;
+    }
+
+    /* Give the read in of the pipe (hPipeRead) to the child as stdin. The 
+     * parent will write the socket data to the child on this pipe.
+     */
+    memset(&si, 0, sizeof(si));
+    memset(&pi, 0, sizeof(pi));
+    si.cb = sizeof(si);
+    si.dwFlags     = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
+    si.wShowWindow = SW_HIDE;
+    si.hStdInput   = hPipeRead;
+    si.hStdOutput  = hNullOutput;
+    si.hStdError   = hShareError;
+
+    if (!CreateProcess(NULL, pCommand, NULL, NULL, 
+                       TRUE,      /* Inherit handles */
+                       0,         /* Creation flags */
+                       NULL, NULL,
+                       &si, &pi)) {
+        ap_log_error(APLOG_MARK, APLOG_WIN32ERROR | APLOG_CRIT, server_conf,
+                     "Parent: Not able to create the child process.");
+        /*
+         * We must close the handles to the new process and its main thread
+         * to prevent handle and memory leaks.
+         */ 
+        CloseHandle(pi.hProcess);
+        CloseHandle(pi.hThread);
+        CloseHandle(hPipeRead);
+        CloseHandle(hPipeWrite);        
+        CloseHandle(hNullOutput);
+
+        return -1;
+    }
+    else {
+        ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_INFO, server_conf,
+                     "Parent: Created child process %d", pi.dwProcessId);
+
+        /* Assume the child process lives. Update the process and event tables */
+        handles[*processes] = pi.hProcess;
+        events[*processes] = kill_event;
+        (*processes)++;
+
+        /* We never store the thread's handle, so close it now. */
+        CloseHandle(pi.hThread);
+
+        /* Run the chain of open sockets. For each socket, duplicate it 
+         * for the target process then send the WSAPROTOCOL_INFO 
+         * (returned by dup socket) to the child */
+        lr = ap_listeners;
+        while (lr != NULL) {
+            lpWSAProtocolInfo = ap_pcalloc(p, sizeof(WSAPROTOCOL_INFO));
+            ap_log_error(APLOG_MARK, APLOG_NOERRNO | APLOG_INFO, server_conf,
+                         "Parent: Duplicating socket %d and sending it to child process %d", lr->fd, pi.dwProcessId);
+            if (WSADuplicateSocket(lr->fd, 
+                                   pi.dwProcessId,
+                                   lpWSAProtocolInfo) == SOCKET_ERROR) {
+                ap_log_error(APLOG_MARK, APLOG_WIN32ERROR | APLOG_CRIT, server_conf,
+                             "Parent: WSADuplicateSocket failed for socket %d.", lr->fd );
+                return -1;
+            }
+
+            if (!WriteFile(hPipeWrite, lpWSAProtocolInfo, (DWORD) sizeof(WSAPROTOCOL_INFO),
+                           &BytesWritten,
+                           (LPOVERLAPPED) NULL)) {
+                ap_log_error(APLOG_MARK, APLOG_WIN32ERROR | APLOG_CRIT, server_conf,
+                             "Parent: Unable to write duplicated socket %d to the child.", lr->fd );
+                return -1;
+            }
+
+            lr = lr->next;
+            if (lr == ap_listeners)
+                break;
+        }
+    }
+    CloseHandle(hPipeRead);
+    CloseHandle(hPipeWrite);        
+    CloseHandle(hNullOutput);
+
+    return 0;
+}
+
+/* To share the semaphores with other processes, we need a NULL ACL
+ * Code from MS KB Q106387
+ */
+
+static PSECURITY_ATTRIBUTES GetNullACL()
+{
+    PSECURITY_DESCRIPTOR pSD;
+    PSECURITY_ATTRIBUTES sa;
+
+    sa  = (PSECURITY_ATTRIBUTES) LocalAlloc(LPTR, sizeof(SECURITY_ATTRIBUTES));
+    pSD = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR,
+					    SECURITY_DESCRIPTOR_MIN_LENGTH);
+    if (pSD == NULL || sa == NULL) {
+        return NULL;
+    }
+    /*
+     * Win98 returns nonzero on failure; check LastError to make sure.
+     */
+    SetLastError(0);
+    if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION)
+	|| GetLastError()) {
+        LocalFree( pSD );
+        LocalFree( sa );
+        return NULL;
+    }
+    if (!SetSecurityDescriptorDacl(pSD, TRUE, (PACL) NULL, FALSE)
+	|| GetLastError()) {
+        LocalFree( pSD );
+        LocalFree( sa );
+        return NULL;
+    }
+    sa->nLength = sizeof(sa);
+    sa->lpSecurityDescriptor = pSD;
+    sa->bInheritHandle = TRUE;
+    return sa;
+}
+
+
+static void CleanNullACL( void *sa ) {
+    if( sa ) {
+        LocalFree( ((PSECURITY_ATTRIBUTES)sa)->lpSecurityDescriptor);
+        LocalFree( sa );
+    }
+}
+
+int master_main(int argc, char **argv)
+{
+    /* returns NULL if invalid (Win95?) */
+    PSECURITY_ATTRIBUTES sa = GetNullACL();
+    int nchild = ap_daemons_to_start;
+    int child_num = 0;
+    int rv, cld;
+    char signal_prefix_string[100];
+    int i;
+    time_t tmstart;
+    HANDLE signal_shutdown_event;	/* used to signal shutdown to parent */
+    HANDLE signal_restart_event;	/* used to signal a restart to parent */
+    HANDLE process_handles[MAX_PROCESSES];
+    HANDLE process_kill_events[MAX_PROCESSES];
+    int current_live_processes = 0; /* number of child process we know about */
+    int processes_to_create = 0;    /* number of child processes to create */
+    pool *pparent = NULL;  /* pool for the parent process. Cleaned on each restart */
+
+    nchild = 1;	    /* only allowed one child process for current generation */
+    processes_to_create = nchild;
+
+    is_graceful = 0;
+
+    ap_snprintf(signal_prefix_string, sizeof(signal_prefix_string),
+	        "ap%d", getpid());
+    setup_signal_names(signal_prefix_string);
+
+    /* Create shutdown event, apPID_shutdown, where PID is the parent 
+     * Apache process ID. Shutdown is signaled by 'apache -k shutdown'.
+     */
+    signal_shutdown_event = CreateEvent(sa, TRUE, FALSE, signal_shutdown_name);
+    if (!signal_shutdown_event) {
+	ap_log_error(APLOG_MARK, APLOG_EMERG|APLOG_WIN32ERROR, server_conf,
+		    "master_main: Cannot create shutdown event %s", signal_shutdown_name);
+        CleanNullACL((void *)sa);
+	exit(1);
+    }
+
+    /* Create restart event, apPID_restart, where PID is the parent 
+     * Apache process ID. Restart is signaled by 'apache -k restart'.
+     */
+    signal_restart_event = CreateEvent(sa, TRUE, FALSE, signal_restart_name);
+    if (!signal_restart_event) {
+	CloseHandle(signal_shutdown_event);
+	ap_log_error(APLOG_MARK, APLOG_EMERG|APLOG_WIN32ERROR, server_conf,
+		    "master_main: Cannot create restart event %s", signal_restart_name);
+        CleanNullACL((void *)sa);
+	exit(1);
+    }
+    CleanNullACL((void *)sa);
+
+    /* Create the start mutex, apPID, where PID is the parent Apache process ID.
+     * Ths start mutex is used during a restart to prevent more than one 
+     * child process from entering the accept loop at once.
+     */
+    start_mutex = ap_create_mutex(signal_prefix_string);
+    restart_pending = shutdown_pending = 0;
+
+    do { /* restart-pending */
+	if (!is_graceful) {
+	    ap_restart_time = time(NULL);
+	}
+        copy_listeners(pconf);
+	ap_clear_pool(pconf);
+	pparent = ap_make_sub_pool(pconf);
+
+	server_conf = ap_read_config(pconf, pparent, ap_server_confname);
+        setup_listeners(pconf);
+	ap_clear_pool(plog);
+	ap_open_logs(server_conf, plog);
+	ap_set_version();
+	ap_init_modules(pconf, server_conf);
+	version_locked++;
+        service_set_status(SERVICE_START_PENDING);
+        /* Create child processes */
+        while (processes_to_create--) {
+            if (create_process(pconf, process_handles, process_kill_events, 
+                               &current_live_processes, &child_num, signal_prefix_string, argc, argv) < 0) {
+                ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
+                             "master_main: create child process failed. Exiting.");
+                goto die_now;
+            }
+        }
+        service_set_status(SERVICE_RUNNING);
+	restart_pending = shutdown_pending = 0;
+
+        /* Wait for either the shutdown or restart events to be signaled */
+        process_handles[current_live_processes] = signal_shutdown_event;
+        process_handles[current_live_processes+1] = signal_restart_event;
+        rv = WaitForMultipleObjects(current_live_processes+2, (HANDLE *)process_handles, 
+                                    FALSE, INFINITE);
+        if (rv == WAIT_FAILED) {
+            /* Something serious is wrong */
+            ap_log_error(APLOG_MARK,APLOG_CRIT|APLOG_WIN32ERROR, server_conf,
+                         "master_main: : WaitForMultipeObjects on process handles and apache-signal -- doing shutdown");
+            shutdown_pending = 1;
+            break;
+        }
+        if (rv == WAIT_TIMEOUT) {
+            /* Hey, this cannot happen */
+            ap_log_error(APLOG_MARK, APLOG_ERR, server_conf,
+                         "master_main: WaitForMultipeObjects with INFINITE wait exited with WAIT_TIMEOUT");
+            shutdown_pending = 1;
+        }
+
+        cld = rv - WAIT_OBJECT_0;
+        APD4("main process: wait finished, cld=%d handle %d (max=%d)", cld, process_handles[cld], current_live_processes);
+        if (cld == current_live_processes) {
+            /* apPID_shutdown event signalled, we should exit now */
+            shutdown_pending = 1;
+            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, server_conf, 
+                         "master_main: Shutdown event signaled. Shutting the server down.");
+            if (ResetEvent(signal_shutdown_event) == 0) {
+                ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_WIN32ERROR, server_conf,
+                             "ResetEvent(signal_shutdown_event)");
+            }
+	    /* Signal each child processes to die */
+	    for (i = 0; i < current_live_processes; i++) {
+		APD3("master_main: signalling child %d, handle %d to die", i, process_handles[i]);
+		if (SetEvent(process_kill_events[i]) == 0)
+		    ap_log_error(APLOG_MARK,APLOG_ERR|APLOG_WIN32ERROR, server_conf,
+                                 "master_main: SetEvent for child process in slot #%d failed", i);
+	    }
+            break;
+        } else if (cld == current_live_processes+1) {
+            /* apPID_restart event signalled. 
+             * Signal the child to shutdown and start a new child process.
+             * The restart event can be signaled by a command line restart or
+             * by the child process when it handles MaxRequestPerChild connections.
+             */
+            int children_to_kill = current_live_processes;
+            restart_pending = 1;
+            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, server_conf, 
+                         "master_main: Restart event signaled. Doing a graceful restart.");
+            if (ResetEvent(signal_restart_event) == 0) {
+                ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_WIN32ERROR, server_conf,
+                             "master_main: ResetEvent(signal_restart_event) failed.");
+            }
+            /* Signal each child process to die */
+	    for (i = 0; i < children_to_kill; i++) {
+		APD3("master_main: signalling child #%d handle %d to die", i, process_handles[i]);
+		if (SetEvent(process_kill_events[i]) == 0)
+		    ap_log_error(APLOG_MARK, APLOG_ERR|APLOG_WIN32ERROR, server_conf,
+                                 "master_main: SetEvent for child process in slot #%d failed", i);
+                /* Remove the process (and event) from the process table */
+                cleanup_process(process_handles, process_kill_events, i, &current_live_processes);
+	    }
+	    processes_to_create = 1;
+            ++ap_my_generation;
+            continue;
+        } else {
+            /* The child process exited premeturely because of a fatal error condition
+             * (eg, seg fault). Cleanup and restart the child process.
+             */
+            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, server_conf, 
+                         "master_main: Child processed exited prematurely. Restarting the child process.");
+	    ap_assert(cld < current_live_processes);
+	    cleanup_process(process_handles, process_kill_events, cld, &current_live_processes);
+	    APD2("main_process: child in slot %d died", rv);
+            processes_to_create = 1;
+            continue;
+	}
+
+    } while (1);
+
+    /* If we dropped out of the loop we definitly want to die completely. We need to
+     * make sure we wait for all the child process to exit first.
+     */
+
+    APD2("*** main process shutdown, processes=%d ***", current_live_processes);
+
+die_now:
+
+    tmstart = time(NULL);
+    while (current_live_processes && ((tmstart+60) > time(NULL))) {
+	service_set_status(SERVICE_STOP_PENDING);
+	rv = WaitForMultipleObjects(current_live_processes, (HANDLE *)process_handles, FALSE, 2000);
+	if (rv == WAIT_TIMEOUT)
+	    continue;
+	ap_assert(rv != WAIT_FAILED);
+	cld = rv - WAIT_OBJECT_0;
+	ap_assert(rv < current_live_processes);
+	APD4("main_process: child in #%d handle %d died, left=%d", 
+	    rv, process_handles[rv], current_live_processes);
+	cleanup_process(process_handles, process_kill_events, cld, &current_live_processes);
+    }
+    for (i = 0; i < current_live_processes; i++) {
+	ap_log_error(APLOG_MARK,APLOG_ERR|APLOG_NOERRNO, server_conf,
+ 	    "forcing termination of child #%d (handle %d)", i, process_handles[i]);
+	TerminateProcess((HANDLE) process_handles[i], 1);
+    }
+
+    CloseHandle(signal_restart_event);
+    CloseHandle(signal_shutdown_event);
+
+    /* cleanup pid file on normal shutdown */
+    {
+	const char *pidfile = NULL;
+	pidfile = ap_server_root_relative (pparent, ap_pid_fname);
+	if ( pidfile != NULL && unlink(pidfile) == 0)
+	    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO,
+			 server_conf,
+			 "removed PID file %s (pid=%ld)",
+			 pidfile, (long)getpid());
+    }
+
+    if (pparent) {
+	ap_destroy_pool(pparent);
+    }
+
+    ap_destroy_mutex(start_mutex);
+    return (0);
+}
+#endif
+
+/*
+ * Send signal to a running Apache. On entry signal should contain
+ * either "shutdown" or "restart"
+ */
+
+int send_signal(pool *p, char *signal)
+{
+    char prefix[20];
+    FILE *fp;
+    int nread;
+    char *fname;
+    int end;
+
+    fname = ap_server_root_relative (p, ap_pid_fname);
+
+    fp = fopen(fname, "r");
+    if (!fp) {
+	printf("Cannot read apache PID file %s\n", fname);
+        return FALSE;
+    }
+    prefix[0] = 'a';
+    prefix[1] = 'p';
+
+    nread = fread(prefix+2, 1, sizeof(prefix)-3, fp);
+    if (nread == 0) {
+	fclose(fp);
+	printf("PID file %s was empty\n", fname);
+        return FALSE;
+    }
+    fclose(fp);
+
+    /* Terminate the prefix string */
+    end = 2 + nread - 1;
+    while (end > 0 && (prefix[end] == '\r' || prefix[end] == '\n'))
+	end--;
+    prefix[end + 1] = '\0';
+
+    setup_signal_names(prefix);
+
+    if (!strcasecmp(signal, "shutdown"))
+	ap_start_shutdown();
+    else if (!strcasecmp(signal, "restart"))
+	ap_start_restart(1);
+    else {
+	printf("Unknown signal name \"%s\". Use either shutdown or restart.\n",
+	    signal);
+        return FALSE;
+    }
+    return TRUE;
+}
+
+void post_parse_init()
+{
+    ap_set_version();
+    ap_init_modules(pconf, server_conf);
+    ap_suexec_enabled = init_suexec();
+    version_locked++;
+    ap_open_logs(server_conf, plog);
+    set_group_privs();
+}
+
+
+#ifdef NETWARE
+extern char *optarg;
+
+void signal_handler(int sig)
+{
+    switch (sig) {
+    case SIGTERM:
+        shutdown_pending = 1;
+
+        while(!ap_main_finished)
+            ThreadSwitchWithDelay();
+
+        break;
+    }
+    return;
+}
+#endif
+
+#if defined(NETWARE)
+int apache_main(int argc, char *argv[])
+#elif defined(WIN32)
+ __declspec(dllexport)
+int apache_main(int argc, char *argv[])
+#else
+int REALMAIN(int argc, char *argv[]) 
+#endif
+{
+    int c;
+    int child = 0;
+    char *cp;
+    char *s;
+    int conf_specified = 0;
+    
+#ifdef WIN32
+    jmp_buf reparse_args;
+    char *service_name = NULL;
+    int install = 0;
+    int reparsed = 0;
+    int is_child_of_service = 0;
+    char *signal_to_send = NULL;
+
+    /* Service application under WinNT the first time through only...
+     * service_main immediately resets real_exit_code to zero
+     */
+    if (real_exit_code && isWindowsNT()) 
+    {
+        if (((argc == 1) && isProcessService()) 
+            || ((argc == 2) && !strcmp(argv[1], "--ntservice")))
+        {
+            service_main(apache_main, argc, argv);
+            /* this was the end of the service control thread... 
+             * cleanups already ran when second thread of apache_main
+             * terminated, so simply...
+             */
+            exit(0);
+        }
+    }
+
+    /* This behavior is voided by setting real_exit_code to 0 */
+    atexit(hold_console_open_on_error);
+#endif
+
+#ifdef NETWARE
+    int currentScreen = GetCurrentScreen();
+    /* If top_module is not NULL then APACHEC was not exited cleanly
+     * and is in a bad state.  Simply clean up and exit.
+     */
+    check_clean_load (top_module);
+    init_name_space();
+    signal(SIGTERM, signal_handler);
+    atexit(clean_shutdown_on_exit);
+    init_tsd();
+#endif
+
+    /* Console application or a child process. */
+
+    if ((s = strrchr(argv[0], PATHSEPARATOR)) != NULL) {
+        ap_server_argv0 = ++s;
+    }
+    else {
+        ap_server_argv0 = argv[0];
+    }
+
+    common_init();
+    ap_setup_prelinked_modules();
+
+    /* initialize ap_server_root to the directory of the executable, in case
+     * the user chooses a relative path for the -d serverroot arg a bit later
+     */
+
+#ifdef NETWARE
+    if(!*ap_server_root) {
+        ap_cpystrn(ap_server_root, bslash2slash(remove_filename(argv[0])),
+                   sizeof(ap_server_root));
+    }
+#endif
+
+#ifdef WIN32
+    if(!*ap_server_root) {
+        if (GetModuleFileName(NULL, ap_server_root, sizeof(ap_server_root))) {
+            ap_cpystrn(ap_server_root,
+                       ap_os_canonical_filename(pcommands, ap_server_root), 
+                       sizeof(ap_server_root));
+            if (ap_os_is_path_absolute(ap_server_root) 
+                    && strchr(ap_server_root, '/'))
+                *strrchr(ap_server_root, '/') = '\0';
+            else 
+                *ap_server_root = '\0';
+        }
+    }
+#endif
+
+    /* Fallback position if argv[0] wasn't deciphered
+     */
+    if (!*ap_server_root)
+        ap_cpystrn(ap_server_root, HTTPD_ROOT, sizeof(ap_server_root));
+
+    chdir (ap_server_root);
+
+#ifdef WIN32
+    /* If this is a service, we will need to fall back here and 
+     * reparse the entire options list.
+     */
+    if (setjmp(reparse_args)) {
+        /* Reset and reparse the command line */
+        ap_server_pre_read_config  = ap_make_array(pcommands, 1, sizeof(char *));
+        ap_server_post_read_config = ap_make_array(pcommands, 1, sizeof(char *));
+        ap_server_config_defines   = ap_make_array(pcommands, 1, sizeof(char *));
+
+        /* Reset optreset and optind to allow getopt to work correctly
+         * the second time around, and assure we never come back here.
+         */
+        optreset = 1;
+        optind = 1;
+        reparsed = 1;
+    }
+
+    while ((c = getopt(argc, argv, "D:C:c:Xd:f:vVlLz:Z:wiuStThk:n:W:")) != -1) {
+#else /* !WIN32 */
+    while ((c = getopt(argc, argv, "D:C:c:Xd:Ff:vVlLesStTh")) != -1) {
+#endif
+        char **new;
+	switch (c) {
+	case 'c':
+	    new = (char **)ap_push_array(ap_server_post_read_config);
+	    *new = ap_pstrdup(pcommands, optarg);
+	    break;
+	case 'C':
+	    new = (char **)ap_push_array(ap_server_pre_read_config);
+	    *new = ap_pstrdup(pcommands, optarg);
+	    break;
+	case 'D':
+	    new = (char **)ap_push_array(ap_server_config_defines);
+	    *new = ap_pstrdup(pcommands, optarg);
+	    break;
+#ifdef WIN32
+        /* Shortcuts; include the -w option to hold the window open on error.
+         * This must not be toggled once we reset real_exit_code to 0!
+         */
+        case 'w':
+            if (real_exit_code)
+                real_exit_code = 2;
+            break;
+	/* service children must be created with the -z option,
+	 * while console mode (interactive apache) children are created
+	 * with the -Z option
+	 */
+        case 'z':
+            is_child_of_service = 1;
+        case 'Z':
+            /* Prevent holding open the (nonexistant) console */
+            real_exit_code = 0;
+	    exit_event = open_event(optarg);
+	    APD2("child: opened process event %s", optarg);
+	    cp = strchr(optarg, '_');
+	    ap_assert(cp);
+	    *cp = 0;
+	    setup_signal_names(optarg);
+	    start_mutex = ap_open_mutex(signal_name_prefix);
+	    ap_assert(start_mutex);
+	    child = 1;
+	    break;
+        case 'n':
+            service_name = ap_pstrdup(pcommands, optarg);
+            break;
+	case 'i':
+            install = 2;
+	    break;
+	case 'u':
+            install = -1;
+	    break;
+	case 'k':
+            if (!strcasecmp(optarg, "stop"))
+                signal_to_send = "shutdown";
+            else if (!strcasecmp(optarg, "install"))
+                install = 2;
+            else if (!strcasecmp(optarg, "config"))
+                install = 1;
+            else if (!strcasecmp(optarg, "uninstall"))
+                install = -1;
+            else
+                signal_to_send = optarg;
+	    break;
+        case 'W':
+            /* -With a dependent service */
+            if (install < 1) {
+	        fprintf(stderr, "%s: invalid option: -W %s ignored\n"
+                        "\t-W only modifies -k install or -k config\n",
+                        argv[0], optarg);
+            }
+            else if (!isWindowsNT()) {
+                fprintf(stderr, "%s: invalid option: -W %s ignored\n"
+                        "\t-W is only supported for Windows NT/2000\n",
+                        argv[0], optarg);
+            }
+            break;
+#endif /* WIN32 */
+#ifdef NETWARE
+        case 'e':
+            {
+                int screenHandle;  
+
+                /* Get a screen handle for the console screen. */
+                if ((screenHandle = CreateScreen("System Console", 0)) != NULL)
+                {
+                    SetAutoScreenDestructionMode(1); 
+                    SetCurrentScreen(screenHandle);  /* switch to console screen I/O */
+                }
+            }
+            break;
+        case 's':
+            if (DestroyScreen(GetCurrentScreen()) == 0)
+            {
+                int screenHandle;  
+
+                /* Create a screen handle for the console screen, 
+                even though the console screen exists. */
+                if ((screenHandle = CreateScreen("System Console", 0)) != NULL)
+                {
+                    SetCurrentScreen(screenHandle);  /* switch to console screen I/O */
+                    currentScreen = GetCurrentScreen();
+                }
+            }
+            break;
+#endif
+	case 'S':
+	    ap_dump_settings = 1;
+	    break;
+	case 'd':
+            optarg = ap_os_canonical_filename(pcommands, optarg);
+            if (!ap_os_is_path_absolute(optarg)) {
+	        optarg = ap_pstrcat(pcommands, ap_server_root, "/", 
+                                    optarg, NULL);
+            }
+            ap_cpystrn(ap_server_root, optarg, sizeof(ap_server_root));
+            ap_getparents(ap_server_root);
+            ap_no2slash(ap_server_root);
+            if (ap_server_root[0] 
+                    && ap_server_root[strlen(ap_server_root) - 1] == '/')
+                ap_server_root[strlen(ap_server_root) - 1] = '\0';
+	    break;
+#ifndef WIN32
+	case 'F':
+	    do_detach = 0;
+	    break;
+#endif
+	case 'f':
+            ap_cpystrn(ap_server_confname,
+                       ap_os_canonical_filename(pcommands, optarg),
+                       sizeof(ap_server_confname));
+            conf_specified = 1;
+	    break;
+	case 'v':
+	    ap_set_version();
+	    printf("Server version: %s\n", ap_get_server_version());
+	    printf("Server built:   %s\n", ap_get_server_built());
+#ifdef WIN32
+            clean_parent_exit(1);
+#else
+            clean_parent_exit(0);
+#endif
+
+        case 'V':
+	    ap_set_version();
+	    show_compile_settings();
+#ifdef WIN32
+            clean_parent_exit(1);
+#else
+            clean_parent_exit(0);
+#endif
+
+	case 'l':
+	    ap_show_modules();
+#ifdef WIN32
+            clean_parent_exit(1);
+#else
+            clean_parent_exit(0);
+#endif
+
+	case 'L':
+	    ap_show_directives();
+#ifdef WIN32
+            clean_parent_exit(1);
+#else
+            clean_parent_exit(0);
+#endif
+
+	case 'X':
+	    ++one_process;	/* Weird debugging mode. */
+	    break;
+	case 't':
+	    ap_configtestonly = 1;
+	    ap_docrootcheck = 1;
+	    break;
+	case 'T':
+	    ap_configtestonly = 1;
+	    ap_docrootcheck = 0;
+	    break;
+	case 'h':
+	    usage(ap_server_argv0);
+	case '?':
+	    usage(ap_server_argv0);
+        }   /* switch */
+#ifdef NETWARE
+        ThreadSwitch();
+#endif
+    }       /* while  */
+
+#ifdef WIN32
+
+    if (!service_name && install) {
+        service_name = DEFAULTSERVICENAME;
+    }
+
+    if (service_name) {
+        service_name = get_display_name(service_name);
+    }
+
+    if (service_name && isValidService(service_name)) 
+    {
+        if (install == 2) {
+            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, NULL,
+                         "Service \"%s\" is already installed!", service_name);
+            clean_parent_exit(1);
+        }
+        /* Don't proceed if we are configuring, uninstalling 
+         * or already merged and reparsed the service args
+         */
+        if (!install && !reparsed)
+        {
+            int svcargc;
+            char **newargv, **svcargv;
+            if (ap_configtestonly)
+                fprintf(stderr, "Default command options for service %s:\n", 
+                        service_name);
+                    
+            /* Merge the service's default args */
+            if (ap_registry_get_service_args(pcommands, &svcargc, &svcargv, 
+                                             service_name) > 0) {
+                newargv = (char**)malloc((svcargc + argc + 1) * sizeof(char*));
+                newargv[0] = argv[0];  /* The true executable name */
+                memcpy(newargv + 1, svcargv, svcargc * sizeof(char*)); 
+                memcpy(newargv + 1 + svcargc, argv + 1, 
+                       (argc - 1) * sizeof(char*));
+                argc += svcargc; /* Add the startup options args */
+                argv = newargv;
+                argv[argc] = NULL;
+
+                if (ap_configtestonly) {
+                    while (svcargc-- > 0) {
+                        if ((**svcargv == '-') && strchr("dfDCc", svcargv[0][1])
+                            && svcargc) {
+                            fprintf(stderr, "    %s %s\n", 
+                                    *svcargv, *(svcargv + 1));
+                            svcargv += 2; --svcargc;
+                        }
+                        else
+                            fprintf(stderr, "    %s\n", *(svcargv++));
+                    }
+                }
+                /* Run through the command line args all over again */
+                longjmp(reparse_args, 1);
+            }
+            else if (ap_configtestonly)
+                fprintf (stderr, "    (none)\n");
+        }
+    }
+    else if (service_name && (install <= 1))
+    {
+        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, NULL,
+                     "Service \"%s\" is not installed!", service_name);
+        clean_parent_exit(1);
+    }
+#endif
+
+    /* ServerRoot/ServerConfFile are found in this order:
+     * (1) serverroot set to Apache.exe's path, or HTTPD_ROOT if unparsable
+     * (2) arguments are grabbed for the -n named service, if given
+     * (3) the -d argument is taken from the given command line
+     * (4) the -d argument is taken from the service's default args
+     * (5) the -f argument is taken from the given command line
+     * (6) the -f argument is taken from the service's default args
+     * (7) if -f is omitted, then initialized to SERVER_CONFIG_FILE
+     * (8) if ap_server_confname is not absolute, then merge it to serverroot
+     */
+    
+    if (!conf_specified)
+        ap_cpystrn(ap_server_confname, SERVER_CONFIG_FILE, sizeof(ap_server_confname));
+
+    if (!ap_os_is_path_absolute(ap_server_confname))
+        ap_cpystrn(ap_server_confname,
+                   ap_server_root_relative(pcommands, ap_server_confname),
+                   sizeof(ap_server_confname));
+    ap_getparents(ap_server_confname);
+    ap_no2slash(ap_server_confname);
+    
+#ifdef WIN32
+    /* Read the conf now unless we are uninstalling the service,
+     * or shutting down a running service 
+     * (but do read the conf for the pidfile if we shutdown the console)
+     */
+    if ((install >= 0) && (!service_name || !signal_to_send 
+                            || strcasecmp(signal_to_send,"shutdown"))) {
+        server_conf = ap_read_config(pconf, ptrans, ap_server_confname);
+    }
+
+    if (install) {
+        if (install > 0) 
+            InstallService(pconf, service_name, argc, argv, install == 1);
+        else
+            RemoveService(service_name);
+        clean_parent_exit(0);
+    }
+
+    /* All NT signals, and all but the 9x start signal are handled entirely.
+     * Die if we failed, are on NT, or are not "start"ing the service
+     */
+    if (service_name && signal_to_send) {
+        if (send_signal_to_service(service_name, signal_to_send, argc, argv))
+            clean_parent_exit(0);
+        if (isWindowsNT() || strcasecmp(signal_to_send, "start"))
+            clean_parent_exit(1);
+        /* Still here?  Then we are hanging around to detach the console 
+         * and use this process as the Windows 9x service.
+         */
+    }
+#else /* ndef WIN32 */
+    server_conf = ap_read_config(pconf, ptrans, ap_server_confname);
+#endif
+
+    if (ap_configtestonly) {
+        fprintf(stderr, "%s: Syntax OK\n", ap_server_root_relative(pcommands, ap_server_confname));
+#ifdef WIN32
+        clean_parent_exit(1);
+#else
+        clean_parent_exit(0);
+#endif
+    }
+
+    if (ap_dump_settings) {
+#ifdef WIN32
+        clean_parent_exit(1);
+#else
+        clean_parent_exit(0);
+#endif
+    }
+
+#ifdef WIN32
+    /* Non-service Signals.  (Ignore -k start for now [with or without -n arg]) */
+    if (signal_to_send && strcasecmp(signal_to_send, "start")) {
+        send_signal(pconf, signal_to_send);
+        clean_parent_exit(0);
+    }
+#endif
+
+#ifndef NETWARE
+    if (!child && !ap_dump_settings) { 
+        ap_log_pid(pconf, ap_pid_fname);
+    }
+#endif
+
+    post_parse_init();
+
+#if defined(OS2)
+    printf("%s running...\n", ap_get_server_version());
+#elif defined(WIN32)
+    if (!child) {
+        printf("%s running...\n", ap_get_server_version());
+    }
+#elif defined(NETWARE)
+    if (currentScreen != GetCurrentScreen()) {
+        SetCurrentScreen(currentScreen);  /* switch to console screen I/O */
+        SetAutoScreenDestructionMode(0); 
+    }
+
+    printf("%s running...\n", ap_get_server_version());
+#endif
+
+#ifndef NETWARE
+    if (one_process && !exit_event)
+	exit_event = create_event(0, 0, NULL);
+    if (one_process && !start_mutex)
+	start_mutex = ap_create_mutex(NULL);
+#endif
+
+#ifdef NETWARE
+    worker_main();
+    destroy_semaphore(allowed_globals.jobsemaphore);
+
+    while((ap_thread_count) || (!shutdown_pending))
+        ThreadSwitchWithDelay();
+#else 
+    /*
+     * In the future, the main will spawn off a couple
+     * of children and monitor them. As soon as a child
+     * exits, it spawns off a new one
+     */
+    if (child || one_process) {
+	if (!exit_event || !start_mutex)
+	    exit(-1);
+#ifdef WIN32
+        if (child)
+            ap_start_child_console(is_child_of_service);
+        else
+            ap_start_console_monitor();
+#endif
+	worker_main();
+	ap_destroy_mutex(start_mutex);
+	destroy_event(exit_event);
+    } 
+#ifdef WIN32
+    /* Windows NT service second time around ... we have all the overrides 
+     * from the NT SCM, so go to town and return to the SCM when we quit.
+     */
+    if (isWindowsNT() && isProcessService())
+    {
+        master_main(argc, argv);
+    }
+    else if (service_name && signal_to_send && !isWindowsNT()
+             && !strcasecmp(signal_to_send, "start")) {
+        /* service95_main will call master_main() */
+        service95_main(master_main, argc, argv, service_name);
+    }
+    else 
+    {
+	/* Let's go fishing for some signals including ctrl+c, ctrl+break,
+         * logoff, close and shutdown, while the server is running
+	 */
+	ap_start_console_monitor();
+        master_main(argc, argv);
+    }
+#else /* ndef WIN32 */
+    else 
+    {
+        master_main(argc, argv);
+    }
+#endif /* ndef WIN32 */
+#endif /* ndef NETWARE */
+
+    clean_parent_exit(0);
+    return 0;	/* purely to avoid a warning */
+}
+
+#endif /* ndef MULTITHREAD */
+
+#else  /* ndef SHARED_CORE_TIESTATIC */
+
+/*
+**  Standalone Tie Program for Shared Core support
+**
+**  It's purpose is to tie the static libraries and 
+**  the shared core library under link-time and  
+**  passing execution control to the real main function
+**  in the shared core library under run-time.
+*/
+
+extern int ap_main(int argc, char *argv[]);
+
+int main(int argc, char *argv[]) 
+{
+    return ap_main(argc, argv);
+}
+
+#endif /* ndef SHARED_CORE_TIESTATIC */
+#else  /* ndef SHARED_CORE_BOOTSTRAP */
+
+#if defined(OS2) || defined(CYGWIN)
+/* Shared core loader for OS/2 and Cygwin */
+
+#if defined(CYGWIN)
+__declspec(dllimport) 
+#endif
+
+
+int ap_main(int argc, char *argv[]); /* Load time linked from cyghttpd.dll */
+
+int main(int argc, char *argv[])
+{
+    return ap_main(argc, argv);
+}
+
+#else
+
+/*
+**  Standalone Bootstrap Program for Shared Core support
+**
+**  It's purpose is to initialise the LD_LIBRARY_PATH
+**  environment variable therewith the Unix loader is able
+**  to start the Standalone Tie Program (see above)
+**  and then replacing itself with this program by
+**  immediately passing execution to it.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "ap_config.h"
+#include "httpd.h"
+
+#if defined(HPUX) || defined(HPUX10) || defined(HPUX11)
+#define VARNAME "SHLIB_PATH"
+#else
+#define VARNAME "LD_LIBRARY_PATH"
+#endif
+
+#ifndef SHARED_CORE_DIR 
+#define SHARED_CORE_DIR HTTPD_ROOT "/libexec"
+#endif
+
+#ifndef SHARED_CORE_EXECUTABLE_PROGRAM
+#define SHARED_CORE_EXECUTABLE_PROGRAM "lib" TARGET ".ep"
+#endif
+
+extern char *optarg;
+extern int   optind;
+
+int main(int argc, char *argv[], char *envp[]) 
+{
+    char prog[MAX_STRING_LEN];
+    char llp_buf[MAX_STRING_LEN];
+    char **llp_slot;
+    char *llp_existing;
+    char *llp_dir;
+    char **envpnew;
+    int c, i, l;
+
+#ifdef MPE
+    /*
+     * MPE doesn't currently initialize the envp parameter.  Instead, we must
+     * use the global variable environ. 
+     */
+    envp = environ;
+#endif
+	
+    /* 
+     * parse argument line, 
+     * but only handle the -L option 
+     */
+    llp_dir = SHARED_CORE_DIR;
+    while ((c = getopt(argc, argv, "D:C:c:Xd:Ff:vVlLR:SZ:tTh")) != -1) {
+	switch (c) {
+	case 'D':
+	case 'C':
+	case 'c':
+	case 'X':
+	case 'd':
+	case 'F':
+	case 'f':
+	case 'v':
+	case 'V':
+	case 'l':
+	case 'L':
+	case 'S':
+	case 'Z':
+	case 't':
+	case 'T':
+	case 'h':
+	case '?':
+	    break;
+	case 'R':
+	    llp_dir = strdup(optarg);
+	    break;
+	}
+    }
+
+#ifdef MPE
+    /*
+     * MPE doesn't currently initialize the envp parameter.  Instead, we must
+     * use the global variable environ. 
+     */
+    envp = environ;
+#endif
+	
+    /* 
+     * create path to SHARED_CORE_EXECUTABLE_PROGRAM
+     */
+    ap_snprintf(prog, sizeof(prog), "%s/%s", llp_dir, SHARED_CORE_EXECUTABLE_PROGRAM);
+
+    /* 
+     * adjust process environment therewith the Unix loader 
+     * is able to start the SHARED_CORE_EXECUTABLE_PROGRAM.
+     */
+    llp_slot = NULL;
+    llp_existing = NULL;
+    l = strlen(VARNAME);
+    for (i = 0; envp[i] != NULL; i++) {
+	if (strncmp(envp[i], VARNAME "=", l+1) == 0) {
+	    llp_slot = &envp[i];
+	    llp_existing = strchr(envp[i], '=') + 1;
+	}
+    }
+    if (llp_slot == NULL) {
+	envpnew = (char **)malloc(sizeof(char *)*(i + 2));
+	if (envpnew == NULL) {
+	    fprintf(stderr, "Ouch!  Out of memory generating envpnew!\n");
+	}
+	memcpy(envpnew, envp, sizeof(char *)*i);
+	envp = envpnew;
+	llp_slot = &envp[i++];
+	envp[i] = NULL;
+    }
+    if (llp_existing != NULL)
+	 ap_snprintf(llp_buf, sizeof(llp_buf), "%s=%s:%s", VARNAME, llp_dir, llp_existing);
+    else
+	 ap_snprintf(llp_buf, sizeof(llp_buf), "%s=%s", VARNAME, llp_dir);
+    *llp_slot = strdup(llp_buf);
+
+    /* 
+     * finally replace our process with 
+     * the SHARED_CORE_EXECUTABLE_PROGRAM
+     */
+    if (execve(prog, argv, envp) == -1) {
+	fprintf(stderr, 
+		"%s: Unable to exec Shared Core Executable Program `%s'\n",
+		argv[0], prog);
+	return 1;
+    }
+    else
+	return 0;
+}
+
+#endif /* def OS2 */
+#endif /* ndef SHARED_CORE_BOOTSTRAP */
+
+#ifndef SHARED_CORE_BOOTSTRAP
+#include "httpd.h"
+/*
+ * Force ap_validate_password() into the image so that modules like
+ * mod_auth can use it even if they're dynamically loaded.
+ */
+void suck_in_ap_validate_password(void);
+void suck_in_ap_validate_password(void)
+{
+    ap_validate_password("a", "b");
+}
+#endif
+
+/* force Expat to be linked into the server executable */
+#if defined(USE_EXPAT) && !defined(SHARED_CORE_BOOTSTRAP)
+#include "xmlparse.h"
+const XML_LChar *suck_in_expat(void);
+const XML_LChar *suck_in_expat(void)
+{
+    return XML_ErrorString(XML_ERROR_NONE);
+}
+#endif /* USE_EXPAT */
+
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/main/http_protocol.c apache_1.3.33/src/main/http_protocol.c
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/main/http_protocol.c	Thu Sep 16 01:45:18 2004
+++ apache_1.3.33/src/main/http_protocol.c	Mon Jul 18 15:22:25 2005
@@ -1172,6 +1172,10 @@
     r->status          = HTTP_REQUEST_TIME_OUT;  /* Until we get a request */
     r->the_request     = NULL;
 
+#ifdef EAPI
+    r->ctx = ap_ctx_new(r->pool);
+#endif /* EAPI */
+
 #ifdef CHARSET_EBCDIC
     ap_bsetflag(r->connection->client, B_ASCII2EBCDIC, r->ebcdic.conv_in  = 1);
     ap_bsetflag(r->connection->client, B_EBCDIC2ASCII, r->ebcdic.conv_out = 1);
@@ -1328,6 +1332,11 @@
     rnew->read_body       = REQUEST_NO_BODY;
 
     rnew->main = (request_rec *) r;
+
+#ifdef EAPI
+    rnew->ctx = r->ctx;
+#endif /* EAPI */
+
 }
 
 API_EXPORT(void) ap_finalize_sub_req_protocol(request_rec *sub)
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/main/http_protocol.c.orig apache_1.3.33/src/main/http_protocol.c.orig
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/main/http_protocol.c.orig	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/main/http_protocol.c.orig	Thu Sep 16 01:45:18 2004
@@ -0,0 +1,3140 @@
+/* Copyright 1999-2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * http_protocol.c --- routines which directly communicate with the client.
+ *
+ * Code originally by Rob McCool; much redone by Robert S. Thau
+ * and the Apache Group.
+ */
+
+#define CORE_PRIVATE
+#include "httpd.h"
+#include "http_config.h"
+#include "http_core.h"
+#include "http_protocol.h"
+#include "http_main.h"
+#include "http_request.h"
+#include "http_vhost.h"
+#include "http_log.h"           /* For errors detected in basic auth common
+                                 * support code... */
+#include "util_date.h"          /* For parseHTTPdate and BAD_DATE */
+#include <stdarg.h>
+#include "http_conf_globals.h"
+#include "util_md5.h"           /* For digestAuth */
+
+#define SET_BYTES_SENT(r) \
+  do { if (r->sent_bodyct) \
+          ap_bgetopt (r->connection->client, BO_BYTECT, &r->bytes_sent); \
+  } while (0)
+
+#ifdef CHARSET_EBCDIC
+/* Save & Restore the current conversion settings
+ * "input"  means: ASCII -> EBCDIC (when reading MIME Headers and PUT/POST data)
+ * "output" means: EBCDIC -> ASCII (when sending MIME Headers and Chunks)
+ */
+
+#define PUSH_EBCDIC_INPUTCONVERSION_STATE(_buff, _onoff) \
+        int _convert_in = ap_bgetflag(_buff, B_ASCII2EBCDIC); \
+        ap_bsetflag(_buff, B_ASCII2EBCDIC, _onoff);
+
+#define POP_EBCDIC_INPUTCONVERSION_STATE(_buff) \
+        ap_bsetflag(_buff, B_ASCII2EBCDIC, _convert_in);
+
+#define PUSH_EBCDIC_INPUTCONVERSION_STATE_r(_req, _onoff) \
+        ap_bsetflag(_req->connection->client, B_ASCII2EBCDIC, _onoff);
+
+#define POP_EBCDIC_INPUTCONVERSION_STATE_r(_req) \
+        ap_bsetflag(_req->connection->client, B_ASCII2EBCDIC, _req->ebcdic.conv_in);
+
+#define PUSH_EBCDIC_OUTPUTCONVERSION_STATE_r(_req, _onoff) \
+        ap_bsetflag(_req->connection->client, B_EBCDIC2ASCII, _onoff);
+
+#define POP_EBCDIC_OUTPUTCONVERSION_STATE_r(_req) \
+        ap_bsetflag(_req->connection->client, B_EBCDIC2ASCII, _req->ebcdic.conv_out);
+
+#endif /*CHARSET_EBCDIC*/
+
+/*
+ * Builds the content-type that should be sent to the client from the
+ * content-type specified.  The following rules are followed:
+ *    - if type is NULL, type is set to ap_default_type(r)
+ *    - if charset adding is disabled, stop processing and return type.
+ *    - then, if there are no parameters on type, add the default charset
+ *    - return type
+ */
+static const char *make_content_type(request_rec *r, const char *type) {
+    char *needcset[] = {
+	"text/plain",
+	"text/html",
+	NULL };
+    char **pcset;
+    core_dir_config *conf;
+
+    conf = (core_dir_config *)ap_get_module_config(r->per_dir_config,
+                                                   &core_module);
+    if (!type) {
+        type = ap_default_type(r);
+    }
+    if (conf->add_default_charset != ADD_DEFAULT_CHARSET_ON) {
+        return type;
+    }
+
+    if (ap_strcasestr(type, "charset=") != NULL) {
+	/* already has parameter, do nothing */
+	/* XXX we don't check the validity */
+	;
+    }
+    else {
+    	/* see if it makes sense to add the charset. At present,
+	 * we only add it if the Content-type is one of needcset[]
+	 */
+	for (pcset = needcset; *pcset ; pcset++) {
+	    if (ap_strcasestr(type, *pcset) != NULL) {
+		type = ap_pstrcat(r->pool, type, "; charset=", 
+                                  conf->add_default_charset_name, NULL);
+		break;
+	    }
+        }
+    }
+    return type;
+}
+
+enum byterange_token {
+    BYTERANGE_OK,
+    BYTERANGE_EMPTY,
+    BYTERANGE_BADSYNTAX,
+    BYTERANGE_UNSATISFIABLE
+};
+
+static enum byterange_token
+    parse_byterange(request_rec *r, long *start, long *end)
+{
+    /* parsing first, semantics later */
+
+    while (ap_isspace(*r->range))
+        ++r->range;
+
+    /* check for an empty range, which is OK */
+    if (*r->range == '\0') {
+	return BYTERANGE_EMPTY;
+    }
+    else if (*r->range == ',') {
+	++r->range;
+	return BYTERANGE_EMPTY;
+    }
+
+    if (ap_isdigit(*r->range))
+	*start = ap_strtol(r->range, (char **)&r->range, 10);
+    else
+	*start = -1;
+
+    while (ap_isspace(*r->range))
+        ++r->range;
+
+    if (*r->range != '-')
+	return BYTERANGE_BADSYNTAX;
+    ++r->range;
+
+    while (ap_isspace(*r->range))
+        ++r->range;
+
+    if (ap_isdigit(*r->range))
+	*end = ap_strtol(r->range, (char **)&r->range, 10);
+    else
+	*end = -1;
+
+    while (ap_isspace(*r->range))
+        ++r->range;
+
+    /* check the end of the range */
+    if (*r->range == ',') {
+	++r->range;
+    }
+    else if (*r->range != '\0') {
+	return BYTERANGE_BADSYNTAX;
+    }
+
+    /* parsing done; now check the numbers */
+
+    if (*start < 0) { /* suffix-byte-range-spec */
+	if (*end < 0) /* no numbers */
+	    return BYTERANGE_BADSYNTAX;
+	*start = r->clength - *end;
+	if (*start < 0)
+	    *start = 0;
+	*end = r->clength - 1;
+    }
+    else {
+	if (*end >= 0 && *start > *end) /* out-of-order range */
+	    return BYTERANGE_BADSYNTAX;
+	if (*end < 0 || *end >= r->clength)
+	    *end = r->clength - 1;
+    }
+    /* RFC 2616 is somewhat unclear about what we should do if the end
+     * is missing and the start is after the clength. The robustness
+     * principle says we should accept it as an unsatisfiable range.
+     * We accept suffix-byte-range-specs like -0 for the same reason.
+     */
+    if (*start >= r->clength)
+	return BYTERANGE_UNSATISFIABLE;
+
+    return BYTERANGE_OK;
+}
+
+/* If this function is called with output=1, it will spit out the
+ * correct headers for a byterange chunk. If output=0 it will not
+ * output anything but just return the number of bytes it would have
+ * output. If start or end are less than 0 then it will do a byterange
+ * chunk trailer instead of a header.
+ */
+static int byterange_boundary(request_rec *r, long start, long end, int output)
+{
+    int length = 0;
+
+#ifdef CHARSET_EBCDIC
+    /* determine current setting of conversion flag,
+     * set to ON (protocol strings MUST be converted)
+     * and reset to original setting before returning
+     */
+    PUSH_EBCDIC_OUTPUTCONVERSION_STATE_r(r, 1);
+#endif /*CHARSET_EBCDIC*/
+
+    if (start < 0 || end < 0) {
+	if (output)
+	    ap_rvputs(r, CRLF "--", r->boundary, "--" CRLF, NULL);
+	else
+	    length = 4 + strlen(r->boundary) + 4;
+    }
+    else {
+	const char *ct = make_content_type(r, r->content_type);
+	char ts[MAX_STRING_LEN];
+
+	ap_snprintf(ts, sizeof(ts), "%ld-%ld/%ld", start, end, r->clength);
+	if (output)
+	    ap_rvputs(r, CRLF "--", r->boundary, CRLF "Content-type: ",
+		      ct, CRLF "Content-range: bytes ", ts, CRLF CRLF,
+		      NULL);
+	else
+	    length = 4 + strlen(r->boundary) + 16
+		+ strlen(ct) + 23 + strlen(ts) + 4;
+    }
+
+#ifdef CHARSET_EBCDIC
+    POP_EBCDIC_OUTPUTCONVERSION_STATE_r(r);
+#endif /*CHARSET_EBCDIC*/
+
+    return length;
+}
+
+API_EXPORT(int) ap_set_byterange(request_rec *r)
+{
+    const char *range, *if_range, *match;
+    long length, start, end, one_start = 0, one_end = 0;
+    int ranges, empty;
+    
+    if (!r->clength || r->assbackwards)
+        return 0;
+
+    /* Check for Range request-header (HTTP/1.1) or Request-Range for
+     * backwards-compatibility with second-draft Luotonen/Franks
+     * byte-ranges (e.g. Netscape Navigator 2-3).
+     *
+     * We support this form, with Request-Range, and (farther down) we
+     * send multipart/x-byteranges instead of multipart/byteranges for
+     * Request-Range based requests to work around a bug in Netscape
+     * Navigator 2-3 and MSIE 3.
+     */
+
+    if (!(range = ap_table_get(r->headers_in, "Range")))
+        range = ap_table_get(r->headers_in, "Request-Range");
+
+    if (!range || strncasecmp(range, "bytes=", 6) || (r->status != HTTP_OK)) {
+        return 0;
+    }
+    range += 6;
+
+    /* Check the If-Range header for Etag or Date.
+     * Note that this check will return false (as required) if either
+     * of the two etags are weak.
+     */
+    if ((if_range = ap_table_get(r->headers_in, "If-Range"))) {
+        if (if_range[0] == '"') {
+            if (!(match = ap_table_get(r->headers_out, "Etag")) ||
+                (strcmp(if_range, match) != 0))
+                return 0;
+        }
+        else if (!(match = ap_table_get(r->headers_out, "Last-Modified")) ||
+                 (strcmp(if_range, match) != 0))
+            return 0;
+    }
+
+    /*
+     * Parse the byteranges, counting how many of them there are and
+     * the total number of bytes we will send to the client. This is a
+     * dummy run for the while(ap_each_byterange()) loop that the
+     * caller will perform if we return 1.
+     */
+    r->range = range;
+    r->boundary = ap_psprintf(r->pool, "%lx%lx",
+			      r->request_time, (long) getpid());
+    length = 0;
+    ranges = 0;
+    empty = 1;
+    do {
+	switch (parse_byterange(r, &start, &end)) {
+	case BYTERANGE_UNSATISFIABLE:
+	    empty = 0;
+	    break;
+	default:
+	    /* be more defensive here? */
+	case BYTERANGE_BADSYNTAX:
+	    r->boundary = NULL;
+	    r->range = NULL;
+	    return 0;
+	case BYTERANGE_EMPTY:
+	    break;
+	case BYTERANGE_OK:
+	    ++ranges;
+	    length += byterange_boundary(r, start, end, 0)
+		+ end - start + 1;
+	    /* save in case of unsatisfiable ranges */
+	    one_start = start;
+	    one_end = end;
+	    break;
+	}
+    } while (*r->range != '\0');
+
+    if (ranges == 0) {
+	/* no ranges or only unsatisfiable ranges */
+	if (empty || if_range) {
+	    r->boundary = NULL;
+	    r->range = NULL;
+	    return 0;
+	}
+	else {
+	    ap_table_setn(r->headers_out, "Content-Range",
+		ap_psprintf(r->pool, "bytes */%ld", r->clength));
+	    ap_set_content_length(r, 0);			  
+	    r->boundary = NULL;
+	    r->range = range;
+	    r->header_only = 1;
+	    r->status = HTTP_RANGE_NOT_SATISFIABLE;
+	    return 1;
+	}
+    }
+    else if (ranges == 1) {
+	/* simple handling of a single range -- no boundaries */
+        ap_table_setn(r->headers_out, "Content-Range",
+	    ap_psprintf(r->pool, "bytes %ld-%ld/%ld",
+		one_start, one_end, r->clength));
+	ap_table_setn(r->headers_out, "Content-Length",
+	    ap_psprintf(r->pool, "%ld", one_end - one_start + 1));
+	r->boundary = NULL;
+	r->byterange = 1;
+	r->range = range;
+	r->status = PARTIAL_CONTENT;
+	return 1;
+    }
+    else {
+	/* multiple ranges */
+	length += byterange_boundary(r, -1, -1, 0);
+	ap_table_setn(r->headers_out, "Content-Length",
+	    ap_psprintf(r->pool, "%ld", length));
+	r->byterange = 2;
+	r->range = range;
+	r->status = PARTIAL_CONTENT;
+	return 1;
+    }
+}
+
+API_EXPORT(int) ap_each_byterange(request_rec *r, long *offset, long *length)
+{
+    long start, end;
+
+    do {
+	if (parse_byterange(r, &start, &end) == BYTERANGE_OK) {
+	    if (r->byterange > 1)
+		byterange_boundary(r, start, end, 1);
+	    *offset = start;
+	    *length = end - start + 1;
+	    return 1;
+	}
+    } while (*r->range != '\0');
+    if (r->byterange > 1)
+	byterange_boundary(r, -1, -1, 1);
+    return 0;
+}
+
+API_EXPORT(int) ap_set_content_length(request_rec *r, long clength)
+{
+    r->clength = clength;
+    ap_table_setn(r->headers_out, "Content-Length", ap_psprintf(r->pool, "%ld", clength));
+    return 0;
+}
+
+API_EXPORT(int) ap_set_keepalive(request_rec *r)
+{
+    int ka_sent = 0;
+    int wimpy = ap_find_token(r->pool,
+                           ap_table_get(r->headers_out, "Connection"), "close");
+    const char *conn = ap_table_get(r->headers_in, "Connection");
+
+    /* The following convoluted conditional determines whether or not
+     * the current connection should remain persistent after this response
+     * (a.k.a. HTTP Keep-Alive) and whether or not the output message
+     * body should use the HTTP/1.1 chunked transfer-coding.  In English,
+     *
+     *   IF  we have not marked this connection as errored;
+     *   and the response body has a defined length due to the status code
+     *       being 304 or 204, the request method being HEAD, already
+     *       having defined Content-Length or Transfer-Encoding: chunked, or
+     *       the request version being HTTP/1.1 and thus capable of being set
+     *       as chunked [we know the (r->chunked = 1) side-effect is ugly];
+     *   and the server configuration enables keep-alive;
+     *   and the server configuration has a reasonable inter-request timeout;
+     *   and there is no maximum # requests or the max hasn't been reached;
+     *   and the response status does not require a close;
+     *   and the response generator has not already indicated close;
+     *   and the client did not request non-persistence (Connection: close);
+     *   and    we haven't been configured to ignore the buggy twit
+     *       or they're a buggy twit coming through a HTTP/1.1 proxy
+     *   and    the client is requesting an HTTP/1.0-style keep-alive
+     *       or the client claims to be HTTP/1.1 compliant (perhaps a proxy);
+     *   THEN we can be persistent, which requires more headers be output.
+     *
+     * Note that the condition evaluation order is extremely important.
+     */
+    if ((r->connection->keepalive != -1) &&
+        ((r->status == HTTP_NOT_MODIFIED) ||
+         (r->status == HTTP_NO_CONTENT) ||
+         r->header_only ||
+         ap_table_get(r->headers_out, "Content-Length") ||
+         ap_find_last_token(r->pool,
+                         ap_table_get(r->headers_out, "Transfer-Encoding"),
+                         "chunked") ||
+         ((r->proto_num >= HTTP_VERSION(1,1)) &&
+	  (r->chunked = 1))) && /* THIS CODE IS CORRECT, see comment above. */
+        r->server->keep_alive &&
+        (r->server->keep_alive_timeout > 0) &&
+        ((r->server->keep_alive_max == 0) ||
+         (r->server->keep_alive_max > r->connection->keepalives)) &&
+        !ap_status_drops_connection(r->status) &&
+        !wimpy &&
+        !ap_find_token(r->pool, conn, "close") &&
+        (!ap_table_get(r->subprocess_env, "nokeepalive") ||
+         ap_table_get(r->headers_in, "Via")) &&
+        ((ka_sent = ap_find_token(r->pool, conn, "keep-alive")) ||
+         (r->proto_num >= HTTP_VERSION(1,1)))
+       ) {
+        int left = r->server->keep_alive_max - r->connection->keepalives;
+
+	/*
+	 * ap_set_keepalive could be called multiple times (eg: in
+	 * ap_die() followed by ap_send_http_header()) during this
+	 * one single request. To ensure that we don't incorrectly
+	 * increment the keepalives counter for each call, we
+	 * assume that only here do we set keepalive. So if keepalive
+	 * is already set to 1, we must have already been here and
+	 * we should not increment the keepalives counter since we
+	 * already done so for this request.
+	 */
+        if (r->connection->keepalive != 1) {
+            r->connection->keepalive = 1;
+            r->connection->keepalives++;
+	}
+
+        /* If they sent a Keep-Alive token, send one back */
+        if (ka_sent) {
+            if (r->server->keep_alive_max)
+		ap_table_setn(r->headers_out, "Keep-Alive",
+		    ap_psprintf(r->pool, "timeout=%d, max=%d",
+                            r->server->keep_alive_timeout, left));
+            else
+		ap_table_setn(r->headers_out, "Keep-Alive",
+		    ap_psprintf(r->pool, "timeout=%d",
+                            r->server->keep_alive_timeout));
+            ap_table_mergen(r->headers_out, "Connection", "Keep-Alive");
+        }
+
+        return 1;
+    }
+
+    /* Otherwise, we need to indicate that we will be closing this
+     * connection immediately after the current response.
+     *
+     * We only really need to send "close" to HTTP/1.1 clients, but we
+     * always send it anyway, because a broken proxy may identify itself
+     * as HTTP/1.0, but pass our request along with our HTTP/1.1 tag
+     * to a HTTP/1.1 client. Better safe than sorry.
+     */
+    if (!wimpy)
+	ap_table_mergen(r->headers_out, "Connection", "close");
+
+    r->connection->keepalive = 0;
+
+    return 0;
+}
+
+/*
+ * Return the latest rational time from a request/mtime (modification time)
+ * pair.  We return the mtime unless it's in the future, in which case we
+ * return the current time.  We use the request time as a reference in order
+ * to limit the number of calls to time().  We don't check for futurosity
+ * unless the mtime is at least as new as the reference.
+ */
+API_EXPORT(time_t) ap_rationalize_mtime(request_rec *r, time_t mtime)
+{
+    time_t now;
+
+    /* For all static responses, it's almost certain that the file was
+     * last modified before the beginning of the request.  So there's
+     * no reason to call time(NULL) again.  But if the response has been
+     * created on demand, then it might be newer than the time the request
+     * started.  In this event we really have to call time(NULL) again
+     * so that we can give the clients the most accurate Last-Modified.  If we
+     * were given a time in the future, we return the current time - the
+     * Last-Modified can't be in the future.
+     */
+    now = (mtime < r->request_time) ? r->request_time : time(NULL);
+    return (mtime > now) ? now : mtime;
+}
+
+API_EXPORT(int) ap_meets_conditions(request_rec *r)
+{
+    const char *etag = ap_table_get(r->headers_out, "ETag");
+    const char *if_match, *if_modified_since, *if_unmodified, *if_nonematch;
+    time_t mtime;
+
+    /* Check for conditional requests --- note that we only want to do
+     * this if we are successful so far and we are not processing a
+     * subrequest or an ErrorDocument.
+     *
+     * The order of the checks is important, since ETag checks are supposed
+     * to be more accurate than checks relative to the modification time.
+     * However, not all documents are guaranteed to *have* ETags, and some
+     * might have Last-Modified values w/o ETags, so this gets a little
+     * complicated.
+     */
+
+    if (!ap_is_HTTP_SUCCESS(r->status) || r->no_local_copy) {
+        return OK;
+    }
+
+    mtime = (r->mtime != 0) ? r->mtime : time(NULL);
+
+    /* If an If-Match request-header field was given
+     * AND the field value is not "*" (meaning match anything)
+     * AND if our strong ETag does not match any entity tag in that field,
+     *     respond with a status of 412 (Precondition Failed).
+     */
+    if ((if_match = ap_table_get(r->headers_in, "If-Match")) != NULL) {
+        if (if_match[0] != '*' &&
+            (etag == NULL || etag[0] == 'W' ||
+             !ap_find_list_item(r->pool, if_match, etag))) {
+            return HTTP_PRECONDITION_FAILED;
+        }
+    }
+    else {
+        /* Else if a valid If-Unmodified-Since request-header field was given
+         * AND the requested resource has been modified since the time
+         * specified in this field, then the server MUST
+         *     respond with a status of 412 (Precondition Failed).
+         */
+        if_unmodified = ap_table_get(r->headers_in, "If-Unmodified-Since");
+        if (if_unmodified != NULL) {
+            time_t ius = ap_parseHTTPdate(if_unmodified);
+
+            if ((ius != BAD_DATE) && (mtime > ius)) {
+                return HTTP_PRECONDITION_FAILED;
+            }
+        }
+    }
+
+    /* If an If-None-Match request-header field was given
+     * AND the field value is "*" (meaning match anything)
+     *     OR our ETag matches any of the entity tags in that field, fail.
+     *
+     * If the request method was GET or HEAD, failure means the server
+     *    SHOULD respond with a 304 (Not Modified) response.
+     * For all other request methods, failure means the server MUST
+     *    respond with a status of 412 (Precondition Failed).
+     *
+     * GET or HEAD allow weak etag comparison, all other methods require
+     * strong comparison.  We can only use weak if it's not a range request.
+     */
+    if_nonematch = ap_table_get(r->headers_in, "If-None-Match");
+    if (if_nonematch != NULL) {
+        if (r->method_number == M_GET) {
+            if (if_nonematch[0] == '*')
+                return HTTP_NOT_MODIFIED;
+            if (etag != NULL) {
+                if (ap_table_get(r->headers_in, "Range")) {
+                    if (etag[0] != 'W' &&
+                        ap_find_list_item(r->pool, if_nonematch, etag)) {
+                        return HTTP_NOT_MODIFIED;
+                    }
+                }
+                else if (strstr(if_nonematch, etag)) {
+                    return HTTP_NOT_MODIFIED;
+                }
+            }
+        }
+        else if (if_nonematch[0] == '*' ||
+                 (etag != NULL &&
+                  ap_find_list_item(r->pool, if_nonematch, etag))) {
+            return HTTP_PRECONDITION_FAILED;
+        }
+    }
+    /* Else if a valid If-Modified-Since request-header field was given
+     * AND it is a GET or HEAD request
+     * AND the requested resource has not been modified since the time
+     * specified in this field, then the server MUST
+     *    respond with a status of 304 (Not Modified).
+     * A date later than the server's current request time is invalid.
+     */
+    else if ((r->method_number == M_GET)
+             && ((if_modified_since =
+                  ap_table_get(r->headers_in, "If-Modified-Since")) != NULL)) {
+        time_t ims = ap_parseHTTPdate(if_modified_since);
+
+        if ((ims >= mtime) && (ims <= r->request_time)) {
+            return HTTP_NOT_MODIFIED;
+        }
+    }
+    return OK;
+}
+
+/*
+ * Construct an entity tag (ETag) from resource information.  If it's a real
+ * file, build in some of the file characteristics.  If the modification time
+ * is newer than (request-time minus 1 second), mark the ETag as weak - it
+ * could be modified again in as short an interval.  We rationalize the
+ * modification time we're given to keep it from being in the future.
+ */
+API_EXPORT(char *) ap_make_etag(request_rec *r, int force_weak)
+{
+    char *etag;
+    char *weak;
+    core_dir_config *cfg;
+    etag_components_t etag_bits;
+
+    cfg = (core_dir_config *)ap_get_module_config(r->per_dir_config,
+                                                  &core_module);
+    etag_bits = (cfg->etag_bits & (~ cfg->etag_remove)) | cfg->etag_add;
+    if (etag_bits == ETAG_UNSET) {
+        etag_bits = ETAG_BACKWARD;
+    }
+    /*
+     * Make an ETag header out of various pieces of information. We use
+     * the last-modified date and, if we have a real file, the
+     * length and inode number - note that this doesn't have to match
+     * the content-length (i.e. includes), it just has to be unique
+     * for the file.
+     *
+     * If the request was made within a second of the last-modified date,
+     * we send a weak tag instead of a strong one, since it could
+     * be modified again later in the second, and the validation
+     * would be incorrect.
+     */
+    
+    weak = ((r->request_time - r->mtime > 1) && !force_weak) ? "" : "W/";
+
+    if (r->finfo.st_mode != 0) {
+        char **ent;
+        array_header *components;
+        int i;
+
+        /*
+         * If it's a file (or we wouldn't be here) and no ETags
+         * should be set for files, return an empty string and
+         * note it for ap_send_header_field() to ignore.
+         */
+        if (etag_bits & ETAG_NONE) {
+            ap_table_setn(r->notes, "no-etag", "omit");
+            return "";
+        }
+
+        components = ap_make_array(r->pool, 4, sizeof(char *));
+        if (etag_bits & ETAG_INODE) {
+            ent = (char **) ap_push_array(components);
+            *ent = ap_psprintf(r->pool, "%lx",
+                               (unsigned long) r->finfo.st_ino);
+        }
+        if (etag_bits & ETAG_SIZE) {
+            ent = (char **) ap_push_array(components);
+            *ent = ap_psprintf(r->pool, "%lx",
+                               (unsigned long) r->finfo.st_size);
+        }
+        if (etag_bits & ETAG_MTIME) {
+            ent = (char **) ap_push_array(components);
+            *ent = ap_psprintf(r->pool, "%lx", (unsigned long) r->mtime);
+        }
+        ent = (char **) components->elts;
+        etag = ap_pstrcat(r->pool, weak, "\"", NULL);
+        for (i = 0; i < components->nelts; ++i) {
+            etag = ap_psprintf(r->pool, "%s%s%s", etag,
+                               (i == 0 ? "" : "-"),
+                               ent[i]);
+        }
+        etag = ap_pstrcat(r->pool, etag, "\"", NULL);
+    }
+    else {
+        etag = ap_psprintf(r->pool, "%s\"%lx\"", weak,
+                    (unsigned long) r->mtime);
+    }
+
+    return etag;
+}
+
+API_EXPORT(void) ap_set_etag(request_rec *r)
+{
+    char *etag;
+    char *variant_etag, *vlv;
+    int vlv_weak;
+
+    if (!r->vlist_validator) {
+        etag = ap_make_etag(r, 0);
+
+        /* If we get a blank etag back, don't set the header. */
+        if (!etag[0]) {
+            return;
+        }
+    }
+    else {
+        /* If we have a variant list validator (vlv) due to the
+         * response being negotiated, then we create a structured
+         * entity tag which merges the variant etag with the variant
+         * list validator (vlv).  This merging makes revalidation
+         * somewhat safer, ensures that caches which can deal with
+         * Vary will (eventually) be updated if the set of variants is
+         * changed, and is also a protocol requirement for transparent
+         * content negotiation.
+         */
+
+        /* if the variant list validator is weak, we make the whole
+         * structured etag weak.  If we would not, then clients could
+         * have problems merging range responses if we have different
+         * variants with the same non-globally-unique strong etag.
+         */
+
+        vlv = r->vlist_validator;
+        vlv_weak = (vlv[0] == 'W');
+               
+        variant_etag = ap_make_etag(r, vlv_weak);
+
+        /* If we get a blank etag back, don't append vlv and stop now. */
+        if (!variant_etag[0]) {
+            return;
+        }
+
+        /* merge variant_etag and vlv into a structured etag */
+        variant_etag[strlen(variant_etag) - 1] = '\0';
+        if (vlv_weak)
+            vlv += 3;
+        else
+            vlv++;
+        etag = ap_pstrcat(r->pool, variant_etag, ";", vlv, NULL);
+    }
+
+    ap_table_setn(r->headers_out, "ETag", etag);
+}
+
+/*
+ * This function sets the Last-Modified output header field to the value
+ * of the mtime field in the request structure - rationalized to keep it from
+ * being in the future.
+ */
+API_EXPORT(void) ap_set_last_modified(request_rec *r)
+{
+    time_t mod_time = ap_rationalize_mtime(r, r->mtime);
+
+    ap_table_setn(r->headers_out, "Last-Modified",
+              ap_gm_timestr_822(r->pool, mod_time));
+}
+
+/* Get the method number associated with the given string, assumed to
+ * contain an HTTP method.  Returns M_INVALID if not recognized.
+ *
+ * This is the first step toward placing method names in a configurable
+ * list.  Hopefully it (and other routines) can eventually be moved to
+ * something like a mod_http_methods.c, complete with config stuff.
+ */
+API_EXPORT(int) ap_method_number_of(const char *method)
+{
+    switch (*method) {
+        case 'H':
+           if (strcmp(method, "HEAD") == 0)
+               return M_GET;   /* see header_only in request_rec */
+           break;
+        case 'G':
+           if (strcmp(method, "GET") == 0)
+               return M_GET;
+           break;
+        case 'P':
+           if (strcmp(method, "POST") == 0)
+               return M_POST;
+           if (strcmp(method, "PUT") == 0)
+               return M_PUT;
+           if (strcmp(method, "PATCH") == 0)
+               return M_PATCH;
+           if (strcmp(method, "PROPFIND") == 0)
+               return M_PROPFIND;
+           if (strcmp(method, "PROPPATCH") == 0)
+               return M_PROPPATCH;
+           break;
+        case 'D':
+           if (strcmp(method, "DELETE") == 0)
+               return M_DELETE;
+           break;
+        case 'C':
+           if (strcmp(method, "CONNECT") == 0)
+               return M_CONNECT;
+           if (strcmp(method, "COPY") == 0)
+               return M_COPY;
+           break;
+        case 'M':
+           if (strcmp(method, "MKCOL") == 0)
+               return M_MKCOL;
+           if (strcmp(method, "MOVE") == 0)
+               return M_MOVE;
+           break;
+        case 'O':
+           if (strcmp(method, "OPTIONS") == 0)
+               return M_OPTIONS;
+           break;
+        case 'T':
+           if (strcmp(method, "TRACE") == 0)
+               return M_TRACE;
+           break;
+        case 'L':
+           if (strcmp(method, "LOCK") == 0)
+               return M_LOCK;
+           break;
+        case 'U':
+           if (strcmp(method, "UNLOCK") == 0)
+               return M_UNLOCK;
+           break;
+    }
+    return M_INVALID;
+}
+
+/* Get a line of protocol input, including any continuation lines
+ * caused by MIME folding (or broken clients) if fold != 0, and place it
+ * in the buffer s, of size n bytes, without the ending newline.
+ *
+ * Returns -1 on error, or the length of s.
+ *
+ * Note: Because bgets uses 1 char for newline and 1 char for NUL,
+ *       the most we can get is (n - 2) actual characters if it
+ *       was ended by a newline, or (n - 1) characters if the line
+ *       length exceeded (n - 1).  So, if the result == (n - 1),
+ *       then the actual input line exceeded the buffer length,
+ *       and it would be a good idea for the caller to puke 400 or 414.
+ */
+API_EXPORT(int) ap_getline(char *s, int n, BUFF *in, int fold)
+{
+    char *pos, next;
+    int retval;
+    int total = 0;
+#ifdef CHARSET_EBCDIC
+    /* When ap_getline() is called, the HTTP protocol is in a state
+     * where we MUST be reading "plain text" protocol stuff,
+     * (Request line, MIME headers, Chunk sizes) regardless of
+     * the MIME type and conversion setting of the document itself.
+     * Save the current setting of the ASCII-EBCDIC conversion flag
+     * for uploads, then temporarily set it to ON
+     * (and restore it before returning).
+     */
+    PUSH_EBCDIC_INPUTCONVERSION_STATE(in, 1);
+#endif /*CHARSET_EBCDIC*/
+
+    pos = s;
+
+    do {
+        retval = ap_bgets(pos, n, in);     /* retval == -1 if error, 0 if EOF */
+
+        if (retval <= 0) {
+            total = ((retval < 0) && (total == 0)) ? -1 : total;
+            break;
+        }
+
+        /* retval is the number of characters read, not including NUL      */
+
+        n -= retval;            /* Keep track of how much of s is full     */
+        pos += (retval - 1);    /* and where s ends                        */
+        total += retval;        /* and how long s has become               */
+
+        if (*pos == '\n') {     /* Did we get a full line of input?        */
+            /*
+             * Trim any extra trailing spaces or tabs except for the first
+             * space or tab at the beginning of a blank string.  This makes
+             * it much easier to check field values for exact matches, and
+             * saves memory as well.  Terminate string at end of line.
+             */
+            while (pos > (s + 1) && (*(pos - 1) == ' ' || *(pos - 1) == '\t')) {
+                --pos;          /* trim extra trailing spaces or tabs      */
+                --total;        /* but not one at the beginning of line    */
+                ++n;
+            }
+            *pos = '\0';
+            --total;
+            ++n;
+        }
+        else
+            break;       /* if not, input line exceeded buffer size */
+
+        /* Continue appending if line folding is desired and
+         * the last line was not empty and we have room in the buffer and
+         * the next line begins with a continuation character.
+         */
+    } while (fold && (retval != 1) && (n > 1)
+                  && (ap_blookc(&next, in) == 1)
+                  && ((next == ' ') || (next == '\t')));
+
+#ifdef CHARSET_EBCDIC
+    /* restore ASCII->EBCDIC conversion state */
+    POP_EBCDIC_INPUTCONVERSION_STATE(in);
+#endif /*CHARSET_EBCDIC*/
+
+    return total;
+}
+
+/* parse_uri: break apart the uri
+ * Side Effects:
+ * - sets r->args to rest after '?' (or NULL if no '?')
+ * - sets r->uri to request uri (without r->args part)
+ * - sets r->hostname (if not set already) from request (scheme://host:port)
+ */
+CORE_EXPORT(void) ap_parse_uri(request_rec *r, const char *uri)
+{
+    int status = HTTP_OK;
+
+    r->unparsed_uri = ap_pstrdup(r->pool, uri);
+
+    if (r->method_number == M_CONNECT) {
+	status = ap_parse_hostinfo_components(r->pool, uri, &r->parsed_uri);
+    } else {
+	/* Simple syntax Errors in URLs are trapped by parse_uri_components(). */
+	status = ap_parse_uri_components(r->pool, uri, &r->parsed_uri);
+    }
+
+    if (ap_is_HTTP_SUCCESS(status)) {
+	/* if it has a scheme we may need to do absoluteURI vhost stuff */
+	if (r->parsed_uri.scheme
+	    && !strcasecmp(r->parsed_uri.scheme, ap_http_method(r))) {
+	    r->hostname = r->parsed_uri.hostname;
+	} else if (r->method_number == M_CONNECT) {
+	    r->hostname = r->parsed_uri.hostname;
+	}
+	r->args = r->parsed_uri.query;
+	r->uri = r->parsed_uri.path ? r->parsed_uri.path
+				    : ap_pstrdup(r->pool, "/");
+#if defined(OS2) || defined(WIN32)
+	/* Handle path translations for OS/2 and plug security hole.
+	 * This will prevent "http://www.wherever.com/..\..\/" from
+	 * returning a directory for the root drive.
+	 */
+	{
+	    char *x;
+
+	    for (x = r->uri; (x = strchr(x, '\\')) != NULL; )
+		*x = '/';
+	}
+#endif  /* OS2 || WIN32 */
+    }
+    else {
+	r->args = NULL;
+	r->hostname = NULL;
+	r->status = status;             /* set error status */
+	r->uri = ap_pstrdup(r->pool, uri);
+    }
+}
+
+static int read_request_line(request_rec *r)
+{
+    char l[DEFAULT_LIMIT_REQUEST_LINE + 2]; /* ap_getline's two extra for \n\0 */
+    const char *ll = l;
+    const char *uri;
+    conn_rec *conn = r->connection;
+    unsigned int major = 1, minor = 0;   /* Assume HTTP/1.0 if non-"HTTP" protocol */
+    int len = 0;
+    int valid_protocol = 1;
+
+    /* Read past empty lines until we get a real request line,
+     * a read error, the connection closes (EOF), or we timeout.
+     *
+     * We skip empty lines because browsers have to tack a CRLF on to the end
+     * of POSTs to support old CERN webservers.  But note that we may not
+     * have flushed any previous response completely to the client yet.
+     * We delay the flush as long as possible so that we can improve
+     * performance for clients that are pipelining requests.  If a request
+     * is pipelined then we won't block during the (implicit) read() below.
+     * If the requests aren't pipelined, then the client is still waiting
+     * for the final buffer flush from us, and we will block in the implicit
+     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will
+     * have to block during a read.
+     */
+    ap_bsetflag(conn->client, B_SAFEREAD, 1);
+    while ((len = ap_getline(l, sizeof(l), conn->client, 0)) <= 0) {
+        if ((len < 0) || ap_bgetflag(conn->client, B_EOF) || !conn->keepalives) {
+            ap_bsetflag(conn->client, B_SAFEREAD, 0);
+	    /* this is a hack to make sure that request time is set,
+	     * it's not perfect, but it's better than nothing 
+	     */
+	    r->request_time = time(0);
+            return 0;
+        }
+    }
+    /* we've probably got something to do, ignore graceful restart requests */
+#ifdef SIGUSR1
+    signal(SIGUSR1, SIG_IGN);
+#endif
+
+    ap_bsetflag(conn->client, B_SAFEREAD, 0);
+
+    r->request_time = time(NULL);
+    r->the_request = ap_pstrdup(r->pool, l);
+    r->method = ap_getword_white(r->pool, &ll);
+    uri = ap_getword_white(r->pool, &ll);
+
+    /* Provide quick information about the request method as soon as known */
+
+    r->method_number = ap_method_number_of(r->method);
+    if (r->method_number == M_GET && r->method[0] == 'H') {
+        r->header_only = 1;
+    }
+
+    ap_parse_uri(r, uri);
+
+    /* ap_getline returns (size of max buffer - 1) if it fills up the
+     * buffer before finding the end-of-line.  This is only going to
+     * happen if it exceeds the configured limit for a request-line.
+     */
+    if (len > r->server->limit_req_line) {
+        r->status    = HTTP_REQUEST_URI_TOO_LARGE;
+        r->proto_num = HTTP_VERSION(1,0);
+        r->protocol  = ap_pstrdup(r->pool, "HTTP/1.0");
+        return 0;
+    }
+
+    r->assbackwards = (ll[0] == '\0');
+    r->protocol = ap_pstrdup(r->pool, ll[0] ? ll : "HTTP/0.9");
+
+    /* Avoid sscanf in the common case */
+    if (strlen(r->protocol) == 8
+        && r->protocol[0] == 'H' && r->protocol[1] == 'T'
+	&& r->protocol[2] == 'T' && r->protocol[3] == 'P'
+        && r->protocol[4] == '/' && ap_isdigit(r->protocol[5])
+	&& r->protocol[6] == '.' && ap_isdigit(r->protocol[7])) {
+        r->proto_num = HTTP_VERSION(r->protocol[5] - '0', r->protocol[7] - '0');
+    }
+    else {
+        char lint[2];
+        char http[5];
+	if (3 == sscanf(r->protocol, "%4s/%u.%u%1s", http, &major, &minor, lint)
+            && (strcasecmp("http", http) == 0)
+	    && (minor < HTTP_VERSION(1,0)) ) /* don't allow HTTP/0.1000 */
+	    r->proto_num = HTTP_VERSION(major, minor);
+	else {
+	    r->proto_num = HTTP_VERSION(1,0);
+	    valid_protocol = 0;
+	}
+    }
+
+    /* Check for a valid protocol, and disallow everything but whitespace
+     * after the protocol string. A protocol string of nothing but
+     * whitespace is considered valid */
+    if (ap_protocol_req_check && !valid_protocol) {
+        int n = 0;
+	while (ap_isspace(r->protocol[n]))
+	    ++n;
+	if (r->protocol[n] != '\0') {
+	    r->status    = HTTP_BAD_REQUEST;
+	    r->proto_num = HTTP_VERSION(1,0);
+	    r->protocol  = ap_pstrdup(r->pool, "HTTP/1.0");
+	    ap_table_setn(r->notes, "error-notes",
+                     "The request line contained invalid characters "
+                     "following the protocol string.<P>\n");
+	    return 0;
+	}
+    }
+
+    return 1;
+}
+
+static void get_mime_headers(request_rec *r)
+{
+    char field[DEFAULT_LIMIT_REQUEST_FIELDSIZE + 2]; /* ap_getline's two extra */
+    conn_rec *c = r->connection;
+    char *value;
+    char *copy;
+    int len;
+    int fields_read = 0;
+    table *tmp_headers;
+
+    /* We'll use ap_overlap_tables later to merge these into r->headers_in. */
+    tmp_headers = ap_make_table(r->pool, 50);
+
+    /*
+     * Read header lines until we get the empty separator line, a read error,
+     * the connection closes (EOF), reach the server limit, or we timeout.
+     */
+    while ((len = ap_getline(field, sizeof(field), c->client, 1)) > 0) {
+
+        if (r->server->limit_req_fields &&
+            (++fields_read > r->server->limit_req_fields)) {
+            r->status = HTTP_BAD_REQUEST;
+            ap_table_setn(r->notes, "error-notes",
+                          "The number of request header fields exceeds "
+                          "this server's limit.<P>\n");
+            return;
+        }
+        /* ap_getline returns (size of max buffer - 1) if it fills up the
+         * buffer before finding the end-of-line.  This is only going to
+         * happen if it exceeds the configured limit for a field size.
+         */
+        if (len > r->server->limit_req_fieldsize) {
+            r->status = HTTP_BAD_REQUEST;
+            ap_table_setn(r->notes, "error-notes", ap_pstrcat(r->pool,
+                "Size of a request header field exceeds server limit.<P>\n"
+                "<PRE>\n", ap_escape_html(r->pool, field), "</PRE>\n", NULL));
+            return;
+        }
+        copy = ap_palloc(r->pool, len + 1);
+        memcpy(copy, field, len + 1);
+
+        if (!(value = strchr(copy, ':'))) {     /* Find the colon separator */
+            r->status = HTTP_BAD_REQUEST;       /* or abort the bad request */
+            ap_table_setn(r->notes, "error-notes", ap_pstrcat(r->pool,
+                "Request header field is missing colon separator.<P>\n"
+                "<PRE>\n", ap_escape_html(r->pool, copy), "</PRE>\n", NULL));
+            return;
+        }
+
+        *value = '\0';
+        ++value;
+        while (*value == ' ' || *value == '\t')
+            ++value;            /* Skip to start of value   */
+
+	ap_table_addn(tmp_headers, copy, value);
+    }
+
+    ap_overlap_tables(r->headers_in, tmp_headers, AP_OVERLAP_TABLES_MERGE);
+}
+
+API_EXPORT(request_rec *) ap_read_request(conn_rec *conn)
+{
+    request_rec *r;
+    pool *p;
+    const char *expect;
+    int access_status;
+
+    p = ap_make_sub_pool(conn->pool);
+    r = ap_pcalloc(p, sizeof(request_rec));
+    r->pool            = p;
+    r->connection      = conn;
+    conn->server       = conn->base_server;
+    r->server          = conn->server;
+
+    conn->keptalive    = conn->keepalive == 1;
+    conn->keepalive    = 0;
+
+    conn->user         = NULL;
+    conn->ap_auth_type    = NULL;
+
+    r->headers_in      = ap_make_table(r->pool, 50);
+    r->subprocess_env  = ap_make_table(r->pool, 50);
+    r->headers_out     = ap_make_table(r->pool, 12);
+    r->err_headers_out = ap_make_table(r->pool, 5);
+    r->notes           = ap_make_table(r->pool, 5);
+
+    r->request_config  = ap_create_request_config(r->pool);
+    r->per_dir_config  = r->server->lookup_defaults;
+
+    r->sent_bodyct     = 0;                      /* bytect isn't for body */
+
+    r->read_length     = 0;
+    r->read_body       = REQUEST_NO_BODY;
+
+    r->status          = HTTP_REQUEST_TIME_OUT;  /* Until we get a request */
+    r->the_request     = NULL;
+
+#ifdef CHARSET_EBCDIC
+    ap_bsetflag(r->connection->client, B_ASCII2EBCDIC, r->ebcdic.conv_in  = 1);
+    ap_bsetflag(r->connection->client, B_EBCDIC2ASCII, r->ebcdic.conv_out = 1);
+#endif
+
+    /* Get the request... */
+
+    ap_keepalive_timeout("read request line", r);
+    if (!read_request_line(r)) {
+        ap_kill_timeout(r);
+        if (r->status == HTTP_REQUEST_URI_TOO_LARGE) {
+
+            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+                         "request failed: URI too long");
+            ap_send_error_response(r, 0);
+            ap_log_transaction(r);
+            return r;
+        }
+        else if (r->status == HTTP_BAD_REQUEST) {
+            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+                         "request failed: erroneous characters after protocol string: %s",
+			 ap_escape_logitem(r->pool, r->the_request));
+            ap_send_error_response(r, 0);
+            ap_log_transaction(r);
+            return r;
+        }
+        return NULL;
+    }
+    if (!r->assbackwards) {
+        ap_hard_timeout("read request headers", r);
+        get_mime_headers(r);
+        ap_kill_timeout(r);
+        if (r->status != HTTP_REQUEST_TIME_OUT) {
+            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+                         "request failed: error reading the headers");
+            ap_send_error_response(r, 0);
+            ap_log_transaction(r);
+            return r;
+        }
+    }
+    else {
+        ap_kill_timeout(r);
+
+        if (r->header_only) {
+            /*
+             * Client asked for headers only with HTTP/0.9, which doesn't send
+             * headers! Have to dink things just to make sure the error message
+             * comes through...
+             */
+            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+                          "client sent invalid HTTP/0.9 request: HEAD %s",
+                          r->uri);
+            r->header_only = 0;
+            r->status = HTTP_BAD_REQUEST;
+            ap_send_error_response(r, 0);
+            ap_log_transaction(r);
+            return r;
+        }
+    }
+
+    r->status = HTTP_OK;                         /* Until further notice. */
+
+    /* update what we think the virtual host is based on the headers we've
+     * now read. may update status.
+     */
+    ap_update_vhost_from_headers(r);
+
+    /* we may have switched to another server */
+    r->per_dir_config = r->server->lookup_defaults;
+
+    conn->keptalive = 0;        /* We now have a request to play with */
+
+    if ((!r->hostname && (r->proto_num >= HTTP_VERSION(1,1))) ||
+        ((r->proto_num == HTTP_VERSION(1,1)) &&
+         !ap_table_get(r->headers_in, "Host"))) {
+        /*
+         * Client sent us an HTTP/1.1 or later request without telling us the
+         * hostname, either with a full URL or a Host: header. We therefore
+         * need to (as per the 1.1 spec) send an error.  As a special case,
+         * HTTP/1.1 mentions twice (S9, S14.23) that a request MUST contain
+         * a Host: header, and the server MUST respond with 400 if it doesn't.
+         */
+        r->status = HTTP_BAD_REQUEST;
+        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+                      "client sent HTTP/1.1 request without hostname "
+                      "(see RFC2616 section 14.23): %s", r->uri);
+    }
+    if (r->status != HTTP_OK) {
+        ap_send_error_response(r, 0);
+        ap_log_transaction(r);
+        return r;
+    }
+
+    if ((access_status = ap_run_post_read_request(r))) {
+        ap_die(access_status, r);
+        ap_log_transaction(r);
+        return NULL;
+    }
+
+    if (((expect = ap_table_get(r->headers_in, "Expect")) != NULL) &&
+        (expect[0] != '\0')) {
+        /*
+         * The Expect header field was added to HTTP/1.1 after RFC 2068
+         * as a means to signal when a 100 response is desired and,
+         * unfortunately, to signal a poor man's mandatory extension that
+         * the server must understand or return 417 Expectation Failed.
+         */
+        if (strcasecmp(expect, "100-continue") == 0) {
+            r->expecting_100 = 1;
+        }
+        else {
+            r->status = HTTP_EXPECTATION_FAILED;
+            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_INFO, r,
+                          "client sent an unrecognized expectation value of "
+                          "Expect: %s", expect);
+            ap_send_error_response(r, 0);
+            (void) ap_discard_request_body(r);
+            ap_log_transaction(r);
+            return r;
+        }
+    }
+
+    return r;
+}
+
+/*
+ * A couple of other functions which initialize some of the fields of
+ * a request structure, as appropriate for adjuncts of one kind or another
+ * to a request in progress.  Best here, rather than elsewhere, since
+ * *someone* has to set the protocol-specific fields...
+ */
+
+API_EXPORT(void) ap_set_sub_req_protocol(request_rec *rnew, const request_rec *r)
+{
+    rnew->the_request     = r->the_request;  /* Keep original request-line */
+
+    rnew->assbackwards    = 1;   /* Don't send headers from this. */
+    rnew->no_local_copy   = 1;   /* Don't try to send USE_LOCAL_COPY for a
+                                  * fragment. */
+    rnew->method          = "GET";
+    rnew->method_number   = M_GET;
+    rnew->protocol        = "INCLUDED";
+
+    rnew->status          = HTTP_OK;
+
+    rnew->headers_in      = r->headers_in;
+    rnew->subprocess_env  = ap_copy_table(rnew->pool, r->subprocess_env);
+    rnew->headers_out     = ap_make_table(rnew->pool, 5);
+    rnew->err_headers_out = ap_make_table(rnew->pool, 5);
+    rnew->notes           = ap_make_table(rnew->pool, 5);
+
+    rnew->expecting_100   = r->expecting_100;
+    rnew->read_length     = r->read_length;
+    rnew->read_body       = REQUEST_NO_BODY;
+
+    rnew->main = (request_rec *) r;
+}
+
+API_EXPORT(void) ap_finalize_sub_req_protocol(request_rec *sub)
+{
+    SET_BYTES_SENT(sub->main);
+}
+
+/*
+ * Support for the Basic authentication protocol, and a bit for Digest.
+ */
+
+API_EXPORT(void) ap_note_auth_failure(request_rec *r)
+{
+    if (!strcasecmp(ap_auth_type(r), "Basic"))
+        ap_note_basic_auth_failure(r);
+    else if (!strcasecmp(ap_auth_type(r), "Digest"))
+        ap_note_digest_auth_failure(r);
+}
+
+API_EXPORT(void) ap_note_basic_auth_failure(request_rec *r)
+{
+    if (strcasecmp(ap_auth_type(r), "Basic"))
+        ap_note_auth_failure(r);
+    else
+        ap_table_setn(r->err_headers_out,
+                  r->proxyreq == STD_PROXY ? "Proxy-Authenticate"
+		      : "WWW-Authenticate",
+                  ap_pstrcat(r->pool, "Basic realm=\"", ap_auth_name(r), "\"",
+                          NULL));
+}
+
+API_EXPORT(void) ap_note_digest_auth_failure(request_rec *r)
+{
+    /* We need to create a nonce which:
+     * a) changes all the time (see r->request_time)
+     *    below and
+     * b) of which we can verify that it is our own
+     *    fairly easily when it comes to veryfing
+     *    the digest coming back in the response.
+     * c) and which as a whole should not
+     *    be unlikely to be in use anywhere else.
+     */
+    char * nonce_prefix = ap_md5(r->pool,
+           (unsigned char *)
+           ap_psprintf(r->pool, "%s%lu",
+                       ap_auth_nonce(r), r->request_time));
+
+    ap_table_setn(r->err_headers_out,
+	    r->proxyreq == STD_PROXY ? "Proxy-Authenticate"
+		  : "WWW-Authenticate",
+           ap_psprintf(r->pool, "Digest realm=\"%s\", nonce=\"%s%lu\"",
+               ap_auth_name(r), nonce_prefix, r->request_time));
+}
+
+API_EXPORT(int) ap_get_basic_auth_pw(request_rec *r, const char **pw)
+{
+    const char *auth_line = ap_table_get(r->headers_in,
+					 r->proxyreq == STD_PROXY
+					 ? "Proxy-Authorization"
+					 : "Authorization");
+    const char *t;
+
+    if (!(t = ap_auth_type(r)) || strcasecmp(t, "Basic"))
+        return DECLINED;
+
+    if (!ap_auth_name(r)) {
+        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR,
+		    r, "need AuthName: %s", r->uri);
+        return SERVER_ERROR;
+    }
+
+    if (!auth_line) {
+        ap_note_basic_auth_failure(r);
+        return AUTH_REQUIRED;
+    }
+
+    if (strcasecmp(ap_getword(r->pool, &auth_line, ' '), "Basic")) {
+        /* Client tried to authenticate using wrong auth scheme */
+        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+                    "client used wrong authentication scheme: %s", r->uri);
+        ap_note_basic_auth_failure(r);
+        return AUTH_REQUIRED;
+    }
+
+    /* No CHARSET_EBCDIC Issue here because the line has already
+     * been converted to native text.
+     */
+    while (*auth_line== ' ' || *auth_line== '\t')
+        auth_line++;
+
+    t = ap_pbase64decode(r->pool, auth_line);
+    /* Note that this allocation has to be made from r->connection->pool
+     * because it has the lifetime of the connection.  The other allocations
+     * are temporary and can be tossed away any time.
+     */
+    r->connection->user = ap_getword_nulls (r->connection->pool, &t, ':');
+    r->connection->ap_auth_type = "Basic";
+
+    *pw = t;
+
+    return OK;
+}
+
+/* New Apache routine to map status codes into array indicies
+ *  e.g.  100 -> 0,  101 -> 1,  200 -> 2 ...
+ * The number of status lines must equal the value of RESPONSE_CODES (httpd.h)
+ * and must be listed in order.
+ */
+
+#ifdef UTS21
+/* The second const triggers an assembler bug on UTS 2.1.
+ * Another workaround is to move some code out of this file into another,
+ *   but this is easier.  Dave Dykstra, 3/31/99 
+ */
+static const char * status_lines[RESPONSE_CODES] =
+#else
+static const char * const status_lines[RESPONSE_CODES] =
+#endif
+{
+    "100 Continue",
+    "101 Switching Protocols",
+    "102 Processing",
+#define LEVEL_200  3
+    "200 OK",
+    "201 Created",
+    "202 Accepted",
+    "203 Non-Authoritative Information",
+    "204 No Content",
+    "205 Reset Content",
+    "206 Partial Content",
+    "207 Multi-Status",
+#define LEVEL_300 11
+    "300 Multiple Choices",
+    "301 Moved Permanently",
+    "302 Found",
+    "303 See Other",
+    "304 Not Modified",
+    "305 Use Proxy",
+    "306 unused",
+    "307 Temporary Redirect",
+#define LEVEL_400 19
+    "400 Bad Request",
+    "401 Authorization Required",
+    "402 Payment Required",
+    "403 Forbidden",
+    "404 Not Found",
+    "405 Method Not Allowed",
+    "406 Not Acceptable",
+    "407 Proxy Authentication Required",
+    "408 Request Time-out",
+    "409 Conflict",
+    "410 Gone",
+    "411 Length Required",
+    "412 Precondition Failed",
+    "413 Request Entity Too Large",
+    "414 Request-URI Too Large",
+    "415 Unsupported Media Type",
+    "416 Requested Range Not Satisfiable",
+    "417 Expectation Failed",
+    "418 unused",
+    "419 unused",
+    "420 unused",
+    "421 unused",
+    "422 Unprocessable Entity",
+    "423 Locked",
+    "424 Failed Dependency",
+#define LEVEL_500 44
+    "500 Internal Server Error",
+    "501 Method Not Implemented",
+    "502 Bad Gateway",
+    "503 Service Temporarily Unavailable",
+    "504 Gateway Time-out",
+    "505 HTTP Version Not Supported",
+    "506 Variant Also Negotiates",
+    "507 Insufficient Storage",
+    "508 unused",
+    "509 unused",
+    "510 Not Extended"
+};
+
+/* The index is found by its offset from the x00 code of each level.
+ * Although this is fast, it will need to be replaced if some nutcase
+ * decides to define a high-numbered code before the lower numbers.
+ * If that sad event occurs, replace the code below with a linear search
+ * from status_lines[shortcut[i]] to status_lines[shortcut[i+1]-1];
+ */
+API_EXPORT(int) ap_index_of_response(int status)
+{
+    static int shortcut[6] = {0, LEVEL_200, LEVEL_300, LEVEL_400,
+    LEVEL_500, RESPONSE_CODES};
+    int i, pos;
+
+    if (status < 100)           /* Below 100 is illegal for HTTP status */
+        return LEVEL_500;
+
+    for (i = 0; i < 5; i++) {
+        status -= 100;
+        if (status < 100) {
+            pos = (status + shortcut[i]);
+            if (pos < shortcut[i + 1])
+                return pos;
+            else
+                return LEVEL_500;       /* status unknown (falls in gap) */
+        }
+    }
+    return LEVEL_500;           /* 600 or above is also illegal */
+}
+
+/* Send a single HTTP header field to the client.  Note that this function
+ * is used in calls to table_do(), so their interfaces are co-dependent.
+ * In other words, don't change this one without checking table_do in alloc.c.
+ * It returns true unless there was a write error of some kind.
+ */
+API_EXPORT_NONSTD(int) ap_send_header_field(request_rec *r,
+                                            const char *fieldname,
+                                            const char *fieldval)
+{
+    if (strcasecmp(fieldname, "ETag") == 0) {
+        if (ap_table_get(r->notes, "no-etag") != NULL) {
+            return 1;
+        }
+    }
+    return (0 < ap_rvputs(r, fieldname, ": ", fieldval, CRLF, NULL));
+}
+
+API_EXPORT(void) ap_basic_http_header(request_rec *r)
+{
+    char *protocol;
+
+    if (r->assbackwards)
+        return;
+
+    if (!r->status_line)
+        r->status_line = status_lines[ap_index_of_response(r->status)];
+
+    /* kluge around broken browsers when indicated by force-response-1.0
+     */
+    if (r->proto_num == HTTP_VERSION(1,0)
+       && ap_table_get(r->subprocess_env, "force-response-1.0")) {
+
+        protocol = "HTTP/1.0";
+        r->connection->keepalive = -1;
+    }
+    else
+        protocol = SERVER_PROTOCOL;
+
+#ifdef CHARSET_EBCDIC
+    PUSH_EBCDIC_OUTPUTCONVERSION_STATE_r(r, 1);
+#endif /*CHARSET_EBCDIC*/
+
+    /* output the HTTP/1.x Status-Line */
+    ap_rvputs(r, protocol, " ", r->status_line, CRLF, NULL);
+
+    /* output the date header */
+    ap_send_header_field(r, "Date", ap_gm_timestr_822(r->pool, r->request_time));
+
+    /* keep the set-by-proxy server header, otherwise
+     * generate a new server header */
+    if (r->proxyreq) {
+        const char *server = ap_table_get(r->headers_out, "Server");
+        if (server) {
+            ap_send_header_field(r, "Server", server);
+        }
+    }
+    else {
+        ap_send_header_field(r, "Server", ap_get_server_version());
+    }
+
+    /* unset so we don't send them again */
+    ap_table_unset(r->headers_out, "Date");        /* Avoid bogosity */
+    ap_table_unset(r->headers_out, "Server");
+#ifdef CHARSET_EBCDIC
+    POP_EBCDIC_OUTPUTCONVERSION_STATE_r(r);
+#endif /*CHARSET_EBCDIC*/
+}
+
+/* Navigator versions 2.x, 3.x and 4.0 betas up to and including 4.0b2
+ * have a header parsing bug.  If the terminating \r\n occur starting
+ * at offset 256, 257 or 258 of output then it will not properly parse
+ * the headers.  Curiously it doesn't exhibit this problem at 512, 513.
+ * We are guessing that this is because their initial read of a new request
+ * uses a 256 byte buffer, and subsequent reads use a larger buffer.
+ * So the problem might exist at different offsets as well.
+ *
+ * This should also work on keepalive connections assuming they use the
+ * same small buffer for the first read of each new request.
+ *
+ * At any rate, we check the bytes written so far and, if we are about to
+ * tickle the bug, we instead insert a bogus padding header.  Since the bug
+ * manifests as a broken image in Navigator, users blame the server.  :(
+ * It is more expensive to check the User-Agent than it is to just add the
+ * bytes, so we haven't used the BrowserMatch feature here.
+ */
+static void terminate_header(BUFF *client)
+{
+    long int bs;
+
+    ap_bgetopt(client, BO_BYTECT, &bs);
+    if (bs >= 255 && bs <= 257)
+        ap_bputs("X-Pad: avoid browser bug" CRLF, client);
+
+    ap_bputs(CRLF, client);  /* Send the terminating empty line */
+}
+
+/* Build the Allow field-value from the request handler method mask.
+ * Note that we always allow TRACE, since it is handled below.
+ */
+static char *make_allow(request_rec *r)
+{
+    return 2 + ap_pstrcat(r->pool,
+                   (r->allowed & (1 << M_GET))       ? ", GET, HEAD" : "",
+                   (r->allowed & (1 << M_POST))      ? ", POST"      : "",
+                   (r->allowed & (1 << M_PUT))       ? ", PUT"       : "",
+                   (r->allowed & (1 << M_DELETE))    ? ", DELETE"    : "",
+                   (r->allowed & (1 << M_CONNECT))   ? ", CONNECT"   : "",
+                   (r->allowed & (1 << M_OPTIONS))   ? ", OPTIONS"   : "",
+                   (r->allowed & (1 << M_PATCH))     ? ", PATCH"     : "",
+                   (r->allowed & (1 << M_PROPFIND))  ? ", PROPFIND"  : "",
+                   (r->allowed & (1 << M_PROPPATCH)) ? ", PROPPATCH" : "",
+                   (r->allowed & (1 << M_MKCOL))     ? ", MKCOL"     : "",
+                   (r->allowed & (1 << M_COPY))      ? ", COPY"      : "",
+                   (r->allowed & (1 << M_MOVE))      ? ", MOVE"      : "",
+                   (r->allowed & (1 << M_LOCK))      ? ", LOCK"      : "",
+                   (r->allowed & (1 << M_UNLOCK))    ? ", UNLOCK"    : "",
+                   ", TRACE",
+                   NULL);
+}
+
+API_EXPORT(int) ap_send_http_trace(request_rec *r)
+{
+    int rv;
+
+    /* Get the original request */
+    while (r->prev)
+        r = r->prev;
+
+    if ((rv = ap_setup_client_block(r, REQUEST_NO_BODY)))
+        return rv;
+
+    ap_hard_timeout("send TRACE", r);
+
+    r->content_type = "message/http";
+    ap_send_http_header(r);
+#ifdef CHARSET_EBCDIC
+    /* Server-generated response, converted */
+    ap_bsetflag(r->connection->client, B_EBCDIC2ASCII, r->ebcdic.conv_out = 1);
+#endif
+
+    /* Now we recreate the request, and echo it back */
+
+    ap_rvputs(r, r->the_request, CRLF, NULL);
+
+    ap_table_do((int (*) (void *, const char *, const char *))
+                ap_send_header_field, (void *) r, r->headers_in, NULL);
+    ap_rputs(CRLF, r);
+
+    ap_kill_timeout(r);
+    return OK;
+}
+
+API_EXPORT(int) ap_send_http_options(request_rec *r)
+{
+    const long int zero = 0L;
+
+    if (r->assbackwards)
+        return DECLINED;
+
+    ap_hard_timeout("send OPTIONS", r);
+
+    ap_basic_http_header(r);
+
+    ap_table_setn(r->headers_out, "Content-Length", "0");
+    ap_table_setn(r->headers_out, "Allow", make_allow(r));
+    ap_set_keepalive(r);
+
+    ap_table_do((int (*) (void *, const char *, const char *)) ap_send_header_field,
+             (void *) r, r->headers_out, NULL);
+
+    terminate_header(r->connection->client);
+
+    ap_kill_timeout(r);
+    ap_bsetopt(r->connection->client, BO_BYTECT, &zero);
+
+    return OK;
+}
+
+/*
+ * Here we try to be compatible with clients that want multipart/x-byteranges
+ * instead of multipart/byteranges (also see above), as per HTTP/1.1. We
+ * look for the Request-Range header (e.g. Netscape 2 and 3) as an indication
+ * that the browser supports an older protocol. We also check User-Agent
+ * for Microsoft Internet Explorer 3, which needs this as well.
+ */
+static int use_range_x(request_rec *r)
+{
+    const char *ua;
+    return (ap_table_get(r->headers_in, "Request-Range") ||
+            ((ua = ap_table_get(r->headers_in, "User-Agent"))
+             && strstr(ua, "MSIE 3")));
+}
+
+/* This routine is called by ap_table_do and merges all instances of
+ * the passed field values into a single array that will be further
+ * processed by some later routine.  Originally intended to help split
+ * and recombine multiple Vary fields, though it is generic to any field
+ * consisting of comma/space-separated tokens.
+ */
+static int uniq_field_values(void *d, const char *key, const char *val)
+{
+    array_header *values;
+    char *start;
+    char *e;
+    char **strpp;
+    int  i;
+
+    values = (array_header *)d;
+
+    e = ap_pstrdup(values->pool, val);
+
+    do {
+        /* Find a non-empty fieldname */
+
+        while (*e == ',' || ap_isspace(*e)) {
+            ++e;
+        }
+        if (*e == '\0') {
+            break;
+        }
+        start = e;
+        while (*e != '\0' && *e != ',' && !ap_isspace(*e)) {
+            ++e;
+        }
+        if (*e != '\0') {
+            *e++ = '\0';
+        }
+
+        /* Now add it to values if it isn't already represented.
+         * Could be replaced by a ap_array_strcasecmp() if we had one.
+         */
+        for (i = 0, strpp = (char **) values->elts; i < values->nelts;
+             ++i, ++strpp) {
+            if (*strpp && strcasecmp(*strpp, start) == 0) {
+                break;
+            }
+        }
+        if (i == values->nelts) {  /* if not found */
+           *(char **)ap_push_array(values) = start;
+        }
+    } while (*e != '\0');
+
+    return 1;
+}
+
+/*
+ * Since some clients choke violently on multiple Vary fields, or
+ * Vary fields with duplicate tokens, combine any multiples and remove
+ * any duplicates.
+ */
+static void fixup_vary(request_rec *r)
+{
+    array_header *varies;
+
+    varies = ap_make_array(r->pool, 5, sizeof(char *));
+
+    /* Extract all Vary fields from the headers_out, separate each into
+     * its comma-separated fieldname values, and then add them to varies
+     * if not already present in the array.
+     */
+    ap_table_do((int (*)(void *, const char *, const char *))uniq_field_values,
+		(void *) varies, r->headers_out, "Vary", NULL);
+
+    /* If we found any, replace old Vary fields with unique-ified value */
+
+    if (varies->nelts > 0) {
+	ap_table_setn(r->headers_out, "Vary",
+		      ap_array_pstrcat(r->pool, varies, ','));
+    }
+}
+
+API_EXPORT(void) ap_send_http_header(request_rec *r)
+{
+    int i;
+    const long int zero = 0L;
+
+#ifdef CHARSET_EBCDIC
+    /* Use previously determined conversion (output): */
+    ap_bsetflag(r->connection->client, B_EBCDIC2ASCII, ap_checkconv(r));
+#endif /*CHARSET_EBCDIC*/
+
+    if (r->assbackwards) {
+        if (!r->main)
+            ap_bsetopt(r->connection->client, BO_BYTECT, &zero);
+        r->sent_bodyct = 1;
+        return;
+    }
+
+    /*
+     * Now that we are ready to send a response, we need to combine the two
+     * header field tables into a single table.  If we don't do this, our
+     * later attempts to set or unset a given fieldname might be bypassed.
+     */
+    if (!ap_is_empty_table(r->err_headers_out))
+        r->headers_out = ap_overlay_tables(r->pool, r->err_headers_out,
+                                        r->headers_out);
+
+    /*
+     * Remove the 'Vary' header field if the client can't handle it.
+     * Since this will have nasty effects on HTTP/1.1 caches, force
+     * the response into HTTP/1.0 mode.
+     */
+    if (ap_table_get(r->subprocess_env, "force-no-vary") != NULL) {
+	ap_table_unset(r->headers_out, "Vary");
+	r->proto_num = HTTP_VERSION(1,0);
+	ap_table_set(r->subprocess_env, "force-response-1.0", "1");
+    }
+    else {
+	fixup_vary(r);
+    }
+
+    ap_hard_timeout("send headers", r);
+
+    ap_basic_http_header(r);
+
+#ifdef CHARSET_EBCDIC
+    PUSH_EBCDIC_OUTPUTCONVERSION_STATE_r(r, 1);
+#endif /*CHARSET_EBCDIC*/
+
+    ap_set_keepalive(r);
+
+    if (r->chunked) {
+        ap_table_mergen(r->headers_out, "Transfer-Encoding", "chunked");
+        ap_table_unset(r->headers_out, "Content-Length");
+    }
+
+    if (r->byterange > 1)
+        ap_table_setn(r->headers_out, "Content-Type",
+                  ap_pstrcat(r->pool, "multipart", use_range_x(r) ? "/x-" : "/",
+                          "byteranges; boundary=", r->boundary, NULL));
+    else ap_table_setn(r->headers_out, "Content-Type", make_content_type(r, 
+	r->content_type));
+
+    if (r->content_encoding)
+        ap_table_setn(r->headers_out, "Content-Encoding", r->content_encoding);
+
+    if (r->content_languages && r->content_languages->nelts) {
+        for (i = 0; i < r->content_languages->nelts; ++i) {
+            ap_table_mergen(r->headers_out, "Content-Language",
+                        ((char **) (r->content_languages->elts))[i]);
+        }
+    }
+    else if (r->content_language)
+        ap_table_setn(r->headers_out, "Content-Language", r->content_language);
+
+    /*
+     * Control cachability for non-cachable responses if not already set by
+     * some other part of the server configuration.
+     */
+    if (r->no_cache && !ap_table_get(r->headers_out, "Expires"))
+        ap_table_addn(r->headers_out, "Expires",
+                  ap_gm_timestr_822(r->pool, r->request_time));
+
+    /* Send the entire table of header fields, terminated by an empty line. */
+
+    ap_table_do((int (*) (void *, const char *, const char *)) ap_send_header_field,
+             (void *) r, r->headers_out, NULL);
+
+    terminate_header(r->connection->client);
+
+    ap_kill_timeout(r);
+
+    ap_bsetopt(r->connection->client, BO_BYTECT, &zero);
+    r->sent_bodyct = 1;         /* Whatever follows is real body stuff... */
+
+    /* Set buffer flags for the body */
+    if (r->chunked)
+        ap_bsetflag(r->connection->client, B_CHUNK, 1);
+#ifdef CHARSET_EBCDIC
+    POP_EBCDIC_OUTPUTCONVERSION_STATE_r(r);
+#endif /*CHARSET_EBCDIC*/
+}
+
+/* finalize_request_protocol is called at completion of sending the
+ * response.  It's sole purpose is to send the terminating protocol
+ * information for any wrappers around the response message body
+ * (i.e., transfer encodings).  It should have been named finalize_response.
+ */
+API_EXPORT(void) ap_finalize_request_protocol(request_rec *r)
+{
+    if (r->chunked && !r->connection->aborted) {
+#ifdef CHARSET_EBCDIC
+        PUSH_EBCDIC_OUTPUTCONVERSION_STATE_r(r, 1);
+#endif
+        /*
+         * Turn off chunked encoding --- we can only do this once.
+         */
+        r->chunked = 0;
+        ap_bsetflag(r->connection->client, B_CHUNK, 0);
+
+        ap_soft_timeout("send ending chunk", r);
+        ap_rputs("0" CRLF, r);
+        /* If we had footer "headers", we'd send them now */
+        ap_rputs(CRLF, r);
+        ap_kill_timeout(r);
+
+#ifdef CHARSET_EBCDIC
+        POP_EBCDIC_OUTPUTCONVERSION_STATE_r(r);
+#endif /*CHARSET_EBCDIC*/
+    }
+}
+
+/* Here we deal with getting the request message body from the client.
+ * Whether or not the request contains a body is signaled by the presence
+ * of a non-zero Content-Length or by a Transfer-Encoding: chunked.
+ *
+ * Note that this is more complicated than it was in Apache 1.1 and prior
+ * versions, because chunked support means that the module does less.
+ *
+ * The proper procedure is this:
+ *
+ * 1. Call setup_client_block() near the beginning of the request
+ *    handler. This will set up all the necessary properties, and will
+ *    return either OK, or an error code. If the latter, the module should
+ *    return that error code. The second parameter selects the policy to
+ *    apply if the request message indicates a body, and how a chunked
+ *    transfer-coding should be interpreted. Choose one of
+ *
+ *    REQUEST_NO_BODY          Send 413 error if message has any body
+ *    REQUEST_CHUNKED_ERROR    Send 411 error if body without Content-Length
+ *    REQUEST_CHUNKED_DECHUNK  If chunked, remove the chunks for me.
+ *    REQUEST_CHUNKED_PASS     Pass the chunks to me without removal.
+ *
+ *    In order to use the last two options, the caller MUST provide a buffer
+ *    large enough to hold a chunk-size line, including any extensions.
+ *
+ * 2. When you are ready to read a body (if any), call should_client_block().
+ *    This will tell the module whether or not to read input. If it is 0,
+ *    the module should assume that there is no message body to read.
+ *    This step also sends a 100 Continue response to HTTP/1.1 clients,
+ *    so should not be called until the module is *definitely* ready to
+ *    read content. (otherwise, the point of the 100 response is defeated).
+ *    Never call this function more than once.
+ *
+ * 3. Finally, call get_client_block in a loop. Pass it a buffer and its size.
+ *    It will put data into the buffer (not necessarily a full buffer), and
+ *    return the length of the input block. When it is done reading, it will
+ *    return 0 if EOF, or -1 if there was an error.
+ *    If an error occurs on input, we force an end to keepalive.
+ */
+
+API_EXPORT(int) ap_setup_client_block(request_rec *r, int read_policy)
+{
+    const char *tenc = ap_table_get(r->headers_in, "Transfer-Encoding");
+    const char *lenp = ap_table_get(r->headers_in, "Content-Length");
+    unsigned long max_body;
+
+    r->read_body = read_policy;
+    r->read_chunked = 0;
+    r->remaining = 0;
+
+    if (tenc) {
+        if (strcasecmp(tenc, "chunked")) {
+            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+                        "Unknown Transfer-Encoding %s", tenc);
+            return HTTP_NOT_IMPLEMENTED;
+        }
+        if (r->read_body == REQUEST_CHUNKED_ERROR) {
+            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+                        "chunked Transfer-Encoding forbidden: %s", r->uri);
+            return (lenp) ? HTTP_BAD_REQUEST : HTTP_LENGTH_REQUIRED;
+        }
+
+        r->read_chunked = 1;
+    }
+    else if (lenp) {
+        const char *pos = lenp;
+        int conversion_error = 0;
+
+        while (ap_isspace(*pos))
+            ++pos;
+
+        if (*pos == '\0') {
+            /* special case test - a C-L field NULL or all blanks is
+             * assumed OK and defaults to 0. Otherwise, we do a
+             * strict check of the field */
+            r->remaining = 0;
+        }
+        else {
+            char *endstr;
+            errno = 0;
+            r->remaining = ap_strtol(lenp, &endstr, 10);
+            if (errno || (endstr && *endstr) || (r->remaining < 0)) {
+                conversion_error = 1;
+            }
+        }
+
+        if (conversion_error) {
+            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+                        "Invalid Content-Length");
+            return HTTP_BAD_REQUEST;
+        }
+    }
+
+    if ((r->read_body == REQUEST_NO_BODY) &&
+        (r->read_chunked || (r->remaining > 0))) {
+        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+                    "%s with body is not allowed for %s", r->method, r->uri);
+        return HTTP_REQUEST_ENTITY_TOO_LARGE;
+    }
+
+    max_body = ap_get_limit_req_body(r);
+    if (max_body && ((unsigned long)r->remaining > max_body)
+                 && (r->remaining >= 0)) {
+        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+          "Request content-length of %s is larger than the configured "
+          "limit of %lu", lenp, max_body);
+        return HTTP_REQUEST_ENTITY_TOO_LARGE;
+    }
+
+#ifdef CHARSET_EBCDIC
+    {
+        /* Determine the EBCDIC conversion for the uploaded content
+         * by looking at the Content-Type MIME header. 
+         * If no Content-Type header is found, text conversion is assumed.
+         */
+        ap_bsetflag(r->connection->client, B_ASCII2EBCDIC, ap_checkconv_in(r));
+    }
+#endif
+
+    return OK;
+}
+
+API_EXPORT(int) ap_should_client_block(request_rec *r)
+{
+    /* First check if we have already read the request body */
+
+    if (r->read_length || (!r->read_chunked && (r->remaining <= 0)))
+        return 0;
+
+    if (r->expecting_100 && r->proto_num >= HTTP_VERSION(1,1)) {
+        /* sending 100 Continue interim response */
+        ap_rvputs(r, SERVER_PROTOCOL, " ", status_lines[0], CRLF CRLF,
+                  NULL);
+        ap_rflush(r);
+    }
+
+    return 1;
+}
+
+/**
+ * Parse a chunk extension, detect overflow.
+ * There are two error cases:
+ *  1) If the conversion would require too many bits, a -1 is returned.
+ *  2) If the conversion used the correct number of bits, but an overflow
+ *     caused only the sign bit to flip, then that negative number is
+ *     returned.
+ * In general, any negative number can be considered an overflow error.
+ */
+API_EXPORT(long) ap_get_chunk_size(char *b)
+{
+    long chunksize = 0;
+    long chunkbits = sizeof(long) * 8;
+
+    /* Skip leading zeros */
+    while (*b == '0') {
+        ++b;
+    }
+
+    while (ap_isxdigit(*b) && (chunkbits > 0)) {
+        int xvalue = 0;
+
+        if (*b >= '0' && *b <= '9') {
+            xvalue = *b - '0';
+        }
+        else if (*b >= 'A' && *b <= 'F') {
+            xvalue = *b - 'A' + 0xa;
+        }
+        else if (*b >= 'a' && *b <= 'f') {
+            xvalue = *b - 'a' + 0xa;
+        }
+
+        chunksize = (chunksize << 4) | xvalue;
+        chunkbits -= 4;
+        ++b;
+    }
+    if (ap_isxdigit(*b) && (chunkbits <= 0)) {
+        /* overflow */
+        return -1;
+    }
+
+    return chunksize;
+}
+
+/* get_client_block is called in a loop to get the request message body.
+ * This is quite simple if the client includes a content-length
+ * (the normal case), but gets messy if the body is chunked. Note that
+ * r->remaining is used to maintain state across calls and that
+ * r->read_length is the total number of bytes given to the caller
+ * across all invocations.  It is messy because we have to be careful not
+ * to read past the data provided by the client, since these reads block.
+ * Returns 0 on End-of-body, -1 on error or premature chunk end.
+ *
+ * Reading the chunked encoding requires a buffer size large enough to
+ * hold a chunk-size line, including any extensions. For now, we'll leave
+ * that to the caller, at least until we can come up with a better solution.
+ */
+API_EXPORT(long) ap_get_client_block(request_rec *r, char *buffer, int bufsiz)
+{
+    int c;
+    long len_read, len_to_read;
+    long chunk_start = 0;
+    unsigned long max_body;
+
+    if (!r->read_chunked) {     /* Content-length read */
+        len_to_read = (r->remaining > bufsiz) ? bufsiz : r->remaining;
+        len_read = ap_bread(r->connection->client, buffer, len_to_read);
+        if (len_read <= 0) {
+            if (len_read < 0)
+                r->connection->keepalive = -1;
+            return len_read;
+        }
+        r->read_length += len_read;
+        r->remaining -= len_read;
+        return len_read;
+    }
+
+    /*
+     * Handle chunked reading Note: we are careful to shorten the input
+     * bufsiz so that there will always be enough space for us to add a CRLF
+     * (if necessary).
+     */
+    if (r->read_body == REQUEST_CHUNKED_PASS)
+        bufsiz -= 2;
+    if (bufsiz <= 0)
+        return -1;              /* Cannot read chunked with a small buffer */
+
+    /* Check to see if we have already read too much request data.
+     * For efficiency reasons, we only check this at the top of each
+     * caller read pass, since the limit exists just to stop infinite
+     * length requests and nobody cares if it goes over by one buffer.
+     */
+    max_body = ap_get_limit_req_body(r);
+    if (max_body && ((unsigned long) r->read_length > max_body)
+                 && (r->read_length >= 0)) {
+        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+            "Chunked request body is larger than the configured limit of %lu",
+            max_body);
+        r->connection->keepalive = -1;
+        return -1;
+    }
+
+    if (r->remaining == 0) {    /* Start of new chunk */
+
+        chunk_start = ap_getline(buffer, bufsiz, r->connection->client, 0);
+        if ((chunk_start <= 0) || (chunk_start >= (bufsiz - 1))
+            || !ap_isxdigit(*buffer)) {
+            r->connection->keepalive = -1;
+            return -1;
+        }
+
+        len_to_read = ap_get_chunk_size(buffer);
+
+        if (len_to_read == 0) { /* Last chunk indicated, get footers */
+            if (r->read_body == REQUEST_CHUNKED_DECHUNK) {
+                get_mime_headers(r);
+                ap_snprintf(buffer, bufsiz, "%ld", r->read_length);
+                ap_table_unset(r->headers_in, "Transfer-Encoding");
+                ap_table_setn(r->headers_in, "Content-Length",
+                    ap_pstrdup(r->pool, buffer));
+                return 0;
+            }
+            r->remaining = -1;  /* Indicate footers in-progress */
+        }
+        else if (len_to_read < 0) {
+            r->connection->keepalive = -1;
+            return -1;
+        }
+        else {
+            r->remaining = len_to_read;
+        }
+        if (r->read_body == REQUEST_CHUNKED_PASS) {
+            buffer[chunk_start++] = CR; /* Restore chunk-size line end  */
+            buffer[chunk_start++] = LF;
+            buffer += chunk_start;      /* and pass line on to caller   */
+            bufsiz -= chunk_start;
+        }
+        else {
+            /* REQUEST_CHUNKED_DECHUNK -- do not include the length of the
+             * header in the return value
+             */
+            chunk_start = 0;
+        }
+    }
+                                /* When REQUEST_CHUNKED_PASS, we are */
+    if (r->remaining == -1) {   /* reading footers until empty line  */
+        len_read = chunk_start;
+
+        while ((bufsiz > 1) && ((len_read =
+                  ap_getline(buffer, bufsiz, r->connection->client, 1)) > 0)) {
+
+            if (len_read != (bufsiz - 1)) {
+                buffer[len_read++] = CR;        /* Restore footer line end  */
+                buffer[len_read++] = LF;
+            }
+            chunk_start += len_read;
+            buffer += len_read;
+            bufsiz -= len_read;
+        }
+        if (len_read < 0) {
+            r->connection->keepalive = -1;
+            return -1;
+        }
+
+        if (len_read == 0) {    /* Indicates an empty line */
+            buffer[0] = CR;
+            buffer[1] = LF;
+            chunk_start += 2;
+            r->remaining = -2;
+        }
+        r->read_length += chunk_start;
+        return chunk_start;
+    }
+                                /* When REQUEST_CHUNKED_PASS, we     */
+    if (r->remaining == -2) {   /* finished footers when last called */
+        r->remaining = 0;       /* so now we must signal EOF         */
+        return 0;
+    }
+
+    /* Otherwise, we are in the midst of reading a chunk of data */
+
+    len_to_read = (r->remaining > bufsiz) ? bufsiz : r->remaining;
+
+    len_read = ap_bread(r->connection->client, buffer, len_to_read);
+    if (len_read <= 0) {
+        r->connection->keepalive = -1;
+        return -1;
+    }
+
+    r->remaining -= len_read;
+
+    if (r->remaining == 0) {    /* End of chunk, get trailing CRLF */
+#ifdef CHARSET_EBCDIC
+        /* Chunk end is Protocol stuff! Set conversion = 1 to read CR LF: */
+        PUSH_EBCDIC_INPUTCONVERSION_STATE_r(r, 1);
+#endif /*CHARSET_EBCDIC*/
+
+        if ((c = ap_bgetc(r->connection->client)) == CR) {
+            c = ap_bgetc(r->connection->client);
+        }
+
+#ifdef CHARSET_EBCDIC
+        /* restore ASCII->EBCDIC conversion state */
+        POP_EBCDIC_INPUTCONVERSION_STATE_r(r);
+#endif /*CHARSET_EBCDIC*/
+
+        if (c != LF) {
+            r->connection->keepalive = -1;
+            return -1;
+        }
+        if (r->read_body == REQUEST_CHUNKED_PASS) {
+            buffer[len_read++] = CR;
+            buffer[len_read++] = LF;
+        }
+    }
+    r->read_length += (chunk_start + len_read);
+
+    return (chunk_start + len_read);
+}
+
+/* In HTTP/1.1, any method can have a body.  However, most GET handlers
+ * wouldn't know what to do with a request body if they received one.
+ * This helper routine tests for and reads any message body in the request,
+ * simply discarding whatever it receives.  We need to do this because
+ * failing to read the request body would cause it to be interpreted
+ * as the next request on a persistent connection.
+ *
+ * Since we return an error status if the request is malformed, this
+ * routine should be called at the beginning of a no-body handler, e.g.,
+ *
+ *    if ((retval = ap_discard_request_body(r)) != OK)
+ *        return retval;
+ */
+API_EXPORT(int) ap_discard_request_body(request_rec *r)
+{
+    int rv;
+
+    if ((rv = ap_setup_client_block(r, REQUEST_CHUNKED_PASS)))
+        return rv;
+
+    /* In order to avoid sending 100 Continue when we already know the
+     * final response status, and yet not kill the connection if there is
+     * no request body to be read, we need to duplicate the test from
+     * ap_should_client_block() here negated rather than call it directly.
+     */
+    if ((r->read_length == 0) && (r->read_chunked || (r->remaining > 0))) {
+        char dumpbuf[HUGE_STRING_LEN];
+
+        if (r->expecting_100) {
+            r->connection->keepalive = -1;
+            return OK;
+        }
+        ap_hard_timeout("reading request body", r);
+        while ((rv = ap_get_client_block(r, dumpbuf, HUGE_STRING_LEN)) > 0)
+            continue;
+        ap_kill_timeout(r);
+
+        if (rv < 0)
+            return HTTP_BAD_REQUEST;
+    }
+    return OK;
+}
+
+/*
+ * Send the body of a response to the client.
+ */
+API_EXPORT(long) ap_send_fd(FILE *f, request_rec *r)
+{
+    return ap_send_fd_length(f, r, -1);
+}
+
+API_EXPORT(long) ap_send_fd_length(FILE *f, request_rec *r, long length)
+{
+    char buf[IOBUFSIZE];
+    long total_bytes_sent = 0;
+    register int n, w, o, len;
+
+    if (length == 0)
+        return 0;
+
+    ap_soft_timeout("send body", r);
+
+    while (!r->connection->aborted) {
+        if ((length > 0) && (total_bytes_sent + IOBUFSIZE) > length)
+            len = length - total_bytes_sent;
+        else
+            len = IOBUFSIZE;
+
+        while ((n = fread(buf, sizeof(char), len, f)) < 1
+               && ferror(f) && errno == EINTR && !r->connection->aborted)
+            continue;
+
+        if (n < 1) {
+            break;
+        }
+        o = 0;
+
+        while (n && !r->connection->aborted) {
+            w = ap_bwrite(r->connection->client, &buf[o], n);
+            if (w > 0) {
+                ap_reset_timeout(r); /* reset timeout after successful write */
+                total_bytes_sent += w;
+                n -= w;
+                o += w;
+            }
+            else if (w < 0) {
+                if (!r->connection->aborted) {
+                    ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
+                     "client stopped connection before send body completed");
+                    ap_bsetflag(r->connection->client, B_EOUT, 1);
+                    r->connection->aborted = 1;
+                }
+                break;
+            }
+        }
+    }
+
+    ap_kill_timeout(r);
+    SET_BYTES_SENT(r);
+    return total_bytes_sent;
+}
+
+/*
+ * Send the body of a response to the client.
+ */
+API_EXPORT(long) ap_send_fb(BUFF *fb, request_rec *r)
+{
+    return ap_send_fb_length(fb, r, -1);
+}
+
+API_EXPORT(long) ap_send_fb_length(BUFF *fb, request_rec *r, long length)
+{
+    char buf[IOBUFSIZE];
+    long total_bytes_sent = 0;
+    register int n, w, o, len, fd;
+    fd_set fds;
+#ifdef TPF_HAVE_NONSOCKET_SELECT
+    struct timeval tv;
+#endif 
+
+    if (length == 0)
+        return 0;
+
+    /* Make fb unbuffered and non-blocking */
+    ap_bsetflag(fb, B_RD, 0);
+#ifndef TPF_NO_NONSOCKET_SELECT
+    ap_bnonblock(fb, B_RD);
+#endif
+    fd = ap_bfileno(fb, B_RD);
+#ifdef CHECK_FD_SETSIZE
+    if (fd >= FD_SETSIZE) {
+	ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, NULL,
+	    "send body: filedescriptor (%u) larger than FD_SETSIZE (%u) "
+	    "found, you probably need to rebuild Apache with a "
+	    "larger FD_SETSIZE", fd, FD_SETSIZE);
+	return 0;
+    }
+#endif
+
+    ap_soft_timeout("send body", r);
+
+    FD_ZERO(&fds);
+    while (!r->connection->aborted) {
+#ifdef NDELAY_PIPE_RETURNS_ZERO
+	/* Contributed by dwd@bell-labs.com for UTS 2.1.2, where the fcntl */
+	/*   O_NDELAY flag causes read to return 0 when there's nothing */
+	/*   available when reading from a pipe.  That makes it tricky */
+	/*   to detect end-of-file :-(.  This stupid bug is even documented */
+	/*   in the read(2) man page where it says that everything but */
+	/*   pipes return -1 and EAGAIN.  That makes it a feature, right? */
+	int afterselect = 0;
+#endif
+        if ((length > 0) && (total_bytes_sent + IOBUFSIZE) > length)
+            len = length - total_bytes_sent;
+        else
+            len = IOBUFSIZE;
+
+        do {
+            n = ap_bread(fb, buf, len);
+#ifdef NDELAY_PIPE_RETURNS_ZERO
+	    if ((n > 0) || (n == 0 && afterselect))
+		break;
+#else
+            if (n >= 0)
+                break;
+#endif
+            if (r->connection->aborted)
+                break;
+            if (n < 0 && errno != EAGAIN)
+                break;
+
+            /* we need to block, so flush the output first */
+            if (ap_bflush(r->connection->client) < 0) {
+                ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
+                    "client stopped connection before send body completed");
+                ap_bsetflag(r->connection->client, B_EOUT, 1);
+                r->connection->aborted = 1;
+                break;
+            }
+            FD_SET(fd, &fds);
+            /*
+             * we don't care what select says, we might as well loop back
+             * around and try another read
+             */
+#ifdef TPF_HAVE_NONSOCKET_SELECT
+            tv.tv_sec =  1;
+            tv.tv_usec = 0;
+            ap_select(fd + 1, &fds, NULL, NULL, &tv);
+#else
+            ap_select(fd + 1, &fds, NULL, NULL, NULL);
+#endif  
+#ifdef NDELAY_PIPE_RETURNS_ZERO
+	    afterselect = 1;
+#endif
+        } while (!r->connection->aborted);
+
+        if (n < 1 || r->connection->aborted) {
+            break;
+        }
+        o = 0;
+
+        while (n && !r->connection->aborted) {
+            w = ap_bwrite(r->connection->client, &buf[o], n);
+            if (w > 0) {
+                ap_reset_timeout(r); /* reset timeout after successful write */
+                total_bytes_sent += w;
+                n -= w;
+                o += w;
+            }
+            else if (w < 0) {
+                if (!r->connection->aborted) {
+                    ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
+                       "client stopped connection before send body completed");
+                    ap_bsetflag(r->connection->client, B_EOUT, 1);
+                    r->connection->aborted = 1;
+                }
+                break;
+            }
+        }
+    }
+
+    ap_kill_timeout(r);
+    SET_BYTES_SENT(r);
+    return total_bytes_sent;
+}
+
+
+
+/* The code writes MMAP_SEGMENT_SIZE bytes at a time.  This is due to Apache's
+ * timeout model, which is a timeout per-write rather than a time for the
+ * entire transaction to complete.  Essentially this should be small enough
+ * so that in one Timeout period, your slowest clients should be reasonably
+ * able to receive this many bytes.
+ *
+ * To take advantage of zero-copy TCP under Solaris 2.6 this should be a
+ * multiple of 16k.  (And you need a SunATM2.0 network card.)
+ */
+#ifndef MMAP_SEGMENT_SIZE
+#define MMAP_SEGMENT_SIZE       32768
+#endif
+
+/* send data from an in-memory buffer */
+API_EXPORT(size_t) ap_send_mmap(void *mm, request_rec *r, size_t offset,
+                             size_t length)
+{
+    size_t total_bytes_sent = 0;
+    int n, w;
+
+    if (length == 0)
+        return 0;
+
+    ap_soft_timeout("send mmap", r);
+
+    length += offset;
+    while (!r->connection->aborted && offset < length) {
+        if (length - offset > MMAP_SEGMENT_SIZE) {
+            n = MMAP_SEGMENT_SIZE;
+        }
+        else {
+            n = length - offset;
+        }
+
+        while (n && !r->connection->aborted) {
+            w = ap_bwrite(r->connection->client, (char *) mm + offset, n);
+            if (w > 0) {
+                ap_reset_timeout(r); /* reset timeout after successful write */
+                total_bytes_sent += w;
+                n -= w;
+                offset += w;
+            }
+            else if (w < 0) {
+                if (!r->connection->aborted) {
+                    ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
+                       "client stopped connection before send mmap completed");
+                    ap_bsetflag(r->connection->client, B_EOUT, 1);
+                    r->connection->aborted = 1;
+                }
+                break;
+            }
+        }
+    }
+
+    ap_kill_timeout(r);
+    SET_BYTES_SENT(r);
+    return total_bytes_sent;
+}
+
+API_EXPORT(int) ap_rputc(int c, request_rec *r)
+{
+    if (r->connection->aborted)
+        return EOF;
+
+    if (ap_bputc(c, r->connection->client) < 0) {
+        if (!r->connection->aborted) {
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
+                "client stopped connection before rputc completed");
+            ap_bsetflag(r->connection->client, B_EOUT, 1);
+            r->connection->aborted = 1;
+        }
+        return EOF;
+    }
+    SET_BYTES_SENT(r);
+    return c;
+}
+
+API_EXPORT(int) ap_rputs(const char *str, request_rec *r)
+{
+    int rcode;
+
+    if (r->connection->aborted)
+        return EOF;
+    
+    rcode = ap_bputs(str, r->connection->client);
+    if (rcode < 0) {
+        if (!r->connection->aborted) {
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
+                "client stopped connection before rputs completed");
+            ap_bsetflag(r->connection->client, B_EOUT, 1);
+            r->connection->aborted = 1;
+        }
+        return EOF;
+    }
+    SET_BYTES_SENT(r);
+    return rcode;
+}
+
+API_EXPORT(int) ap_rwrite(const void *buf, int nbyte, request_rec *r)
+{
+    int n;
+
+    if (r->connection->aborted)
+        return -1;
+
+    n = ap_bwrite(r->connection->client, buf, nbyte);
+    if (n < 0) {
+        if (!r->connection->aborted) {
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
+                "client stopped connection before rwrite completed");
+            ap_bsetflag(r->connection->client, B_EOUT, 1);
+            r->connection->aborted = 1;
+        }
+        return -1;
+    }
+    SET_BYTES_SENT(r);
+    return n;
+}
+
+API_EXPORT(int) ap_vrprintf(request_rec *r, const char *fmt, va_list ap)
+{
+    int n;
+
+    if (r->connection->aborted)
+        return -1;
+
+    n = ap_vbprintf(r->connection->client, fmt, ap);
+
+    if (n < 0) {
+        if (!r->connection->aborted) {
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
+                "client stopped connection before vrprintf completed");
+            ap_bsetflag(r->connection->client, B_EOUT, 1);
+            r->connection->aborted = 1;
+        }
+        return -1;
+    }
+    SET_BYTES_SENT(r);
+    return n;
+}
+
+API_EXPORT_NONSTD(int) ap_rprintf(request_rec *r, const char *fmt,...)
+{
+    va_list vlist;
+    int n;
+
+    if (r->connection->aborted)
+        return -1;
+
+    va_start(vlist, fmt);
+    n = ap_vbprintf(r->connection->client, fmt, vlist);
+    va_end(vlist);
+
+    if (n < 0) {
+        if (!r->connection->aborted) {
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
+                "client stopped connection before rprintf completed");
+            ap_bsetflag(r->connection->client, B_EOUT, 1);
+            r->connection->aborted = 1;
+        }
+        return -1;
+    }
+    SET_BYTES_SENT(r);
+    return n;
+}
+
+API_EXPORT_NONSTD(int) ap_rvputs(request_rec *r,...)
+{
+    va_list args;
+    int i, j, k;
+    const char *x;
+    BUFF *fb = r->connection->client;
+
+    if (r->connection->aborted)
+        return EOF;
+
+    va_start(args, r);
+    for (k = 0;;) {
+        x = va_arg(args, const char *);
+        if (x == NULL)
+            break;
+        j = strlen(x);
+        i = ap_bwrite(fb, x, j);
+        if (i != j) {
+            va_end(args);
+            if (!r->connection->aborted) {
+                ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
+                    "client stopped connection before rvputs completed");
+                ap_bsetflag(r->connection->client, B_EOUT, 1);
+                r->connection->aborted = 1;
+            }
+            return EOF;
+        }
+        k += i;
+    }
+    va_end(args);
+
+    SET_BYTES_SENT(r);
+    return k;
+}
+
+API_EXPORT(int) ap_rflush(request_rec *r)
+{
+    if (ap_bflush(r->connection->client) < 0) {
+        if (!r->connection->aborted) {
+            ap_log_rerror(APLOG_MARK, APLOG_INFO, r,
+                "client stopped connection before rflush completed");
+            ap_bsetflag(r->connection->client, B_EOUT, 1);
+            r->connection->aborted = 1;
+        }
+        return EOF;
+    }
+    return 0;
+}
+
+/* We should have named this send_canned_response, since it is used for any
+ * response that can be generated by the server from the request record.
+ * This includes all 204 (no content), 3xx (redirect), 4xx (client error),
+ * and 5xx (server error) messages that have not been redirected to another
+ * handler via the ErrorDocument feature.
+ */
+API_EXPORT(void) ap_send_error_response(request_rec *r, int recursive_error)
+{
+    int status = r->status;
+    int idx = ap_index_of_response(status);
+    char *custom_response;
+    const char *location = ap_table_get(r->headers_out, "Location");
+#ifdef CHARSET_EBCDIC
+    /* Error Responses (builtin / string literal / redirection) are TEXT! */
+    ap_bsetflag(r->connection->client, B_EBCDIC2ASCII, r->ebcdic.conv_out = 1);
+#endif
+
+    /*
+     * It's possible that the Location field might be in r->err_headers_out
+     * instead of r->headers_out; use the latter if possible, else the
+     * former.
+     */
+    if (location == NULL) {
+	location = ap_table_get(r->err_headers_out, "Location");
+    }
+    /* We need to special-case the handling of 204 and 304 responses,
+     * since they have specific HTTP requirements and do not include a
+     * message body.  Note that being assbackwards here is not an option.
+     */
+    if (status == HTTP_NOT_MODIFIED) {
+        if (!ap_is_empty_table(r->err_headers_out))
+            r->headers_out = ap_overlay_tables(r->pool, r->err_headers_out,
+                                               r->headers_out);
+        ap_hard_timeout("send 304", r);
+
+        ap_basic_http_header(r);
+        ap_set_keepalive(r);
+
+        ap_table_do((int (*)(void *, const char *, const char *)) ap_send_header_field,
+                    (void *) r, r->headers_out,
+                    "Connection",
+                    "Keep-Alive",
+                    "ETag",
+                    "Content-Location",
+                    "Expires",
+                    "Cache-Control",
+                    "Vary",
+                    "Warning",
+                    "WWW-Authenticate",
+                    "Proxy-Authenticate",
+                    NULL);
+
+        terminate_header(r->connection->client);
+
+        ap_kill_timeout(r);
+        return;
+    }
+
+    if (status == HTTP_NO_CONTENT) {
+        ap_send_http_header(r);
+        ap_finalize_request_protocol(r);
+        return;
+    }
+
+    if (!r->assbackwards) {
+        table *tmp = r->headers_out;
+
+        /* For all HTTP/1.x responses for which we generate the message,
+         * we need to avoid inheriting the "normal status" header fields
+         * that may have been set by the request handler before the
+         * error or redirect, except for Location on external redirects.
+         */
+        r->headers_out = r->err_headers_out;
+        r->err_headers_out = tmp;
+        ap_clear_table(r->err_headers_out);
+
+        if (ap_is_HTTP_REDIRECT(status) || (status == HTTP_CREATED)) {
+            if ((location != NULL) && *location) {
+	        ap_table_setn(r->headers_out, "Location", location);
+            }
+            else {
+                location = "";   /* avoids coredump when printing, below */
+            }
+        }
+
+        r->content_language = NULL;
+        r->content_languages = NULL;
+        r->content_encoding = NULL;
+        r->clength = 0;
+        if (ap_table_get(r->subprocess_env,
+                         "suppress-error-charset") != NULL) {
+            r->content_type = "text/html";
+        }
+        else {
+            r->content_type = "text/html; charset=iso-8859-1";
+        }
+
+        if ((status == METHOD_NOT_ALLOWED) || (status == NOT_IMPLEMENTED))
+            ap_table_setn(r->headers_out, "Allow", make_allow(r));
+
+        ap_send_http_header(r);
+
+        if (r->header_only) {
+            ap_finalize_request_protocol(r);
+            ap_rflush(r);
+            return;
+        }
+    }
+
+#ifdef CHARSET_EBCDIC
+    /* Server-generated response, converted */
+    ap_bsetflag(r->connection->client, B_EBCDIC2ASCII, r->ebcdic.conv_out = 1);
+#endif
+
+    ap_hard_timeout("send error body", r);
+
+    if ((custom_response = ap_response_code_string(r, idx))) {
+        /*
+         * We have a custom response output. This should only be
+         * a text-string to write back. But if the ErrorDocument
+         * was a local redirect and the requested resource failed
+         * for any reason, the custom_response will still hold the
+         * redirect URL. We don't really want to output this URL
+         * as a text message, so first check the custom response
+         * string to ensure that it is a text-string (using the
+         * same test used in ap_die(), i.e. does it start with a ").
+         * If it doesn't, we've got a recursive error, so find
+         * the original error and output that as well.
+         */
+        if (custom_response[0] == '\"') {
+            ap_rputs(custom_response + 1, r);
+            ap_kill_timeout(r);
+            ap_finalize_request_protocol(r);
+            ap_rflush(r);
+            return;
+        }
+        /*
+         * Redirect failed, so get back the original error
+         */
+        while (r->prev && (r->prev->status != HTTP_OK))
+            r = r->prev;
+    }
+    {
+        const char *title = status_lines[idx];
+        const char *h1;
+        const char *error_notes;
+
+        /* Accept a status_line set by a module, but only if it begins
+         * with the 3 digit status code
+         */
+        if (r->status_line != NULL
+            && strlen(r->status_line) > 4       /* long enough */
+            && ap_isdigit(r->status_line[0])
+            && ap_isdigit(r->status_line[1])
+            && ap_isdigit(r->status_line[2])
+            && ap_isspace(r->status_line[3])
+            && ap_isalnum(r->status_line[4])) {
+            title = r->status_line;
+        }
+
+        /* folks decided they didn't want the error code in the H1 text */
+        h1 = &title[4];
+
+        ap_rvputs(r,
+                  DOCTYPE_HTML_2_0
+                  "<HTML><HEAD>\n<TITLE>", title,
+                  "</TITLE>\n</HEAD><BODY>\n<H1>", h1, "</H1>\n",
+                  NULL);
+
+	switch (status) {
+	case HTTP_MOVED_PERMANENTLY:
+	case HTTP_MOVED_TEMPORARILY:
+	case HTTP_TEMPORARY_REDIRECT:
+	    ap_rvputs(r, "The document has moved <A HREF=\"",
+		      ap_escape_html(r->pool, location), "\">here</A>.<P>\n",
+		      NULL);
+	    break;
+	case HTTP_SEE_OTHER:
+	    ap_rvputs(r, "The answer to your request is located <A HREF=\"",
+		      ap_escape_html(r->pool, location), "\">here</A>.<P>\n",
+		      NULL);
+	    break;
+	case HTTP_USE_PROXY:
+	    ap_rvputs(r, "This resource is only accessible "
+		      "through the proxy\n",
+		      ap_escape_html(r->pool, location),
+		      "<BR>\nYou will need to ",
+		      "configure your client to use that proxy.<P>\n", NULL);
+	    break;
+	case HTTP_PROXY_AUTHENTICATION_REQUIRED:
+	case AUTH_REQUIRED:
+	    ap_rputs("This server could not verify that you\n"
+	             "are authorized to access the document\n"
+	             "requested.  Either you supplied the wrong\n"
+	             "credentials (e.g., bad password), or your\n"
+	             "browser doesn't understand how to supply\n"
+	             "the credentials required.<P>\n", r);
+	    break;
+	case BAD_REQUEST:
+	    ap_rputs("Your browser sent a request that "
+	             "this server could not understand.<P>\n", r);
+	    if ((error_notes = ap_table_get(r->notes, "error-notes")) != NULL) {
+		ap_rvputs(r, error_notes, "<P>\n", NULL);
+	    }
+	    break;
+	case HTTP_FORBIDDEN:
+	    ap_rvputs(r, "You don't have permission to access ",
+		      ap_escape_html(r->pool, r->uri),
+		      "\non this server.<P>\n", NULL);
+	    break;
+	case NOT_FOUND:
+	    ap_rvputs(r, "The requested URL ",
+		      ap_escape_html(r->pool, r->uri),
+		      " was not found on this server.<P>\n", NULL);
+	    break;
+	case METHOD_NOT_ALLOWED:
+	    ap_rvputs(r, "The requested method ", r->method,
+		      " is not allowed "
+		      "for the URL ", ap_escape_html(r->pool, r->uri),
+		      ".<P>\n", NULL);
+	    break;
+	case NOT_ACCEPTABLE:
+	    ap_rvputs(r,
+		      "An appropriate representation of the "
+		      "requested resource ",
+		      ap_escape_html(r->pool, r->uri),
+		      " could not be found on this server.<P>\n", NULL);
+	    /* fall through */
+	case MULTIPLE_CHOICES:
+	    {
+		const char *list;
+		if ((list = ap_table_get(r->notes, "variant-list")))
+		    ap_rputs(list, r);
+	    }
+	    break;
+	case LENGTH_REQUIRED:
+	    ap_rvputs(r, "A request of the requested method ", r->method,
+		      " requires a valid Content-length.<P>\n", NULL);
+	    if ((error_notes = ap_table_get(r->notes, "error-notes")) != NULL) {
+		ap_rvputs(r, error_notes, "<P>\n", NULL);
+	    }
+	    break;
+	case PRECONDITION_FAILED:
+	    ap_rvputs(r, "The precondition on the request for the URL ",
+		      ap_escape_html(r->pool, r->uri),
+		      " evaluated to false.<P>\n", NULL);
+	    break;
+	case HTTP_NOT_IMPLEMENTED:
+	    ap_rvputs(r, ap_escape_html(r->pool, r->method), " to ",
+		      ap_escape_html(r->pool, r->uri),
+		      " not supported.<P>\n", NULL);
+	    if ((error_notes = ap_table_get(r->notes, "error-notes")) != NULL) {
+		ap_rvputs(r, error_notes, "<P>\n", NULL);
+	    }
+	    break;
+	case BAD_GATEWAY:
+	    ap_rputs("The proxy server received an invalid" CRLF
+	             "response from an upstream server.<P>" CRLF, r);
+	    if ((error_notes = ap_table_get(r->notes, "error-notes")) != NULL) {
+		ap_rvputs(r, error_notes, "<P>\n", NULL);
+	    }
+	    break;
+	case VARIANT_ALSO_VARIES:
+	    ap_rvputs(r, "A variant for the requested resource\n<PRE>\n",
+		      ap_escape_html(r->pool, r->uri),
+		      "\n</PRE>\nis itself a negotiable resource. "
+		      "This indicates a configuration error.<P>\n", NULL);
+	    break;
+	case HTTP_REQUEST_TIME_OUT:
+	    ap_rputs("Server timeout waiting for the HTTP request from the client.\n", r);
+	    break;
+	case HTTP_GONE:
+	    ap_rvputs(r, "The requested resource<BR>",
+		      ap_escape_html(r->pool, r->uri),
+		      "<BR>\nis no longer available on this server ",
+		      "and there is no forwarding address.\n",
+		      "Please remove all references to this resource.\n",
+		      NULL);
+	    break;
+	case HTTP_REQUEST_ENTITY_TOO_LARGE:
+	    ap_rvputs(r, "The requested resource<BR>",
+		      ap_escape_html(r->pool, r->uri), "<BR>\n",
+		      "does not allow request data with ", r->method,
+		      " requests, or the amount of data provided in\n",
+		      "the request exceeds the capacity limit.\n", NULL);
+	    break;
+	case HTTP_REQUEST_URI_TOO_LARGE:
+	    ap_rputs("The requested URL's length exceeds the capacity\n"
+	             "limit for this server.<P>\n", r);
+	    if ((error_notes = ap_table_get(r->notes, "error-notes")) != NULL) {
+		ap_rvputs(r, error_notes, "<P>\n", NULL);
+	    }
+	    break;
+	case HTTP_UNSUPPORTED_MEDIA_TYPE:
+	    ap_rputs("The supplied request data is not in a format\n"
+	             "acceptable for processing by this resource.\n", r);
+	    break;
+	case HTTP_RANGE_NOT_SATISFIABLE:
+	    ap_rputs("None of the range-specifier values in the Range\n"
+	             "request-header field overlap the current extent\n"
+	             "of the selected resource.\n", r);
+	    break;
+	case HTTP_EXPECTATION_FAILED:
+	    ap_rvputs(r, "The expectation given in the Expect request-header"
+	              "\nfield could not be met by this server.<P>\n"
+	              "The client sent<PRE>\n    Expect: ",
+	              ap_table_get(r->headers_in, "Expect"), "\n</PRE>\n"
+	              "but we only allow the 100-continue expectation.\n",
+	              NULL);
+	    break;
+	case HTTP_UNPROCESSABLE_ENTITY:
+	    ap_rputs("The server understands the media type of the\n"
+	             "request entity, but was unable to process the\n"
+	             "contained instructions.\n", r);
+	    break;
+	case HTTP_LOCKED:
+	    ap_rputs("The requested resource is currently locked.\n"
+	             "The lock must be released or proper identification\n"
+	             "given before the method can be applied.\n", r);
+	    break;
+	case HTTP_FAILED_DEPENDENCY:
+	    ap_rputs("The method could not be performed on the resource\n"
+	             "because the requested action depended on another\n"
+	             "action and that other action failed.\n", r);
+	    break;
+	case HTTP_INSUFFICIENT_STORAGE:
+	    ap_rputs("The method could not be performed on the resource\n"
+	             "because the server is unable to store the\n"
+	             "representation needed to successfully complete the\n"
+	             "request.  There is insufficient free space left in\n"
+	             "your storage allocation.\n", r);
+	    break;
+	case HTTP_SERVICE_UNAVAILABLE:
+	    ap_rputs("The server is temporarily unable to service your\n"
+	             "request due to maintenance downtime or capacity\n"
+	             "problems. Please try again later.\n", r);
+	    break;
+	case HTTP_GATEWAY_TIME_OUT:
+	    ap_rputs("The proxy server did not receive a timely response\n"
+	             "from the upstream server.\n", r);
+	    break;
+	case HTTP_NOT_EXTENDED:
+	    ap_rputs("A mandatory extension policy in the request is not\n"
+	             "accepted by the server for this resource.\n", r);
+	    break;
+	default:            /* HTTP_INTERNAL_SERVER_ERROR */
+	    /*
+	     * This comparison to expose error-notes could be modified to
+	     * use a configuration directive and export based on that 
+	     * directive.  For now "*" is used to designate an error-notes
+	     * that is totally safe for any user to see (ie lacks paths,
+	     * database passwords, etc.)
+	     */
+	    if (((error_notes = ap_table_get(r->notes, "error-notes")) != NULL)
+		&& (h1 = ap_table_get(r->notes, "verbose-error-to")) != NULL
+		&& (strcmp(h1, "*") == 0)) {
+	        ap_rvputs(r, error_notes, "<P>\n", NULL);
+	    }
+	    else {
+	        ap_rvputs(r, "The server encountered an internal error or\n"
+	             "misconfiguration and was unable to complete\n"
+	             "your request.<P>\n"
+	             "Please contact the server administrator,\n ",
+	             ap_escape_html(r->pool, r->server->server_admin),
+	             " and inform them of the time the error occurred,\n"
+	             "and anything you might have done that may have\n"
+	             "caused the error.<P>\n"
+		     "More information about this error may be available\n"
+		     "in the server error log.<P>\n", NULL);
+	    }
+	 /*
+	  * It would be nice to give the user the information they need to
+	  * fix the problem directly since many users don't have access to
+	  * the error_log (think University sites) even though they can easily
+	  * get this error by misconfiguring an htaccess file.  However, the
+	  * error notes tend to include the real file pathname in this case,
+	  * which some people consider to be a breach of privacy.  Until we
+	  * can figure out a way to remove the pathname, leave this commented.
+	  *
+	  * if ((error_notes = ap_table_get(r->notes, "error-notes")) != NULL) {
+	  *     ap_rvputs(r, error_notes, "<P>\n", NULL);
+	  * }
+	  */
+	    break;
+	}
+
+        if (recursive_error) {
+            ap_rvputs(r, "<P>Additionally, a ",
+                      status_lines[ap_index_of_response(recursive_error)],
+                      "\nerror was encountered while trying to use an "
+                      "ErrorDocument to handle the request.\n", NULL);
+        }
+        ap_rputs(ap_psignature("<HR>\n", r), r);
+        ap_rputs("</BODY></HTML>\n", r);
+    }
+    ap_kill_timeout(r);
+    ap_finalize_request_protocol(r);
+    ap_rflush(r);
+}
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/main/http_request.c apache_1.3.33/src/main/http_request.c
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/main/http_request.c	Sat Aug 28 13:35:27 2004
+++ apache_1.3.33/src/main/http_request.c	Mon Jul 18 15:22:25 2005
@@ -1372,6 +1372,10 @@
 
     new->method          = r->method;
     new->method_number   = r->method_number;
+#ifdef EAPI
+    /* initialize context _BEFORE_ ap_parse_uri() call */
+    new->ctx             = r->ctx;
+#endif /* EAPI */
     ap_parse_uri(new, new_uri);
     new->request_config = ap_create_request_config(r->pool);
     new->per_dir_config = r->server->lookup_defaults;
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/main/http_request.c.orig apache_1.3.33/src/main/http_request.c.orig
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/main/http_request.c.orig	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/main/http_request.c.orig	Sat Aug 28 13:35:27 2004
@@ -0,0 +1,1475 @@
+/* Copyright 1999-2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * http_request.c: functions to get and process requests
+ *
+ * Rob McCool 3/21/93
+ *
+ * Thoroughly revamped by rst for Apache.  NB this file reads
+ * best from the bottom up.
+ *
+ */
+
+#define CORE_PRIVATE
+#include "httpd.h"
+#include "http_config.h"
+#include "http_request.h"
+#include "http_core.h"
+#include "http_protocol.h"
+#include "http_conf_globals.h"	/* for ap_extended_status */
+#include "http_log.h"
+#include "http_main.h"
+#include "scoreboard.h"
+#include "fnmatch.h"
+
+/*****************************************************************
+ *
+ * Getting and checking directory configuration.  Also checks the
+ * FollowSymlinks and FollowSymOwner stuff, since this is really the
+ * only place that can happen (barring a new mid_dir_walk callout).
+ *
+ * We can't do it as an access_checker module function which gets
+ * called with the final per_dir_config, since we could have a directory
+ * with FollowSymLinks disabled, which contains a symlink to another
+ * with a .htaccess file which turns FollowSymLinks back on --- and
+ * access in such a case must be denied.  So, whatever it is that
+ * checks FollowSymLinks needs to know the state of the options as
+ * they change, all the way down.
+ */
+
+/*
+ * We don't want people able to serve up pipes, or unix sockets, or other
+ * scary things.  Note that symlink tests are performed later.
+ */
+static int check_safe_file(request_rec *r)
+{
+    if (r->finfo.st_mode == 0         /* doesn't exist */
+        || S_ISDIR(r->finfo.st_mode)
+        || S_ISREG(r->finfo.st_mode)
+        || S_ISLNK(r->finfo.st_mode)) {
+        return OK;
+    }
+    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+                "object is not a file, directory or symlink: %s",
+                r->filename);
+    return HTTP_FORBIDDEN;
+}
+
+
+static int check_symlinks(char *d, int opts)
+{
+#if defined(OS2) || defined(WIN32) || defined(NETWARE)
+    /* OS/2 doesn't have symlinks */
+    return OK;
+#else
+    struct stat lfi, fi;
+    char *lastp;
+    int res;
+
+    if (opts & OPT_SYM_LINKS)
+        return OK;
+
+    /*
+     * Strip trailing '/', if any, off what we're checking; trailing slashes
+     * make some systems follow symlinks to directories even in lstat().
+     * After we've done the lstat, put it back.  Also, don't bother checking
+     * '/' at all...
+     * 
+     * Note that we don't have to worry about multiple slashes here because of
+     * no2slash() below...
+     */
+
+    lastp = d + strlen(d) - 1;
+    if (lastp == d)
+        return OK;              /* Root directory, '/' */
+
+    if (*lastp == '/')
+        *lastp = '\0';
+    else
+        lastp = NULL;
+
+    res = lstat(d, &lfi);
+
+    if (lastp)
+        *lastp = '/';
+
+    /*
+     * Note that we don't reject accesses to nonexistent files (multiviews or
+     * the like may cons up a way to run the transaction anyway)...
+     */
+
+    if (!(res >= 0) || !S_ISLNK(lfi.st_mode))
+        return OK;
+
+    /* OK, it's a symlink.  May still be OK with OPT_SYM_OWNER */
+
+    if (!(opts & OPT_SYM_OWNER))
+        return HTTP_FORBIDDEN;
+
+    if (stat(d, &fi) < 0)
+        return HTTP_FORBIDDEN;
+
+    return (fi.st_uid == lfi.st_uid) ? OK : HTTP_FORBIDDEN;
+
+#endif
+}
+
+/* Dealing with the file system to get PATH_INFO
+ */
+static int get_path_info(request_rec *r)
+{
+    char *cp;
+    char *path = r->filename;
+    char *end = &path[strlen(path)];
+    char *last_cp = NULL;
+    int rv;
+#if defined(HAVE_DRIVE_LETTERS) || defined(HAVE_UNC_PATHS)
+    char bStripSlash=1;
+#endif
+
+    if (r->finfo.st_mode) {
+	/* assume path_info already set */
+	return OK;
+    }
+
+#ifdef HAVE_DRIVE_LETTERS
+    /* If the directory is x:\, then we don't want to strip
+     * the trailing slash since x: is not a valid directory.
+     */
+    if (strlen(path) == 3 && path[1] == ':' && path[2] == '/')
+        bStripSlash = 0;
+#endif
+
+
+#ifdef HAVE_UNC_PATHS
+    /* If UNC name == //machine/share/, do not 
+     * advance over the trailing slash.  Any other
+     * UNC name is OK to strip the slash.
+     */
+    cp = end;
+    if (strlen(path) > 2 && path[0] == '/' && path[1] == '/' && 
+        path[2] != '/' && cp[-1] == '/') {
+        char *p;
+        int iCount=0;
+        p = path;
+        while (p = strchr(p,'/')) {
+            p++;
+            iCount++;
+        }
+    
+        if (iCount == 4)
+            bStripSlash = 0;
+    }
+#endif
+
+#if defined(HAVE_DRIVE_LETTERS) || defined(HAVE_UNC_PATHS)
+    if (bStripSlash)
+#endif
+        /* Advance over trailing slashes ... NOT part of filename 
+         * if file is not a UNC name (Win32 only).
+         */
+        for (cp = end; cp > path && cp[-1] == '/'; --cp)
+            continue;
+
+    while (cp > path) {
+
+        /* See if the pathname ending here exists... */
+
+        *cp = '\0';
+
+        /* We must not stat() filenames that may cause os-specific system
+         * problems, such as "/file/aux" on DOS-abused filesystems.
+         * So pretend that they do not exist by returning an ENOENT error.
+         * This will force us to drop that part of the path and keep
+         * looking back for a "real" file that exists, while still allowing
+         * the "invalid" path parts within the PATH_INFO.
+         */
+        if (!ap_os_is_filename_valid(path)) {
+            errno = ENOENT;
+            rv = -1;
+        }
+        else {
+            errno = 0;
+            rv = stat(path, &r->finfo);
+#ifdef OS2
+            r->finfo.st_ino = 0;
+#endif
+        }
+
+        if (cp != end)
+            *cp = '/';
+
+        if (!rv) {
+
+            /*
+             * Aha!  Found something.  If it was a directory, we will search
+             * contents of that directory for a multi_match, so the PATH_INFO
+             * argument starts with the component after that.
+             */
+
+            if (S_ISDIR(r->finfo.st_mode) && last_cp) {
+                r->finfo.st_mode = 0;   /* No such file... */
+                cp = last_cp;
+            }
+
+            r->path_info = ap_pstrdup(r->pool, cp);
+            *cp = '\0';
+            return OK;
+        }
+	/* must set this to zero, some stat()s may have corrupted it
+	 * even if they returned an error.
+	 */
+	r->finfo.st_mode = 0;
+#if defined(ENOENT) && defined(ENOTDIR)
+        if (errno == ENOENT || errno == ENOTDIR) {
+            last_cp = cp;
+
+            while (--cp > path && *cp != '/')
+                continue;
+
+            while (cp > path && cp[-1] == '/')
+                --cp;
+        }
+        else {
+#if defined(EACCES)
+            if (errno == EACCES)
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
+                            "access to %s failed because search "
+                            "permissions are missing on a component "
+                            "of the path", r->uri);
+            else
+#endif 
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
+                            "access to %s failed", r->uri);
+            return HTTP_FORBIDDEN;
+        }
+#else
+#error ENOENT || ENOTDIR not defined; please see the
+#error comments at this line in the source for a workaround.
+        /*
+         * If ENOENT || ENOTDIR is not defined in one of the your OS's
+         * include files, Apache does not know how to check to see why the
+         * stat() of the index file failed; there are cases where it can fail
+         * even though the file exists.  This means that it is possible for
+         * someone to get a directory listing of a directory even though
+         * there is an index (eg. index.html) file in it.  If you do not have
+         * a problem with this, delete the above #error lines and start the
+         * compile again.  If you need to do this, please submit a bug report
+         * from http://www.apache.org/bug_report.html letting us know that
+         * you needed to do this.  Please be sure to include the operating
+         * system you are using.
+         */
+	last_cp = cp;
+
+	while (--cp > path && *cp != '/')
+	    continue;
+
+	while (cp > path && cp[-1] == '/')
+	    --cp;
+#endif  /* ENOENT && ENOTDIR */
+    }
+    return OK;
+}
+
+static int directory_walk(request_rec *r)
+{
+    core_server_config *sconf = ap_get_module_config(r->server->module_config,
+                                                  &core_module);
+    void *per_dir_defaults = r->server->lookup_defaults;
+    void **sec = (void **) sconf->sec->elts;
+    int num_sec = sconf->sec->nelts;
+    char *test_filename;
+    char *test_dirname;
+    int res;
+    unsigned i, num_dirs;
+    int j, test_filename_len;
+#if defined(HAVE_UNC_PATHS) || defined(NETWARE)
+    unsigned iStart = 1;
+#endif
+
+    /*
+     * Are we dealing with a file? If not, we can (hopefuly) safely assume we
+     * have a handler that doesn't require one, but for safety's sake, and so
+     * we have something find_types() can get something out of, fake one. But
+     * don't run through the directory entries.
+     */
+
+    if (r->filename == NULL) {
+        r->filename = ap_pstrdup(r->pool, r->uri);
+        r->finfo.st_mode = 0;   /* Not really a file... */
+        r->per_dir_config = per_dir_defaults;
+
+        return OK;
+    }
+
+    /*
+     * Go down the directory hierarchy.  Where we have to check for symlinks,
+     * do so.  Where a .htaccess file has permission to override anything,
+     * try to find one.  If either of these things fails, we could poke
+     * around, see why, and adjust the lookup_rec accordingly --- this might
+     * save us a call to get_path_info (with the attendant stat()s); however,
+     * for the moment, that's not worth the trouble.
+     *
+     * Fake filenames (i.e. proxy:) only match Directory sections.
+     */
+
+    if (!ap_os_is_path_absolute(r->filename))
+    {
+        void *this_conf, *entry_config;
+        core_dir_config *entry_core;
+        char *entry_dir;
+
+        for (j = 0; j < num_sec; ++j) {
+
+            entry_config = sec[j];
+
+            entry_core = (core_dir_config *)
+                ap_get_module_config(entry_config, &core_module);
+            entry_dir = entry_core->d;
+
+            this_conf = NULL;
+            if (entry_core->r) {
+                if (!ap_regexec(entry_core->r, r->filename, 0, NULL, 0))
+                    this_conf = entry_config;
+            }
+            else if (entry_core->d_is_fnmatch) {
+                if (!ap_fnmatch(entry_dir, r->filename, 0))
+                    this_conf = entry_config;
+            }
+            else if (!strncmp(r->filename, entry_dir, strlen(entry_dir)))
+                this_conf = entry_config;
+
+            if (this_conf)
+                per_dir_defaults = ap_merge_per_dir_configs(r->pool,
+                                                         per_dir_defaults,
+                                                         this_conf);
+        }
+
+        r->per_dir_config = per_dir_defaults;
+
+        return OK;
+    }
+
+    r->filename   = ap_os_case_canonical_filename(r->pool, r->filename);
+
+    res = get_path_info(r);
+    if (res != OK) {
+        return res;
+    }
+
+    r->case_preserved_filename = r->filename;
+
+    r->filename   = ap_os_canonical_filename(r->pool, r->filename);
+
+    test_filename = ap_pstrdup(r->pool, r->filename);
+
+    ap_no2slash(test_filename);
+    num_dirs = ap_count_dirs(test_filename);
+
+    if (!ap_os_is_filename_valid(r->filename) &&
+        !(r->method_number == M_OPTIONS && !strcmp(r->uri, "*"))) {
+        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+                      "Filename is not valid: %s", r->filename);
+        return HTTP_FORBIDDEN;
+    }
+
+    if ((res = check_safe_file(r))) {
+        return res;
+    }
+
+    test_filename_len = strlen(test_filename);
+    if (test_filename[test_filename_len - 1] == '/')
+        --num_dirs;
+
+    if (S_ISDIR(r->finfo.st_mode))
+        ++num_dirs;
+
+    /*
+     * We will use test_dirname as scratch space while we build directory
+     * names during the walk.  Profiling shows directory_walk to be a busy
+     * function so we try to avoid allocating lots of extra memory here.
+     * We need 2 extra bytes, one for trailing \0 and one because
+     * make_dirstr_prefix will add potentially one extra /.
+     */
+    test_dirname = ap_palloc(r->pool, test_filename_len + 2);
+
+#if defined(HAVE_UNC_PATHS)
+    /* If the name is a UNC name, then do not perform any true file test
+     * against the machine name (start at //machine/share/)
+     * This is optimized to use the normal walk (skips the redundant '/' root)
+     */
+    if (num_dirs > 3 && test_filename[0] == '/' && test_filename[1] == '/')
+        iStart = 4;
+#endif
+
+#if defined(NETWARE)
+    /* If the name is a fully qualified volume name, then do not perform any
+     * true file test on the machine name (start at machine/share:/)
+     * XXX: The implementation eludes me at this moment... 
+     *      Does this make sense?  Please test!
+     */
+    if (num_dirs > 1 && strchr(test_filename, '/') < strchr(test_filename, ':'))
+        iStart = 2;
+#endif
+
+#if defined(HAVE_DRIVE_LETTERS) || defined(NETWARE)
+    /* Should match <Directory> sections starting from '/', not 'e:/' 
+     * (for example).  WIN32/OS2/NETWARE do not have a single root directory,
+     * they have one for each filesystem.  Traditionally, Apache has treated 
+     * <Directory /> permissions as the base for the whole server, and this 
+     * tradition should probably be preserved. 
+     *
+     * NOTE: MUST SYNC WITH ap_make_dirstr_prefix() CHANGE IN src/main/util.c
+     */
+    if (test_filename[0] == '/')
+        i = 1;
+    else
+        i = 0;
+#else
+    /* Normal File Systems are rooted at / */
+    i = 1;
+#endif /* def HAVE_DRIVE_LETTERS || NETWARE */
+
+    /* j keeps track of which section we're on, see core_reorder_directories */
+    j = 0;
+    for (; i <= num_dirs; ++i) {
+        int overrides_here;
+        core_dir_config *core_dir = (core_dir_config *)
+            ap_get_module_config(per_dir_defaults, &core_module);
+
+        /*
+         * XXX: this could be made faster by only copying the next component
+         * rather than copying the entire thing all over.
+         */
+        ap_make_dirstr_prefix(test_dirname, test_filename, i);
+
+        /*
+         * Do symlink checks first, because they are done with the
+         * permissions appropriate to the *parent* directory...
+         */
+
+#if defined(HAVE_UNC_PATHS) || defined(NETWARE)
+        /* Test only legal names against the real filesystem */
+        if (i >= iStart)
+#endif
+        if ((res = check_symlinks(test_dirname, core_dir->opts))) {
+            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+                        "Symbolic link not allowed: %s", test_dirname);
+            return res;
+        }
+
+        /*
+         * Begin *this* level by looking for matching <Directory> sections
+         * from access.conf.
+         */
+
+        for (; j < num_sec; ++j) {
+            void *entry_config = sec[j];
+            core_dir_config *entry_core;
+            char *entry_dir;
+            void *this_conf;
+
+            entry_core = (core_dir_config *)
+                         ap_get_module_config(entry_config, &core_module);
+            entry_dir = entry_core->d;
+
+            if (entry_core->r
+		|| !ap_os_is_path_absolute(entry_dir)
+#if defined(HAVE_DRIVE_LETTERS) || defined(NETWARE)
+    /* To account for the top-level "/" directory when i == 0 
+     * XXX: I think the net test is wrong... may fail ap_os_is_path_absolute
+     */
+                || (entry_core->d_components > 1
+                    && entry_core->d_components > i))
+#else
+                || entry_core->d_components > i)
+#endif /* def HAVE_DRIVE_LETTERS || NETWARE */                  
+                break;
+
+            this_conf = NULL;
+            if (entry_core->d_is_fnmatch) {
+                if (!ap_fnmatch(entry_dir, test_dirname, FNM_PATHNAME)) {
+                    this_conf = entry_config;
+                }
+            }
+            else if (!strcmp(test_dirname, entry_dir))
+                this_conf = entry_config;
+
+            if (this_conf) {
+                per_dir_defaults = ap_merge_per_dir_configs(r->pool,
+                                                         per_dir_defaults,
+                                                         this_conf);
+                core_dir = (core_dir_config *)
+                           ap_get_module_config(per_dir_defaults, &core_module);
+            }
+#if defined(HAVE_DRIVE_LETTERS) || defined(NETWARE)
+            /* So that other top-level directory sections (e.g. "e:/") aren't
+             * skipped when i == 0
+             * XXX: I don't get you here, Tim... That's a level 1 section, but
+             *      we are at level 0. Did you mean fast-forward to the next?
+             */
+            else if (!i)
+                break;
+#endif /* def HAVE_DRIVE_LETTERS || NETWARE */
+        }
+        overrides_here = core_dir->override;
+
+        /* If .htaccess files are enabled, check for one. */
+
+#if defined(HAVE_UNC_PATHS) || defined(NETWARE)
+        /* Test only legal names against the real filesystem */
+        if (i >= iStart)
+#endif
+        if (overrides_here) {
+            void *htaccess_conf = NULL;
+
+            res = ap_parse_htaccess(&htaccess_conf, r, overrides_here,
+                                 ap_pstrdup(r->pool, test_dirname),
+                                 sconf->access_name);
+            if (res)
+                return res;
+
+            if (htaccess_conf) {
+                per_dir_defaults = ap_merge_per_dir_configs(r->pool,
+							    per_dir_defaults,
+							    htaccess_conf);
+		r->per_dir_config = per_dir_defaults;
+	    }
+        }
+    }
+
+    /*
+     * There's two types of IS_SPECIAL sections (see http_core.c), and we've
+     * already handled the proxy:-style stuff.  Now we'll deal with the
+     * regexes.
+     */
+    for (; j < num_sec; ++j) {
+        void *entry_config = sec[j];
+        core_dir_config *entry_core;
+
+        entry_core = (core_dir_config *)
+                     ap_get_module_config(entry_config, &core_module);
+
+        if (entry_core->r) {
+            if (!ap_regexec(entry_core->r, test_dirname, 0, NULL, REG_NOTEOL)) {
+                per_dir_defaults =
+                    ap_merge_per_dir_configs(r->pool, per_dir_defaults,
+                                          entry_config);
+            }
+        }
+    }
+    r->per_dir_config = per_dir_defaults;
+
+    /*
+     * Symlink permissions are determined by the parent.  If the request is
+     * for a directory then applying the symlink test here would use the
+     * permissions of the directory as opposed to its parent.  Consider a
+     * symlink pointing to a dir with a .htaccess disallowing symlinks.  If
+     * you access /symlink (or /symlink/) you would get a 403 without this
+     * S_ISDIR test.  But if you accessed /symlink/index.html, for example,
+     * you would *not* get the 403.
+     */
+    if (!S_ISDIR(r->finfo.st_mode)
+        && (res = check_symlinks(r->filename, ap_allow_options(r)))) {
+        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+                    "Symbolic link not allowed: %s", r->filename);
+        return res;
+    }
+    return OK;                  /* Can only "fail" if access denied by the
+                                 * symlink goop. */
+}
+
+static int location_walk(request_rec *r)
+{
+    core_server_config *sconf = ap_get_module_config(r->server->module_config,
+                                                  &core_module);
+    void *per_dir_defaults = r->per_dir_config;
+    void **url = (void **) sconf->sec_url->elts;
+    int len, num_url = sconf->sec_url->nelts;
+    char *test_location;
+    void *this_conf, *entry_config;
+    core_dir_config *entry_core;
+    char *entry_url;
+    int j;
+
+    if (!num_url) {
+	return OK;
+    }
+
+    /* Location and LocationMatch differ on their behaviour w.r.t. multiple
+     * slashes.  Location matches multiple slashes with a single slash,
+     * LocationMatch doesn't.  An exception, for backwards brokenness is
+     * absoluteURIs... in which case neither match multiple slashes.
+     */
+    if (r->uri[0] != '/') {
+	test_location = r->uri;
+    }
+    else {
+	test_location = ap_pstrdup(r->pool, r->uri);
+	ap_no2slash(test_location);
+    }
+
+    /* Go through the location entries, and check for matches. */
+
+    /* we apply the directive sections in some order;
+     * should really try them with the most general first.
+     */
+    for (j = 0; j < num_url; ++j) {
+
+	entry_config = url[j];
+
+	entry_core = (core_dir_config *)
+	    ap_get_module_config(entry_config, &core_module);
+	entry_url = entry_core->d;
+
+	len = strlen(entry_url);
+
+	this_conf = NULL;
+
+	if (entry_core->r) {
+	    if (!ap_regexec(entry_core->r, r->uri, 0, NULL, 0))
+		this_conf = entry_config;
+	}
+	else if (entry_core->d_is_fnmatch) {
+	    if (!ap_fnmatch(entry_url, test_location, FNM_PATHNAME)) {
+		this_conf = entry_config;
+	    }
+	}
+	else if (!strncmp(test_location, entry_url, len) &&
+		    (entry_url[len - 1] == '/' ||
+		test_location[len] == '/' || test_location[len] == '\0'))
+	    this_conf = entry_config;
+
+	if (this_conf)
+	    per_dir_defaults = ap_merge_per_dir_configs(r->pool,
+					    per_dir_defaults, this_conf);
+    }
+    r->per_dir_config = per_dir_defaults;
+
+    return OK;
+}
+
+static int file_walk(request_rec *r)
+{
+    core_dir_config *conf = ap_get_module_config(r->per_dir_config, &core_module);
+    void *per_dir_defaults = r->per_dir_config;
+    void **file = (void **) conf->sec->elts;
+    int num_files = conf->sec->nelts;
+    char *test_file;
+
+    /* get the basename */
+    test_file = strrchr(r->filename, '/');
+    if (test_file == NULL) {
+	test_file = r->filename;
+    }
+    else {
+	++test_file;
+    }
+
+    /* Go through the file entries, and check for matches. */
+
+    if (num_files) {
+        void *this_conf, *entry_config;
+        core_dir_config *entry_core;
+        char *entry_file;
+        int j;
+
+        /* we apply the directive sections in some order;
+         * should really try them with the most general first.
+         */
+        for (j = 0; j < num_files; ++j) {
+
+            entry_config = file[j];
+
+            entry_core = (core_dir_config *)
+                         ap_get_module_config(entry_config, &core_module);
+            entry_file = entry_core->d;
+
+            this_conf = NULL;
+
+            if (entry_core->r) {
+                if (!ap_regexec(entry_core->r, test_file, 0, NULL, 0))
+                    this_conf = entry_config;
+            }
+            else if (entry_core->d_is_fnmatch) {
+                if (!ap_fnmatch(entry_file, test_file, FNM_PATHNAME)) {
+                    this_conf = entry_config;
+                }
+            }
+            else if (!strcmp(test_file, entry_file)) {
+                this_conf = entry_config;
+	    }
+
+            if (this_conf)
+                per_dir_defaults = ap_merge_per_dir_configs(r->pool,
+                                                         per_dir_defaults,
+                                                         this_conf);
+        }
+        r->per_dir_config = per_dir_defaults;
+    }
+    return OK;
+}
+
+/*****************************************************************
+ *
+ * The sub_request mechanism.
+ *
+ * Fns to look up a relative URI from, e.g., a map file or SSI document.
+ * These do all access checks, etc., but don't actually run the transaction
+ * ... use run_sub_req below for that.  Also, be sure to use destroy_sub_req
+ * as appropriate if you're likely to be creating more than a few of these.
+ * (An early Apache version didn't destroy the sub_reqs used in directory
+ * indexing.  The result, when indexing a directory with 800-odd files in
+ * it, was massively excessive storage allocation).
+ *
+ * Note more manipulation of protocol-specific vars in the request
+ * structure...
+ */
+
+static request_rec *make_sub_request(const request_rec *r)
+{
+    pool *rrp = ap_make_sub_pool(r->pool);
+    request_rec *rr = ap_pcalloc(rrp, sizeof(request_rec));
+
+    rr->pool = rrp;
+#ifdef CHARSET_EBCDIC
+    /* Assume virgin state (like after reading the request_line): */
+    ap_bsetflag(r->connection->client, B_ASCII2EBCDIC, rr->ebcdic.conv_in  = 1);
+    ap_bsetflag(r->connection->client, B_EBCDIC2ASCII, rr->ebcdic.conv_out = 1);
+#endif   
+    return rr;
+}
+
+API_EXPORT(request_rec *) ap_sub_req_method_uri(const char *method,
+                                                const char *new_file,
+                                                const request_rec *r)
+{
+    request_rec *rnew;
+    int res;
+    char *udir;
+
+    rnew = make_sub_request(r);
+    rnew->hostname       = r->hostname;
+    rnew->request_time   = r->request_time;
+    rnew->connection     = r->connection;
+    rnew->server         = r->server;
+    rnew->request_config = ap_create_request_config(rnew->pool);
+    rnew->htaccess       = r->htaccess;
+    rnew->per_dir_config = r->server->lookup_defaults;
+
+    ap_set_sub_req_protocol(rnew, r);
+
+    /* would be nicer to pass "method" to ap_set_sub_req_protocol */
+    rnew->method = method;
+    rnew->method_number = ap_method_number_of(method);
+
+    if (new_file[0] == '/')
+        ap_parse_uri(rnew, new_file);
+    else {
+        udir = ap_make_dirstr_parent(rnew->pool, r->uri);
+        udir = ap_escape_uri(rnew->pool, udir);    /* re-escape it */
+        ap_parse_uri(rnew, ap_make_full_path(rnew->pool, udir, new_file));
+    }
+
+    /* We cannot return NULL without violating the API. So just turn this
+     * subrequest into a 500 to indicate the failure. */
+    if (ap_is_recursion_limit_exceeded(r)) {
+        rnew->status = HTTP_INTERNAL_SERVER_ERROR;
+        return rnew;
+    }
+
+    res = ap_unescape_url(rnew->uri);
+    if (res) {
+        rnew->status = res;
+        return rnew;
+    }
+
+    ap_getparents(rnew->uri);
+
+    if ((res = location_walk(rnew))) {
+        rnew->status = res;
+        return rnew;
+    }
+
+    res = ap_translate_name(rnew);
+    if (res) {
+        rnew->status = res;
+        return rnew;
+    }
+
+    /*
+     * We could be clever at this point, and avoid calling directory_walk,
+     * etc. However, we'd need to test that the old and new filenames contain
+     * the same directory components, so it would require duplicating the
+     * start of translate_name. Instead we rely on the cache of .htaccess
+     * results.
+     *
+     * NB: directory_walk() clears the per_dir_config, so we don't inherit
+     * from location_walk() above
+     */
+
+    if ((res = directory_walk(rnew))
+        || (res = file_walk(rnew))
+        || (res = location_walk(rnew))
+        || ((ap_satisfies(rnew) == SATISFY_ALL
+             || ap_satisfies(rnew) == SATISFY_NOSPEC)
+            ? ((res = ap_check_access(rnew))
+               || (ap_some_auth_required(rnew)
+                   && ((res = ap_check_user_id(rnew))
+                       || (res = ap_check_auth(rnew)))))
+            : ((res = ap_check_access(rnew))
+               && (!ap_some_auth_required(rnew)
+                   || ((res = ap_check_user_id(rnew))
+                       || (res = ap_check_auth(rnew)))))
+           )
+        || (res = ap_find_types(rnew))
+        || (res = ap_run_fixups(rnew))
+       ) {
+        rnew->status = res;
+    }
+    return rnew;
+}
+
+API_EXPORT(request_rec *) ap_sub_req_lookup_uri(const char *new_file,
+                                                const request_rec *r)
+{
+    return ap_sub_req_method_uri("GET", new_file, r);
+}
+
+API_EXPORT(request_rec *) ap_sub_req_lookup_file(const char *new_file,
+                                              const request_rec *r)
+{
+    request_rec *rnew;
+    int res;
+    char *fdir;
+
+    rnew = make_sub_request(r);
+    rnew->hostname       = r->hostname;
+    rnew->request_time   = r->request_time;
+    rnew->connection     = r->connection;
+    rnew->server         = r->server;
+    rnew->request_config = ap_create_request_config(rnew->pool);
+    rnew->htaccess       = r->htaccess;
+
+    ap_set_sub_req_protocol(rnew, r);
+    fdir = ap_make_dirstr_parent(rnew->pool, r->filename);
+
+    /* We cannot return NULL without violating the API. So just turn this
+     * subrequest into a 500. */
+    if (ap_is_recursion_limit_exceeded(r)) {
+        rnew->status = HTTP_INTERNAL_SERVER_ERROR;
+        return rnew;
+    }
+
+    /*
+     * Check for a special case... if there are no '/' characters in new_file
+     * at all, then we are looking at a relative lookup in the same
+     * directory. That means we won't have to redo directory_walk, and we may
+     * not even have to redo access checks.
+     */
+
+    if (strchr(new_file, '/') == NULL) {
+        char *udir = ap_make_dirstr_parent(rnew->pool, r->uri);
+
+        rnew->uri = ap_make_full_path(rnew->pool, udir, new_file);
+        rnew->filename = ap_make_full_path(rnew->pool, fdir, new_file);
+        ap_parse_uri(rnew, rnew->uri);    /* fill in parsed_uri values */
+        if (stat(rnew->filename, &rnew->finfo) < 0) {
+            rnew->finfo.st_mode = 0;
+#ifdef ENAMETOOLONG
+            /* Special case for filenames which exceed the maximum limit
+	     * imposed by the operating system (~1024). These should
+	     * NOT be treated like "file not found", because there is
+	     * a difference between "the file is not there" and
+	     * "the file exists, but you tried to access it using a
+	     * path which exceeds the path length limit".
+	     * The idea here is to handle DoS attacks with long
+	     * runs of //////'s in a graceful and secure manner.
+	     */
+            if (errno == ENAMETOOLONG) {
+                ap_log_rerror(APLOG_MARK, APLOG_CRIT, r,
+                              "Possible DoS attempt? Path=%s", r->filename);
+                rnew->status = HTTP_FORBIDDEN;
+                return rnew;
+            }
+#endif
+        }
+
+        if ((res = check_safe_file(rnew))) {
+            rnew->status = res;
+            return rnew;
+        }
+
+        rnew->per_dir_config = r->per_dir_config;
+
+        /*
+         * no matter what, if it's a subdirectory, we need to re-run
+         * directory_walk
+         */
+        if (S_ISDIR(rnew->finfo.st_mode)) {
+            res = directory_walk(rnew);
+            if (!res) {
+                res = file_walk(rnew);
+            }
+        }
+        else {
+            if ((res = check_symlinks(rnew->filename, ap_allow_options(rnew)))) {
+                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, rnew,
+                            "Symbolic link not allowed: %s", rnew->filename);
+                rnew->status = res;
+                return rnew;
+            }
+            /*
+             * do a file_walk, if it doesn't change the per_dir_config then
+             * we know that we don't have to redo all the access checks
+             */
+            if ((res = file_walk(rnew))) {
+                rnew->status = res;
+                return rnew;
+            }
+            if (rnew->per_dir_config == r->per_dir_config) {
+                if ((res = ap_find_types(rnew)) || (res = ap_run_fixups(rnew))) {
+                    rnew->status = res;
+                }
+                return rnew;
+            }
+        }
+    }
+    else {
+	/* XXX: @@@: What should be done with the parsed_uri values? */
+	ap_parse_uri(rnew, new_file);	/* fill in parsed_uri values */
+        /*
+         * XXX: this should be set properly like it is in the same-dir case
+         * but it's actually sometimes to impossible to do it... because the
+         * file may not have a uri associated with it -djg
+         */
+        rnew->uri = "INTERNALLY GENERATED file-relative req";
+        rnew->filename = ((ap_os_is_path_absolute(new_file)) ?
+                          ap_pstrdup(rnew->pool, new_file) :
+                          ap_make_full_path(rnew->pool, fdir, new_file));
+        rnew->per_dir_config = r->server->lookup_defaults;
+        res = directory_walk(rnew);
+        if (!res) {
+            res = file_walk(rnew);
+        }
+    }
+
+    if (res
+        || ((ap_satisfies(rnew) == SATISFY_ALL
+             || ap_satisfies(rnew) == SATISFY_NOSPEC)
+            ? ((res = ap_check_access(rnew))
+               || (ap_some_auth_required(rnew)
+                   && ((res = ap_check_user_id(rnew))
+                       || (res = ap_check_auth(rnew)))))
+            : ((res = ap_check_access(rnew))
+               && (!ap_some_auth_required(rnew)
+                   || ((res = ap_check_user_id(rnew))
+                       || (res = ap_check_auth(rnew)))))
+           )
+        || (res = ap_find_types(rnew))
+        || (res = ap_run_fixups(rnew))
+       ) {
+        rnew->status = res;
+    }
+    return rnew;
+}
+
+API_EXPORT(int) ap_run_sub_req(request_rec *r)
+{
+    int retval = ap_invoke_handler(r);
+    ap_finalize_sub_req_protocol(r);
+    return retval;
+}
+
+API_EXPORT(void) ap_destroy_sub_req(request_rec *r)
+{
+#ifdef CHARSET_EBCDIC
+    if (r->main) {
+        ap_bsetflag(r->connection->client, B_ASCII2EBCDIC, r->main->ebcdic.conv_in);
+        ap_bsetflag(r->connection->client, B_EBCDIC2ASCII, r->main->ebcdic.conv_out);
+    }
+#endif   
+    /* Reclaim the space */
+    ap_destroy_pool(r->pool);
+}
+
+/*****************************************************************
+ *
+ * Mainline request processing...
+ */
+
+API_EXPORT(void) ap_die(int type, request_rec *r)
+{
+    int error_index = ap_index_of_response(type);
+    char *custom_response = ap_response_code_string(r, error_index);
+    int recursive_error = 0;
+
+    if (type == DONE) {
+        ap_finalize_request_protocol(r);
+        return;
+    }
+
+    /*
+     * The following takes care of Apache redirects to custom response URLs
+     * Note that if we are already dealing with the response to some other
+     * error condition, we just report on the original error, and give up on
+     * any attempt to handle the other thing "intelligently"...
+     */
+
+    if (r->status != HTTP_OK) {
+        recursive_error = type;
+
+        while (r->prev && (r->prev->status != HTTP_OK))
+            r = r->prev;        /* Get back to original error */
+
+        type = r->status;
+        custom_response = NULL; /* Do NOT retry the custom thing! */
+    }
+
+    r->status = type;
+
+    /*
+     * This test is done here so that none of the auth modules needs to know
+     * about proxy authentication.  They treat it like normal auth, and then
+     * we tweak the status.
+     */
+    if (r->status == AUTH_REQUIRED && r->proxyreq == STD_PROXY) {
+        r->status = HTTP_PROXY_AUTHENTICATION_REQUIRED;
+    }
+
+    /*
+     * We need to ensure that r->connection->keepalive is set in order
+     * to determine if we need to call ap_discard_request_body() to read
+     * the rest of the request body for this request.  There is no point
+     * reading the body for this request if we are not in keepalive mode
+     * since we are in ap_die() and about to toss this request anyway.
+     */
+    ap_set_keepalive(r);
+
+    /*
+     * If we want to keep the connection, be sure that the request body
+     * (if any) has been read.
+     */
+    if ((r->status != HTTP_NOT_MODIFIED) && (r->status != HTTP_NO_CONTENT)
+        && !ap_status_drops_connection(r->status)
+        && r->connection && (r->connection->keepalive > 0)) {
+
+        (void) ap_discard_request_body(r);
+    }
+
+    /*
+     * Two types of custom redirects --- plain text, and URLs. Plain text has
+     * a leading '"', so the URL code, here, is triggered on its absence
+     */
+
+    if (custom_response && custom_response[0] != '"') {
+
+        if (ap_is_url(custom_response)) {
+            /*
+             * The URL isn't local, so lets drop through the rest of this
+             * apache code, and continue with the usual REDIRECT handler.
+             * But note that the client will ultimately see the wrong
+             * status...
+             *
+             * Also, before updating r->status, we may need to ensure that
+             * the connection is dropped.  For example, there may be
+             * unread request body that would confuse us if we try
+             * to read another request.
+             */
+            if (ap_status_drops_connection(r->status)) {
+                r->connection->keepalive = -1;
+            }
+            r->status = REDIRECT;
+            ap_table_setn(r->headers_out, "Location", custom_response);
+        }
+        else if (custom_response[0] == '/') {
+            const char *error_notes;
+            r->no_local_copy = 1;       /* Do NOT send USE_LOCAL_COPY for
+                                         * error documents! */
+            /*
+             * This redirect needs to be a GET no matter what the original
+             * method was.
+             */
+            ap_table_setn(r->subprocess_env, "REQUEST_METHOD", r->method);
+
+	    /*
+	     * Provide a special method for modules to communicate
+	     * more informative (than the plain canned) messages to us.
+	     * Propagate them to ErrorDocuments via the ERROR_NOTES variable:
+	     */
+            if ((error_notes = ap_table_get(r->notes, "error-notes")) != NULL) {
+		ap_table_setn(r->subprocess_env, "ERROR_NOTES", error_notes);
+	    }
+	    /* 
+	     * If it is already a GET or a HEAD, don't change it 
+	     * (method_number for GET and HEAD is the same) 
+	     */
+	    if(r->method_number!=M_GET) { 
+            	r->method = ap_pstrdup(r->pool, "GET");
+            	r->method_number = M_GET;
+	    }
+            ap_internal_redirect(custom_response, r);
+            return;
+        }
+        else {
+            /*
+             * Dumb user has given us a bad url to redirect to --- fake up
+             * dying with a recursive server error...
+             */
+            recursive_error = SERVER_ERROR;
+            ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+                        "Invalid error redirection directive: %s",
+                        custom_response);
+        }
+    }
+    ap_send_error_response(r, recursive_error);
+}
+
+static void decl_die(int status, char *phase, request_rec *r)
+{
+    if (status == DECLINED) {
+        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_CRIT, r,
+                    "configuration error:  couldn't %s: %s", phase, r->uri);
+        ap_die(SERVER_ERROR, r);
+    }
+    else
+        ap_die(status, r);
+}
+
+API_EXPORT(int) ap_some_auth_required(request_rec *r)
+{
+    /* Is there a require line configured for the type of *this* req? */
+
+    const array_header *reqs_arr = ap_requires(r);
+    require_line *reqs;
+    int i;
+
+    if (!reqs_arr)
+        return 0;
+
+    reqs = (require_line *) reqs_arr->elts;
+
+    for (i = 0; i < reqs_arr->nelts; ++i)
+        if (reqs[i].method_mask & (1 << r->method_number))
+            return 1;
+
+    return 0;
+}
+
+static void process_request_internal(request_rec *r)
+{
+    int access_status;
+
+    /* Ignore embedded %2F's in path for proxy requests */
+    if (r->proxyreq == NOT_PROXY && r->parsed_uri.path) {
+	access_status = ap_unescape_url(r->parsed_uri.path);
+	if (access_status) {
+	    ap_die(access_status, r);
+	    return;
+	}
+    }
+
+    ap_getparents(r->uri);     /* OK --- shrinking transformations... */
+
+    if ((access_status = location_walk(r))) {
+        ap_die(access_status, r);
+        return;
+    }
+
+    if ((access_status = ap_translate_name(r))) {
+        decl_die(access_status, "translate", r);
+        return;
+    }
+
+    if (r->proxyreq == NOT_PROXY) {
+	/*
+	 * We don't want TRACE to run through the normal handler set, we
+	 * handle it specially.
+	 */
+	if (r->method_number == M_TRACE) {
+	    if ((access_status = ap_send_http_trace(r)))
+		ap_die(access_status, r);
+	    else
+		ap_finalize_request_protocol(r);
+	    return;
+	}
+    }
+
+    if (r->proto_num > HTTP_VERSION(1,0) && ap_table_get(r->subprocess_env, "downgrade-1.0")) {
+        r->proto_num = HTTP_VERSION(1,0);
+    }
+
+    /*
+     * NB: directory_walk() clears the per_dir_config, so we don't inherit
+     * from location_walk() above
+     */
+
+    if ((access_status = directory_walk(r))) {
+        ap_die(access_status, r);
+        return;
+    }
+
+    if ((access_status = file_walk(r))) {
+        ap_die(access_status, r);
+        return;
+    }
+
+    if ((access_status = location_walk(r))) {
+        ap_die(access_status, r);
+        return;
+    }
+
+    if ((access_status = ap_header_parse(r))) {
+        ap_die(access_status, r);
+        return;
+    }
+
+    switch (ap_satisfies(r)) {
+    case SATISFY_ALL:
+    case SATISFY_NOSPEC:
+        if ((access_status = ap_check_access(r)) != 0) {
+            decl_die(access_status, "check access", r);
+            return;
+        }
+        if (ap_some_auth_required(r)) {
+            if (((access_status = ap_check_user_id(r)) != 0) || !ap_auth_type(r)) {
+                decl_die(access_status, ap_auth_type(r)
+		    ? "check user.  No user file?"
+		    : "perform authentication. AuthType not set!", r);
+                return;
+            }
+            if (((access_status = ap_check_auth(r)) != 0) || !ap_auth_type(r)) {
+                decl_die(access_status, ap_auth_type(r)
+		    ? "check access.  No groups file?"
+		    : "perform authentication. AuthType not set!", r);
+                return;
+            }
+        }
+        break;
+    case SATISFY_ANY:
+        if (((access_status = ap_check_access(r)) != 0)) {
+            if (!ap_some_auth_required(r)) {
+                decl_die(access_status, "check access", r);
+                return;
+            }
+            if (((access_status = ap_check_user_id(r)) != 0) || !ap_auth_type(r)) {
+                decl_die(access_status, ap_auth_type(r)
+		    ? "check user.  No user file?"
+		    : "perform authentication. AuthType not set!", r);
+                return;
+            }
+            if (((access_status = ap_check_auth(r)) != 0) || !ap_auth_type(r)) {
+                decl_die(access_status, ap_auth_type(r)
+		    ? "check access.  No groups file?"
+		    : "perform authentication. AuthType not set!", r);
+                return;
+            }
+        }
+        break;
+    }
+
+    if (! (r->proxyreq != NOT_PROXY
+	   && r->parsed_uri.scheme != NULL
+	   && strcmp(r->parsed_uri.scheme, "http") == 0) ) {
+	if ((access_status = ap_find_types(r)) != 0) {
+	    decl_die(access_status, "find types", r);
+	    return;
+	}
+    }
+
+    if ((access_status = ap_run_fixups(r)) != 0) {
+        ap_die(access_status, r);
+        return;
+    }
+
+    if ((access_status = ap_invoke_handler(r)) != 0) {
+        ap_die(access_status, r);
+        return;
+    }
+
+    /* Take care of little things that need to happen when we're done */
+    ap_finalize_request_protocol(r);
+}
+
+API_EXPORT(void) ap_process_request(request_rec *r)
+{
+    int old_stat;
+
+    if (ap_extended_status)
+	ap_time_process_request(r->connection->child_num, START_PREQUEST);
+
+    process_request_internal(r);
+
+    old_stat = ap_update_child_status(r->connection->child_num,
+                                   SERVER_BUSY_LOG, r);
+
+    /*
+     * We want to flush the last packet if this isn't a pipelining connection
+     * *before* we start into logging.  Suppose that the logging causes a DNS
+     * lookup to occur, which may have a high latency.  If we hold off on
+     * this packet, then it'll appear like the link is stalled when really
+     * it's the application that's stalled.
+     */
+    ap_bhalfduplex(r->connection->client);
+    ap_log_transaction(r);
+
+    (void) ap_update_child_status(r->connection->child_num, old_stat, r);
+    if (ap_extended_status)
+	ap_time_process_request(r->connection->child_num, STOP_PREQUEST);
+}
+
+static table *rename_original_env(pool *p, table *t)
+{
+    array_header *env_arr = ap_table_elts(t);
+    table_entry *elts = (table_entry *) env_arr->elts;
+    table *new = ap_make_table(p, env_arr->nalloc);
+    int i;
+
+    for (i = 0; i < env_arr->nelts; ++i) {
+        if (!elts[i].key)
+            continue;
+        ap_table_setn(new, ap_pstrcat(p, "REDIRECT_", elts[i].key, NULL),
+                  elts[i].val);
+    }
+
+    return new;
+}
+
+static request_rec *internal_internal_redirect(const char *new_uri, request_rec *r)
+{
+    int access_status;
+    request_rec *new;
+
+    if (ap_is_recursion_limit_exceeded(r)) {
+        ap_die(HTTP_INTERNAL_SERVER_ERROR, r);
+        return NULL;
+    }
+
+    new = (request_rec *) ap_pcalloc(r->pool, sizeof(request_rec));
+
+    new->connection = r->connection;
+    new->server     = r->server;
+    new->pool       = r->pool;
+
+    /*
+     * A whole lot of this really ought to be shared with http_protocol.c...
+     * another missing cleanup.  It's particularly inappropriate to be
+     * setting header_only, etc., here.
+     */
+
+    new->method          = r->method;
+    new->method_number   = r->method_number;
+    ap_parse_uri(new, new_uri);
+    new->request_config = ap_create_request_config(r->pool);
+    new->per_dir_config = r->server->lookup_defaults;
+
+    new->prev = r;
+    r->next   = new;
+
+    /* Inherit the rest of the protocol info... */
+
+    new->the_request = r->the_request;
+
+    new->allowed         = r->allowed;
+
+    new->status          = r->status;
+    new->assbackwards    = r->assbackwards;
+    new->header_only     = r->header_only;
+    new->protocol        = r->protocol;
+    new->proto_num       = r->proto_num;
+    new->hostname        = r->hostname;
+    new->request_time    = r->request_time;
+    new->main            = r->main;
+
+    new->headers_in      = r->headers_in;
+    new->headers_out     = ap_make_table(r->pool, 12);
+    new->err_headers_out = r->err_headers_out;
+    new->subprocess_env  = rename_original_env(r->pool, r->subprocess_env);
+    new->notes           = ap_make_table(r->pool, 5);
+
+    new->htaccess        = r->htaccess;
+    new->no_cache        = r->no_cache;
+    new->expecting_100	 = r->expecting_100;
+    new->no_local_copy   = r->no_local_copy;
+    new->read_length     = r->read_length;     /* We can only read it once */
+    new->vlist_validator = r->vlist_validator;
+#ifdef CHARSET_EBCDIC /* @@@ Is this correct? When is it used? */
+    new->ebcdic.conv_out= r->ebcdic.conv_out;
+    new->ebcdic.conv_in = r->ebcdic.conv_in;
+#endif
+
+    ap_table_setn(new->subprocess_env, "REDIRECT_STATUS",
+	ap_psprintf(r->pool, "%d", r->status));
+
+    /*
+     * XXX: hmm.  This is because mod_setenvif and mod_unique_id really need
+     * to do their thing on internal redirects as well.  Perhaps this is a
+     * misnamed function.
+     */
+    if ((access_status = ap_run_post_read_request(new))) {
+        ap_die(access_status, new);
+        return NULL;
+    }
+
+    return new;
+}
+
+API_EXPORT(void) ap_internal_redirect(const char *new_uri, request_rec *r)
+{
+    request_rec *new = internal_internal_redirect(new_uri, r);
+
+    if (new) {
+        process_request_internal(new);
+    }
+}
+
+/* This function is designed for things like actions or CGI scripts, when
+ * using AddHandler, and you want to preserve the content type across
+ * an internal redirect.
+ */
+API_EXPORT(void) ap_internal_redirect_handler(const char *new_uri, request_rec *r)
+{
+    request_rec *new = internal_internal_redirect(new_uri, r);
+
+    if (new) {
+        if (r->handler)
+            new->content_type = r->content_type;
+        process_request_internal(new);
+    }
+}
+
+/*
+ * Is it the initial main request, which we only get *once* per HTTP request?
+ */
+API_EXPORT(int) ap_is_initial_req(request_rec *r)
+{
+    return
+        (r->main == NULL)       /* otherwise, this is a sub-request */
+        &&
+        (r->prev == NULL);      /* otherwise, this is an internal redirect */
+}
+
+/*
+ * Function to set the r->mtime field to the specified value if it's later
+ * than what's already there.
+ */
+API_EXPORT(time_t) ap_update_mtime(request_rec *r, time_t dependency_mtime)
+{
+    if (r->mtime < dependency_mtime) {
+        r->mtime = dependency_mtime;
+    }
+    return r->mtime;
+}
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/extra/mod_macro.c apache_1.3.33/src/modules/extra/mod_macro.c
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/extra/mod_macro.c	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/modules/extra/mod_macro.c	Mon Jul 18 15:22:20 2005
@@ -0,0 +1,921 @@
+/*
+ * The following license applies to "mod_macro" version 1.1.1.
+ * It is a third-party module by Fabien Coelho <coelho@cri.ensmp.fr>
+ * for the Apache Http Server (http://www.apache.org/).
+ *
+ * ====================================================================
+ * Copyright (c) 1998-1999 Fabien Coelho. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by
+ *    Fabien Coelho <coelho@cri.ensmp.fr>
+ *    for use in the mod_macro project
+ *    (http://www.cri.ensmp.fr/~coelho/mod_macro/)."
+ *
+ * 4. The name "mod_macro" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    Fabien Coelho <coelho@cri.ensmp.fr>.
+ *
+ * 5. Products derived from this software may not be called "mod_macro"
+ *    nor may "mod_macro" appear in their names without prior written
+ *    permission of Fabien Coelho.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by
+ *    Fabien Coelho <coelho@cri.ensmp.fr>
+ *    for use in the mod_macro project
+ *    (http://www.cri.ensmp.fr/~coelho/mod_macro/)."
+ *
+ * 7. Any modification must be properly copyrighted by its author.
+ *
+ * THIS SOFTWARE IS PROVIDED BY FABIEN COELHO ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE APACHE GROUP OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ */
+/*
+  $Id: apache-1.3.33.patch,v 1.1 2006/06/14 07:54:35 cvs Exp $
+
+  mod_macro version 1.1.1.
+
+  This modules allows the definition and use of macros within apache
+  runtime configuration files. Patch suggestions may be sent to the
+  author.
+
+  Fabien Coelho <coelho@cri.ensmp.fr>.
+  URL: http://www.cri.ensmp.fr/~coelho/
+*/
+
+#include "httpd.h"
+#include "http_config.h"
+#include "http_log.h"
+
+/************************************************ COMPILE TIME DEBUG CONTROL */
+
+/* debug: */
+/* #define MOD_MACRO_DEBUG 1 */
+
+/* no warnings: */
+/* #define MOD_MACRO_NO_WARNINGS 1 */
+/* #define MOD_MACRO_NO_CHAR_PREFIX_WARNINGS 1 */
+
+/* no advertisement in version component */
+#define MOD_MACRO_NO_ADVERTISEMENT 1
+
+#if defined(debug)
+#undef debug
+#endif
+
+#if defined(MOD_MACRO_DEBUG)
+#define debug(stmt) stmt
+#else
+#define debug(stmt)
+#endif
+
+/************************************************************* ADVERTISEMENT */
+
+module macro_module;
+
+#define MACRO_MODULE_NAME       "mod_macro"
+#define MACRO_MODULE_VERSION    "1.1.1"
+
+/* initializer for the macro module.
+ * just advertise the module in apache server signature.
+ */
+static void macro_startup(server_rec * dummy1, pool * dummy2)
+{
+#if !defined(MOD_MACRO_NO_ADVERTISEMENT)
+    /* advertise the macro module;-) */
+    ap_add_version_component(MACRO_MODULE_NAME "/" MACRO_MODULE_VERSION);
+#endif
+}
+
+/********************************************************** MACRO MANAGEMENT */
+
+/* a macro: name, arguments, contents, location.
+ */
+typedef struct {
+    char * name;              /* case-insensitive name of the macro. */
+    array_header * arguments; /* of char* */
+    array_header * contents;  /* of char* */
+    char * location;          /* of the macro definition. */
+} macro_t;
+
+/* configuration tokens.
+ */
+#define BEGIN_MACRO "<Macro"
+#define END_MACRO "</Macro>"
+#define USE_MACRO "Use"
+
+#define empty_string_p(p) (!(p) || *(p) == '\0')
+
+/* macros are kept globally...
+   they are not per-server or per-directory entities.
+
+   I would need a hook BEFORE and AFTER configuration processing
+   to initialize and close them properly.
+
+   I would have such a hook if in the main/... I guess.
+
+   The "initializer" does not seem to be called before.
+
+   HACK:
+   -----
+   I put them in the temp_pool.
+   restarts are detected because the temp_pool has changed...
+   note that there is always a restart implicitely to check for the syntax.
+*/
+static array_header * all_macros = NULL;
+
+/* returns the macro structure for name, or NULL if not found.
+ */
+static macro_t * get_macro_by_name(const array_header * macros,
+                                   const char * name)
+{
+    int i;
+    macro_t ** tab;
+    ap_assert(macros);
+    tab = (macro_t **)macros->elts;
+
+    for (i = 0; i < macros->nelts; i++) {
+        if (!strcasecmp(name, tab[i]->name)) {
+            return tab[i];
+        }
+    }
+    return NULL;
+}
+
+/* configuration state initialization.
+   the state is simply an array_header which holds the macros.
+ */
+static void macro_init(pool * p)
+{
+    static ap_pool * last_time_temp_pool_hack = NULL;
+
+    debug(fprintf(stderr, "macro_init\n"));
+
+    /* is it a restart? what about concurrent threads?
+     */
+    if (last_time_temp_pool_hack != p) {
+        last_time_temp_pool_hack = p;
+        all_macros = ap_make_array(p, 1, sizeof(macro_t *));
+        debug(fprintf(stderr, "macro_init done for %p\n", p));
+    }
+}
+
+/*************************************************************** PARSE UTILS */
+
+#define trim(line) while (*(line)==' ' || *(line)=='\t') (line)++
+
+/* return configuration-parsed arguments from line as an array.
+   the line is expected not to contain any '\n'?
+ */
+static array_header * get_arguments(ap_pool * p, const char * line)
+{
+    array_header * args = ap_make_array(p, 1, sizeof(char *));
+    char * arg, ** new;
+
+    trim(line);
+    while (*line) {
+        arg = ap_getword_conf(p, &line);
+        new = ap_push_array(args);
+        *new = arg;
+        trim(line);
+    }
+
+    return args;
+}
+
+/* get read lines as an array till end_token.
+   counts nesting for begin_token/end_token.
+   it assumes a line-per-line configuration (thru getline).
+   this function could be exported.
+   begin_token may be NULL.
+*/
+static char * get_lines_till_end_token(ap_pool * p,
+                                       configfile_t * config_file,
+                                       const char * end_token,
+                                       const char * begin_token,
+                                       const char * where,
+                                       array_header ** plines)
+{
+    array_header * lines = ap_make_array(p, 1, sizeof(char *));
+    char ** new, * first, * ptr;
+    char line[MAX_STRING_LEN]; /* sorry, but that is expected by getline. */
+    int macro_nesting = 1, any_nesting = 1, line_number = 0;
+
+    while (!ap_cfg_getline(line, MAX_STRING_LEN, config_file)) {
+        ptr = line;
+        first = ap_getword_conf_nc(p, &ptr);
+        line_number++;
+        if (first) {
+            /* nesting... */
+            if (!strncmp(first, "</", 2)) {
+                any_nesting--;
+#if !defined(MOD_MACRO_NO_WARNINGS)
+                if (any_nesting<0) {
+                    ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, NULL,
+                                 "bad (negative) nesting on line %d of %s\n",
+                                 line_number, where);
+                }
+#endif
+            }
+            else if (!strncmp(first, "<", 1)) {
+                any_nesting++;
+            }
+
+            if (!strcasecmp(first, end_token)) { /* okay! */
+                macro_nesting--;
+                if (!macro_nesting) {
+#if !defined(MOD_MACRO_NO_WARNINGS)
+                    if (any_nesting) {
+                        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING,
+                                     NULL,
+                                     "bad cumulated nesting (%+d) in %s\n",
+                                     any_nesting, where);
+                    }
+#endif
+                    *plines = lines;
+                    return NULL;
+                }
+            }
+            else if (begin_token && !strcasecmp(first, begin_token)) {
+                macro_nesting++;
+            }
+        }
+        /* free first. */
+        new  = ap_push_array(lines);
+        *new = ap_psprintf(p, "%s\n", line); /* put '\n' back */
+    }
+
+    return ap_psprintf(p, "expected token not found: %s", end_token);
+}
+
+/* returns whether it looks like an argument, i.e. prefixed by ARGUMENT_PREFIX.
+ */
+#define ARGUMENT_PREFIX "$%&@#"
+
+/* characters allowed in an argument? not used yet.
+ */
+#define ARGUMENT_CONTENT \
+    "abcdefghijklmnopqrstuvwxyz" \
+    "ABCDEFGHIJKLMNOPQRSTUVWXYZ" \
+    "0123456789_" ARGUMENT_PREFIX
+
+static int looks_like_an_argument(const char * word)
+{
+    return (int)strchr(ARGUMENT_PREFIX, *word);
+}
+
+/* generates an error on macro with two arguments of the same name.
+   generates an error if a macro argument name is empty.
+   generates a warning if arguments name prefixes conflict.
+   generates a warning if the first char of an argument is not
+       in ARGUMENT_PREFIX
+*/
+static const char * check_macro_arguments(ap_pool * p, const macro_t * macro)
+{
+    char ** tab = (char **)macro->arguments->elts;
+    int nelts = macro->arguments->nelts, i, j;
+    size_t ltabi, ltabj;
+
+    for (i = 0; i < nelts; i++) {
+        ltabi = strlen(tab[i]);
+
+        if (ltabi == 0) {
+            return ap_psprintf(p,
+                               "macro '%s' (%s)\n\tempty argument #%d name\n",
+                               macro->name, macro->location, i + 1);
+        }
+
+#if !defined(MOD_MACRO_NO_CHAR_PREFIX_WARNINGS) || \
+    !defined(MOD_MACRO_NO_WARNINGS)
+        if (!looks_like_an_argument(tab[i])) {
+            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, NULL,
+                         "macro '%s' (%s)\n"
+                        "\targument name '%s' (#%d) without expected prefix.\n"
+         "\tit is good practice to prefix argument names with one of '%s'.\n",
+                         macro->name, macro->location,
+                         tab[i], i + 1, ARGUMENT_PREFIX);
+        }
+#endif
+
+        for (j = i + 1; j < nelts; j++) {
+            ltabj = strlen(tab[j]);
+
+            if (!strcmp(tab[i], tab[j])) {
+                return ap_psprintf(p,
+                                  "argument name conflict in macro '%s' (%s)\n"
+                                   "\targument '%s': #%d and #%d\n"
+                                   "\tchange argument names!",
+                                   macro->name, macro->location,
+                                   tab[i], i + 1, j + 1);
+            }
+
+#if !defined(MOD_MACRO_NO_WARNINGS)
+            if (!strncmp(tab[i], tab[j], ltabi < ltabj ? ltabi : ltabj)) {
+                ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, NULL,
+                        "macro '%s' (%s)\n"
+                        "\targument name prefix conflict (%s #%d and %s #%d)\n"
+                        "\tbe careful about your macro definition!\n",
+                             macro->name, macro->location,
+                             tab[i], i + 1, tab[j], j + 1);
+            }
+#endif
+        }
+    }
+
+    return NULL;
+}
+
+/* warn about empty strings in array.
+ */
+static void check_macro_use_arguments(const char * where,
+                                      const array_header * array)
+{
+    int i;
+    char ** tab = (char **)array->elts;
+
+#if !defined(MOD_MACRO_NO_WARNINGS)
+    for (i = 0; i < array->nelts; i++) {
+        if (empty_string_p(tab[i])) {
+            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, NULL,
+                         "%s\n\tempty argument #%d\n", where, i + 1);
+        }
+    }
+#endif
+}
+
+/******************************************************** SUBSTITUTION UTILS */
+
+/* replace name by replacement at the beginning of buf of bufsize.
+   returns an error message or NULL.
+*/
+static char * substitute(char * buf, int bufsize,
+                         const char * name, const char * replacement)
+{
+    char tmp[MAX_STRING_LEN]; /* sorry. should I malloc and free? */
+    int lbuf = strlen(buf),
+        lname = strlen(name),
+        lrepl = strlen(replacement);
+
+    ap_assert(!strncmp(buf, name, lname));
+
+    if (lbuf + lrepl - lname >= bufsize) {
+        return "cannot substitute, buffer size too small";
+    }
+    if (lbuf + lrepl - lname >= MAX_STRING_LEN) {
+        return "cannot substitute, tmp size too small";
+    }
+
+    /* simple. */
+    strcpy(tmp, replacement);
+    strcpy(tmp + lrepl, buf + lname);
+    strcpy(buf, tmp);
+
+    return NULL;
+}
+
+/* find first occurence of args in buf.
+   in case of conflict, the LONGEST argument is kept. (could be the FIRST?).
+   returns the pointer and the whichone found, or NULL.
+*/
+static char * next_substitution(const char * buf,
+                                const array_header * args,
+                                int * whichone)
+{
+    int i;
+    char * chosen = NULL, * found, ** tab = (char **)args->elts;
+    size_t lchosen = 0, lfound;
+
+    for (i = 0; i < args->nelts; i++) {
+        found = strstr(buf, tab[i]);
+        lfound = strlen(tab[i]);
+        if (found && (!chosen || found < chosen ||
+                      (found == chosen && lchosen < lfound))) {
+            chosen = found;
+            lchosen = lfound;
+            *whichone = i;
+        }
+    }
+
+    return chosen;
+}
+
+/* substitute macro arguments by replacements in buf of bufsize.
+   returns an error message or NULL.
+   if used is defined, returns the used macro arguments.
+*/
+static char * substitute_macro_args(char * buf, int bufsize,
+                                    const macro_t * macro,
+                                    const array_header * replacements,
+                                    array_header * used)
+{
+    char * ptr = buf, * errmsg,
+        ** atab = (char **)macro->arguments->elts,
+        ** rtab = (char **)replacements->elts;
+    int whichone;
+
+    if (used) {
+        ap_assert(used->nalloc >= replacements->nelts);
+    }
+
+    while ((ptr = next_substitution(ptr, macro->arguments, &whichone))) {
+        errmsg = substitute(ptr, buf - ptr + bufsize,
+                            atab[whichone], rtab[whichone]);
+        if (errmsg) {
+            return errmsg;
+        }
+        ptr += strlen(rtab[whichone]);
+        if (used) {
+            used->elts[whichone] = 1;
+        }
+    }
+
+    return NULL;
+}
+
+/* perform substitutions in a macro contents and
+   return the result as a newly allocated array, if result is defined.
+   may also return an error message.
+   passes used down to substitute_macro_args.
+*/
+static const char * process_content(ap_pool * p,
+                                    const macro_t * macro,
+                                    const array_header * replacements,
+                                    array_header * used,
+                                    array_header ** result)
+{
+    array_header * contents = macro->contents;
+    char ** new, * errmsg, line[MAX_STRING_LEN]; /* sorry again. */
+    int i;
+
+    if (result) {
+        *result = ap_make_array(p, 1, sizeof(char *));
+    }
+
+    for (i = 0; i < contents->nelts; i++) {
+        strncpy(line, ((char **)contents->elts)[i], MAX_STRING_LEN - 1);
+        errmsg = substitute_macro_args(line, MAX_STRING_LEN,
+                                       macro, replacements, used);
+        if (errmsg) {
+            return ap_psprintf(p, "while processing line %d of macro '%s'"
+                               " (%s)\n\t%s",
+                               i + 1, macro->name, macro->location, errmsg);
+        }
+
+        if (result) {
+            new = ap_push_array(*result);
+            *new = ap_pstrdup(p, line);
+        }
+    }
+
+    return NULL;
+}
+
+/* warn if some macro arguments are not used.
+ */
+static const char * check_macro_contents(ap_pool * p, const macro_t * macro)
+{
+#if !defined(MOD_MACRO_NO_WARNINGS)
+
+    int nelts = macro->arguments->nelts, i;
+    array_header * used;
+    const char * errmsg;
+    char ** names = (char **)macro->arguments->elts;
+
+    if (macro->contents->nelts == 0) {
+        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, NULL,
+                     "macro '%s' (%s)\n\tempty contents!\n",
+                     macro->name, macro->location);
+        return NULL; /* no need to further warnings... */
+    }
+
+    used = ap_make_array(p, nelts, sizeof(char));
+
+    for (i = 0; i < nelts; i++) {
+        used->elts[i] = 0;
+    }
+
+    errmsg = process_content(p, macro, macro->arguments, used, NULL);
+
+    if (errmsg) {
+        /* free used. */
+        return errmsg;
+    }
+
+    for (i = 0; i < nelts; i++) {
+        if (!used->elts[i]) {
+            ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, NULL,
+                         "macro '%s' (%s)\n\targument '%s' (#%d) never used\n",
+                         macro->name, macro->location, names[i], i + 1);
+        }
+    }
+
+    /* free used. */
+#endif
+
+    return NULL;
+}
+
+/********************************************************* MACRO CONFIG FILE */
+
+/* the expanded content of the macro is to be parsed as a configfile_t.
+   the following struct stores the content.
+
+
+   IMPORTANT NOTE:
+   ---------------
+
+   in http_config.c there is such a stuff made static,
+   which does not implement getch().
+   maybe this should be moved to util.c ???
+*/
+typedef struct {
+    int index;                  /* current element. */
+    int char_index;             /* current char in element. */
+    int length;                 /* cached length of the current line. */
+    array_header * contents;    /* array of char * */
+    configfile_t * next;        /* next config once this one is processed. */
+    configfile_t ** upper;      /* hack: where to update it if needed. */
+} array_contents_t;
+
+/* next config if any. */
+static int next_one(array_contents_t * ml)
+{
+    if (ml->next) {
+        ap_assert(ml->upper);
+        *(ml->upper) = ml->next;
+        return 1;
+    }
+    return 0;
+}
+
+/* returns next char or -1.
+ */
+static int array_getch(void * param)
+{
+    array_contents_t * ml = (array_contents_t *)param;
+    char ** tab = (char **)ml->contents->elts;
+
+    while (ml->char_index >= ml->length) { /* next element */
+        if (ml->index >= ml->contents->nelts) {
+            /* maybe update. */
+            if (ml->next && ml->next->getch && next_one(ml)) {
+                return ml->next->getch(ml->next->param);
+            }
+            return -1;
+        }
+        ml->index++;
+        ml->char_index = 0;
+        ml->length = ml->index >= ml->contents->nelts
+            ? 0 : strlen(tab[ml->index]);
+    }
+
+    return tab[ml->index][ml->char_index++];
+}
+
+/* returns a buf a la fgets.
+   no more than a line at a time, otherwise the parsing is too much ahead...
+   NULL at EOF.
+*/
+static void * array_getstr(void * buf, size_t bufsize, void * param)
+{
+    array_contents_t * ml = (array_contents_t *)param;
+    char * buffer = (char *) buf;
+    size_t i = 0;
+    int next = 0;
+
+    while (i < bufsize - 1 && next != '\n'
+           && ((next = array_getch(param)) != -1)) {
+        buffer[i++] = (char)next;
+    }
+
+    if (next == -1 && i == 0) { /* EOF */
+        /* maybe update to next. */
+        if (next_one(ml)) {
+            ap_assert(ml->next->getstr);
+            return ml->next->getstr(buf, bufsize, ml->next->param);
+        }
+        return NULL;
+    }
+
+    buffer[i] = '\0';
+    return buf;
+}
+
+/* close the array stream?
+ */
+static int array_close(void * param)
+{
+    array_contents_t * ml = (array_contents_t *)param;
+    ml->index = ml->contents->nelts;
+    ml->char_index = ml->length;
+    return 0;
+}
+
+/* this one could be exported.
+ */
+static configfile_t * make_array_config(ap_pool * p,
+                                        array_header * contents,
+                                        const char * where,
+                                        configfile_t * cfg,
+                                        configfile_t ** upper)
+{
+    array_contents_t * ls =
+        (array_contents_t *)ap_palloc(p, sizeof(array_contents_t));
+
+    ls->index      = 0;
+    ls->char_index = 0;
+    ls->contents   = contents;
+    ls->length     = ls->contents->nelts < 1
+                ? 0 : strlen(((char **)ls->contents->elts)[0]);
+    ls->next       = cfg;
+    ls->upper      = upper;
+
+    return ap_pcfg_open_custom(p, where, (void *)ls,
+                               array_getch, array_getstr, array_close);
+}
+
+
+/********************************************************** KEYWORD HANDLING */
+
+/* handles: <Macro macroname arg1 arg2 ...>
+ */
+static const char * macro_section(cmd_parms * cmd, void * dummy,
+                                  const char * arg)
+{
+    const char * errmsg, * where;
+    char ** new, * name, * endp = strrchr(arg, '>');
+    macro_t * macro, * old;
+
+    debug(fprintf(stderr, "macro_section -%s-\n", arg));
+
+    macro_init(cmd->temp_pool); /* lazy... */
+
+    if (endp) {
+        *endp = '\0';
+    }
+
+    /* get name. */
+    name = ap_getword_conf(cmd->temp_pool, &arg);
+
+    if (empty_string_p(name)) {
+        return "macro definition: name not specified";
+    }
+
+    old = get_macro_by_name(all_macros, name);
+    if (old) {
+#if !defined(MOD_MACRO_NO_WARNINGS)
+        /* already define: warn about the redefinition. */
+        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, NULL,
+                     "macro '%s' multiply defined.\n"
+                     "\t%s, redefined on line %d of %s",
+                     old->name, old->location,
+                     cmd->config_file->line_number, cmd->config_file->name);
+#endif
+        macro = old;
+    }
+    else {
+        macro = (macro_t *)ap_palloc(cmd->temp_pool, sizeof(macro_t));
+    }
+
+    macro->name = name;
+
+    /* get arguments. */
+    macro->location = ap_psprintf(cmd->temp_pool,
+                                  "defined on line %d of %s",
+                                  cmd->config_file->line_number,
+                                  cmd->config_file->name);
+
+    where = ap_psprintf(cmd->temp_pool, "macro '%s' (%s)",
+                        macro->name, macro->location);
+
+#if !defined(MOD_MACRO_NO_CHAR_PREFIX_WARNINGS) || \
+    !defined(MOD_MACRO_NO_WARNINGS)
+    if (looks_like_an_argument(name)) {
+        ap_log_error(APLOG_MARK, APLOG_NOERRNO|APLOG_WARNING, NULL,
+                     "%s\n\tit is good practice not "
+                     "to prefix a macro name with any of '%s'\n",
+                     where, ARGUMENT_PREFIX);
+    }
+#endif
+
+    macro->arguments = get_arguments(cmd->temp_pool, arg);
+
+    errmsg = check_macro_arguments(cmd->temp_pool, macro);
+
+    if (errmsg) {
+        return errmsg;
+    }
+
+    /* get contents */
+    errmsg = get_lines_till_end_token(cmd->temp_pool, cmd->config_file,
+                                      END_MACRO, BEGIN_MACRO,
+                                      where, &macro->contents);
+
+    if (errmsg) {
+        return ap_psprintf(cmd->temp_pool,
+                           "%s\n\tcontents error: %s", where, errmsg);
+    }
+
+    errmsg = check_macro_contents(cmd->temp_pool, macro);
+
+    if (errmsg) {
+        return ap_psprintf(cmd->temp_pool,
+                           "%s\n\tcontents checking error: %s", where, errmsg);
+    }
+
+    /* add the new macro. */
+    new  = ap_push_array(all_macros);
+    *new = (char *)macro;
+
+    return NULL;
+}
+
+/* handles: Use name value1 value2 ...
+ */
+static const char * use_macro(cmd_parms * cmd, void * dummy, const char * arg)
+{
+    char * name, * where, * recursion;
+    const char * errmsg;
+    array_header * contents, * replacements;
+    macro_t * macro;
+
+    debug(fprintf(stderr, "use_macro -%s-\n", arg));
+
+    macro_init(cmd->temp_pool); /* lazy... */
+
+    name = ap_getword_conf(cmd->temp_pool, &arg);
+
+    if (empty_string_p(name)) {
+        return "no macro name specified in " USE_MACRO;
+    }
+
+    macro = get_macro_by_name(all_macros, name);
+
+    if (!macro) {
+        return ap_psprintf(cmd->temp_pool, "macro '%s' is not defined", name);
+    }
+
+    /* recursion is detected by looking at the config file name,
+       which may already contains "macro 'foo'". Ok, it looks like a hack,
+       but otherwise it is uneasy to keep this data available somewhere...
+       the name has just the needed visibility and liveness.
+    */
+    recursion = ap_pstrcat(cmd->temp_pool, "macro '", macro->name, "'", NULL);
+
+    where = ap_psprintf(cmd->temp_pool,
+                        "macro '%s' (%s) used on line %d of %s",
+                        macro->name, macro->location,
+                        cmd->config_file->line_number,
+                        cmd->config_file->name);
+
+    if (strstr(cmd->config_file->name, recursion)) {
+        return ap_psprintf(cmd->temp_pool,
+                           "%s\n\trecursive use of macro '%s' is invalid.",
+                           where, macro->name);
+    }
+
+    replacements = get_arguments(cmd->temp_pool, arg);
+
+    if (macro->arguments->nelts != replacements->nelts) {
+        return ap_psprintf(cmd->temp_pool,
+                          "use of macro '%s' %s\n"
+                          "\twith %d argument%s instead of %d",
+                           macro->name, macro->location, replacements->nelts,
+                           replacements->nelts > 1 ? "s" : "", /* grammar;-) */
+                           macro->arguments->nelts);
+    }
+
+    check_macro_use_arguments(where, replacements);
+
+    errmsg = process_content(cmd->temp_pool, macro, replacements,
+                             NULL, &contents);
+
+    if (errmsg) {
+        return ap_psprintf(cmd->temp_pool,
+                           "%s\n\terror while substituting:\n%s",
+                           where, errmsg);
+    }
+
+    /* fix??? why is it wrong? should I -- the new one? */
+    cmd->config_file->line_number++;
+
+    cmd->config_file = make_array_config
+        (cmd->temp_pool, contents, where, cmd->config_file, &cmd->config_file);
+
+    return NULL;
+}
+
+/* handles: a lonely </Macro> or other unexpected keyword.
+ * such a function already exists? where? could be in util.c or config.c?
+ */
+static const char * unexpected_keyword(cmd_parms * parms, void * dummy1,
+                                       const char * dummy2)
+{
+    return ap_psprintf(parms->temp_pool,
+                       "unexpected %s encountered", (char *)parms->info);
+}
+
+/************************************ ERROR AND WARNING DURING CONFIGURATION */
+
+/* maybe ConfigurationError and ConfigurationWarning could be used?
+ */
+#define ERROR_KEYWORD "Error"
+#define WARNING_KEYWORD "Warning"
+
+/* configuration generated erros or warnings.
+ */
+static const char * say_it(cmd_parms * parms, void * dummy, const char * arg)
+{
+    int level = (int)parms->info;
+    trim(arg);
+
+    ap_log_error(APLOG_MARK, APLOG_NOERRNO|level, NULL,
+                 "on line %d of %s:\n\t%s\n",
+                 parms->config_file->line_number,
+                 parms->config_file->name, arg);
+
+    return level & APLOG_ERR ?
+        "configuration file processing aborted by " ERROR_KEYWORD "." : NULL;
+}
+
+/************************************************************* EXPORT MODULE */
+
+/* macro module commands.
+ */
+static const command_rec macro_cmds[] =
+{
+    /* configuration file macro stuff
+     */
+    { BEGIN_MACRO, macro_section, NULL, OR_ALL, RAW_ARGS,
+      "Beginning of a macro definition section." },
+    { END_MACRO, unexpected_keyword, (void *)END_MACRO, OR_ALL, NO_ARGS,
+      "End of a macro definition section." },
+    { USE_MACRO, use_macro, NULL, OR_ALL, RAW_ARGS,
+      "Use of a macro." },
+
+    /* configuration errors and warnings.
+     */
+    { ERROR_KEYWORD, say_it, (void *)APLOG_ERR, OR_ALL, RAW_ARGS,
+      "Error in a configuration file." },
+    { WARNING_KEYWORD, say_it, (void *)APLOG_WARNING, OR_ALL, RAW_ARGS,
+      "Warning in a configuration file." },
+
+    { NULL }
+};
+
+/* Module hooks are request-oriented thus it does not suit configuration
+   file utils a lot. I haven't found any clean hook to apply something
+   before then after configuration file processing. Also what about
+   .htaccess files?
+
+   Thus I think that main/http_co*.c would be a better place for this stuff.
+*/
+module MODULE_VAR_EXPORT macro_module =
+{
+    STANDARD_MODULE_STUFF,
+    macro_startup,             /* initializer */
+    NULL,                      /* create per-dir config */
+    NULL,                      /* merge per-dir config */
+    NULL,                      /* server config */
+    NULL,                      /* merge server config */
+    macro_cmds,                /* command table */
+    NULL,                      /* handlers */
+    NULL,                      /* filename translation */
+    NULL,                      /* check_user_id */
+    NULL,                      /* check auth */
+    NULL,                      /* check access */
+    NULL,                      /* type_checker */
+    NULL,                      /* fixups */
+    NULL,                      /* logger */
+    NULL,                      /* header parser */
+    NULL,                      /* child_init */
+    NULL,                      /* child_exit */
+    NULL                       /* post read-request */
+};
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/proxy/mod_proxy.c apache_1.3.33/src/modules/proxy/mod_proxy.c
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/proxy/mod_proxy.c	Tue Feb 17 22:52:22 2004
+++ apache_1.3.33/src/modules/proxy/mod_proxy.c	Mon Jul 18 15:22:25 2005
@@ -175,6 +175,9 @@
 static int proxy_fixup(request_rec *r)
 {
     char *url, *p;
+#ifdef EAPI
+    int rc;
+#endif /* EAPI */
 
     if (r->proxyreq == NOT_PROXY || strncmp(r->filename, "proxy:", 6) != 0)
         return DECLINED;
@@ -182,6 +185,14 @@
     url = &r->filename[6];
 
 /* canonicalise each specific scheme */
+#ifdef EAPI
+    if (ap_hook_use("ap::mod_proxy::canon",
+                    AP_HOOK_SIG3(int,ptr,ptr),
+                    AP_HOOK_DECLINE(DECLINED),
+                    &rc, r, url) && rc != DECLINED)
+        return rc;  
+    else
+#endif /* EAPI */
     if (strncasecmp(url, "http:", 5) == 0)
         return ap_proxy_http_canon(r, url + 5, "http", DEFAULT_HTTP_PORT);
     else if (strncasecmp(url, "ftp:", 4) == 0)
@@ -197,9 +208,44 @@
 static void proxy_init(server_rec *r, pool *p)
 {
     ap_proxy_garbage_init(r, p);
+#ifdef EAPI
+    ap_hook_use("ap::mod_proxy::init", 
+                AP_HOOK_SIG3(void,ptr,ptr), AP_HOOK_ALL, r, p);
+#endif
 }
 
-
+#ifdef EAPI
+static void proxy_addmod(module *m)
+{
+    /* export: ap_proxy_http_canon() as `ap::mod_proxy::http::canon' */
+    ap_hook_configure("ap::mod_proxy::http::canon", 
+                      AP_HOOK_SIG5(int,ptr,ptr,ptr,int), AP_HOOK_TOPMOST);
+    ap_hook_register("ap::mod_proxy::http::canon", 
+                     ap_proxy_http_canon, AP_HOOK_NOCTX);
+
+    /* export: ap_proxy_http_handler() as `ap::mod_proxy::http::handler' */
+    ap_hook_configure("ap::mod_proxy::http::handler", 
+                      AP_HOOK_SIG6(int,ptr,ptr,ptr,ptr,int), AP_HOOK_TOPMOST);
+    ap_hook_register("ap::mod_proxy::http::handler", 
+                     ap_proxy_http_handler, AP_HOOK_NOCTX);
+
+    /* export: ap_proxyerror() as `ap::mod_proxy::error' */
+    ap_hook_configure("ap::mod_proxy::error", 
+                      AP_HOOK_SIG3(int,ptr,ptr), AP_HOOK_TOPMOST);
+    ap_hook_register("ap::mod_proxy::error", 
+                     ap_proxyerror, AP_HOOK_NOCTX);
+    return;
+}
+
+static void proxy_remmod(module *m)
+{
+	/* remove the hook references */
+    ap_hook_unregister("ap::mod_proxy::http::canon", ap_proxy_http_canon);
+    ap_hook_unregister("ap::mod_proxy::http::handler", ap_proxy_http_handler);
+    ap_hook_unregister("ap::mod_proxy::error", ap_proxyerror);
+    return;
+}
+#endif /* EAPI */
 
 /* Send a redirection if the request contains a hostname which is not */
 /* fully qualified, i.e. doesn't have a domain name appended. Some proxy */
@@ -331,6 +377,14 @@
                  * CONNECT is a special method that bypasses the normal proxy
                  * code.
                  */
+#ifdef EAPI
+		if (!ap_hook_use("ap::mod_proxy::handler",
+				 AP_HOOK_SIG7(int,ptr,ptr,ptr,ptr,int,ptr),
+				 AP_HOOK_DECLINE(DECLINED),
+				 &rc, r, cr, url, 
+				 ents[i].hostname, ents[i].port, 
+				 ents[i].protocol) || rc == DECLINED) {
+#endif /* EAPI */
                 if (r->method_number == M_CONNECT)
                     rc = ap_proxy_connect_handler(r, cr, url, ents[i].hostname,
                                                   ents[i].port);
@@ -340,6 +394,9 @@
                                                ents[i].port);
                 else
                     rc = DECLINED;
+#ifdef EAPI
+		}
+#endif /* EAPI */
 
                 /* an error or success */
                 if (rc != DECLINED && rc != HTTP_BAD_GATEWAY)
@@ -354,6 +411,14 @@
      */
 
     /* handle the scheme */
+#ifdef EAPI
+    if (ap_hook_use("ap::mod_proxy::handler",
+		    AP_HOOK_SIG7(int,ptr,ptr,ptr,ptr,int,ptr),
+		    AP_HOOK_DECLINE(DECLINED),
+		    &rc, r, cr, url, 
+                    NULL, 0, scheme) && rc != DECLINED)
+        return rc;
+#endif /* EAPI */
     if (r->method_number == M_CONNECT) {
         return ap_proxy_connect_handler(r, cr, url, NULL, 0);
     }
@@ -951,4 +1016,10 @@
     NULL,                       /* child_init */
     NULL,                       /* child_exit */
     proxy_detect                /* post read-request */
+#ifdef EAPI
+   ,proxy_addmod,		/* EAPI: add_module */
+    proxy_remmod,		/* EAPI: remove_module */
+    NULL,			/* EAPI: rewrite_command */
+    NULL			/* EAPI: new_connection  */
+#endif
 };
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/proxy/proxy_cache.c apache_1.3.33/src/modules/proxy/proxy_cache.c
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/proxy/proxy_cache.c	Tue Feb 17 22:52:22 2004
+++ apache_1.3.33/src/modules/proxy/proxy_cache.c	Mon Jul 18 15:22:19 2005
@@ -191,6 +191,8 @@
 
         case 0:         /* Child */
             /* The setpgrp() stuff was snarfed from http_main.c */
+	    nice(10);
+#define NO_SETSID
 #ifndef NO_SETSID
             if ((pgrp = setsid()) == -1) {
                 perror("setsid");
@@ -214,7 +216,7 @@
                 exit(1);
             }
 #else
-            if ((pgrp = setpgrp(getpid(), 0)) == -1) {
+            if ((pgrp = setpgrp()) == -1) {
                 perror("setpgrp");
                 fprintf(stderr, "%s: setpgrp failed\n",
                         ap_server_argv0);
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/proxy/proxy_cache.c.orig apache_1.3.33/src/modules/proxy/proxy_cache.c.orig
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/proxy/proxy_cache.c.orig	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/modules/proxy/proxy_cache.c.orig	Tue Feb 17 22:52:22 2004
@@ -0,0 +1,1767 @@
+/* Copyright 1999-2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* Cache and garbage collection routines for Apache proxy */
+
+#include "mod_proxy.h"
+#include "http_conf_globals.h"
+#include "http_log.h"
+#include "http_main.h"
+#include "http_core.h"
+#include "util_date.h"
+#ifdef WIN32
+#include <sys/utime.h>
+#else
+#include <utime.h>
+#endif                          /* WIN32 */
+#include "multithread.h"
+#include "ap_md5.h"
+#ifdef __TANDEM
+#include <sys/types.h>
+#include <sys/stat.h>
+#endif
+#ifdef TPF
+#include "os.h"
+#endif
+
+struct gc_ent {
+    unsigned long int len;
+    time_t expire;
+    char file[HASH_LEN + 1];
+};
+
+/* Poor man's 61 bit arithmetic */
+typedef struct {
+    long lower;                 /* lower 30 bits of result */
+    long upper;                 /* upper 31 bits of result */
+} long61_t;
+
+/* FIXME: The block size can be different on a `per file system' base.
+ * This would make automatic detection highly OS specific.
+ * In the GNU fileutils code for du(1), you can see how complicated it can
+ * become to detect the block size. And, with BSD-4.x fragments, it
+ * it even more difficult to get precise results.
+ * As a compromise (and to improve on the incorrect counting of cache
+ * size on byte level, omitting directory sizes entirely, which was
+ * used up to apache-1.3b7) we're rounding to multiples of 512 here.
+ * Your file system may be using larger blocks (I certainly hope so!)
+ * but it will hardly use smaller blocks.
+ * (So this approximation is still closer to reality than the old behavior).
+ * The best solution would be automatic detection, the next best solution
+ * IMHO is a sensible default and the possibility to override it.
+ */
+
+#define ROUNDUP2BLOCKS(_bytes) (((_bytes)+block_size-1) & ~(block_size-1))
+static long block_size = 512;   /* this must be a power of 2 */
+static long61_t curbytes, cachesize;
+static time_t garbage_now, garbage_expire;
+static mutex *garbage_mutex = NULL;
+
+
+int ap_proxy_garbage_init(server_rec *r, pool *p)
+{
+    if (!garbage_mutex)
+        garbage_mutex = ap_create_mutex(NULL);
+
+    return (0);
+}
+
+
+static int sub_garbage_coll(request_rec *r, array_header *files,
+                             const char *cachedir, const char *cachesubdir);
+static void help_proxy_garbage_coll(request_rec *r);
+static int should_proxy_garbage_coll(request_rec *r);
+#if !defined(WIN32) && !defined(MPE) && !defined(OS2) && !defined(NETWARE) && !defined(TPF)
+static void detached_proxy_garbage_coll(request_rec *r);
+#endif
+
+
+void ap_proxy_garbage_coll(request_rec *r)
+{
+    static int inside = 0;
+
+    (void)ap_acquire_mutex(garbage_mutex);
+    if (inside == 1) {
+        (void)ap_release_mutex(garbage_mutex);
+        return;
+    }
+    else
+        inside = 1;
+    (void)ap_release_mutex(garbage_mutex);
+
+    ap_block_alarms();          /* avoid SIGALRM on big cache cleanup */
+    if (should_proxy_garbage_coll(r))
+#if !defined(WIN32) && !defined(MPE) && !defined(OS2) && !defined(NETWARE) && !defined(TPF)
+        detached_proxy_garbage_coll(r);
+#else
+        help_proxy_garbage_coll(r);
+#endif
+    ap_unblock_alarms();
+
+    (void)ap_acquire_mutex(garbage_mutex);
+    inside = 0;
+    (void)ap_release_mutex(garbage_mutex);
+}
+
+
+static void add_long61(long61_t *accu, long val)
+{
+    /* Add in lower 30 bits */
+    accu->lower += (val & 0x3FFFFFFFL);
+    /* add in upper bits, and carry */
+    accu->upper += (val >> 30) + ((accu->lower & ~0x3FFFFFFFL) != 0L);
+    /* Clear carry */
+    accu->lower &= 0x3FFFFFFFL;
+}
+
+static void sub_long61(long61_t *accu, long val)
+{
+    int carry = (val & 0x3FFFFFFFL) > accu->lower;
+    /* Subtract lower 30 bits */
+    accu->lower = accu->lower - (val & 0x3FFFFFFFL) + ((carry) ? 0x40000000 : 0);
+    /* add in upper bits, and carry */
+    accu->upper -= (val >> 30) + carry;
+}
+
+/* Compare two long61's:
+ * return <0 when left < right
+ * return  0 when left == right
+ * return >0 when left > right
+ */
+static long cmp_long61(long61_t *left, long61_t *right)
+{
+    return (left->upper == right->upper) ? (left->lower - right->lower)
+    : (left->upper - right->upper);
+}
+
+/* Compare two gc_ent's, sort them by expiration date */
+static int gcdiff(const void *ap, const void *bp)
+{
+    const struct gc_ent *a = (const struct gc_ent *) ap;
+    const struct gc_ent *b = (const struct gc_ent *) bp;
+
+    if (a->expire > b->expire)
+        return 1;
+    else if (a->expire < b->expire)
+        return -1;
+    else
+        return 0;
+}
+
+#if !defined(WIN32) && !defined(MPE) && !defined(OS2) && !defined(NETWARE) && !defined(TPF)
+static void detached_proxy_garbage_coll(request_rec *r)
+{
+    pid_t pid;
+    int status;
+    pid_t pgrp;
+
+#if 0
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, r->server,
+                 "proxy: Guess what; we fork() again...");
+#endif
+    switch (pid = fork()) {
+    case -1:
+        ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
+                     "proxy: fork() for cache cleanup failed");
+        return;
+
+    case 0:                     /* Child */
+
+        /* close all sorts of things, including the socket fd */
+        ap_cleanup_for_exec();
+
+        /* Fork twice to disassociate from the child */
+        switch (pid = fork()) {
+        case -1:
+            ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
+                         "proxy: fork(2nd) for cache cleanup failed");
+            exit(1);
+
+        case 0:         /* Child */
+            /* The setpgrp() stuff was snarfed from http_main.c */
+#ifndef NO_SETSID
+            if ((pgrp = setsid()) == -1) {
+                perror("setsid");
+                fprintf(stderr, "%s: setsid failed\n",
+                        ap_server_argv0);
+                exit(1);
+            }
+#elif defined(NEXT) || defined(NEWSOS)
+            if (setpgrp(0, getpid()) == -1 || (pgrp = getpgrp(0)) == -1) {
+                perror("setpgrp");
+                fprintf(stderr, "%S: setpgrp or getpgrp failed\n",
+                        ap_server_argv0);
+                exit(1);
+            }
+#elif defined(CYGWIN)
+            /* Cygwin does not take any argument for setpgrp() */
+            if ((pgrp = setpgrp()) == -1) {
+                perror("setpgrp");
+                fprintf(stderr, "%S: setpgrp failed\n",
+                        ap_server_argv0);
+                exit(1);
+            }
+#else
+            if ((pgrp = setpgrp(getpid(), 0)) == -1) {
+                perror("setpgrp");
+                fprintf(stderr, "%s: setpgrp failed\n",
+                        ap_server_argv0);
+                exit(1);
+            }
+#endif
+            help_proxy_garbage_coll(r);
+            exit(0);
+
+        default:                /* Father */
+            /* After grandson has been forked off, */
+            /* there's nothing else to do. */
+            exit(0);
+        }
+    default:
+        /* Wait until grandson has been forked off */
+        /* (without wait we'd leave a zombie) */
+        waitpid(pid, &status, 0);
+        return;
+    }
+}
+#endif                          /* ndef WIN32 */
+
+#define DOT_TIME "/.time"       /* marker */
+
+static int should_proxy_garbage_coll(request_rec *r)
+{
+    void *sconf = r->server->module_config;
+    proxy_server_conf *pconf =
+    (proxy_server_conf *)ap_get_module_config(sconf, &proxy_module);
+    const struct cache_conf *conf = &pconf->cache;
+
+    const char *cachedir = conf->root;
+    char *filename;
+    struct stat buf;
+    int timefd;
+    time_t every = conf->gcinterval;
+    static time_t lastcheck = BAD_DATE; /* static (per-process) data!!! */
+
+    if (cachedir == NULL || every == -1)
+        return 0;
+
+    filename = ap_palloc(r->pool, strlen(cachedir) + strlen(DOT_TIME) + 1);
+
+    garbage_now = time(NULL);
+    /*
+     * Usually, the modification time of <cachedir>/.time can only increase.
+     * Thus, even with several child processes having their own copy of
+     * lastcheck, if time(NULL) still < lastcheck then it's not time for GC
+     * yet.
+     */
+    if (garbage_now != -1 && lastcheck != BAD_DATE && garbage_now < lastcheck + every)
+        return 0;
+
+    strcpy(filename, cachedir);
+    strcat(filename, DOT_TIME);
+
+    /*
+     * At this point we have a bit of an engineering compromise. We could
+     * either create and/or mark the .time file  (prior to the fork which
+     * might fail on a resource issue) or wait until we are safely forked.
+     * The advantage of doing it now in this process is that we get some
+     * usefull live out of the global last check variable. (XXX which should
+     * go scoreboard IMHO.) Note that the actual counting is at a later
+     * moment.
+     */
+    if (stat(filename, &buf) == -1) {   /* does not exist */
+        if (errno != ENOENT) {
+            ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
+                         "proxy: stat(%s)", filename);
+            return 0;
+        }
+        if ((timefd = creat(filename, 0666)) == -1) {
+            if (errno != EEXIST)
+                ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
+                             "proxy: creat(%s)", filename);
+            else
+                lastcheck = garbage_now;        /* someone else got in there */
+            return 0;
+        }
+        close(timefd);
+    }
+    else {
+        lastcheck = buf.st_mtime;       /* save the time */
+        if (garbage_now < lastcheck + every) {
+            return 0;
+        }
+        if (utime(filename, NULL) == -1)
+            ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
+                         "proxy: utimes(%s)", filename);
+    }
+
+    return 1;
+}
+
+static void help_proxy_garbage_coll(request_rec *r)
+{
+    const char *cachedir;
+    void *sconf = r->server->module_config;
+    proxy_server_conf *pconf =
+    (proxy_server_conf *)ap_get_module_config(sconf, &proxy_module);
+    const struct cache_conf *conf = &pconf->cache;
+    array_header *files;
+    struct gc_ent *fent;
+    char *filename;
+    int i;
+
+    cachedir = conf->root;
+    filename = ap_palloc(r->pool, strlen(cachedir) + HASH_LEN + 2);
+    /* configured size is given in kB. Make it bytes, convert to long61_t: */
+    cachesize.lower = cachesize.upper = 0;
+    add_long61(&cachesize, conf->space << 10);
+
+    ap_block_alarms();          /* avoid SIGALRM on big cache cleanup */
+
+    files = ap_make_array(r->pool, 100, sizeof(struct gc_ent));
+    curbytes.upper = curbytes.lower = 0L;
+
+    sub_garbage_coll(r, files, cachedir, "/");
+
+    if (cmp_long61(&curbytes, &cachesize) < 0L) {
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server,
+                     "proxy GC: Cache is %ld%% full (nothing deleted)",
+                     (long)(((curbytes.upper << 20) | (curbytes.lower >> 10)) * 100 / conf->space));
+        ap_unblock_alarms();
+        return;
+    }
+
+    /* sort the files we found by expiration date */
+    qsort(files->elts, files->nelts, sizeof(struct gc_ent), gcdiff);
+
+    for (i = 0; i < files->nelts; i++) {
+        fent = &((struct gc_ent *) files->elts)[i];
+        sprintf(filename, "%s%s", cachedir, fent->file);
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "GC Unlinking %s (expiry %ld, garbage_now %ld)", filename, (long)fent->expire, (long)garbage_now);
+#if TESTING
+        fprintf(stderr, "Would unlink %s\n", filename);
+#else
+        if (unlink(filename) == -1) {
+            if (errno != ENOENT)
+                ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
+                             "proxy gc: unlink(%s)", filename);
+        }
+        else
+#endif
+        {
+            sub_long61(&curbytes, ROUNDUP2BLOCKS(fent->len));
+            if (cmp_long61(&curbytes, &cachesize) < 0)
+                break;
+        }
+    }
+
+    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server,
+                 "proxy GC: Cache is %ld%% full (%d deleted)",
+                 (long)(((curbytes.upper << 20) | (curbytes.lower >> 10)) * 100 / conf->space), i);
+    ap_unblock_alarms();
+}
+
+static int sub_garbage_coll(request_rec *r, array_header *files,
+                          const char *cachebasedir, const char *cachesubdir)
+{
+    char line[17 * (3)];
+    char cachedir[HUGE_STRING_LEN];
+    struct stat buf;
+    int fd, i;
+    DIR *dir;
+#if defined(NEXT) || defined(WIN32)
+    struct DIR_TYPE *ent;
+#else
+    struct dirent *ent;
+#endif
+    struct gc_ent *fent;
+    int nfiles = 0;
+    char *filename;
+
+    ap_snprintf(cachedir, sizeof(cachedir), "%s%s", cachebasedir, cachesubdir);
+    filename = ap_palloc(r->pool, strlen(cachedir) + HASH_LEN + 2);
+    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "GC Examining directory %s", cachedir);
+    dir = opendir(cachedir);
+    if (dir == NULL) {
+        ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
+                     "proxy gc: opendir(%s)", cachedir);
+        return 0;
+    }
+
+    while ((ent = readdir(dir)) != NULL) {
+        if (ent->d_name[0] == '.')
+            continue;
+        sprintf(filename, "%s%s", cachedir, ent->d_name);
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "GC Examining file %s", filename);
+/* is it a temporary file? */
+        if (strncmp(ent->d_name, "tmp", 3) == 0) {
+/* then stat it to see how old it is; delete temporary files > 1 day old */
+            if (stat(filename, &buf) == -1) {
+                if (errno != ENOENT)
+                    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
+                                 "proxy gc: stat(%s)", filename);
+            }
+            else if (garbage_now != -1 && buf.st_atime < garbage_now - SEC_ONE_DAY &&
+                     buf.st_mtime < garbage_now - SEC_ONE_DAY) {
+                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "GC unlink %s", filename);
+                ap_log_error(APLOG_MARK, APLOG_INFO | APLOG_NOERRNO, r->server,
+                     "proxy gc: deleting orphaned cache file %s", filename);
+#if TESTING
+                fprintf(stderr, "Would unlink %s\n", filename);
+#else
+                unlink(filename);
+#endif
+            }
+            continue;
+        }
+        ++nfiles;
+/* is it another file? */
+        /* FIXME: Shouldn't any unexpected files be deleted? */
+        /* if (strlen(ent->d_name) != HASH_LEN) continue; */
+
+/* under OS/2 use dirent's d_attr to identify a diretory */
+/* under TPF use stat to identify a directory */
+#if defined(OS2) || defined(TPF)
+/* is it a directory? */
+#ifdef OS2
+        if (ent->d_attr & A_DIR)
+#elif defined(TPF)
+            if (stat(filename, &buf) == -1) {
+                if (errno != ENOENT)
+                    ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
+                                 "proxy gc: stat(%s)", filename);
+            }
+        if (S_ISDIR(buf.st_mode))
+#endif
+        {
+            char newcachedir[HUGE_STRING_LEN];
+            ap_snprintf(newcachedir, sizeof(newcachedir),
+                        "%s%s/", cachesubdir, ent->d_name);
+            if (!sub_garbage_coll(r, files, cachebasedir, newcachedir)) {
+                ap_snprintf(newcachedir, sizeof(newcachedir),
+                            "%s%s", cachedir, ent->d_name);
+#if TESTING
+                fprintf(stderr, "Would remove directory %s\n", newcachedir);
+#else
+                rmdir(newcachedir);
+#endif
+                --nfiles;
+            }
+            continue;
+        }
+#endif
+
+/* read the file */
+#if defined(WIN32)
+        /*
+         * On WIN32 open does not work for directories, so we us stat instead
+         * of fstat to determine if the file is a directory
+         */
+        if (stat(filename, &buf) == -1) {
+            ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
+                         "proxy gc: stat(%s)", filename);
+            continue;
+        }
+        fd = -1;
+#else
+        fd = open(filename, O_RDONLY | O_BINARY);
+        if (fd == -1) {
+            if (errno != ENOENT)
+                ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
+                             "proxy gc: open(%s)", filename);
+            continue;
+        }
+        if (fstat(fd, &buf) == -1) {
+            ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
+                         "proxy gc: fstat(%s)", filename);
+            close(fd);
+            continue;
+        }
+#endif
+
+/* In OS/2 and TPF this has already been done above */
+#if !defined(OS2) && !defined(TPF)
+        if (S_ISDIR(buf.st_mode)) {
+            char newcachedir[HUGE_STRING_LEN];
+#if !defined(WIN32)
+            /* Win32 used stat, no file to close */
+            close(fd);
+#endif
+            ap_snprintf(newcachedir, sizeof(newcachedir),
+                        "%s%s/", cachesubdir, ent->d_name);
+            if (!sub_garbage_coll(r, files, cachebasedir, newcachedir)) {
+                ap_snprintf(newcachedir, sizeof(newcachedir),
+                            "%s%s", cachedir, ent->d_name);
+#if TESTING
+                fprintf(stderr, "Would remove directory %s\n", newcachedir);
+#else
+                rmdir(newcachedir);
+#endif
+                --nfiles;
+            }
+            else {
+                /* Directory is not empty. Account for its size: */
+                add_long61(&curbytes, ROUNDUP2BLOCKS(buf.st_size));
+            }
+            continue;
+        }
+#endif
+
+#if defined(WIN32)
+        /*
+         * Since we have determined above that the file is not a directory,
+         * it should be safe to open it now
+         */
+        fd = open(filename, O_RDONLY | O_BINARY);
+        if (fd == -1) {
+            if (errno != ENOENT)
+                ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
+                             "proxy gc: open(%s) = %d", filename, errno);
+            continue;
+        }
+#endif
+
+        i = read(fd, line, 17 * (3) - 1);
+        close(fd);
+        if (i == -1) {
+            ap_log_error(APLOG_MARK, APLOG_ERR, r->server,
+                         "proxy gc: read(%s)", filename);
+            continue;
+        }
+        line[i] = '\0';
+        garbage_expire = ap_proxy_hex2sec(line + 17 * (2));
+        if (!ap_checkmask(line, "&&&&&&&&&&&&&&&& &&&&&&&&&&&&&&&& &&&&&&&&&&&&&&&&") ||
+            garbage_expire == BAD_DATE) {
+            /* bad file */
+            if (garbage_now != -1 && buf.st_atime > garbage_now + SEC_ONE_DAY &&
+                buf.st_mtime > garbage_now + SEC_ONE_DAY) {
+                ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_NOERRNO, r->server,
+                             "proxy: deleting bad cache file with future date: %s", filename);
+#if TESTING
+                fprintf(stderr, "Would unlink bad file %s\n", filename);
+#else
+                unlink(filename);
+#endif
+            }
+            continue;
+        }
+
+/*
+ * we need to calculate an 'old' factor, and remove the 'oldest' files
+ * so that the space requirement is met; sort by the expires date of the
+ * file.
+ *
+ */
+        fent = (struct gc_ent *) ap_push_array(files);
+        fent->len = buf.st_size;
+        fent->expire = garbage_expire;
+        strcpy(fent->file, cachesubdir);
+        strcat(fent->file, ent->d_name);
+
+/* accumulate in blocks, to cope with directories > 4Gb */
+        add_long61(&curbytes, ROUNDUP2BLOCKS(buf.st_size));
+    }
+
+    closedir(dir);
+
+    return nfiles;
+
+}
+
+
+/*
+ * Read a cache file;
+ * returns 1 on success,
+ *         0 on failure (bad file or wrong URL)
+ *        -1 on UNIX error
+ *
+ * We read the cache hex header, then the message response line and
+ * response headers, and finally we return with the filepointer
+ * pointing at the start of the message body itself, ready to be
+ * shipped to the client later on, if appropriate.
+ */
+static int rdcache(request_rec *r, BUFF *cachefp, cache_req *c)
+{
+    char urlbuff[HUGE_STRING_LEN], *strp;
+    int len;
+
+    /* read the data from the cache file */
+
+    /*
+     * Format:
+     * 
+     * The cache needs to keep track of the following information: - Date,
+     * LastMod, Version, ReqTime, RespTime, ContentLength - The original
+     * request headers (for Vary) - The original response headers (for
+     * returning with a cached response) - The body of the message
+     * 
+     * date SP lastmod SP expire SP count SP request-time SP response-time SP
+     * content-lengthCRLF (dates are stored as hex seconds since 1970)
+     * Original URLCRLF Original Request Headers CRLF Original Response
+     * Headers CRLF Body
+     * 
+     */
+
+    /* retrieve cachefile information values */
+    len = ap_bgets(urlbuff, sizeof urlbuff, cachefp);
+    if (len == -1) {
+        /* Delete broken cache file */
+        unlink(c->filename);
+        return -1;
+    }
+    if (len == 0 || urlbuff[len - 1] != '\n')
+        return 0;
+    urlbuff[len - 1] = '\0';
+
+    if (!ap_checkmask(urlbuff,
+                      "&&&&&&&&&&&&&&&& &&&&&&&&&&&&&&&& &&&&&&&&&&&&&&&& &&&&&&&&&&&&&&&& &&&&&&&&&&&&&&&& &&&&&&&&&&&&&&&& &&&&&&&&&&&&&&&&"))
+        return 0;
+
+    c->date = ap_proxy_hex2sec(urlbuff + 17 * (0));
+    c->lmod = ap_proxy_hex2sec(urlbuff + 17 * (1));
+    c->expire = ap_proxy_hex2sec(urlbuff + 17 * (2));
+    c->version = ap_proxy_hex2sec(urlbuff + 17 * (3));
+    c->req_time = ap_proxy_hex2sec(urlbuff + 17 * (4));
+    c->resp_time = ap_proxy_hex2sec(urlbuff + 17 * (5));
+    c->len = ap_proxy_hex2sec(urlbuff + 17 * (6));
+
+    /* check that we have the same URL */
+    len = ap_bgets(urlbuff, sizeof urlbuff, cachefp);
+    if (len == -1) {
+        /* Delete broken cache file */
+        unlink(c->filename);
+        return -1;
+    }
+    if (len == 0 || strncmp(urlbuff, "X-URL: ", 7) != 0 ||
+        urlbuff[len - 1] != '\n')
+        return 0;
+    urlbuff[len - 1] = '\0';
+    if (strcmp(urlbuff + 7, c->url) != 0)
+        return 0;
+
+    /* then the original request headers */
+    c->req_hdrs = ap_proxy_read_headers(r, urlbuff, sizeof urlbuff, cachefp);
+    if (c->req_hdrs == NULL) {
+        /* Delete broken cache file */
+        unlink(c->filename);
+        return -1;
+    }
+
+    /* then the original response headers */
+    len = ap_bgets(urlbuff, sizeof urlbuff, cachefp);
+    if (len == -1) {
+        /* Delete broken cache file */
+        unlink(c->filename);
+        return -1;
+    }
+    if (len == 0 || urlbuff[len - 1] != '\n')
+        return 0;
+    urlbuff[--len] = '\0';
+
+    c->resp_line = ap_pstrdup(r->pool, urlbuff);
+    strp = strchr(urlbuff, ' ');
+    if (strp == NULL)
+        return 0;
+
+    c->status = atoi(strp);
+    c->hdrs = ap_proxy_read_headers(r, urlbuff, sizeof urlbuff, cachefp);
+    if (c->hdrs == NULL) {
+        /* Delete broken cache file */
+        unlink(c->filename);
+        return -1;
+    }
+    if (c->len != -1)           /* add a content-length header */
+        if (ap_table_get(c->hdrs, "Content-Length") == NULL) {
+            ap_table_set(c->hdrs, "Content-Length",
+                         ap_psprintf(r->pool, "%lu", (unsigned long)c->len));
+        }
+
+
+    return 1;
+}
+
+/*
+ * Call this to check the possible conditional status of
+ * the client request, and return the response from the cache
+ *
+ * Conditionals include If-Modified-Since, If-Match, If-Unmodified-Since
+ * and If-None-Match.
+ *
+ * We don't yet understand If-Range, but we will...
+ */
+int ap_proxy_cache_conditional(request_rec *r, cache_req *c, BUFF *cachefp)
+{
+    const char *etag, *wetag = NULL;
+
+    /* get etag */
+    if ((etag = ap_table_get(c->hdrs, "Etag"))) {
+        wetag = ap_pstrcat(r->pool, "W/", etag, NULL);
+    }
+
+    /* check for If-Match, If-Unmodified-Since */
+    while (1) {
+
+        /*
+         * check If-Match and If-Unmodified-Since exist
+         * 
+         * If neither of these exist, the request is not conditional, and we
+         * serve it normally
+         */
+        if (!c->im && BAD_DATE == c->ius) {
+            break;
+        }
+
+        /*
+         * check If-Match
+         * 
+         * we check if the Etag on the cached file is in the list of Etags in
+         * the If-Match field. The comparison must be a strong comparison, so
+         * the Etag cannot be marked as weak. If the comparision fails we
+         * return 412 Precondition Failed.
+         * 
+         * if If-Match is specified AND If-Match is not a "*" AND Etag is
+         * missing or weak or not in the list THEN return 412 Precondition
+         * Failed
+         */
+
+        if (c->im) {
+            if (strcmp(c->im, "*") &&
+                (!etag || (strlen(etag) > 1 && 'W' == etag[0] && '/' == etag[1]) || !ap_proxy_liststr(c->im, etag, NULL))) {
+                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "If-Match specified, and it didn't - return 412");
+            }
+            else {
+                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "If-Match specified, and it matched");
+                break;
+            }
+        }
+
+        /*
+         * check If-Unmodified-Since
+         * 
+         * if If-Unmodified-Since is specified AND Last-Modified is specified
+         * somewhere AND If-Unmodified-Since is in the past compared to
+         * Last-Modified THEN return 412 Precondition Failed
+         */
+        if (BAD_DATE != c->ius && BAD_DATE != c->lmod) {
+            if (c->ius < c->lmod) {
+                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "If-Unmodified-Since specified, but it wasn't - return 412");
+            }
+            else {
+                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "If-Unmodified-Since specified, and it was unmodified");
+                break;
+            }
+        }
+
+        /* if cache file is being updated */
+        if (c->origfp) {
+            ap_proxy_write_headers(c, c->resp_line, c->hdrs);
+            ap_proxy_send_fb(c->origfp, r, c, c->len, 1, 0, IOBUFSIZE);
+            ap_proxy_cache_tidy(c);
+        }
+        else
+            ap_pclosef(r->pool, ap_bfileno(cachefp, B_WR));
+
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Use your cached copy, conditional precondition failed.");
+        return HTTP_PRECONDITION_FAILED;
+    }
+
+
+    /* check for If-None-Match, If-Modified-Since */
+    while (1) {
+
+        /*
+         * check for existance of If-None-Match and If-Modified-Since
+         * 
+         * if neither of these headers have been set, then the request is not
+         * conditional, and we just send the cached response and be done with
+         * it.
+         */
+        if (!c->inm && BAD_DATE == c->ims) {
+            break;
+        }
+
+        /*
+         * check If-None-Match
+         * 
+         * we check if the Etag on the cached file is in the list of Etags in
+         * the If-None-Match field. The comparison must be a strong
+         * comparison, so the Etag cannot be marked as weak. If the
+         * comparision fails we return 412 Precondition Failed.
+         * 
+         * if If-None-Match is specified: if If-None-Match is a "*" THEN 304
+         * else if Etag is specified AND we get a match THEN 304 else if Weak
+         * Etag is specified AND we get a match THEN 304 else sent the
+         * original object
+         */
+        if (c->inm) {
+            if (!strcmp(c->inm, "*")) {
+                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "If-None-Match: * specified, return 304");
+            }
+            else if (etag && ap_proxy_liststr(c->inm, etag, NULL)) {
+                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "If-None-Match: specified and we got a strong match - return 304");
+            }
+            else if (wetag && ap_proxy_liststr(c->inm, wetag, NULL)) {
+                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "If-None-Match specified, and we got a weak match - return 304");
+            }
+            else
+                break;
+        }
+
+        /*
+         * check If-Modified-Since
+         * 
+         * if If-Modified-Since is specified AND Last-Modified is specified
+         * somewhere: if last modification date is earlier than
+         * If-Modified-Since THEN 304 else send the original object
+         */
+        if (BAD_DATE != c->ims && BAD_DATE != c->lmod) {
+            if (c->ims >= c->lmod) {
+                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "If-Modified-Since specified and not modified, try return 304");
+            }
+            else
+                break;
+        }
+
+
+        /* are we updating the cache file? */
+        if (c->origfp) {
+            ap_proxy_write_headers(c, c->resp_line, c->hdrs);
+            ap_proxy_send_fb(c->origfp, r, c, c->len, 1, 0, IOBUFSIZE);
+            ap_proxy_cache_tidy(c);
+        }
+        else
+            ap_pclosef(r->pool, ap_bfileno(cachefp, B_WR));
+
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Use local copy, cached file hasn't changed");
+        return HTTP_NOT_MODIFIED;
+    }
+
+
+    /* No conditional - just send it cousin! */
+    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Local copy modified, send it");
+    r->status_line = strchr(c->resp_line, ' ') + 1;
+    r->status = c->status;
+
+    /* Prepare and send headers to client */
+    ap_proxy_table_replace(r->headers_out, c->hdrs);
+    /* make sure our X-Cache header does not stomp on a previous header */
+    ap_table_mergen(r->headers_out, "X-Cache", c->xcache);
+
+    /* content type is already set in the headers */
+    r->content_type = ap_table_get(r->headers_out, "Content-Type");
+
+    ap_send_http_header(r);
+
+    /* are we rewriting the cache file? */
+    if (c->origfp) {
+        ap_proxy_write_headers(c, c->resp_line, c->hdrs);
+        ap_proxy_send_fb(c->origfp, r, c, c->len, r->header_only, 0, IOBUFSIZE);
+        ap_proxy_cache_tidy(c);
+        return OK;
+    }
+
+    /* no, we not */
+    if (!r->header_only) {
+        ap_proxy_send_fb(cachefp, r, NULL, c->len, 0, 0, IOBUFSIZE);
+    }
+    else {
+        ap_pclosef(r->pool, ap_bfileno(cachefp, B_WR));
+    }
+
+    return OK;
+}
+
+
+/*
+ * Call this to test for a resource in the cache
+ * Returns DECLINED if we need to check the remote host
+ * or an HTTP status code if successful
+ *
+ * Functions:
+ *   if URL is cached then
+ *      if cached file is not expired then
+ *         if last modified after if-modified-since then send body
+ *         else send 304 Not modified
+ *      else if cached file is expired then
+ *         if last modified after if-modified-since then add
+ *            last modified date to request
+ */
+int ap_proxy_cache_check(request_rec *r, char *url, struct cache_conf * conf,
+                             cache_req **cr)
+{
+    const char *datestr, *pragma_req = NULL, *pragma_cresp = NULL, *cc_req = NULL,
+        *cc_cresp = NULL;
+    cache_req *c;
+    BUFF *cachefp;
+    int i;
+    void *sconf = r->server->module_config;
+    proxy_server_conf *pconf =
+    (proxy_server_conf *)ap_get_module_config(sconf, &proxy_module);
+    const char *agestr = NULL;
+    char *val;
+    time_t age_c = 0;
+    time_t age, maxage_req, maxage_cresp, maxage, smaxage, maxstale, minfresh;
+
+    c = ap_pcalloc(r->pool, sizeof(cache_req));
+    *cr = c;
+    c->req = r;
+    c->url = ap_pstrdup(r->pool, url);
+    c->filename = NULL;
+    c->tempfile = NULL;
+    c->fp = NULL;
+    c->origfp = NULL;
+    c->version = 0;
+    c->len = -1;
+    c->req_hdrs = NULL;
+    c->hdrs = NULL;
+    c->xcache = NULL;
+
+    /* get the If-Modified-Since date of the request, if it exists */
+    c->ims = BAD_DATE;
+    datestr = ap_table_get(r->headers_in, "If-Modified-Since");
+    if (datestr != NULL) {
+        /* this may modify the value in the original table */
+        datestr = ap_proxy_date_canon(r->pool, datestr);
+        c->ims = ap_parseHTTPdate(datestr);
+        if (c->ims == BAD_DATE) /* bad or out of range date; remove it */
+            ap_table_unset(r->headers_in, "If-Modified-Since");
+    }
+
+/* get the If-Unmodified-Since date of the request, if it exists */
+    c->ius = BAD_DATE;
+    datestr = ap_table_get(r->headers_in, "If-Unmodified-Since");
+    if (datestr != NULL) {
+        /* this may modify the value in the original table */
+        datestr = ap_proxy_date_canon(r->pool, datestr);
+        c->ius = ap_parseHTTPdate(datestr);
+        if (c->ius == BAD_DATE) /* bad or out of range date; remove it */
+            ap_table_unset(r->headers_in, "If-Unmodified-Since");
+    }
+
+/* get the If-Match of the request, if it exists */
+    c->im = ap_table_get(r->headers_in, "If-Match");
+
+/* get the If-None-Match of the request, if it exists */
+    c->inm = ap_table_get(r->headers_in, "If-None-Match");
+
+/* find the filename for this cache entry */
+    if (conf->root != NULL) {
+        char hashfile[66];
+        ap_proxy_hash(url, hashfile, pconf->cache.dirlevels, pconf->cache.dirlength);
+        c->filename = ap_pstrcat(r->pool, conf->root, "/", hashfile, NULL);
+    }
+    else {
+        c->filename = NULL;
+        c->fp = NULL;
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "No CacheRoot, so no caching. Declining.");
+        return DECLINED;
+    }
+
+/* find certain cache controlling headers */
+    pragma_req = ap_table_get(r->headers_in, "Pragma");
+    cc_req = ap_table_get(r->headers_in, "Cache-Control");
+
+/* first things first - does the request allow us to return
+ * cached information at all? If not, just decline the request.
+ *
+ * Note that there is a big difference between not being allowed
+ * to cache a request (no-store) and not being allowed to return
+ * a cached request without revalidation (max-age=0).
+ *
+ * Caching is forbidden under the following circumstances:
+ *
+ * - RFC2616 14.9.2 Cache-Control: no-store
+ * we are not supposed to store this request at all. Behave as a tunnel.
+ *
+ */
+    if (ap_proxy_liststr(cc_req, "no-store", NULL)) {
+
+/* delete the previously cached file */
+        if (c->filename)
+            unlink(c->filename);
+        c->fp = NULL;
+        c->filename = NULL;
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "no-store forbids caching. Declining.");
+        return DECLINED;
+    }
+
+/* if the cache file exists, open it */
+    cachefp = NULL;
+    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Request for %s, pragma_req=%s, ims=%ld", url,
+                 (pragma_req == NULL) ? "(unset)" : pragma_req, c->ims);
+/* find out about whether the request can access the cache */
+    if (c->filename != NULL && r->method_number == M_GET &&
+        strlen(url) < 1024) {
+        cachefp = ap_proxy_open_cachefile(r, c->filename);
+    }
+
+
+    /*
+     * if a cache file exists, try reading body and headers from cache file
+     */
+    if (cachefp != NULL) {
+        i = rdcache(r, cachefp, c);
+        if (i == -1)
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
+                          "proxy: error reading cache file %s",
+                          c->filename);
+        else if (i == 0)
+            ap_log_rerror(APLOG_MARK, APLOG_ERR | APLOG_NOERRNO, r,
+                          "proxy: bad (short?) cache file: %s", c->filename);
+        if (i != 1) {
+            ap_pclosef(r->pool, ap_bfileno(cachefp, B_WR));
+            cachefp = NULL;
+        }
+        if (c->hdrs) {
+            cc_cresp = ap_table_get(c->hdrs, "Cache-Control");
+            pragma_cresp = ap_table_get(c->hdrs, "Pragma");
+            if ((agestr = ap_table_get(c->hdrs, "Age"))) {
+                age_c = atoi(agestr);
+            }
+        }
+    }
+
+    /* if a cache file does not exist, create empty header array */
+/* fixed?  in this case, we want to get the headers from the remote server
+   it will be handled later if we don't do this (I hope ;-)
+
+    if (cachefp == NULL)
+        c->hdrs = ap_make_table(r->pool, 20);
+*/
+    /* FIXME: Shouldn't we check the URL somewhere? */
+
+    /*
+     * Check Content-Negotiation - Vary
+     * 
+     * At this point we need to make sure that the object we found in the cache
+     * is the same object that would be delivered to the client, when the
+     * effects of content negotiation are taken into effect.
+     * 
+     * In plain english, we want to make sure that a language-negotiated
+     * document in one language is not given to a client asking for a
+     * language negotiated document in a different language by mistake.
+     * 
+     * RFC2616 13.6 and 14.44 describe the Vary mechanism.
+     */
+    if (c->hdrs && c->req_hdrs) {
+        char *vary = ap_pstrdup(r->pool, ap_table_get(c->hdrs, "Vary"));
+
+        while (vary && *vary) {
+            char *name = vary;
+            const char *h1, *h2;
+
+            /* isolate header name */
+            while (*vary && !ap_isspace(*vary) && (*vary != ','))
+                ++vary;
+            while (*vary && (ap_isspace(*vary) || (*vary == ','))) {
+                *vary = '\0';
+                ++vary;
+            }
+
+            /*
+             * is this header in the request and the header in the cached
+             * request identical? If not, we give up and do a straight get
+             */
+            h1 = ap_table_get(r->headers_in, name);
+            h2 = ap_table_get(c->req_hdrs, name);
+            if (h1 == h2) {
+                /* both headers NULL, so a match - do nothing */
+            }
+            else if (h1 && h2 && !strcmp(h1, h2)) {
+                /* both headers exist and are equal - do nothing */
+            }
+            else {
+
+                /* headers do not match, so Vary failed */
+                c->fp = cachefp;
+                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Vary header mismatch - object must be fetched from scratch. Declining.");
+                return DECLINED;
+            }
+        }
+    }
+
+
+    /*
+     * We now want to check if our cached data is still fresh. This depends
+     * on a few things, in this order:
+     * 
+     * - RFC2616 14.9.4 End to end reload, Cache-Control: no-cache no-cache in
+     * either the request or the cached response means that we must
+     * revalidate the request unconditionally, overriding any expiration
+     * mechanism. It's equivalent to max-age=0,must-revalidate.
+     * 
+     * - RFC2616 14.32 Pragma: no-cache This is treated the same as
+     * Cache-Control: no-cache.
+     * 
+     * - RFC2616 14.9.3 Cache-Control: max-stale, must-revalidate,
+     * proxy-revalidate if the max-stale request header exists, modify the
+     * stale calculations below so that an object can be at most <max-stale>
+     * seconds stale before we request a revalidation, _UNLESS_ a
+     * must-revalidate or proxy-revalidate cached response header exists to
+     * stop us doing this.
+     * 
+     * - RFC2616 14.9.3 Cache-Control: s-maxage the origin server specifies the
+     * maximum age an object can be before it is considered stale. This
+     * directive has the effect of proxy|must revalidate, which in turn means
+     * simple ignore any max-stale setting.
+     * 
+     * - RFC2616 14.9.4 Cache-Control: max-age this header can appear in both
+     * requests and responses. If both are specified, the smaller of the two
+     * takes priority.
+     * 
+     * - RFC2616 14.21 Expires: if this request header exists in the cached
+     * entity, and it's value is in the past, it has expired.
+     * 
+     */
+
+    /* calculate age of object */
+    age = ap_proxy_current_age(c, age_c);
+
+    /* extract s-maxage */
+    if (cc_cresp && ap_proxy_liststr(cc_cresp, "s-maxage", &val))
+        smaxage = atoi(val);
+    else
+        smaxage = -1;
+
+    /* extract max-age from request */
+    if (cc_req && ap_proxy_liststr(cc_req, "max-age", &val))
+        maxage_req = atoi(val);
+    else
+        maxage_req = -1;
+
+    /* extract max-age from response */
+    if (cc_cresp && ap_proxy_liststr(cc_cresp, "max-age", &val))
+        maxage_cresp = atoi(val);
+    else
+        maxage_cresp = -1;
+
+    /*
+     * if both maxage request and response, the smaller one takes priority
+     */
+    if (-1 == maxage_req)
+        maxage = maxage_cresp;
+    else if (-1 == maxage_cresp)
+        maxage = maxage_req;
+    else
+        maxage = MIN(maxage_req, maxage_cresp);
+
+    /* extract max-stale */
+    if (cc_req && ap_proxy_liststr(cc_req, "max-stale", &val))
+        maxstale = atoi(val);
+    else
+        maxstale = 0;
+
+    /* extract min-fresh */
+    if (cc_req && ap_proxy_liststr(cc_req, "min-fresh", &val))
+        minfresh = atoi(val);
+    else
+        minfresh = 0;
+
+    /* override maxstale if must-revalidate or proxy-revalidate */
+    if (maxstale && ((cc_cresp && ap_proxy_liststr(cc_cresp, "must-revalidate", NULL)) || (cc_cresp && ap_proxy_liststr(cc_cresp, "proxy-revalidate", NULL))))
+        maxstale = 0;
+
+    if (cachefp != NULL &&
+
+    /* handle no-cache */
+        !((cc_req && ap_proxy_liststr(cc_req, "no-cache", NULL)) ||
+          (pragma_req && ap_proxy_liststr(pragma_req, "no-cache", NULL)) ||
+          (cc_cresp && ap_proxy_liststr(cc_cresp, "no-cache", NULL)) ||
+      (pragma_cresp && ap_proxy_liststr(pragma_cresp, "no-cache", NULL))) &&
+
+    /* handle expiration */
+        ((-1 < smaxage && age < (smaxage - minfresh)) ||
+         (-1 < maxage && age < (maxage + maxstale - minfresh)) ||
+         (c->expire != BAD_DATE && age < (c->expire - c->date + maxstale - minfresh)))
+        ) {
+
+        /* it's fresh darlings... */
+
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Unexpired data available");
+
+        /* set age header on response */
+        ap_table_set(c->hdrs, "Age",
+                     ap_psprintf(r->pool, "%lu", (unsigned long)age));
+
+        /* add warning if maxstale overrode freshness calculation */
+        if (!((-1 < smaxage && age < smaxage) ||
+              (-1 < maxage && age < maxage) ||
+              (c->expire != BAD_DATE && (c->expire - c->date) > age))) {
+            /* make sure we don't stomp on a previous warning */
+            ap_table_merge(c->hdrs, "Warning", "110 Response is stale");
+        }
+
+        /* check conditionals (If-Modified-Since, etc) */
+        c->xcache = ap_pstrcat(r->pool, "HIT from ", ap_get_server_name(r), NULL);
+        return ap_proxy_cache_conditional(r, c, cachefp);
+
+
+    }
+
+    /*
+     * at this point we have determined our cached data needs revalidation
+     * but first - we check 1 thing:
+     * 
+     * RFC2616 14.9.4 - if "only-if-cached" specified, send a 504 Gateway
+     * Timeout - we're not allowed to revalidate the object
+     */
+    if (ap_proxy_liststr(cc_req, "only-if-cached", NULL)) {
+        if (cachefp)
+            ap_pclosef(r->pool, ap_bfileno(cachefp, B_WR));
+        return HTTP_GATEWAY_TIME_OUT;
+    }
+
+
+    /*
+     * If we already have cached data and a last-modified date, and it is not
+     * a head request, then add an If-Modified-Since.
+     * 
+     * If we also have an Etag, then the object must have come from an HTTP/1.1
+     * server. Add an If-None-Match as well.
+     * 
+     * See RFC2616 13.3.4
+     */
+
+    if (cachefp != NULL && !r->header_only) {
+
+        const char *etag = ap_table_get(c->hdrs, "Etag");
+
+        /* If-Modified-Since */
+        if (c->lmod != BAD_DATE) {
+            /*
+             * use the later of the one from the request and the
+             * last-modified date from the cache
+             */
+            if (c->ims == BAD_DATE || c->ims < c->lmod) {
+                const char *q;
+
+                if ((q = ap_table_get(c->hdrs, "Last-Modified")) != NULL)
+                    ap_table_set(r->headers_in, "If-Modified-Since", (char *)q);
+            }
+        }
+
+        /* If-None-Match */
+        if (etag) {
+            ap_table_set(r->headers_in, "If-None-Match", etag);
+        }
+
+    }
+
+
+    c->fp = cachefp;
+
+    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Local copy not present or expired. Declining.");
+
+    return DECLINED;
+}
+
+/*
+ * Having read the response from the client, decide what to do
+ * If the response is not cachable, then delete any previously cached
+ * response, and copy data from remote server to client.
+ * Functions:
+ *  parse dates
+ *  check for an uncachable response
+ *  calculate an expiry date, if one is not provided
+ *  if the remote file has not been modified, then return the document
+ *  from the cache, maybe updating the header line
+ *  otherwise, delete the old cached file and open a new temporary file
+ */
+int ap_proxy_cache_update(cache_req *c, table *resp_hdrs,
+                              const int is_HTTP1, int nocache)
+{
+#if defined(ULTRIX_BRAIN_DEATH) || defined(SINIX_D_RESOLVER_BUG)
+    extern char *mktemp(char *template);
+#endif
+    request_rec *r = c->req;
+    char *p;
+    const char *expire, *lmods, *dates, *clen;
+    time_t expc, date, lmod, now;
+    char buff[17 * 7 + 1];
+    void *sconf = r->server->module_config;
+    proxy_server_conf *conf =
+    (proxy_server_conf *)ap_get_module_config(sconf, &proxy_module);
+    const char *cc_resp;
+    table *req_hdrs;
+
+    cc_resp = ap_table_get(resp_hdrs, "Cache-Control");
+
+    c->tempfile = NULL;
+
+    /* we've received the response from the origin server */
+
+    /*
+     * read expiry date; if a bad date, then leave it so the client can read
+     * it
+     */
+    expire = ap_table_get(resp_hdrs, "Expires");
+    if (expire != NULL)
+        expc = ap_parseHTTPdate(expire);
+    else
+        expc = BAD_DATE;
+
+    /* read the last-modified date; if the date is bad, then delete it */
+    lmods = ap_table_get(resp_hdrs, "Last-Modified");
+    if (lmods != NULL) {
+        lmod = ap_parseHTTPdate(lmods);
+        if (lmod == BAD_DATE) {
+            /* kill last modified date */
+            lmods = NULL;
+        }
+    }
+    else
+        lmod = BAD_DATE;
+
+
+    /*
+     * what responses should we not cache?
+     * 
+     * At this point we decide based on the response headers whether it is
+     * appropriate _NOT_ to cache the data from the server. There are a whole
+     * lot of conditions that prevent us from caching this data. They are
+     * tested here one by one to be clear and unambiguous.
+     */
+
+    /*
+     * RFC2616 13.4 we are allowed to cache 200, 203, 206, 300, 301 or 410 We
+     * don't cache 206, because we don't (yet) cache partial responses. We
+     * include 304 Not Modified here too as this is the origin server telling
+     * us to serve the cached copy.
+     */
+    if ((r->status != HTTP_OK && r->status != HTTP_NON_AUTHORITATIVE && r->status != HTTP_MULTIPLE_CHOICES && r->status != HTTP_MOVED_PERMANENTLY && r->status != HTTP_NOT_MODIFIED) ||
+
+    /* if a broken Expires header is present, don't cache it */
+        (expire != NULL && expc == BAD_DATE) ||
+
+    /*
+     * if the server said 304 Not Modified but we have no cache file - pass
+     * this untouched to the user agent, it's not for us.
+     */
+        (r->status == HTTP_NOT_MODIFIED && (c == NULL || c->fp == NULL)) ||
+
+    /*
+     * 200 OK response from HTTP/1.0 and up without a Last-Modified header
+     */
+        (r->status == HTTP_OK && lmods == NULL && is_HTTP1) ||
+
+    /* HEAD requests */
+        r->header_only ||
+
+    /*
+     * RFC2616 14.9.2 Cache-Control: no-store response indicating do not
+     * cache, or stop now if you are trying to cache it
+     */
+        ap_proxy_liststr(cc_resp, "no-store", NULL) ||
+
+    /*
+     * RFC2616 14.9.1 Cache-Control: private this object is marked for this
+     * user's eyes only. Behave as a tunnel.
+     */
+        ap_proxy_liststr(cc_resp, "private", NULL) ||
+
+    /*
+     * RFC2616 14.8 Authorisation: if authorisation is included in the
+     * request, we don't cache, but we can cache if the following exceptions
+     * are true: 1) If Cache-Control: s-maxage is included 2) If
+     * Cache-Control: must-revalidate is included 3) If Cache-Control: public
+     * is included
+     */
+        (ap_table_get(r->headers_in, "Authorization") != NULL
+
+         && !(ap_proxy_liststr(cc_resp, "s-maxage", NULL) || ap_proxy_liststr(cc_resp, "must-revalidate", NULL) || ap_proxy_liststr(cc_resp, "public", NULL))
+         ) ||
+
+    /* or we've been asked not to cache it above */
+        nocache) {
+
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Response is not cacheable, unlinking %s", c->filename);
+
+        /* close the file */
+        if (c->fp != NULL) {
+            ap_pclosef(r->pool, ap_bfileno(c->fp, B_WR));
+            c->fp = NULL;
+        }
+
+        /* delete the previously cached file */
+        if (c->filename)
+            unlink(c->filename);
+        return DECLINED;        /* send data to client but not cache */
+    }
+
+
+    /*
+     * It's safe to cache the response.
+     * 
+     * We now want to update the cache file header information with the new
+     * date, last modified, expire and content length and write it away to
+     * our cache file. First, we determine these values from the response,
+     * using heuristics if appropriate.
+     * 
+     * In addition, we make HTTP/1.1 age calculations and write them away too.
+     */
+
+    /* Read the date. Generate one if one is not supplied */
+    dates = ap_table_get(resp_hdrs, "Date");
+    if (dates != NULL)
+        date = ap_parseHTTPdate(dates);
+    else
+        date = BAD_DATE;
+
+    now = time(NULL);
+
+    if (date == BAD_DATE) {     /* No, or bad date */
+/* no date header! */
+/* add one; N.B. use the time _now_ rather than when we were checking the cache
+ */
+        date = now;
+        dates = ap_gm_timestr_822(r->pool, now);
+        ap_table_set(resp_hdrs, "Date", dates);
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Added date header");
+    }
+
+/* set response_time for HTTP/1.1 age calculations */
+    c->resp_time = now;
+
+/* check last-modified date */
+    if (lmod != BAD_DATE && lmod > date)
+/* if its in the future, then replace by date */
+    {
+        lmod = date;
+        lmods = dates;
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Last modified is in the future, replacing with now");
+    }
+/* if the response did not contain the header, then use the cached version */
+    if (lmod == BAD_DATE && c->fp != NULL) {
+        lmod = c->lmod;
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Reusing cached last modified");
+    }
+
+/* we now need to calculate the expire data for the object. */
+    if (expire == NULL && c->fp != NULL) {      /* no expiry data sent in
+                                                 * response */
+        expire = ap_table_get(c->hdrs, "Expires");
+        if (expire != NULL)
+            expc = ap_parseHTTPdate(expire);
+    }
+/* so we now have the expiry date */
+/* if no expiry date then
+ *   if lastmod
+ *      expiry date = now + min((date - lastmod) * factor, maxexpire)
+ *   else
+ *      expire date = now + defaultexpire
+ */
+    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Expiry date is %ld", (long)expc);
+    if (expc == BAD_DATE) {
+        if (lmod != BAD_DATE) {
+            double x = (double)(date - lmod) * conf->cache.lmfactor;
+            double maxex = conf->cache.maxexpire;
+            if (x > maxex)
+                x = maxex;
+            expc = now + (int)x;
+        }
+        else
+            expc = now + conf->cache.defaultexpire;
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Expiry date calculated %ld", (long)expc);
+    }
+
+/* get the content-length header */
+    clen = ap_table_get(resp_hdrs, "Content-Length");
+    if (clen == NULL)
+        c->len = -1;
+    else
+        c->len = ap_strtol(clen, NULL, 10);
+
+/* we have all the header information we need - write it to the cache file */
+    c->version++;
+    ap_proxy_sec2hex(date, buff + 17 * (0));
+    buff[17 * (1) - 1] = ' ';
+    ap_proxy_sec2hex(lmod, buff + 17 * (1));
+    buff[17 * (2) - 1] = ' ';
+    ap_proxy_sec2hex(expc, buff + 17 * (2));
+    buff[17 * (3) - 1] = ' ';
+    ap_proxy_sec2hex(c->version, buff + 17 * (3));
+    buff[17 * (4) - 1] = ' ';
+    ap_proxy_sec2hex(c->req_time, buff + 17 * (4));
+    buff[17 * (5) - 1] = ' ';
+    ap_proxy_sec2hex(c->resp_time, buff + 17 * (5));
+    buff[17 * (6) - 1] = ' ';
+    ap_proxy_sec2hex(c->len, buff + 17 * (6));
+    buff[17 * (7) - 1] = '\n';
+    buff[17 * (7)] = '\0';
+
+/* Was the server response a 304 Not Modified?
+ *
+ * If it was, it means that we requested a revalidation, and that
+ * the result of that revalidation was that the object was fresh.
+ *
+ */
+
+/* if response from server 304 not modified */
+    if (r->status == HTTP_NOT_MODIFIED) {
+
+/* Have the headers changed?
+ *
+ * if not - we fulfil the request and return now.
+ */
+
+        if (c->hdrs) {
+            /* recall at this point that c->len is already set from resp_hdrs.
+               If Content-Length was NULL, then c->len is -1, otherwise it's
+               set to whatever the value was. */
+            if (c->len == 0 || c->len == -1) {
+                const char *c_clen_str;
+                off_t c_clen;
+                if ( (c_clen_str = ap_table_get(c->hdrs, "Content-Length")) &&
+                   ( (c_clen = ap_strtol(c_clen_str, NULL, 10)) > 0) ) {
+                        ap_table_set(resp_hdrs, "Content-Length", c_clen_str);
+                        c->len = c_clen;
+                        ap_proxy_sec2hex(c->len, buff + 17 * (6));
+                        buff[17 * (7) - 1] = '\n';
+                        buff[17 * (7)] = '\0';
+                }
+            }
+            if (!ap_proxy_table_replace(c->hdrs, resp_hdrs)) {
+                c->xcache = ap_pstrcat(r->pool, "HIT from ", ap_get_server_name(r), " (with revalidation)", NULL);
+                return ap_proxy_cache_conditional(r, c, c->fp);
+            }
+        }
+        else
+            c->hdrs = resp_hdrs;
+/* if we get here - the headers have changed. Go through the motions
+ * of creating a new temporary cache file below, we'll then serve
+ * the request like we would have in ap_proxy_cache_conditional()
+ * above, and at the same time we will also rewrite the contents
+ * to the new temporary file.
+ */
+    }
+
+/*
+ * Ok - lets prepare and open the cached file
+ *
+ * If a cached file (in c->fp) is already open, then we want to
+ * update that cached file. Copy the c->fp to c->origfp and open
+ * up a new one.
+ *
+ * If the cached file (in c->fp) is NULL, we must open a new cached
+ * file from scratch.
+ *
+ * The new cache file will be moved to it's final location in the
+ * directory tree later, overwriting the old cache file should it exist.
+ */
+
+/* if a cache file was already open */
+    if (c->fp != NULL) {
+        c->origfp = c->fp;
+    }
+
+    while (1) {
+/* create temporary filename */
+#ifndef TPF
+#define TMPFILESTR    "/tmpXXXXXX"
+        if (conf->cache.root == NULL) {
+            c = ap_proxy_cache_error(c);
+            break;
+        }
+        c->tempfile = ap_palloc(r->pool, strlen(conf->cache.root) + sizeof(TMPFILESTR));
+        strcpy(c->tempfile, conf->cache.root);
+        strcat(c->tempfile, TMPFILESTR);
+#undef TMPFILESTR
+        p = mktemp(c->tempfile);
+#else
+        if (conf->cache.root == NULL) {
+            c = ap_proxy_cache_error(c);
+            break;
+        }
+        c->tempfile = ap_palloc(r->pool, strlen(conf->cache.root) + 1 + L_tmpnam);
+        strcpy(c->tempfile, conf->cache.root);
+        strcat(c->tempfile, "/");
+        p = tmpnam(NULL);
+        strcat(c->tempfile, p);
+#endif
+        if (p == NULL) {
+            c = ap_proxy_cache_error(c);
+            break;
+        }
+
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Create temporary file %s", c->tempfile);
+
+/* create the new file */
+        c->fp = ap_proxy_create_cachefile(r, c->tempfile);
+        if (NULL == c->fp) {
+            c = ap_proxy_cache_error(c);
+            break;
+        }
+
+/* write away the cache header and the URL */
+        if (ap_bvputs(c->fp, buff, "X-URL: ", c->url, "\n", NULL) == -1) {
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
+                        "proxy: error writing cache file(%s)", c->tempfile);
+            c = ap_proxy_cache_error(c);
+            break;
+        }
+
+/* get original request headers */
+        if (c->req_hdrs)
+            req_hdrs = ap_copy_table(r->pool, c->req_hdrs);
+        else
+            req_hdrs = ap_copy_table(r->pool, r->headers_in);
+
+/* remove hop-by-hop headers */
+        ap_proxy_clear_connection(r->pool, req_hdrs);
+
+/* save original request headers */
+        if (c->req_hdrs)
+            ap_table_do(ap_proxy_send_hdr_line, c, c->req_hdrs, NULL);
+        else
+            ap_table_do(ap_proxy_send_hdr_line, c, r->headers_in, NULL);
+        if (ap_bputs(CRLF, c->fp) == -1) {
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, c->req,
+                          "proxy: error writing request headers terminating CRLF to %s", c->tempfile);
+            c = ap_proxy_cache_error(c);
+            break;
+        }
+        break;
+    }
+
+/* Was the server response a 304 Not Modified?
+ *
+ * If so, we have some work to do that we didn't do when we first
+ * checked above. We need to fulfil the request, and we need to
+ * copy the body from the old object to the new one.
+ */
+
+/* if response from server 304 not modified */
+    if (r->status == HTTP_NOT_MODIFIED) {
+
+/* fulfil the request */
+        c->xcache = ap_pstrcat(r->pool, "HIT from ", ap_get_server_name(r), " (with revalidation)", NULL);
+        return ap_proxy_cache_conditional(r, c, c->fp);
+
+    }
+    return DECLINED;
+}
+
+void ap_proxy_cache_tidy(cache_req *c)
+{
+    server_rec *s;
+    long int bc;
+
+    if (!c || !c->fp)
+        return;
+
+    s = c->req->server;
+
+/* don't care how much was sent, but rather how much was written to cache
+    ap_bgetopt(c->req->connection->client, BO_BYTECT, &bc);
+ */
+    bc = c->written;
+
+    if (c->len != -1) {
+/* file lengths don't match; don't cache it */
+        if (bc != c->len) {
+            ap_pclosef(c->req->pool, ap_bfileno(c->fp, B_WR));  /* no need to flush */
+            unlink(c->tempfile);
+            return;
+        }
+    }
+/* don't care if aborted, cache it if fully retrieved from host!
+    else if (c->req->connection->aborted) {
+        ap_pclosef(c->req->pool, c->fp->fd);    / no need to flush /
+        unlink(c->tempfile);
+        return;
+    }
+*/
+    else {
+/* update content-length of file */
+        char buff[17];
+        off_t curpos;
+
+        c->len = bc;
+        ap_bflush(c->fp);
+        ap_proxy_sec2hex(c->len, buff);
+        curpos = lseek(ap_bfileno(c->fp, B_WR), 17 * 6, SEEK_SET);
+        if (curpos == -1)
+            ap_log_error(APLOG_MARK, APLOG_ERR, s,
+                      "proxy: error seeking on cache file %s", c->tempfile);
+        else if (write(ap_bfileno(c->fp, B_WR), buff, sizeof(buff) - 1) == -1)
+            ap_log_error(APLOG_MARK, APLOG_ERR, s,
+                         "proxy: error updating cache file %s", c->tempfile);
+    }
+
+    if (ap_bflush(c->fp) == -1) {
+        ap_log_error(APLOG_MARK, APLOG_ERR, s,
+                     "proxy: error writing to cache file %s",
+                     c->tempfile);
+        ap_pclosef(c->req->pool, ap_bfileno(c->fp, B_WR));
+        unlink(c->tempfile);
+        return;
+    }
+
+    if (ap_pclosef(c->req->pool, ap_bfileno(c->fp, B_WR))== -1) {
+        ap_log_error(APLOG_MARK, APLOG_ERR, s,
+                     "proxy: error closing cache file %s", c->tempfile);
+        unlink(c->tempfile);
+        return;
+    }
+
+    if (unlink(c->filename) == -1 && errno != ENOENT) {
+        ap_log_error(APLOG_MARK, APLOG_ERR, s,
+                     "proxy: error deleting old cache file %s",
+                     c->filename);
+        (void)unlink(c->tempfile);
+    }
+    else {
+        char *p;
+        proxy_server_conf *conf =
+        (proxy_server_conf *)ap_get_module_config(s->module_config, &proxy_module);
+
+        for (p = c->filename + strlen(conf->cache.root) + 1;;) {
+            p = strchr(p, '/');
+            if (!p)
+                break;
+            *p = '\0';
+#if defined(WIN32) || defined(NETWARE)
+            if (mkdir(c->filename) < 0 && errno != EEXIST)
+#elif defined(__TANDEM)
+                if (mkdir(c->filename, S_IRWXU | S_IRWXG | S_IRWXO) < 0 && errno != EEXIST)
+#else
+            if (mkdir(c->filename, S_IREAD | S_IWRITE | S_IEXEC) < 0 && errno != EEXIST)
+#endif                          /* WIN32 */
+                ap_log_error(APLOG_MARK, APLOG_ERR, s,
+                             "proxy: error creating cache directory %s",
+                             c->filename);
+            *p = '/';
+            ++p;
+        }
+#if defined(OS2) || defined(WIN32) || defined(NETWARE) || defined(MPE)
+        /* Under OS/2 use rename. */
+        if (rename(c->tempfile, c->filename) == -1) {
+            ap_log_error(APLOG_MARK, APLOG_ERR, s,
+                         "proxy: error renaming cache file %s to %s",
+                         c->tempfile, c->filename);
+            (void)unlink(c->tempfile);
+        }
+#else
+
+        if (link(c->tempfile, c->filename) == -1)
+            ap_log_error(APLOG_MARK, APLOG_INFO, s,
+                         "proxy: error linking cache file %s to %s",
+                         c->tempfile, c->filename);
+        if (unlink(c->tempfile) == -1)
+            ap_log_error(APLOG_MARK, APLOG_ERR, s,
+                         "proxy: error deleting temp file %s", c->tempfile);
+#endif
+    }
+}
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/proxy/proxy_ftp.c apache_1.3.33/src/modules/proxy/proxy_ftp.c
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/proxy/proxy_ftp.c	Tue Feb 17 22:52:22 2004
+++ apache_1.3.33/src/modules/proxy/proxy_ftp.c	Mon Jul 18 15:22:19 2005
@@ -558,6 +558,12 @@
         return HTTP_BAD_REQUEST;
     urlptr += 3;
     destport = 21;
+#ifdef EAPI
+    ap_hook_use("ap::mod_proxy::ftp::handler::set_destport",
+		AP_HOOK_SIG2(int,ptr),
+		AP_HOOK_TOPMOST,
+		&destport, r);
+#endif /* EAPI */
     strp = strchr(urlptr, '/');
     if (strp == NULL) {
         desthost = ap_pstrdup(p, urlptr);
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/proxy/proxy_ftp.c.orig apache_1.3.33/src/modules/proxy/proxy_ftp.c.orig
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/proxy/proxy_ftp.c.orig	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/modules/proxy/proxy_ftp.c.orig	Tue Feb 17 22:52:22 2004
@@ -0,0 +1,1392 @@
+/* Copyright 1999-2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* FTP routines for Apache proxy */
+
+#include "mod_proxy.h"
+#include "http_main.h"
+#include "http_log.h"
+#include "http_core.h"
+
+#define AUTODETECT_PWD
+
+/*
+ * Decodes a '%' escaped string, and returns the number of characters
+ */
+static int decodeenc(char *x)
+{
+    int i, j, ch;
+
+    if (x[0] == '\0')
+        return 0;               /* special case for no characters */
+    for (i = 0, j = 0; x[i] != '\0'; i++, j++) {
+/* decode it if not already done */
+        ch = x[i];
+        if (ch == '%' && ap_isxdigit(x[i + 1]) && ap_isxdigit(x[i + 2])) {
+            ch = ap_proxy_hex2c(&x[i + 1]);
+            i += 2;
+        }
+        x[j] = ch;
+    }
+    x[j] = '\0';
+    return j;
+}
+
+/*
+ * checks an encoded ftp string for bad characters, namely, CR, LF or
+ * non-ascii character
+ */
+static int ftp_check_string(const char *x)
+{
+    int i, ch;
+
+    for (i = 0; x[i] != '\0'; i++) {
+        ch = x[i];
+        if (ch == '%' && ap_isxdigit(x[i + 1]) && ap_isxdigit(x[i + 2])) {
+            ch = ap_proxy_hex2c(&x[i + 1]);
+            i += 2;
+        }
+        if (ch == CR || ch == LF || (OS_ASC(ch) & 0x80))
+            return 0;
+    }
+    return 1;
+}
+
+/*
+ * Canonicalise ftp URLs.
+ */
+int ap_proxy_ftp_canon(request_rec *r, char *url)
+{
+    char *user, *password, *host, *path, *parms, *strp, sport[7];
+    pool *p = r->pool;
+    const char *err;
+    int port;
+
+    port = DEFAULT_FTP_PORT;
+    err = ap_proxy_canon_netloc(p, &url, &user, &password, &host, &port);
+    if (err)
+        return HTTP_BAD_REQUEST;
+    if (user != NULL && !ftp_check_string(user))
+        return HTTP_BAD_REQUEST;
+    if (password != NULL && !ftp_check_string(password))
+        return HTTP_BAD_REQUEST;
+
+/* now parse path/parameters args, according to rfc1738 */
+/* N.B. if this isn't a true proxy request, then the URL path
+ * (but not query args) has already been decoded.
+ * This gives rise to the problem of a ; being decoded into the
+ * path.
+ */
+    strp = strchr(url, ';');
+    if (strp != NULL) {
+        *(strp++) = '\0';
+        parms = ap_proxy_canonenc(p, strp, strlen(strp), enc_parm,
+                                  r->proxyreq);
+        if (parms == NULL)
+            return HTTP_BAD_REQUEST;
+    }
+    else
+        parms = "";
+
+    path = ap_proxy_canonenc(p, url, strlen(url), enc_path, r->proxyreq);
+    if (path == NULL)
+        return HTTP_BAD_REQUEST;
+    if (!ftp_check_string(path))
+        return HTTP_BAD_REQUEST;
+
+    if (r->proxyreq == NOT_PROXY && r->args != NULL) {
+        if (strp != NULL) {
+            strp = ap_proxy_canonenc(p, r->args, strlen(r->args), enc_parm, STD_PROXY);
+            if (strp == NULL)
+                return HTTP_BAD_REQUEST;
+            parms = ap_pstrcat(p, parms, "?", strp, NULL);
+        }
+        else {
+            strp = ap_proxy_canonenc(p, r->args, strlen(r->args), enc_fpath, STD_PROXY);
+            if (strp == NULL)
+                return HTTP_BAD_REQUEST;
+            path = ap_pstrcat(p, path, "?", strp, NULL);
+        }
+        r->args = NULL;
+    }
+
+/* now, rebuild URL */
+
+    if (port != DEFAULT_FTP_PORT)
+        ap_snprintf(sport, sizeof(sport), ":%d", port);
+    else
+        sport[0] = '\0';
+
+    r->filename = ap_pstrcat(p, "proxy:ftp://", (user != NULL) ? user : "",
+                             (password != NULL) ? ":" : "",
+                             (password != NULL) ? password : "",
+                          (user != NULL) ? "@" : "", host, sport, "/", path,
+                             (parms[0] != '\0') ? ";" : "", parms, NULL);
+
+    return OK;
+}
+
+/*
+ * Returns the ftp status code;
+ *  or -1 on I/O error, 0 on data error
+ */
+static int ftp_getrc(BUFF *ctrl)
+{
+    int len, status;
+    char linebuff[100], buff[5];
+
+    len = ap_bgets(linebuff, sizeof linebuff, ctrl);
+    if (len == -1)
+        return -1;
+/* check format */
+    if (len < 5 || !ap_isdigit(linebuff[0]) || !ap_isdigit(linebuff[1]) ||
+     !ap_isdigit(linebuff[2]) || (linebuff[3] != ' ' && linebuff[3] != '-'))
+        status = 0;
+    else
+        status = 100 * linebuff[0] + 10 * linebuff[1] + linebuff[2] - 111 * '0';
+
+    if (linebuff[len - 1] != '\n') {
+        (void)ap_bskiplf(ctrl);
+    }
+
+/* skip continuation lines */
+    if (linebuff[3] == '-') {
+        memcpy(buff, linebuff, 3);
+        buff[3] = ' ';
+        do {
+            len = ap_bgets(linebuff, sizeof linebuff, ctrl);
+            if (len == -1)
+                return -1;
+            if (linebuff[len - 1] != '\n') {
+                (void)ap_bskiplf(ctrl);
+            }
+        } while (memcmp(linebuff, buff, 4) != 0);
+    }
+
+    return status;
+}
+
+/*
+ * Like ftp_getrc but returns both the ftp status code and
+ * remembers the response message in the supplied buffer
+ */
+static int ftp_getrc_msg(BUFF *ctrl, char *msgbuf, int msglen)
+{
+    int len, status;
+    char linebuff[100], buff[5];
+    char *mb = msgbuf, *me = &msgbuf[msglen];
+
+    len = ap_bgets(linebuff, sizeof linebuff, ctrl);
+    if (len == -1)
+        return -1;
+    if (len < 5 || !ap_isdigit(linebuff[0]) || !ap_isdigit(linebuff[1]) ||
+     !ap_isdigit(linebuff[2]) || (linebuff[3] != ' ' && linebuff[3] != '-'))
+        status = 0;
+    else
+        status = 100 * linebuff[0] + 10 * linebuff[1] + linebuff[2] - 111 * '0';
+
+    mb = ap_cpystrn(mb, linebuff + 4, me - mb);
+
+    if (linebuff[len - 1] != '\n')
+        (void)ap_bskiplf(ctrl);
+
+    if (linebuff[3] == '-') {
+        memcpy(buff, linebuff, 3);
+        buff[3] = ' ';
+        do {
+            len = ap_bgets(linebuff, sizeof linebuff, ctrl);
+            if (len == -1)
+                return -1;
+            if (linebuff[len - 1] != '\n') {
+                (void)ap_bskiplf(ctrl);
+            }
+            mb = ap_cpystrn(mb, linebuff + 4, me - mb);
+        } while (memcmp(linebuff, buff, 4) != 0);
+    }
+    return status;
+}
+
+static long int send_dir(BUFF *data, request_rec *r, cache_req *c, char *cwd)
+{
+    char *buf, *buf2;
+    size_t buf_size;
+    char *filename;
+    int searchidx = 0;
+    char *searchptr = NULL;
+    int firstfile = 1;
+    unsigned long total_bytes_sent = 0;
+    register int n;
+    conn_rec *con = r->connection;
+    pool *p = r->pool;
+    char *dir, *path, *reldir, *site, *type = NULL;
+    char *basedir = "";         /* By default, path is relative to the $HOME
+                                 * dir */
+
+    /* create default sized buffers for the stuff below */
+    buf_size = IOBUFSIZE;
+    buf = ap_palloc(r->pool, buf_size);
+    buf2 = ap_palloc(r->pool, buf_size);
+
+    /* Save "scheme://site" prefix without password */
+    site = ap_unparse_uri_components(p, &r->parsed_uri, UNP_OMITPASSWORD | UNP_OMITPATHINFO);
+    /* ... and path without query args */
+    path = ap_unparse_uri_components(p, &r->parsed_uri, UNP_OMITSITEPART | UNP_OMITQUERY);
+
+    /* If path began with /%2f, change the basedir */
+    if (strncasecmp(path, "/%2f", 4) == 0) {
+        basedir = "/%2f";
+    }
+
+    /* Strip off a type qualifier. It is ignored for dir listings */
+    if ((type = strstr(path, ";type=")) != NULL)
+        *type++ = '\0';
+
+    (void)decodeenc(path);
+
+    while (path[1] == '/')      /* collapse multiple leading slashes to one */
+        ++path;
+
+    /* Copy path, strip (all except the last) trailing slashes */
+    /* (the trailing slash is needed for the dir component loop below) */
+    path = dir = ap_pstrcat(r->pool, path, "/", NULL);
+    for (n = strlen(path); n > 1 && path[n - 1] == '/' && path[n - 2] == '/'; --n)
+        path[n - 1] = '\0';
+
+    /* print "ftp://host/" */
+    n = ap_snprintf(buf, buf_size, DOCTYPE_HTML_3_2
+                    "<html><head><title>%s%s%s</title>\n"
+                    "<base href=\"%s%s%s\"></head>\n"
+                    "<body><h2>Directory of "
+                    "<a href=\"/\">%s</a>/",
+                    site, basedir, ap_escape_html(p, path),
+                    site, basedir, ap_escape_uri(p, path),
+                    site);
+    total_bytes_sent += ap_proxy_bputs2(buf, con->client, c);
+
+    /* Add a link to the root directory (if %2f hack was used) */
+    if (basedir[0] != '\0') {
+        total_bytes_sent += ap_proxy_bputs2("<a href=\"/%2f/\">%2f</a>/", con->client, c);
+    }
+
+    for (dir = path + 1; (dir = strchr(dir, '/')) != NULL;) {
+        *dir = '\0';
+        if ((reldir = strrchr(path + 1, '/')) == NULL) {
+            reldir = path + 1;
+        }
+        else
+            ++reldir;
+        /* print "path/" component */
+        ap_snprintf(buf, buf_size, "<a href=\"%s%s/\">%s</a>/",
+                    basedir,
+                    ap_escape_uri(p, path),
+                    ap_escape_html(p, reldir));
+        total_bytes_sent += ap_proxy_bputs2(buf, con->client, c);
+        *dir = '/';
+        while (*dir == '/')
+            ++dir;
+    }
+
+    /* If the caller has determined the current directory, and it differs */
+    /* from what the client requested, then show the real name */
+    if (cwd == NULL || strncmp(cwd, path, strlen(cwd)) == 0) {
+        ap_snprintf(buf, buf_size, "</h2>\n<hr /><pre>");
+    }
+    else {
+        ap_snprintf(buf, buf_size, "</h2>\n(%s)\n<hr /><pre>",
+                    ap_escape_html(p, cwd));
+    }
+    total_bytes_sent += ap_proxy_bputs2(buf, con->client, c);
+
+    while (!con->aborted) {
+        n = ap_bgets(buf, buf_size, data);
+        if (n == -1) {          /* input error */
+            if (c != NULL) {
+                ap_log_rerror(APLOG_MARK, APLOG_ERR, c->req,
+                              "proxy: error reading from %s", c->url);
+                c = ap_proxy_cache_error(c);
+            }
+            break;
+        }
+        if (n == 0)
+            break;              /* EOF */
+
+        if (buf[n - 1] == '\n') /* strip trailing '\n' */
+            buf[--n] = '\0';
+        if (buf[n - 1] == '\r') /* strip trailing '\r' if present */
+            buf[--n] = '\0';
+
+        /* Handle unix-style symbolic link */
+        if (buf[0] == 'l' && (filename = strstr(buf, " -> ")) != NULL) {
+            char *link_ptr = filename;
+
+            do {
+                filename--;
+            } while (filename[0] != ' ' && filename > buf);
+            if (filename != buf)
+                *(filename++) = '\0';
+            *(link_ptr++) = '\0';
+            ap_snprintf(buf2, buf_size, "%s <a href=\"%s\">%s %s</a>\n",
+                        ap_escape_html(p, buf),
+                        ap_escape_uri(p, filename),
+                        ap_escape_html(p, filename),
+                        ap_escape_html(p, link_ptr));
+            ap_cpystrn(buf, buf2, buf_size);
+            n = strlen(buf);
+        }
+        /* Handle unix style or DOS style directory  */
+        else if (buf[0] == 'd' || buf[0] == '-' || buf[0] == 'l' || ap_isdigit(buf[0])) {
+            if (ap_isdigit(buf[0])) {   /* handle DOS dir */
+                searchptr = strchr(buf, '<');
+                if (searchptr != NULL)
+                    *searchptr = '[';
+                searchptr = strchr(buf, '>');
+                if (searchptr != NULL)
+                    *searchptr = ']';
+            }
+
+            filename = strrchr(buf, ' ');
+            *(filename++) = 0;
+
+            /* handle filenames with spaces in 'em */
+            if (!strcmp(filename, ".") || !strcmp(filename, "..") || firstfile) {
+                firstfile = 0;
+                searchidx = filename - buf;
+            }
+            else if (searchidx != 0 && buf[searchidx] != 0) {
+                *(--filename) = ' ';
+                buf[searchidx - 1] = 0;
+                filename = &buf[searchidx];
+            }
+
+            /* Special handling for '.' and '..': append slash to link */
+            if (!strcmp(filename, ".") || !strcmp(filename, "..") || buf[0] == 'd') {
+                ap_snprintf(buf2, buf_size, "%s <a href=\"%s/\">%s</a>\n",
+                         ap_escape_html(p, buf), ap_escape_uri(p, filename),
+                            ap_escape_html(p, filename));
+            }
+            else {
+                ap_snprintf(buf2, buf_size, "%s <a href=\"%s\">%s</a>\n",
+                            ap_escape_html(p, buf),
+                            ap_escape_uri(p, filename),
+                            ap_escape_html(p, filename));
+            }
+            ap_cpystrn(buf, buf2, buf_size);
+            n = strlen(buf);
+        }
+        /* else??? What about other OS's output formats? */
+        else {
+            strcat(buf, "\n");  /* re-append the newline char */
+            ap_cpystrn(buf, ap_escape_html(p, buf), buf_size);
+        }
+
+        total_bytes_sent += ap_proxy_bputs2(buf, con->client, c);
+
+        ap_reset_timeout(r);    /* reset timeout after successfule write */
+    }
+
+    total_bytes_sent += ap_proxy_bputs2("</pre><hr />\n", con->client, c);
+    total_bytes_sent += ap_proxy_bputs2(ap_psignature("", r), con->client, c);
+    total_bytes_sent += ap_proxy_bputs2("</body></html>\n", con->client, c);
+
+    ap_bclose(data);
+
+    ap_bflush(con->client);
+
+    return total_bytes_sent;
+}
+
+/* Common routine for failed authorization (i.e., missing or wrong password)
+ * to an ftp service. This causes most browsers to retry the request
+ * with username and password (which was presumably queried from the user)
+ * supplied in the Authorization: header.
+ * Note that we "invent" a realm name which consists of the
+ * ftp://user@host part of the reqest (sans password -if supplied but invalid-)
+ */
+static int ftp_unauthorized(request_rec *r, int log_it)
+{
+    r->proxyreq = NOT_PROXY;
+    /*
+     * Log failed requests if they supplied a password (log username/password
+     * guessing attempts)
+     */
+    if (log_it)
+        ap_log_rerror(APLOG_MARK, APLOG_INFO | APLOG_NOERRNO, r,
+                      "proxy: missing or failed auth to %s",
+                      ap_unparse_uri_components(r->pool,
+                                         &r->parsed_uri, UNP_OMITPATHINFO));
+
+    ap_table_setn(r->err_headers_out, "WWW-Authenticate",
+                  ap_pstrcat(r->pool, "Basic realm=\"",
+                          ap_unparse_uri_components(r->pool, &r->parsed_uri,
+                                       UNP_OMITPASSWORD | UNP_OMITPATHINFO),
+                             "\"", NULL));
+
+    return HTTP_UNAUTHORIZED;
+}
+
+/* Set ftp server to TYPE {A,I,E} before transfer of a directory or file */
+static int ftp_set_TYPE(request_rec *r, BUFF *ctrl, char xfer_type)
+{
+    static char old_type[2] = {'A', '\0'};      /* After logon, mode is ASCII */
+    int ret = HTTP_OK;
+    int rc;
+
+    if (xfer_type == old_type[0])
+        return ret;
+
+    /* set desired type */
+    old_type[0] = xfer_type;
+    ap_bvputs(ctrl, "TYPE ", old_type, CRLF, NULL);
+    ap_bflush(ctrl);
+    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: TYPE %s", old_type);
+
+/* responses: 200, 421, 500, 501, 504, 530 */
+    /* 200 Command okay. */
+    /* 421 Service not available, closing control connection. */
+    /* 500 Syntax error, command unrecognized. */
+    /* 501 Syntax error in parameters or arguments. */
+    /* 504 Command not implemented for that parameter. */
+    /* 530 Not logged in. */
+    rc = ftp_getrc(ctrl);
+    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", rc);
+    if (rc == -1 || rc == 421) {
+        ap_kill_timeout(r);
+        ret = ap_proxyerror(r, HTTP_BAD_GATEWAY,
+                            "Error reading from remote server");
+    }
+    else if (rc != 200 && rc != 504) {
+        ap_kill_timeout(r);
+        ret = ap_proxyerror(r, HTTP_BAD_GATEWAY,
+                            "Unable to set transfer type");
+    }
+/* Allow not implemented */
+    else if (rc == 504)
+         /* ignore it silently */ ;
+
+    return ret;
+}
+
+/* Common cleanup routine: close open BUFFers or sockets, and return an error */
+static int ftp_cleanup_and_return(request_rec *r, BUFF *ctrl, BUFF *data, int csock, int dsock, int rc)
+{
+    if (ctrl != NULL)
+        ap_bclose(ctrl);
+    else if (csock != -1)
+        ap_pclosesocket(r->pool, csock);
+
+    if (data != NULL)
+        ap_bclose(data);
+    else if (dsock != -1)
+        ap_pclosesocket(r->pool, dsock);
+
+    ap_kill_timeout(r);
+
+    return rc;
+}
+
+/*
+ * Handles direct access of ftp:// URLs
+ * Original (Non-PASV) version from
+ * Troy Morrison <spiffnet@zoom.com>
+ * PASV added by Chuck
+ */
+int ap_proxy_ftp_handler(request_rec *r, cache_req *c, char *url)
+{
+    char *desthost, *path, *strp, *parms;
+    char *strp2;
+    char *cwd = NULL;
+    char *user = NULL;
+/*    char *account = NULL; how to supply an account in a URL? */
+    const char *password = NULL;
+    const char *err;
+    int destport, i, j, len, rc, nocache = 0;
+    int csd = 0, sock = -1, dsock = -1;
+    struct sockaddr_in server;
+    struct hostent server_hp;
+    struct in_addr destaddr;
+    table *resp_hdrs;
+    BUFF *ctrl = NULL;
+    BUFF *data = NULL;
+    pool *p = r->pool;
+    char *destportstr = NULL;
+    const char *urlptr = NULL;
+    int one = 1;
+    NET_SIZE_T clen;
+    char xfer_type = 'A';       /* after ftp login, the default is ASCII */
+    int get_dirlisting = 0;
+
+    void *sconf = r->server->module_config;
+    proxy_server_conf *conf =
+    (proxy_server_conf *)ap_get_module_config(sconf, &proxy_module);
+    struct noproxy_entry *npent = (struct noproxy_entry *) conf->noproxies->elts;
+    struct nocache_entry *ncent = (struct nocache_entry *) conf->nocaches->elts;
+
+/* stuff for PASV mode */
+    unsigned int presult, h0, h1, h2, h3, p0, p1;
+    unsigned int paddr;
+    unsigned short pport;
+    struct sockaddr_in data_addr;
+    int pasvmode = 0;
+    char pasv[64];
+    char *pstr;
+
+/* stuff for responses */
+    char resp[MAX_STRING_LEN];
+    char *size = NULL;
+
+/* we only support GET and HEAD */
+
+    if (r->method_number != M_GET)
+        return HTTP_NOT_IMPLEMENTED;
+
+/* We break the URL into host, port, path-search */
+
+    urlptr = strstr(url, "://");
+    if (urlptr == NULL)
+        return HTTP_BAD_REQUEST;
+    urlptr += 3;
+    destport = 21;
+    strp = strchr(urlptr, '/');
+    if (strp == NULL) {
+        desthost = ap_pstrdup(p, urlptr);
+        urlptr = "/";
+    }
+    else {
+        char *q = ap_palloc(p, strp - urlptr + 1);
+        memcpy(q, urlptr, strp - urlptr);
+        q[strp - urlptr] = '\0';
+        urlptr = strp;
+        desthost = q;
+    }
+
+    strp2 = strchr(desthost, ':');
+    if (strp2 != NULL) {
+        *(strp2++) = '\0';
+        if (ap_isdigit(*strp2)) {
+            destport = atoi(strp2);
+            destportstr = strp2;
+        }
+    }
+    path = strchr(urlptr, '/')+1;
+    
+    /*
+     * The "Authorization:" header must be checked first. We allow the user
+     * to "override" the URL-coded user [ & password ] in the Browsers'
+     * User&Password Dialog. NOTE that this is only marginally more secure
+     * than having the password travel in plain as part of the URL, because
+     * Basic Auth simply uuencodes the plain text password. But chances are
+     * still smaller that the URL is logged regularly.
+     */
+    if ((password = ap_table_get(r->headers_in, "Authorization")) != NULL
+        && strcasecmp(ap_getword(r->pool, &password, ' '), "Basic") == 0
+        && (password = ap_pbase64decode(r->pool, password))[0] != ':') {
+        /*
+         * Note that this allocation has to be made from r->connection->pool
+         * because it has the lifetime of the connection.  The other
+         * allocations are temporary and can be tossed away any time.
+         */
+        user = ap_getword_nulls(r->connection->pool, &password, ':');
+        r->connection->ap_auth_type = "Basic";
+        r->connection->user = r->parsed_uri.user = user;
+        nocache = 1;            /* This resource only accessible with
+                                 * username/password */
+    }
+    else if ((user = r->parsed_uri.user) != NULL) {
+        user = ap_pstrdup(p, user);
+        decodeenc(user);
+        if ((password = r->parsed_uri.password) != NULL) {
+            char *tmp = ap_pstrdup(p, password);
+            decodeenc(tmp);
+            password = tmp;
+        }
+        nocache = 1;            /* This resource only accessible with
+                                 * username/password */
+    }
+    else {
+        user = "anonymous";
+        password = "apache_proxy@";
+    }
+
+    /* check if ProxyBlock directive on this host */
+    destaddr.s_addr = ap_inet_addr(desthost);
+    for (i = 0; i < conf->noproxies->nelts; i++) {
+        if (destaddr.s_addr == npent[i].addr.s_addr ||
+            (npent[i].name != NULL &&
+          (npent[i].name[0] == '*' || strstr(desthost, npent[i].name) != NULL)))
+            return ap_proxyerror(r, HTTP_FORBIDDEN,
+                                 "Connect to remote machine blocked");
+    }
+
+    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: connect to %s:%d", desthost, destport);
+
+    parms = strchr(url, ';');
+    if (parms != NULL)
+        *(parms++) = '\0';
+
+    memset(&server, 0, sizeof(struct sockaddr_in));
+    server.sin_family = AF_INET;
+    server.sin_port = htons((unsigned short)destport);
+    err = ap_proxy_host2addr(desthost, &server_hp);
+    if (err != NULL)
+        return ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR, err);
+
+    sock = ap_psocket_ex(p, PF_INET, SOCK_STREAM, IPPROTO_TCP, 1);
+    if (sock == -1) {
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
+                      "proxy: error creating socket");
+        return HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+#if !defined(TPF) && !defined(BEOS)
+    if (conf->recv_buffer_size > 0
+        && setsockopt(sock, SOL_SOCKET, SO_RCVBUF,
+                      (const char *)&conf->recv_buffer_size, sizeof(int))
+        == -1) {
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
+                      "setsockopt(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
+    }
+#endif
+
+    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void *)&one,
+                   sizeof(one)) == -1) {
+#ifndef _OSD_POSIX              /* BS2000 has this option "always on" */
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
+         "proxy: error setting reuseaddr option: setsockopt(SO_REUSEADDR)");
+        ap_pclosesocket(p, sock);
+        return HTTP_INTERNAL_SERVER_ERROR;
+#endif                          /* _OSD_POSIX */
+    }
+
+#ifdef SINIX_D_RESOLVER_BUG
+    {
+        struct in_addr *ip_addr = (struct in_addr *)*server_hp.h_addr_list;
+
+        for (; ip_addr->s_addr != 0; ++ip_addr) {
+            memcpy(&server.sin_addr, ip_addr, sizeof(struct in_addr));
+            i = ap_proxy_doconnect(sock, &server, r);
+            if (i == 0)
+                break;
+        }
+    }
+#else
+    j = 0;
+    while (server_hp.h_addr_list[j] != NULL) {
+        memcpy(&server.sin_addr, server_hp.h_addr_list[j],
+               sizeof(struct in_addr));
+        i = ap_proxy_doconnect(sock, &server, r);
+        if (i == 0)
+            break;
+        j++;
+    }
+#endif
+    if (i == -1) {
+        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                      ap_proxyerror(r, HTTP_BAD_GATEWAY, ap_pstrcat(r->pool,
+                                    "Could not connect to remote machine: ",
+                                                   strerror(errno), NULL)));
+    }
+
+    /* record request_time for HTTP/1.1 age calculation */
+    c->req_time = time(NULL);
+
+    ctrl = ap_bcreate(p, B_RDWR | B_SOCKET);
+    ap_bpushfd(ctrl, sock, sock);
+/* shouldn't we implement telnet control options here? */
+
+#ifdef CHARSET_EBCDIC
+    ap_bsetflag(ctrl, B_ASCII2EBCDIC | B_EBCDIC2ASCII, 1);
+#endif                          /* CHARSET_EBCDIC */
+
+    /* possible results: */
+    /* 120 Service ready in nnn minutes. */
+    /* 220 Service ready for new user. */
+    /* 421 Service not available, closing control connection. */
+    ap_hard_timeout("proxy ftp", r);
+    i = ftp_getrc_msg(ctrl, resp, sizeof resp);
+    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", i);
+    if (i == -1 || i == 421) {
+        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                      ap_proxyerror(r, HTTP_BAD_GATEWAY,
+                                       "Error reading from remote server"));
+    }
+#if 0
+    if (i == 120) {
+        /*
+         * RFC2068 states: 14.38 Retry-After
+         * 
+         * The Retry-After response-header field can be used with a 503 (Service
+         * Unavailable) response to indicate how long the service is expected
+         * to be unavailable to the requesting client. The value of this
+         * field can be either an HTTP-date or an integer number of seconds
+         * (in decimal) after the time of the response. Retry-After  =
+         * "Retry-After" ":" ( HTTP-date | delta-seconds )
+         */
+/**INDENT** Error@756: Unbalanced parens */
+        ap_set_header("Retry-After", ap_psprintf(p, "%u", 60 * wait_mins);
+        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                          ap_proxyerror(r, HTTP_SERVICE_UNAVAILABLE, resp));
+    }
+#endif
+    if (i != 220) {
+        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                  ap_proxyerror(r, HTTP_BAD_GATEWAY, resp));
+    }
+
+    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: connected.");
+
+    ap_bvputs(ctrl, "USER ", user, CRLF, NULL);
+    ap_bflush(ctrl);            /* capture any errors */
+    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: USER %s", user);
+
+    /* possible results; 230, 331, 332, 421, 500, 501, 530 */
+    /* states: 1 - error, 2 - success; 3 - send password, 4,5 fail */
+    /* 230 User logged in, proceed. */
+    /* 331 User name okay, need password. */
+    /* 332 Need account for login. */
+    /* 421 Service not available, closing control connection. */
+    /* 500 Syntax error, command unrecognized. */
+    /* (This may include errors such as command line too long.) */
+    /* 501 Syntax error in parameters or arguments. */
+    /* 530 Not logged in. */
+    i = ftp_getrc(ctrl);
+    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", i);
+    if (i == -1 || i == 421) {
+        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                      ap_proxyerror(r, HTTP_BAD_GATEWAY,
+                                       "Error reading from remote server"));
+    }
+    if (i == 530) {
+        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                      ftp_unauthorized(r, 1));
+    }
+    if (i != 230 && i != 331) {
+        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                      HTTP_BAD_GATEWAY);
+    }
+
+    if (i == 331) {             /* send password */
+        if (password == NULL) {
+            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                          ftp_unauthorized(r, 0));
+        }
+        ap_bvputs(ctrl, "PASS ", password, CRLF, NULL);
+        ap_bflush(ctrl);
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: PASS %s", password);
+        /* possible results 202, 230, 332, 421, 500, 501, 503, 530 */
+        /* 230 User logged in, proceed. */
+        /* 332 Need account for login. */
+        /* 421 Service not available, closing control connection. */
+        /* 500 Syntax error, command unrecognized. */
+        /* 501 Syntax error in parameters or arguments. */
+        /* 503 Bad sequence of commands. */
+        /* 530 Not logged in. */
+        i = ftp_getrc(ctrl);
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", i);
+        if (i == -1 || i == 421) {
+            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                          ap_proxyerror(r, HTTP_BAD_GATEWAY,
+                                       "Error reading from remote server"));
+        }
+        if (i == 332) {
+            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                          ap_proxyerror(r, HTTP_UNAUTHORIZED,
+                                                 "Need account for login"));
+        }
+        /* @@@ questionable -- we might as well return a 403 Forbidden here */
+        if (i == 530)           /* log it: passwd guessing attempt? */
+            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                          ftp_unauthorized(r, 1));
+        if (i != 230 && i != 202)
+            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                          HTTP_BAD_GATEWAY);
+    }
+
+    /*
+     * Special handling for leading "%2f": this enforces a "cwd /" out of the
+     * $HOME directory which was the starting point after login
+     */
+    if (strncasecmp(path, "%2f", 3) == 0) {
+        path += 3;
+        while (*path == '/')    /* skip leading '/' (after root %2f) */
+            ++path;
+        ap_bputs("CWD /" CRLF, ctrl);
+        ap_bflush(ctrl);
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: CWD /");
+
+        /* possible results: 250, 421, 500, 501, 502, 530, 550 */
+        /* 250 Requested file action okay, completed. */
+        /* 421 Service not available, closing control connection. */
+        /* 500 Syntax error, command unrecognized. */
+        /* 501 Syntax error in parameters or arguments. */
+        /* 502 Command not implemented. */
+        /* 530 Not logged in. */
+        /* 550 Requested action not taken. */
+        i = ftp_getrc(ctrl);
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", i);
+        if (i == -1 || i == 421)
+            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                          ap_proxyerror(r, HTTP_BAD_GATEWAY,
+                                       "Error reading from remote server"));
+        else if (i == 550)
+            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                          HTTP_NOT_FOUND);
+        else if (i != 250)
+            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                          HTTP_BAD_GATEWAY);
+    }
+
+/* set the directory (walk directory component by component):
+ * this is what we must do if we don't know the OS type of the remote
+ * machine
+ */
+    for (; (strp = strchr(path, '/')) != NULL; path = strp + 1) {
+        char *slash = strp;
+
+        *slash = '\0';
+
+        /* Skip multiple '/' (or trailing '/') to avoid 500 errors */
+        while (strp[1] == '/')
+            ++strp;
+        if (strp[1] == '\0')
+            break;
+
+        len = decodeenc(path);  /* Note! This decodes a %2f -> "/" */
+        if (strchr(path, '/'))  /* were there any '/' characters? */
+            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                          ap_proxyerror(r, HTTP_BAD_REQUEST,
+                       "Use of %2F is only allowed at the base directory"));
+
+        ap_bvputs(ctrl, "CWD ", path, CRLF, NULL);
+        ap_bflush(ctrl);
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: CWD %s", path);
+        *slash = '/';
+
+/* responses: 250, 421, 500, 501, 502, 530, 550 */
+        /* 250 Requested file action okay, completed. */
+        /* 421 Service not available, closing control connection. */
+        /* 500 Syntax error, command unrecognized. */
+        /* 501 Syntax error in parameters or arguments. */
+        /* 502 Command not implemented. */
+        /* 530 Not logged in. */
+        /* 550 Requested action not taken. */
+        i = ftp_getrc(ctrl);
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", i);
+        if (i == -1 || i == 421)
+            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                          ap_proxyerror(r, HTTP_BAD_GATEWAY,
+                                       "Error reading from remote server"));
+        if (i == 550)
+            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                          HTTP_NOT_FOUND);
+        if (i == 500 || i == 501)
+            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                          ap_proxyerror(r, HTTP_BAD_REQUEST,
+                      "Syntax error in filename (reported by ftp server)"));
+        if (i != 250)
+            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                          HTTP_BAD_GATEWAY);
+    }
+
+    if (parms != NULL && strncmp(parms, "type=", 5) == 0
+        && ap_isalpha(parms[5])) {
+        /*
+         * "type=d" forces a dir listing. The other types (i|a|e) are
+         * directly used for the ftp TYPE command
+         */
+        if (!(get_dirlisting = (parms[5] == 'd')))
+            xfer_type = ap_toupper(parms[5]);
+
+        /* Check valid types, rather than ignoring invalid types silently: */
+        if (strchr("AEI", xfer_type) == NULL)
+            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                      ap_proxyerror(r, HTTP_BAD_REQUEST, ap_pstrcat(r->pool,
+                       "ftp proxy supports only types 'a', 'i', or 'e': \"",
+                                           parms, "\" is invalid.", NULL)));
+    }
+    else {
+        /* make binary transfers the default */
+        xfer_type = 'I';
+    }
+
+/* try to set up PASV data connection first */
+    dsock = ap_psocket_ex(p, PF_INET, SOCK_STREAM, IPPROTO_TCP, 1);
+    if (dsock == -1) {
+        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR,
+                                      "proxy: error creating PASV socket"));
+    }
+
+#if !defined (TPF) && !defined(BEOS)
+    if (conf->recv_buffer_size) {
+        if (setsockopt(dsock, SOL_SOCKET, SO_RCVBUF,
+                (const char *)&conf->recv_buffer_size, sizeof(int)) == -1) {
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
+                          "setsockopt(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
+        }
+    }
+#endif
+
+    ap_bputs("PASV" CRLF, ctrl);
+    ap_bflush(ctrl);
+    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: PASV command issued");
+/* possible results: 227, 421, 500, 501, 502, 530 */
+    /* 227 Entering Passive Mode (h1,h2,h3,h4,p1,p2). */
+    /* 421 Service not available, closing control connection. */
+    /* 500 Syntax error, command unrecognized. */
+    /* 501 Syntax error in parameters or arguments. */
+    /* 502 Command not implemented. */
+    /* 530 Not logged in. */
+
+    i = ap_bgets(pasv, sizeof(pasv), ctrl);
+    if (i == -1 || i == 421) {
+        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR,
+                               "proxy: PASV: control connection is toast"));
+    }
+    else {
+        pasv[i - 1] = '\0';
+        pstr = strtok(pasv, " ");       /* separate result code */
+        if (pstr != NULL) {
+            presult = atoi(pstr);
+            if (*(pstr + strlen(pstr) + 1) == '=')
+                pstr += strlen(pstr) + 2;
+            else {
+                pstr = strtok(NULL, "(");       /* separate address & port
+                                                 * params */
+                if (pstr != NULL)
+                    pstr = strtok(NULL, ")");
+            }
+        }
+        else
+            presult = atoi(pasv);
+
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", presult);
+
+        if (presult == 227 && pstr != NULL && (sscanf(pstr,
+                 "%d,%d,%d,%d,%d,%d", &h3, &h2, &h1, &h0, &p1, &p0) == 6)) {
+            /* pardon the parens, but it makes gcc happy */
+            paddr = (((((h3 << 8) + h2) << 8) + h1) << 8) + h0;
+            pport = (p1 << 8) + p0;
+            ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: contacting host %d.%d.%d.%d:%d",
+                         h3, h2, h1, h0, pport);
+            data_addr.sin_family = AF_INET;
+            data_addr.sin_addr.s_addr = htonl(paddr);
+            data_addr.sin_port = htons(pport);
+            i = ap_proxy_doconnect(dsock, &data_addr, r);
+
+            if (i == -1) {
+                return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                          ap_proxyerror(r, HTTP_BAD_GATEWAY,
+                                                        ap_pstrcat(r->pool,
+                                    "Could not connect to remote machine: ",
+                                                   strerror(errno), NULL)));
+            }
+            pasvmode = 1;
+        }
+        else {
+            ap_pclosesocket(p, dsock);  /* and try the regular way */
+            dsock = -1;
+        }
+    }
+
+    if (!pasvmode) {            /* set up data connection */
+        clen = sizeof(struct sockaddr_in);
+        if (getsockname(sock, (struct sockaddr *)&server, &clen) < 0) {
+            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR,
+                                    "proxy: error getting socket address"));
+        }
+
+        dsock = ap_psocket_ex(p, PF_INET, SOCK_STREAM, IPPROTO_TCP, 1);
+        if (dsock == -1) {
+            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR,
+                                           "proxy: error creating socket"));
+        }
+
+        if (setsockopt(dsock, SOL_SOCKET, SO_REUSEADDR, (void *)&one,
+                       sizeof(one)) == -1) {
+#ifndef _OSD_POSIX              /* BS2000 has this option "always on" */
+            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR,
+                                  "proxy: error setting reuseaddr option"));
+#endif                          /* _OSD_POSIX */
+        }
+
+        if (bind(dsock, (struct sockaddr *)&server,
+                 sizeof(struct sockaddr_in)) == -1) {
+
+            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR,
+             ap_psprintf(p, "proxy: error binding to ftp data socket %s:%d",
+                         inet_ntoa(server.sin_addr), server.sin_port)));
+        }
+        listen(dsock, 2);       /* only need a short queue */
+    }
+
+/* set request; "path" holds last path component */
+    len = decodeenc(path);
+    if (strchr(path, '/'))      /* were there any '/' characters? */
+        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                      ap_proxyerror(r, HTTP_BAD_REQUEST,
+                       "Use of %2F is only allowed at the base directory"));
+
+    /* TM - if len == 0 then it must be a directory (you can't RETR nothing) */
+
+    if (len == 0) {
+        get_dirlisting = 1;
+    }
+    else {
+        ap_bvputs(ctrl, "SIZE ", path, CRLF, NULL);
+        ap_bflush(ctrl);
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: SIZE %s", path);
+        i = ftp_getrc_msg(ctrl, resp, sizeof resp);
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d with response %s", i, resp);
+        if (i != 500) {         /* Size command not recognized */
+            if (i == 550) {     /* Not a regular file */
+                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: SIZE shows this is a directory");
+                get_dirlisting = 1;
+                ap_bvputs(ctrl, "CWD ", path, CRLF, NULL);
+                ap_bflush(ctrl);
+                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: CWD %s", path);
+
+                /* possible results: 250, 421, 500, 501, 502, 530, 550 */
+                /* 250 Requested file action okay, completed. */
+                /* 421 Service not available, closing control connection. */
+                /* 500 Syntax error, command unrecognized. */
+                /* 501 Syntax error in parameters or arguments. */
+                /* 502 Command not implemented. */
+                /* 530 Not logged in. */
+                /* 550 Requested action not taken. */
+                i = ftp_getrc(ctrl);
+                ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", i);
+                if (i == -1 || i == 421)
+                    return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                          ap_proxyerror(r, HTTP_BAD_GATEWAY,
+                                       "Error reading from remote server"));
+                if (i == 550)
+                    return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                                  HTTP_NOT_FOUND);
+                if (i != 250)
+                    return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                                  HTTP_BAD_GATEWAY);
+                path = "";
+                len = 0;
+            }
+            else if (i == 213) {/* Size command ok */
+                for (j = 0; j < sizeof resp && ap_isdigit(resp[j]); j++);
+                resp[j] = '\0';
+                if (resp[0] != '\0')
+                    size = ap_pstrdup(p, resp);
+            }
+        }
+    }
+
+#ifdef AUTODETECT_PWD
+    ap_bvputs(ctrl, "PWD", CRLF, NULL);
+    ap_bflush(ctrl);
+    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: PWD");
+/* responses: 257, 500, 501, 502, 421, 550 */
+    /* 257 "<directory-name>" <commentary> */
+    /* 421 Service not available, closing control connection. */
+    /* 500 Syntax error, command unrecognized. */
+    /* 501 Syntax error in parameters or arguments. */
+    /* 502 Command not implemented. */
+    /* 550 Requested action not taken. */
+    i = ftp_getrc_msg(ctrl, resp, sizeof resp);
+    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: PWD returned status %d", i);
+    if (i == -1 || i == 421)
+        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                      ap_proxyerror(r, HTTP_BAD_GATEWAY,
+                                       "Error reading from remote server"));
+    if (i == 550)
+        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                      HTTP_NOT_FOUND);
+    if (i == 257) {
+        const char *dirp = resp;
+        cwd = ap_getword_conf(r->pool, &dirp);
+    }
+#endif                          /* AUTODETECT_PWD */
+
+    if (get_dirlisting) {
+        if (len != 0)
+            ap_bvputs(ctrl, "LIST ", path, CRLF, NULL);
+        else
+            ap_bputs("LIST -lag" CRLF, ctrl);
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: LIST %s", (len == 0 ? "" : path));
+    }
+    else {
+        ftp_set_TYPE(r, ctrl, xfer_type);
+        ap_bvputs(ctrl, "RETR ", path, CRLF, NULL);
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: RETR %s", path);
+    }
+    ap_bflush(ctrl);
+/* RETR: 110, 125, 150, 226, 250, 421, 425, 426, 450, 451, 500, 501, 530, 550
+   NLST: 125, 150, 226, 250, 421, 425, 426, 450, 451, 500, 501, 502, 530 */
+    /* 110 Restart marker reply. */
+    /* 125 Data connection already open; transfer starting. */
+    /* 150 File status okay; about to open data connection. */
+    /* 226 Closing data connection. */
+    /* 250 Requested file action okay, completed. */
+    /* 421 Service not available, closing control connection. */
+    /* 425 Can't open data connection. */
+    /* 426 Connection closed; transfer aborted. */
+    /* 450 Requested file action not taken. */
+    /* 451 Requested action aborted. Local error in processing. */
+    /* 500 Syntax error, command unrecognized. */
+    /* 501 Syntax error in parameters or arguments. */
+    /* 530 Not logged in. */
+    /* 550 Requested action not taken. */
+    rc = ftp_getrc(ctrl);
+    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", rc);
+    if (rc == -1 || rc == 421)
+        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                      ap_proxyerror(r, HTTP_BAD_GATEWAY,
+                                       "Error reading from remote server"));
+    if (rc == 550) {
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: RETR failed, trying LIST instead");
+        get_dirlisting = 1;
+        ftp_set_TYPE(r, ctrl, 'A');     /* directories must be transferred in
+                                         * ASCII */
+
+        ap_bvputs(ctrl, "CWD ", path, CRLF, NULL);
+        ap_bflush(ctrl);
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: CWD %s", path);
+        /* possible results: 250, 421, 500, 501, 502, 530, 550 */
+        /* 250 Requested file action okay, completed. */
+        /* 421 Service not available, closing control connection. */
+        /* 500 Syntax error, command unrecognized. */
+        /* 501 Syntax error in parameters or arguments. */
+        /* 502 Command not implemented. */
+        /* 530 Not logged in. */
+        /* 550 Requested action not taken. */
+        rc = ftp_getrc(ctrl);
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", rc);
+        if (rc == -1 || rc == 421)
+            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                          ap_proxyerror(r, HTTP_BAD_GATEWAY,
+                                       "Error reading from remote server"));
+        if (rc == 550)
+            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                          HTTP_NOT_FOUND);
+        if (rc != 250)
+            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                          HTTP_BAD_GATEWAY);
+
+#ifdef AUTODETECT_PWD
+        ap_bvputs(ctrl, "PWD", CRLF, NULL);
+        ap_bflush(ctrl);
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: PWD");
+/* responses: 257, 500, 501, 502, 421, 550 */
+        /* 257 "<directory-name>" <commentary> */
+        /* 421 Service not available, closing control connection. */
+        /* 500 Syntax error, command unrecognized. */
+        /* 501 Syntax error in parameters or arguments. */
+        /* 502 Command not implemented. */
+        /* 550 Requested action not taken. */
+        i = ftp_getrc_msg(ctrl, resp, sizeof resp);
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: PWD returned status %d", i);
+        if (i == -1 || i == 421)
+            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                          ap_proxyerror(r, HTTP_BAD_GATEWAY,
+                                       "Error reading from remote server"));
+        if (i == 550)
+            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                          HTTP_NOT_FOUND);
+        if (i == 257) {
+            const char *dirp = resp;
+            cwd = ap_getword_conf(r->pool, &dirp);
+        }
+#endif                          /* AUTODETECT_PWD */
+
+        ap_bputs("LIST -lag" CRLF, ctrl);
+        ap_bflush(ctrl);
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: LIST -lag");
+        rc = ftp_getrc(ctrl);
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", rc);
+        if (rc == -1 || rc == 421)
+            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                          ap_proxyerror(r, HTTP_BAD_GATEWAY,
+                                       "Error reading from remote server"));
+    }
+    ap_kill_timeout(r);
+    if (rc != 125 && rc != 150 && rc != 226 && rc != 250)
+        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                      HTTP_BAD_GATEWAY);
+
+    r->status = HTTP_OK;
+    r->status_line = "200 OK";
+
+    resp_hdrs = ap_make_table(p, 2);
+    c->hdrs = resp_hdrs;
+
+    ap_table_setn(resp_hdrs, "Date", ap_gm_timestr_822(r->pool, r->request_time));
+    ap_table_setn(resp_hdrs, "Server", ap_get_server_version());
+
+    if (get_dirlisting) {
+        ap_table_setn(resp_hdrs, "Content-Type", "text/html");
+#ifdef CHARSET_EBCDIC
+        r->ebcdic.conv_out = 1; /* server-generated */
+#endif
+    }
+    else {
+#ifdef CHARSET_EBCDIC
+        r->ebcdic.conv_out = 0; /* do not convert what we read from the ftp
+                                 * server */
+#endif
+        if (r->content_type != NULL) {
+            ap_table_setn(resp_hdrs, "Content-Type", r->content_type);
+            ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: Content-Type set to %s", r->content_type);
+        }
+        else {
+            ap_table_setn(resp_hdrs, "Content-Type", ap_default_type(r));
+        }
+        if (xfer_type != 'A' && size != NULL) {
+            /* We "trust" the ftp server to really serve (size) bytes... */
+            ap_table_set(resp_hdrs, "Content-Length", size);
+            ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: Content-Length set to %s", size);
+        }
+    }
+    if (r->content_encoding != NULL && r->content_encoding[0] != '\0') {
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: Content-Encoding set to %s", r->content_encoding);
+        ap_table_setn(resp_hdrs, "Content-Encoding", r->content_encoding);
+    }
+
+/* check if NoCache directive on this host */
+    if (nocache == 0) {
+        for (i = 0; i < conf->nocaches->nelts; i++) {
+            if (destaddr.s_addr == ncent[i].addr.s_addr ||
+                (ncent[i].name != NULL &&
+                 (ncent[i].name[0] == '*' ||
+                  strstr(desthost, ncent[i].name) != NULL))) {
+                nocache = 1;
+                break;
+            }
+        }
+    }
+
+    i = ap_proxy_cache_update(c, resp_hdrs, 0, nocache);
+
+    if (i != DECLINED) {
+        return ftp_cleanup_and_return(r, ctrl, data, sock, dsock, i);
+    }
+
+    if (!pasvmode) {            /* wait for connection */
+        ap_hard_timeout("proxy ftp data connect", r);
+        clen = sizeof(struct sockaddr_in);
+        do
+            csd = accept(dsock, (struct sockaddr *)&server, &clen);
+        while (csd == -1 && errno == EINTR);
+        if (csd == -1) {
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
+                          "proxy: failed to accept data connection");
+            if (c != NULL)
+                c = ap_proxy_cache_error(c);
+            return ftp_cleanup_and_return(r, ctrl, data, sock, dsock,
+                                          HTTP_BAD_GATEWAY);
+        }
+        data = ap_bcreate(p, B_RDWR | B_SOCKET);
+        ap_bpushfd(data, csd, -1);
+        ap_kill_timeout(r);
+    }
+    else {
+        data = ap_bcreate(p, B_RDWR | B_SOCKET);
+        ap_bpushfd(data, dsock, dsock);
+    }
+
+    ap_hard_timeout("proxy receive", r);
+
+    /* send response */
+    /* write status line and headers to the cache file */
+    ap_proxy_write_headers(c, ap_pstrcat(p, "HTTP/1.1 ", r->status_line, NULL), resp_hdrs);
+
+    /* Setup the headers for our client from upstreams response-headers */
+    ap_overlap_tables(r->headers_out, resp_hdrs, AP_OVERLAP_TABLES_SET);
+    /* Add X-Cache header */
+    ap_table_setn(r->headers_out, "X-Cache",
+                  ap_pstrcat(r->pool, "MISS from ",
+                             ap_get_server_name(r), NULL));
+    /* The Content-Type of this response is the upstream one. */
+    r->content_type = ap_table_get(r->headers_out, "Content-Type");
+    /* finally output the headers to the client */
+    ap_send_http_header(r);
+
+#ifdef CHARSET_EBCDIC
+    ap_bsetflag(r->connection->client, B_EBCDIC2ASCII, r->ebcdic.conv_out);
+#endif
+/* send body */
+    if (!r->header_only) {
+        if (!get_dirlisting) {
+/* we need to set this for ap_proxy_send_fb()... */
+            if (c != NULL)
+                c->cache_completion = 0;
+            ap_proxy_send_fb(data, r, c, -1, 0, 0, conf->io_buffer_size);
+        }
+        else {
+            send_dir(data, r, c, cwd);
+        }
+        /* ap_proxy_send_fb() closes the socket */
+        data = NULL;
+        dsock = -1;
+
+        /*
+         * We checked for 125||150||226||250 above. See if another rc is
+         * pending, and fetch it:
+         */
+        if (rc == 125 || rc == 150)
+            rc = ftp_getrc(ctrl);
+    }
+    else {
+/* abort the transfer: we send the header only */
+        ap_bputs("ABOR" CRLF, ctrl);
+        ap_bflush(ctrl);
+        if (data != NULL) {
+            ap_bclose(data);
+            data = NULL;
+            dsock = -1;
+        }
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: ABOR");
+/* responses: 225, 226, 421, 500, 501, 502 */
+        /* 225 Data connection open; no transfer in progress. */
+        /* 226 Closing data connection. */
+        /* 421 Service not available, closing control connection. */
+        /* 500 Syntax error, command unrecognized. */
+        /* 501 Syntax error in parameters or arguments. */
+        /* 502 Command not implemented. */
+        i = ftp_getrc(ctrl);
+        ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: returned status %d", i);
+    }
+
+    ap_kill_timeout(r);
+    ap_proxy_cache_tidy(c);
+
+/* finish */
+    ap_bputs("QUIT" CRLF, ctrl);
+    ap_bflush(ctrl);
+    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: QUIT");
+/* responses: 221, 500 */
+    /* 221 Service closing control connection. */
+    /* 500 Syntax error, command unrecognized. */
+    i = ftp_getrc(ctrl);
+    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "FTP: QUIT: status %d", i);
+
+    ap_bclose(ctrl);
+
+    ap_rflush(r);               /* flush before garbage collection */
+
+    ap_proxy_garbage_coll(r);
+
+    return OK;
+}
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/proxy/proxy_http.c apache_1.3.33/src/modules/proxy/proxy_http.c
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/proxy/proxy_http.c	Fri Jun 11 09:54:38 2004
+++ apache_1.3.33/src/modules/proxy/proxy_http.c	Mon Jul 18 15:22:25 2005
@@ -127,6 +127,9 @@
     const char *datestr, *urlstr;
     int result, major, minor;
     const char *content_length;
+#ifdef EAPI
+    char *peer;
+#endif
 
     void *sconf = r->server->module_config;
     proxy_server_conf *conf =
@@ -148,6 +151,12 @@
         return HTTP_BAD_REQUEST;
     urlptr += 3;
     destport = DEFAULT_HTTP_PORT;
+#ifdef EAPI
+    ap_hook_use("ap::mod_proxy::http::handler::set_destport", 
+                AP_HOOK_SIG2(int,ptr), 
+                AP_HOOK_TOPMOST,
+                &destport, r);
+#endif /* EAPI */
     strp = strchr(urlptr, '/');
     if (strp == NULL) {
         desthost = ap_pstrdup(p, urlptr);
@@ -185,12 +194,18 @@
         err = ap_proxy_host2addr(proxyhost, &server_hp);
         if (err != NULL)
             return DECLINED;    /* try another */
+#ifdef EAPI
+	peer = ap_psprintf(p, "%s:%u", proxyhost, proxyport);  
+#endif
     }
     else {
         server.sin_port = htons((unsigned short)destport);
         err = ap_proxy_host2addr(desthost, &server_hp);
         if (err != NULL)
             return ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR, err);
+#ifdef EAPI
+	peer =  ap_psprintf(p, "%s:%u", desthost, destport);  
+#endif
     }
 
 
@@ -275,14 +290,42 @@
     f = ap_bcreate(p, B_RDWR | B_SOCKET);
     ap_bpushfd(f, sock, sock);
 
+#ifdef EAPI
+    {
+        char *errmsg = NULL;
+        ap_hook_use("ap::mod_proxy::http::handler::new_connection", 
+                    AP_HOOK_SIG4(ptr,ptr,ptr,ptr), 
+                    AP_HOOK_DECLINE(NULL),
+                    &errmsg, r, f, peer);
+        if (errmsg != NULL)
+            return ap_proxyerror(r, HTTP_BAD_GATEWAY, errmsg);
+    }
+#endif /* EAPI */
+
     ap_hard_timeout("proxy send", r);
     ap_bvputs(f, r->method, " ", proxyhost ? url : urlptr, " HTTP/1.1" CRLF,
               NULL);
+#ifdef EAPI
+    {
+	int rc = DECLINED;
+	ap_hook_use("ap::mod_proxy::http::handler::write_host_header", 
+		    AP_HOOK_SIG6(int,ptr,ptr,ptr,int,ptr), 
+		    AP_HOOK_DECLINE(DECLINED),
+		    &rc, r, f, desthost, destport, destportstr);
+        if (rc == DECLINED) {
+	    if (destportstr != NULL && destport != DEFAULT_HTTP_PORT)
+		ap_bvputs(f, "Host: ", desthost, ":", destportstr, CRLF, NULL);
+	    else
+		ap_bvputs(f, "Host: ", desthost, CRLF, NULL);
+        }
+    }
+#else /* EAPI */
     /* Send Host: now, adding it to req_hdrs wouldn't be much better */
     if (destportstr != NULL && destport != DEFAULT_HTTP_PORT)
         ap_bvputs(f, "Host: ", desthost, ":", destportstr, CRLF, NULL);
     else
         ap_bvputs(f, "Host: ", desthost, CRLF, NULL);
+#endif /* EAPI */
 
     if (conf->viaopt == via_block) {
         /* Block all outgoing Via: headers */
@@ -526,6 +569,8 @@
         ap_table_set(resp_hdrs, "URI", proxy_location_reverse_map(r, urlstr));
     if ((urlstr = ap_table_get(resp_hdrs, "Content-Location")) != NULL)
         ap_table_set(resp_hdrs, "Content-Location", proxy_location_reverse_map(r, urlstr));
+    if ((urlstr = ap_table_get(resp_hdrs, "Content-Base")) != NULL)
+        ap_table_set(resp_hdrs, "Content-Base", proxy_location_reverse_map(r, urlstr));
 
 /* check if NoCache directive on this host */
     if (nocache == 0) {
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/proxy/proxy_http.c.orig apache_1.3.33/src/modules/proxy/proxy_http.c.orig
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/proxy/proxy_http.c.orig	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/modules/proxy/proxy_http.c.orig	Fri Jun 11 09:54:38 2004
@@ -0,0 +1,624 @@
+/* Copyright 1999-2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* HTTP routines for Apache proxy */
+
+#include "mod_proxy.h"
+#include "http_log.h"
+#include "http_main.h"
+#include "http_core.h"
+#include "util_date.h"
+
+/*
+ * Canonicalise http-like URLs.
+ *  scheme is the scheme for the URL
+ *  url    is the URL starting with the first '/'
+ *  def_port is the default port for this scheme.
+ */
+int ap_proxy_http_canon(request_rec *r, char *url, const char *scheme, int def_port)
+{
+    char *host, *path, *search, sport[7];
+    const char *err;
+    int port;
+
+    /*
+     * do syntatic check. We break the URL into host, port, path, search
+     */
+    port = def_port;
+    err = ap_proxy_canon_netloc(r->pool, &url, NULL, NULL, &host, &port);
+    if (err)
+        return HTTP_BAD_REQUEST;
+
+    /* now parse path/search args, according to rfc1738 */
+    /*
+     * N.B. if this isn't a true proxy request, then the URL _path_ has
+     * already been decoded.  True proxy requests have r->uri ==
+     * r->unparsed_uri, and no others have that property.
+     */
+    if (r->uri == r->unparsed_uri) {
+        search = strchr(url, '?');
+        if (search != NULL)
+            *(search++) = '\0';
+    }
+    else
+        search = r->args;
+
+    /* process path */
+    path = ap_proxy_canonenc(r->pool, url, strlen(url), enc_path,
+                             r->proxyreq);
+    if (path == NULL)
+        return HTTP_BAD_REQUEST;
+
+    if (port != def_port)
+        ap_snprintf(sport, sizeof(sport), ":%d", port);
+    else
+        sport[0] = '\0';
+
+    r->filename = ap_pstrcat(r->pool, "proxy:", scheme, "://", host, sport, "/",
+                   path, (search) ? "?" : "", (search) ? search : "", NULL);
+    return OK;
+}
+
+/* handle the conversion of URLs in the ProxyPassReverse function */
+static const char *proxy_location_reverse_map(request_rec *r, const char *url)
+{
+    void *sconf;
+    proxy_server_conf *conf;
+    struct proxy_alias *ent;
+    int i, l1, l2;
+    char *u;
+
+    sconf = r->server->module_config;
+    conf = (proxy_server_conf *)ap_get_module_config(sconf, &proxy_module);
+    l1 = strlen(url);
+    ent = (struct proxy_alias *)conf->raliases->elts;
+    for (i = 0; i < conf->raliases->nelts; i++) {
+        l2 = strlen(ent[i].real);
+        if (l1 >= l2 && strncmp(ent[i].real, url, l2) == 0) {
+            u = ap_pstrcat(r->pool, ent[i].fake, &url[l2], NULL);
+            return ap_construct_url(r->pool, u, r);
+        }
+    }
+    return url;
+}
+
+/*
+ * This handles http:// URLs, and other URLs using a remote proxy over http
+ * If proxyhost is NULL, then contact the server directly, otherwise
+ * go via the proxy.
+ * Note that if a proxy is used, then URLs other than http: can be accessed,
+ * also, if we have trouble which is clearly specific to the proxy, then
+ * we return DECLINED so that we can try another proxy. (Or the direct
+ * route.)
+ */
+int ap_proxy_http_handler(request_rec *r, cache_req *c, char *url,
+                              const char *proxyhost, int proxyport)
+{
+    const char *strp;
+    char *strp2;
+    const char *err, *desthost;
+    int i, j, sock,/* len,*/ backasswards;
+    table *req_hdrs, *resp_hdrs;
+    array_header *reqhdrs_arr;
+    table_entry *reqhdrs_elts;
+    struct sockaddr_in server;
+    struct in_addr destaddr;
+    struct hostent server_hp;
+    BUFF *f;
+    char buffer[HUGE_STRING_LEN];
+    char portstr[32];
+    pool *p = r->pool;
+    int destport = 0;
+    int chunked = 0;
+    char *destportstr = NULL;
+    const char *urlptr = NULL;
+    const char *datestr, *urlstr;
+    int result, major, minor;
+    const char *content_length;
+
+    void *sconf = r->server->module_config;
+    proxy_server_conf *conf =
+    (proxy_server_conf *)ap_get_module_config(sconf, &proxy_module);
+    struct noproxy_entry *npent = (struct noproxy_entry *) conf->noproxies->elts;
+    struct nocache_entry *ncent = (struct nocache_entry *) conf->nocaches->elts;
+    int nocache = 0;
+
+    if (conf->cache.root == NULL)
+        nocache = 1;
+
+    memset(&server, '\0', sizeof(server));
+    server.sin_family = AF_INET;
+
+    /* We break the URL into host, port, path-search */
+
+    urlptr = strstr(url, "://");
+    if (urlptr == NULL)
+        return HTTP_BAD_REQUEST;
+    urlptr += 3;
+    destport = DEFAULT_HTTP_PORT;
+    strp = strchr(urlptr, '/');
+    if (strp == NULL) {
+        desthost = ap_pstrdup(p, urlptr);
+        urlptr = "/";
+    }
+    else {
+        char *q = ap_palloc(p, strp - urlptr + 1);
+        memcpy(q, urlptr, strp - urlptr);
+        q[strp - urlptr] = '\0';
+        urlptr = strp;
+        desthost = q;
+    }
+
+    strp2 = strchr(desthost, ':');
+    if (strp2 != NULL) {
+        *(strp2++) = '\0';
+        if (ap_isdigit(*strp2)) {
+            destport = atoi(strp2);
+            destportstr = strp2;
+        }
+    }
+
+    /* check if ProxyBlock directive on this host */
+    destaddr.s_addr = ap_inet_addr(desthost);
+    for (i = 0; i < conf->noproxies->nelts; i++) {
+        if (destaddr.s_addr == npent[i].addr.s_addr ||
+            (npent[i].name != NULL &&
+             (npent[i].name[0] == '*' || strstr(desthost, npent[i].name) != NULL)))
+            return ap_proxyerror(r, HTTP_FORBIDDEN,
+                                 "Connect to remote machine blocked");
+    }
+
+    if (proxyhost != NULL) {
+        server.sin_port = htons((unsigned short)proxyport);
+        err = ap_proxy_host2addr(proxyhost, &server_hp);
+        if (err != NULL)
+            return DECLINED;    /* try another */
+    }
+    else {
+        server.sin_port = htons((unsigned short)destport);
+        err = ap_proxy_host2addr(desthost, &server_hp);
+        if (err != NULL)
+            return ap_proxyerror(r, HTTP_INTERNAL_SERVER_ERROR, err);
+    }
+
+
+    /*
+     * we have worked out who exactly we are going to connect to, now make
+     * that connection...
+     */
+    sock = ap_psocket_ex(p, PF_INET, SOCK_STREAM, IPPROTO_TCP, 1);
+    if (sock == -1) {
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
+                      "proxy: error creating socket");
+        return HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+#if !defined(TPF) && !defined(BEOS)
+    if (conf->recv_buffer_size) {
+        if (setsockopt(sock, SOL_SOCKET, SO_RCVBUF,
+                       (const char *)&conf->recv_buffer_size, sizeof(int))
+            == -1) {
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
+                          "setsockopt(SO_RCVBUF): Failed to set ProxyReceiveBufferSize, using default");
+        }
+    }
+#endif
+
+#ifdef SINIX_D_RESOLVER_BUG
+    {
+        struct in_addr *ip_addr = (struct in_addr *)*server_hp.h_addr_list;
+
+        for (; ip_addr->s_addr != 0; ++ip_addr) {
+            memcpy(&server.sin_addr, ip_addr, sizeof(struct in_addr));
+            i = ap_proxy_doconnect(sock, &server, r);
+            if (i == 0)
+                break;
+            /*
+             * Even if the connection was unsuccesful we should
+             * reinit the socket
+             */
+            sock = ap_psocket_ex(p, PF_INET, SOCK_STREAM, IPPROTO_TCP, 1);
+        }
+    }
+#else
+    j = 0;
+    while (server_hp.h_addr_list[j] != NULL) {
+        memcpy(&server.sin_addr, server_hp.h_addr_list[j],
+               sizeof(struct in_addr));
+        i = ap_proxy_doconnect(sock, &server, r);
+        if (i == 0)
+            break;
+        /*
+         * Even if the connection was unsuccesful we should
+         * reinit the socket
+         */
+        sock = ap_psocket_ex(p, PF_INET, SOCK_STREAM, IPPROTO_TCP, 1);
+        j++;
+    }
+#endif
+    if (i == -1) {
+        if (proxyhost != NULL)
+            return DECLINED;    /* try again another way */
+        else
+            return ap_proxyerror(r, HTTP_BAD_GATEWAY, ap_pstrcat(r->pool,
+                                    "Could not connect to remote machine: ",
+                                                    strerror(errno), NULL));
+    }
+
+    /* record request_time for HTTP/1.1 age calculation */
+    c->req_time = time(NULL);
+
+    /*
+     * build upstream-request headers by stripping r->headers_in from
+     * connection specific headers. We must not remove the Connection: header
+     * from r->headers_in, we still have to react to Connection: close
+     */
+    req_hdrs = ap_copy_table(r->pool, r->headers_in);
+    ap_proxy_clear_connection(r->pool, req_hdrs);
+
+    /*
+     * At this point, we start sending the HTTP/1.1 request to the remote
+     * server (proxy or otherwise).
+     */
+    f = ap_bcreate(p, B_RDWR | B_SOCKET);
+    ap_bpushfd(f, sock, sock);
+
+    ap_hard_timeout("proxy send", r);
+    ap_bvputs(f, r->method, " ", proxyhost ? url : urlptr, " HTTP/1.1" CRLF,
+              NULL);
+    /* Send Host: now, adding it to req_hdrs wouldn't be much better */
+    if (destportstr != NULL && destport != DEFAULT_HTTP_PORT)
+        ap_bvputs(f, "Host: ", desthost, ":", destportstr, CRLF, NULL);
+    else
+        ap_bvputs(f, "Host: ", desthost, CRLF, NULL);
+
+    if (conf->viaopt == via_block) {
+        /* Block all outgoing Via: headers */
+        ap_table_unset(req_hdrs, "Via");
+    }
+    else if (conf->viaopt != via_off) {
+        /* Create a "Via:" request header entry and merge it */
+        i = ap_get_server_port(r);
+        if (ap_is_default_port(i, r)) {
+            strcpy(portstr, "");
+        }
+        else {
+            ap_snprintf(portstr, sizeof portstr, ":%d", i);
+        }
+        /* Generate outgoing Via: header with/without server comment: */
+        ap_table_mergen(req_hdrs, "Via",
+                        (conf->viaopt == via_full)
+                        ? ap_psprintf(p, "%d.%d %s%s (%s)",
+                                      HTTP_VERSION_MAJOR(r->proto_num),
+                                      HTTP_VERSION_MINOR(r->proto_num),
+                                      ap_get_server_name(r), portstr,
+                                      SERVER_BASEVERSION)
+                        : ap_psprintf(p, "%d.%d %s%s",
+                                      HTTP_VERSION_MAJOR(r->proto_num),
+                                      HTTP_VERSION_MINOR(r->proto_num),
+                                      ap_get_server_name(r), portstr)
+            );
+    }
+
+    /* the X-* headers are only added if we are a reverse
+     * proxy, otherwise we would be giving away private information.
+     */
+    if (r->proxyreq == PROXY_PASS) {
+        const char *buf;
+
+        /*
+         * Add X-Forwarded-For: so that the upstream has a chance to determine,
+         * where the original request came from.
+         */
+        ap_table_mergen(req_hdrs, "X-Forwarded-For", r->connection->remote_ip);
+
+        /* Add X-Forwarded-Host: so that upstream knows what the
+         * original request hostname was.
+         */
+        if ((buf = ap_table_get(r->headers_in, "Host"))) {
+            ap_table_mergen(req_hdrs, "X-Forwarded-Host", buf);
+        }
+
+        /* Add X-Forwarded-Server: so that upstream knows what the
+         * name of this proxy server is (if there are more than one)
+         * XXX: This duplicates Via: - do we strictly need it?
+         */
+        ap_table_mergen(req_hdrs, "X-Forwarded-Server", r->server->server_hostname);
+    } 
+
+    /* we don't yet support keepalives - but we will soon, I promise! */
+    ap_table_set(req_hdrs, "Connection", "close");
+
+    reqhdrs_arr = ap_table_elts(req_hdrs);
+    reqhdrs_elts = (table_entry *)reqhdrs_arr->elts;
+    for (i = 0; i < reqhdrs_arr->nelts; i++) {
+        if (reqhdrs_elts[i].key == NULL || reqhdrs_elts[i].val == NULL
+
+        /*
+         * Clear out hop-by-hop request headers not to send: RFC2616 13.5.1
+         * says we should strip these headers:
+         */
+            || !strcasecmp(reqhdrs_elts[i].key, "Host") /* Already sent */
+            || !strcasecmp(reqhdrs_elts[i].key, "Keep-Alive")
+            || !strcasecmp(reqhdrs_elts[i].key, "TE")
+            || !strcasecmp(reqhdrs_elts[i].key, "Trailer")
+            || !strcasecmp(reqhdrs_elts[i].key, "Transfer-Encoding")
+            || !strcasecmp(reqhdrs_elts[i].key, "Upgrade")
+        /*
+         * XXX: @@@ FIXME: "Proxy-Authorization" should *only* be suppressed
+         * if THIS server requested the authentication, not when a frontend
+         * proxy requested it!
+         * 
+         * The solution to this problem is probably to strip out the
+         * Proxy-Authorisation header in the authorisation code itself, not
+         * here. This saves us having to signal somehow whether this request
+         * was authenticated or not.
+         */
+            || !strcasecmp(reqhdrs_elts[i].key, "Proxy-Authorization"))
+            continue;
+        ap_bvputs(f, reqhdrs_elts[i].key, ": ", reqhdrs_elts[i].val, CRLF, NULL);
+    }
+
+    /* the obligatory empty line to mark the end of the headers */
+    ap_bputs(CRLF, f);
+
+    /* and flush the above away */
+    ap_bflush(f);
+
+    /* and kill the send timeout */
+    ap_kill_timeout(r);
+
+
+    /* read the request data, and pass it to the backend.
+     * we might encounter a stray 100-continue reponse from a PUT or POST,
+     * if this happens we ignore the 100 continue status line and read the
+     * response again.
+     */
+    {
+        /* send the request data, if any. */
+        ap_hard_timeout("proxy receive request data", r);
+        if (ap_should_client_block(r)) {
+            while ((i = ap_get_client_block(r, buffer, sizeof buffer)) > 0) {
+                ap_reset_timeout(r);
+                ap_bwrite(f, buffer, i);
+            }
+        }
+        ap_bflush(f);
+        ap_kill_timeout(r);
+
+
+        /* then, read a response line */
+        ap_hard_timeout("proxy receive response status line", r);
+        result = ap_proxy_read_response_line(f, r, buffer, sizeof(buffer)-1, &backasswards, &major, &minor);
+        ap_kill_timeout(r);
+
+        /* trap any errors */
+        if (result != OK) {
+            ap_bclose(f);
+            return result;
+        }
+
+        /* if this response was 100-continue, a stray response has been caught.
+         * read the line again for the real response
+         */
+        if (r->status == 100) {
+            ap_hard_timeout("proxy receive response status line", r);
+            result = ap_proxy_read_response_line(f, r, buffer, sizeof(buffer)-1, &backasswards, &major, &minor);
+            ap_kill_timeout(r);
+
+            /* trap any errors */
+            if (result != OK) {
+                ap_bclose(f);
+                return result;
+            }
+        }
+    }
+
+
+    /*
+     * We have our response status line from the convoluted code above,
+     * now we read the headers to continue.
+     */
+    ap_hard_timeout("proxy receive response headers", r);
+
+    /*
+     * Is it an HTTP/1 response? Do some sanity checks on the response. (This
+     * is buggy if we ever see an HTTP/1.10)
+     */
+    if (backasswards == 0) {
+
+        /* read the response headers. */
+        /* N.B. for HTTP/1.0 clients, we have to fold line-wrapped headers */
+        /* Also, take care with headers with multiple occurences. */
+
+        resp_hdrs = ap_proxy_read_headers(r, buffer, sizeof(buffer), f);
+        if (resp_hdrs == NULL) {
+            ap_log_error(APLOG_MARK, APLOG_WARNING | APLOG_NOERRNO, r->server,
+                         "proxy: Bad HTTP/%d.%d header returned by %s (%s)",
+                         major, minor, r->uri, r->method);
+            resp_hdrs = ap_make_table(p, 20);
+            nocache = 1;        /* do not cache this broken file */
+        }
+
+        /* handle Via header in the response */
+        if (conf->viaopt != via_off && conf->viaopt != via_block) {
+            /* Create a "Via:" response header entry and merge it */
+            i = ap_get_server_port(r);
+            if (ap_is_default_port(i, r)) {
+                strcpy(portstr, "");
+            }
+            else {
+                ap_snprintf(portstr, sizeof portstr, ":%d", i);
+            }
+            ap_table_mergen((table *)resp_hdrs, "Via",
+                            (conf->viaopt == via_full)
+                            ? ap_psprintf(p, "%d.%d %s%s (%s)",
+                                          major, minor,
+                                          ap_get_server_name(r), portstr,
+                                          SERVER_BASEVERSION)
+                            : ap_psprintf(p, "%d.%d %s%s",
+                                          major, minor,
+                                          ap_get_server_name(r), portstr)
+                );
+        }
+
+        /* is this content chunked? */
+        chunked = ap_find_last_token(r->pool,
+                                     ap_table_get(resp_hdrs, "Transfer-Encoding"),
+                                     "chunked");
+
+        /* strip hop-by-hop headers defined by Connection and RFC2616 */
+        ap_proxy_clear_connection(p, resp_hdrs);
+
+        content_length = ap_table_get(resp_hdrs, "Content-Length");
+        if (content_length != NULL) {
+            c->len = ap_strtol(content_length, NULL, 10);
+
+	    if (c->len < 0) {
+		ap_kill_timeout(r);
+		return ap_proxyerror(r, HTTP_BAD_GATEWAY, ap_pstrcat(r->pool,
+				     "Invalid Content-Length from remote server",
+                                      NULL));
+	    }
+        }
+
+    }
+    else {
+        /* an http/0.9 response */
+
+        /* no headers */
+        resp_hdrs = ap_make_table(p, 20);
+    }
+
+    ap_kill_timeout(r);
+
+    /*
+     * HTTP/1.1 requires us to accept 3 types of dates, but only generate one
+     * type
+     */
+    /*
+     * we SET the dates here, obliterating possible multiple dates, as only
+     * one of each date makes sense in each response.
+     */
+    if ((datestr = ap_table_get(resp_hdrs, "Date")) != NULL)
+        ap_table_set(resp_hdrs, "Date", ap_proxy_date_canon(p, datestr));
+    if ((datestr = ap_table_get(resp_hdrs, "Last-Modified")) != NULL)
+        ap_table_set(resp_hdrs, "Last-Modified", ap_proxy_date_canon(p, datestr));
+    if ((datestr = ap_table_get(resp_hdrs, "Expires")) != NULL)
+        ap_table_set(resp_hdrs, "Expires", ap_proxy_date_canon(p, datestr));
+
+    /* handle the ProxyPassReverse mappings */
+    if ((urlstr = ap_table_get(resp_hdrs, "Location")) != NULL)
+        ap_table_set(resp_hdrs, "Location", proxy_location_reverse_map(r, urlstr));
+    if ((urlstr = ap_table_get(resp_hdrs, "URI")) != NULL)
+        ap_table_set(resp_hdrs, "URI", proxy_location_reverse_map(r, urlstr));
+    if ((urlstr = ap_table_get(resp_hdrs, "Content-Location")) != NULL)
+        ap_table_set(resp_hdrs, "Content-Location", proxy_location_reverse_map(r, urlstr));
+
+/* check if NoCache directive on this host */
+    if (nocache == 0) {
+        for (i = 0; i < conf->nocaches->nelts; i++) {
+            if (destaddr.s_addr == ncent[i].addr.s_addr ||
+                (ncent[i].name != NULL &&
+                 (ncent[i].name[0] == '*' ||
+                  strstr(desthost, ncent[i].name) != NULL))) {
+                nocache = 1;
+                break;
+            }
+        }
+
+        /*
+         * update the cache file, possibly even fulfilling the request if it
+         * turns out a conditional allowed us to serve the object from the
+         * cache...
+         */
+        i = ap_proxy_cache_update(c, resp_hdrs, !backasswards, nocache);
+        if (i != DECLINED) {
+            ap_bclose(f);
+            return i;
+        }
+
+        /* write status line and headers to the cache file */
+        ap_proxy_write_headers(c, ap_pstrcat(p, "HTTP/1.1 ", r->status_line, NULL), resp_hdrs);
+    }
+
+    /* Setup the headers for our client from upstreams response-headers */
+    ap_proxy_table_replace(r->headers_out, resp_hdrs);
+    /* Add X-Cache header - be careful not to obliterate any upstream headers */
+    ap_table_mergen(r->headers_out, "X-Cache",
+                    ap_pstrcat(r->pool, "MISS from ",
+                               ap_get_server_name(r), NULL));
+    /* The Content-Type of this response is the upstream one. */
+    r->content_type = ap_table_get(r->headers_out, "Content-Type");
+    ap_log_error(APLOG_MARK, APLOG_DEBUG | APLOG_NOERRNO, r->server, "Content-Type: %s", r->content_type);
+
+    /* finally output the headers to the client */
+    ap_send_http_header(r);
+
+    /*
+     * Is it an HTTP/0.9 respose? If so, send the extra data we read from
+     * upstream as the start of the reponse to client
+     */
+/* FIXME: This code is broken: we try and write a buffer and length that
+ * were never intelligently initialised. Rather have a bit of broken protocol
+ * handling for now than broken code.
+ */
+/*
+    if (backasswards) {
+        ap_hard_timeout("proxy send assbackward", r);
+
+        ap_bwrite(r->connection->client, buffer, len);
+        if (c != NULL && c->fp != NULL && ap_bwrite(c->fp, buffer, len) != len) {
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, c->req,
+                      "proxy: error writing extra data to %s", c->tempfile);
+            c = ap_proxy_cache_error(c);
+        }
+        ap_kill_timeout(r);
+    }
+*/
+
+#ifdef CHARSET_EBCDIC
+    /*
+     * What we read/write after the header should not be modified (i.e., the
+     * cache copy is ASCII, not EBCDIC, even for text/html)
+     */
+    r->ebcdic.conv_in = r->ebcdic.conv_out = 0;
+    ap_bsetflag(f, B_ASCII2EBCDIC | B_EBCDIC2ASCII, 0);
+    ap_bsetflag(r->connection->client, B_ASCII2EBCDIC | B_EBCDIC2ASCII, 0);
+#endif
+
+/* send body */
+/* if header only, then cache will be NULL */
+/* HTTP/1.0 tells us to read to EOF, rather than content-length bytes */
+/* XXX CHANGEME: We want to eventually support keepalives, which means
+ * we must read content-length bytes... */
+    if (!r->header_only) {
+/* we need to set this for ap_proxy_send_fb()... */
+        c->cache_completion = conf->cache.cache_completion;
+
+/* XXX CHECKME: c->len should be the expected content length, or -1 if the
+ * content length is not known. We need to make 100% sure c->len is always
+ * set correctly before we get here to correctly do keepalive.
+ */
+        ap_proxy_send_fb(f, r, c, c->len, 0, chunked, conf->io_buffer_size);
+    }
+
+    /* ap_proxy_send_fb() closes the socket f for us */
+
+    ap_proxy_cache_tidy(c);
+
+    ap_proxy_garbage_coll(r);
+    return OK;
+}
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/Makefile.tmpl apache_1.3.33/src/modules/standard/Makefile.tmpl
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/Makefile.tmpl	Fri Jun 23 01:22:40 2000
+++ apache_1.3.33/src/modules/standard/Makefile.tmpl	Mon Jul 18 15:22:52 2005
@@ -3,6 +3,9 @@
 
 $(OBJS) $(OBJS_PIC): Makefile
 
+CFLAGS += -I$(LIBGDBM_DIR) 
+LDFLAGS += -L$(LIBGDBM_DIR)
+
 # DO NOT REMOVE
 mod_access.o: mod_access.c $(INCDIR)/httpd.h \
  $(INCDIR)/ap_config.h $(INCDIR)/ap_mmn.h \
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_auth_db.c apache_1.3.33/src/modules/standard/mod_auth_db.c
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_auth_db.c	Fri Feb 20 21:37:40 2004
+++ apache_1.3.33/src/modules/standard/mod_auth_db.c	Mon Jul 18 15:22:19 2005
@@ -64,6 +64,9 @@
 #endif
 #if (DB_VERSION_MAJOR == 4)
 #define DB4
+#if (DB_VERSION_MINOR >= 1)
+#define DB4_1
+#endif
 #endif
 #endif
 
@@ -127,21 +130,47 @@
     q.data = user;
     q.size = strlen(q.data);
 
-#if defined(DB3) || defined(DB4)
+    int dberr = 0;
+
+#if defined(DB4_1)
+    if (   db_create(&f, NULL, 0) != 0
+	|| (dberr = f->open(f, NULL, auth_dbpwfile, NULL, DB_HASH, DB_RDONLY, 0664)) != 0) {
+#elif defined(DB3) || defined(DB4)
     if (   db_create(&f, NULL, 0) != 0 
 #if DB_VERSION_MAJOR == 4 && DB_VERSION_MINOR > 0
-        || f->open(f, NULL, auth_dbpwfile, NULL, DB_HASH, DB_RDONLY, 0664) != 0) {
+        || (dberr = f->open(f, NULL, auth_dbpwfile, NULL, DB_HASH, DB_RDONLY, 0664)) != 0) {
 #else
-        || f->open(f, auth_dbpwfile, NULL, DB_HASH, DB_RDONLY, 0664) != 0) {
+        || (dberr = f->open(f, auth_dbpwfile, NULL, DB_HASH, DB_RDONLY, 0664)) != 0) {
 #endif
 #elif defined(DB2)
     if (db_open(auth_dbpwfile, DB_HASH, DB_RDONLY, 0664, NULL, NULL, &f) != 0) {
 #else
     if (!(f = dbopen(auth_dbpwfile, O_RDONLY, 0664, DB_HASH, NULL))) {
 #endif
+#if defined(DB4_1) || defined(DB4) || defined(DB3)
+        if (dberr == EINVAL) {
+            (void) (f->close)(f, 0);
+#if defined(DB4_1)
+            if (   db_create(&f, NULL, 0) != 0
+	       || (dberr = f->open(f, NULL, auth_dbpwfile, NULL, DB_BTREE, DB_RDONLY, 0664)) != 0) {
+#elif defined(DB3) || defined(DB4)
+            if (   db_create(&f, NULL, 0) != 0 
+#if DB_VERSION_MAJOR == 4 && DB_VERSION_MINOR > 0
+               || (dberr = f->open(f, NULL, auth_dbpwfile, NULL, DB_BTREE, DB_RDONLY, 0664)) != 0) {
+#else
+               || (dberr = f->open(f, auth_dbpwfile, NULL, DB_BTREE, DB_RDONLY, 0664)) != 0) {
+#endif
+#endif
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
+		        "could not open db auth file: %s", auth_dbpwfile);
+            return NULL;
+            }
+        }
+#else
 	ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
 		    "could not open db auth file: %s", auth_dbpwfile);
 	return NULL;
+#endif
     }
 
 #if defined(DB2) || defined(DB3) || defined(DB4)
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_auth_db.c.orig apache_1.3.33/src/modules/standard/mod_auth_db.c.orig
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_auth_db.c.orig	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/modules/standard/mod_auth_db.c.orig	Fri Feb 20 21:37:40 2004
@@ -0,0 +1,320 @@
+/* Copyright 1999-2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * mod_auth_db: authentication
+ * 
+ * Original work by Rob McCool & Brian Behlendorf.
+ * 
+ * Adapted to Apache by rst (mod_auth_dbm)
+ *
+ * Adapted for Berkeley DB by Andrew Cohen 
+ *
+ * mod_auth_db was based on mod_auth_dbm.
+ * 
+ * Warning, this is not a drop in replacement for mod_auth_dbm, 
+ * for people wanting to switch from dbm to Berkeley DB.
+ * It requires the use of AuthDBUserFile and AuthDBGroupFile
+ *           instead of   AuthDBMUserFile    AuthDBMGroupFile
+ *
+ * Also, in the configuration file you need to specify
+ *  db_auth_module rather than dbm_auth_module
+ *
+ * On some BSD systems (e.g. FreeBSD and NetBSD) dbm is automatically
+ * mapped to Berkeley DB. You can use either mod_auth_dbm or
+ * mod_auth_db. The latter makes it more obvious that it's Berkeley.
+ * On other platforms where you want to use the DB library you
+ * usually have to install it first. See http://www.sleepycat.com/
+ * for the distribution. The interface this module uses is the
+ * one from DB version 1.85 and 1.86, but DB version 2.x
+ * can also be used when compatibility mode is enabled.
+ *
+ * dirkx - Added Authoritative control to allow passing on to lower  
+ *         modules if and only if the user-id is not known to this
+ *         module. A known user with a faulty or absent password still
+ *         causes an AuthRequired. The default is 'Authoritative', i.e.
+ *         no control is passed along.
+ */
+
+#include "httpd.h"
+#include "http_config.h"
+#include "http_core.h"
+#include "http_log.h"
+#include "http_protocol.h"
+#include <db.h>
+
+#if defined(DB_VERSION_MAJOR)
+#if (DB_VERSION_MAJOR == 2)
+#define DB2
+#endif
+#if (DB_VERSION_MAJOR == 3)
+#define DB3
+#endif
+#if (DB_VERSION_MAJOR == 4)
+#define DB4
+#endif
+#endif
+
+typedef struct {
+
+    char *auth_dbpwfile;
+    char *auth_dbgrpfile;
+    int auth_dbauthoritative;
+} db_auth_config_rec;
+
+static void *create_db_auth_dir_config(pool *p, char *d)
+{
+    db_auth_config_rec *sec
+    = (db_auth_config_rec *) ap_pcalloc(p, sizeof(db_auth_config_rec));
+    sec->auth_dbpwfile = NULL;
+    sec->auth_dbgrpfile = NULL;
+    sec->auth_dbauthoritative = 1;	/* fortress is secure by default */
+    return sec;
+}
+
+static const char *set_db_slot(cmd_parms *cmd, void *offset, char *f, char *t)
+{
+    if (!t || strcmp(t, "db"))
+	return DECLINE_CMD;
+
+    return ap_set_file_slot(cmd, offset, f);
+}
+
+static const command_rec db_auth_cmds[] =
+{
+    {"AuthDBUserFile", ap_set_file_slot,
+     (void *) XtOffsetOf(db_auth_config_rec, auth_dbpwfile),
+     OR_AUTHCFG, TAKE1, NULL},
+    {"AuthDBGroupFile", ap_set_file_slot,
+     (void *) XtOffsetOf(db_auth_config_rec, auth_dbgrpfile),
+     OR_AUTHCFG, TAKE1, NULL},
+    {"AuthUserFile", set_db_slot,
+     (void *) XtOffsetOf(db_auth_config_rec, auth_dbpwfile),
+     OR_AUTHCFG, TAKE12, NULL},
+    {"AuthGroupFile", set_db_slot,
+     (void *) XtOffsetOf(db_auth_config_rec, auth_dbgrpfile),
+     OR_AUTHCFG, TAKE12, NULL},
+    {"AuthDBAuthoritative", ap_set_flag_slot,
+     (void *) XtOffsetOf(db_auth_config_rec, auth_dbauthoritative),
+     OR_AUTHCFG, FLAG,
+     "Set to 'no' to allow access control to be passed along to lower modules if the userID is not known to this module"},
+    {NULL}
+};
+
+module db_auth_module;
+
+static char *get_db_pw(request_rec *r, char *user, const char *auth_dbpwfile)
+{
+    DB *f;
+    DBT d, q;
+    char *pw = NULL;
+
+    memset(&d, 0, sizeof(d));
+    memset(&q, 0, sizeof(q));
+
+    q.data = user;
+    q.size = strlen(q.data);
+
+#if defined(DB3) || defined(DB4)
+    if (   db_create(&f, NULL, 0) != 0 
+#if DB_VERSION_MAJOR == 4 && DB_VERSION_MINOR > 0
+        || f->open(f, NULL, auth_dbpwfile, NULL, DB_HASH, DB_RDONLY, 0664) != 0) {
+#else
+        || f->open(f, auth_dbpwfile, NULL, DB_HASH, DB_RDONLY, 0664) != 0) {
+#endif
+#elif defined(DB2)
+    if (db_open(auth_dbpwfile, DB_HASH, DB_RDONLY, 0664, NULL, NULL, &f) != 0) {
+#else
+    if (!(f = dbopen(auth_dbpwfile, O_RDONLY, 0664, DB_HASH, NULL))) {
+#endif
+	ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
+		    "could not open db auth file: %s", auth_dbpwfile);
+	return NULL;
+    }
+
+#if defined(DB2) || defined(DB3) || defined(DB4)
+    if (!((f->get) (f, NULL, &q, &d, 0))) {
+#else
+    if (!((f->get) (f, &q, &d, 0))) {
+#endif
+	pw = ap_palloc(r->pool, d.size + 1);
+	strncpy(pw, d.data, d.size);
+	pw[d.size] = '\0';	/* Terminate the string */
+    }
+
+#if defined(DB2) || defined(DB3) || defined(DB4)
+    (f->close) (f, 0);
+#else
+    (f->close) (f);
+#endif
+    return pw;
+}
+
+/* We do something strange with the group file.  If the group file
+ * contains any : we assume the format is
+ *      key=username value=":"groupname [":"anything here is ignored]
+ * otherwise we now (0.8.14+) assume that the format is
+ *      key=username value=groupname
+ * The first allows the password and group files to be the same 
+ * physical DB file;   key=username value=password":"groupname[":"anything]
+ *
+ * mark@telescope.org, 22Sep95
+ */
+
+static char *get_db_grp(request_rec *r, char *user, const char *auth_dbgrpfile)
+{
+    char *grp_data = get_db_pw(r, user, auth_dbgrpfile);
+    char *grp_colon;
+    char *grp_colon2;
+
+    if (grp_data == NULL)
+	return NULL;
+
+    if ((grp_colon = strchr(grp_data, ':')) != NULL) {
+	grp_colon2 = strchr(++grp_colon, ':');
+	if (grp_colon2)
+	    *grp_colon2 = '\0';
+	return grp_colon;
+    }
+    return grp_data;
+}
+
+static int db_authenticate_basic_user(request_rec *r)
+{
+    db_auth_config_rec *sec =
+    (db_auth_config_rec *) ap_get_module_config(r->per_dir_config,
+					     &db_auth_module);
+    conn_rec *c = r->connection;
+    const char *sent_pw;
+    char *real_pw, *colon_pw;
+    char *invalid_pw;
+    int res;
+
+    if ((res = ap_get_basic_auth_pw(r, &sent_pw)))
+	return res;
+
+    if (!sec->auth_dbpwfile)
+	return DECLINED;
+
+    if (!(real_pw = get_db_pw(r, c->user, sec->auth_dbpwfile))) {
+	if (!(sec->auth_dbauthoritative))
+	    return DECLINED;
+	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+		    "DB user %s not found: %s", c->user, r->filename);
+	ap_note_basic_auth_failure(r);
+	return AUTH_REQUIRED;
+    }
+    /* Password is up to first : if exists */
+    colon_pw = strchr(real_pw, ':');
+    if (colon_pw) {
+	*colon_pw = '\0';
+    }
+    invalid_pw = ap_validate_password(sent_pw, real_pw);
+    if (invalid_pw != NULL) {
+	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+		      "DB user %s: authentication failure for \"%s\": %s",
+		      c->user, r->uri, invalid_pw);
+	ap_note_basic_auth_failure(r);
+	return AUTH_REQUIRED;
+    }
+    return OK;
+}
+
+/* Checking ID */
+
+static int db_check_auth(request_rec *r)
+{
+    db_auth_config_rec *sec =
+    (db_auth_config_rec *) ap_get_module_config(r->per_dir_config,
+					     &db_auth_module);
+    char *user = r->connection->user;
+    int m = r->method_number;
+
+    const array_header *reqs_arr = ap_requires(r);
+    require_line *reqs = reqs_arr ? (require_line *) reqs_arr->elts : NULL;
+
+    register int x;
+    const char *t;
+    char *w;
+
+    if (!sec->auth_dbgrpfile)
+	return DECLINED;
+    if (!reqs_arr)
+	return DECLINED;
+
+    for (x = 0; x < reqs_arr->nelts; x++) {
+
+	if (!(reqs[x].method_mask & (1 << m)))
+	    continue;
+
+	t = reqs[x].requirement;
+	w = ap_getword_white(r->pool, &t);
+
+	if (!strcmp(w, "group") && sec->auth_dbgrpfile) {
+	    const char *orig_groups, *groups;
+	    char *v;
+
+	    if (!(groups = get_db_grp(r, user, sec->auth_dbgrpfile))) {
+		if (!(sec->auth_dbauthoritative))
+		    return DECLINED;
+		ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+			    "user %s not in DB group file %s: %s",
+			    user, sec->auth_dbgrpfile, r->filename);
+		ap_note_basic_auth_failure(r);
+		return AUTH_REQUIRED;
+	    }
+	    orig_groups = groups;
+	    while (t[0]) {
+		w = ap_getword_white(r->pool, &t);
+		groups = orig_groups;
+		while (groups[0]) {
+		    v = ap_getword(r->pool, &groups, ',');
+		    if (!strcmp(v, w))
+			return OK;
+		}
+	    }
+	    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+			"user %s not in right group: %s", user, r->filename);
+	    ap_note_basic_auth_failure(r);
+	    return AUTH_REQUIRED;
+	}
+    }
+
+    return DECLINED;
+}
+
+
+module db_auth_module =
+{
+    STANDARD_MODULE_STUFF,
+    NULL,			/* initializer */
+    create_db_auth_dir_config,	/* dir config creater */
+    NULL,			/* dir merger --- default is to override */
+    NULL,			/* server config */
+    NULL,			/* merge server config */
+    db_auth_cmds,		/* command table */
+    NULL,			/* handlers */
+    NULL,			/* filename translation */
+    db_authenticate_basic_user,	/* check_user_id */
+    db_check_auth,		/* check auth */
+    NULL,			/* check access */
+    NULL,			/* type_checker */
+    NULL,			/* fixups */
+    NULL,			/* logger */
+    NULL,			/* header parser */
+    NULL,			/* child_init */
+    NULL,			/* child_exit */
+    NULL			/* post read-request */
+};
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_auth_db.module apache_1.3.33/src/modules/standard/mod_auth_db.module
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_auth_db.module	Tue Oct 16 11:12:02 2001
+++ apache_1.3.33/src/modules/standard/mod_auth_db.module	Mon Jul 18 15:22:19 2005
@@ -3,6 +3,11 @@
     DB_VERSION=''
     DB_LIB=''
     if ./helpers/TestCompile func db_create; then
+    	DB_VERSION='Berkeley-DB/4.x'
+    elif ./helpers/TestCompile lib db; then
+        DB_VERSION='Berkeley-DB/4.x'
+	DB_LIB='-ldb'
+    elif ./helpers/TestCompile func db_create; then
         DB_VERSION='Berkeley-DB/3.x'
     elif ./helpers/TestCompile lib db db_create; then
         DB_VERSION='Berkeley-DB/3.x'
@@ -38,7 +43,7 @@
             echo "      using $DB_VERSION for mod_auth_db (-lc)"
         fi
     else
-        echo "Error: None of Berkeley-DB 1.x, 2.x or 3.x libraries found."
+        echo "Error: None of Berkeley-DB 1.x, 2.x, 3.x or 4.x libraries found."
         echo "       Either disable mod_auth_db or provide us with the paths"
         echo "       to the Berkeley-DB include and library files."
         echo "       (Hint: INCLUDES, LDFLAGS, LIBS)"
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_auth_dbm.c apache_1.3.33/src/modules/standard/mod_auth_dbm.c
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_auth_dbm.c	Fri Feb 20 21:37:40 2004
+++ apache_1.3.33/src/modules/standard/mod_auth_dbm.c	Mon Jul 18 15:22:18 2005
@@ -38,7 +38,14 @@
 #define dbm_fetch sdbm_fetch
 #define dbm_close sdbm_close
 #else
+#ifndef DB_DBM_HSEARCH
+#define DB_DBM_HSEARCH 0
+#endif
+#if DB_DBM_HSEARCH != 0
+#include <db.h>
+#else
 #include <ndbm.h>
+#endif
 #endif
 
 /*
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_auth_dbm.c.orig apache_1.3.33/src/modules/standard/mod_auth_dbm.c.orig
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_auth_dbm.c.orig	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/modules/standard/mod_auth_dbm.c.orig	Fri Feb 20 21:37:40 2004
@@ -0,0 +1,295 @@
+/* Copyright 1999-2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * http_auth: authentication
+ * 
+ * Rob McCool & Brian Behlendorf.
+ * 
+ * Adapted to Apache by rst.
+ *
+ * dirkx - Added Authoritative control to allow passing on to lower  
+ *         modules if and only if the user-id is not known to this
+ *         module. A known user with a faulty or absent password still
+ *         causes an AuthRequired. The default is 'Authoritative', i.e.
+ *         no control is passed along.
+ */
+
+#include "httpd.h"
+#include "http_config.h"
+#include "http_core.h"
+#include "http_log.h"
+#include "http_protocol.h"
+#if (defined(WIN32) || defined(NETWARE))
+#include <sdbm.h>
+#define dbm_open sdbm_open
+#define dbm_fetch sdbm_fetch
+#define dbm_close sdbm_close
+#else
+#include <ndbm.h>
+#endif
+
+/*
+ * Module definition information - the part between the -START and -END
+ * lines below is used by Configure. This could be stored in a separate
+ * instead.
+ *
+ * MODULE-DEFINITION-START
+ * Name: dbm_auth_module
+ * ConfigStart
+    . ./helpers/find-dbm-lib
+ * ConfigEnd
+ * MODULE-DEFINITION-END
+ */
+
+typedef struct {
+
+    char *auth_dbmpwfile;
+    char *auth_dbmgrpfile;
+    int auth_dbmauthoritative;
+
+} dbm_auth_config_rec;
+
+static void *create_dbm_auth_dir_config(pool *p, char *d)
+{
+    dbm_auth_config_rec *sec
+    = (dbm_auth_config_rec *) ap_pcalloc(p, sizeof(dbm_auth_config_rec));
+
+    sec->auth_dbmpwfile = NULL;
+    sec->auth_dbmgrpfile = NULL;
+    sec->auth_dbmauthoritative = 1;	/* fortress is secure by default */
+
+    return sec;
+}
+
+static const char *set_dbm_slot(cmd_parms *cmd, void *offset, char *f, char *t)
+{
+    if (!t || strcmp(t, "dbm"))
+	return DECLINE_CMD;
+
+    return ap_set_file_slot(cmd, offset, f);
+}
+
+static const command_rec dbm_auth_cmds[] =
+{
+    {"AuthDBMUserFile", ap_set_file_slot,
+     (void *) XtOffsetOf(dbm_auth_config_rec, auth_dbmpwfile),
+     OR_AUTHCFG, TAKE1, NULL},
+    {"AuthDBMGroupFile", ap_set_file_slot,
+     (void *) XtOffsetOf(dbm_auth_config_rec, auth_dbmgrpfile),
+     OR_AUTHCFG, TAKE1, NULL},
+    {"AuthUserFile", set_dbm_slot,
+     (void *) XtOffsetOf(dbm_auth_config_rec, auth_dbmpwfile),
+     OR_AUTHCFG, TAKE12, NULL},
+    {"AuthGroupFile", set_dbm_slot,
+     (void *) XtOffsetOf(dbm_auth_config_rec, auth_dbmgrpfile),
+     OR_AUTHCFG, TAKE12, NULL},
+    {"AuthDBMAuthoritative", ap_set_flag_slot,
+     (void *) XtOffsetOf(dbm_auth_config_rec, auth_dbmauthoritative),
+     OR_AUTHCFG, FLAG, "Set to 'no' to allow access control to be passed along to lower modules, if the UserID is not known in this module"},
+    {NULL}
+};
+
+module MODULE_VAR_EXPORT dbm_auth_module;
+
+static char *get_dbm_pw(request_rec *r, char *user, char *auth_dbmpwfile)
+{
+    DBM *f;
+    datum d, q;
+    char *pw = NULL;
+
+    q.dptr = user;
+#ifndef NETSCAPE_DBM_COMPAT
+    q.dsize = strlen(q.dptr);
+#else
+    q.dsize = strlen(q.dptr) + 1;
+#endif
+
+
+    if (!(f = dbm_open(auth_dbmpwfile, O_RDONLY, 0664))) {
+	ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
+		    "could not open dbm auth file: %s", auth_dbmpwfile);
+	return NULL;
+    }
+
+    d = dbm_fetch(f, q);
+
+    if (d.dptr) {
+	pw = ap_palloc(r->pool, d.dsize + 1);
+	strncpy(pw, d.dptr, d.dsize);
+	pw[d.dsize] = '\0';	/* Terminate the string */
+    }
+
+    dbm_close(f);
+    return pw;
+}
+
+/* We do something strange with the group file.  If the group file
+ * contains any : we assume the format is
+ *      key=username value=":"groupname [":"anything here is ignored]
+ * otherwise we now (0.8.14+) assume that the format is
+ *      key=username value=groupname
+ * The first allows the password and group files to be the same 
+ * physical DBM file;   key=username value=password":"groupname[":"anything]
+ *
+ * mark@telescope.org, 22Sep95
+ */
+
+static char *get_dbm_grp(request_rec *r, char *user, char *auth_dbmgrpfile)
+{
+    char *grp_data = get_dbm_pw(r, user, auth_dbmgrpfile);
+    char *grp_colon;
+    char *grp_colon2;
+
+    if (grp_data == NULL)
+	return NULL;
+
+    if ((grp_colon = strchr(grp_data, ':')) != NULL) {
+	grp_colon2 = strchr(++grp_colon, ':');
+	if (grp_colon2)
+	    *grp_colon2 = '\0';
+	return grp_colon;
+    }
+    return grp_data;
+}
+
+static int dbm_authenticate_basic_user(request_rec *r)
+{
+    dbm_auth_config_rec *sec =
+    (dbm_auth_config_rec *) ap_get_module_config(r->per_dir_config,
+					      &dbm_auth_module);
+    conn_rec *c = r->connection;
+    const char *sent_pw;
+    char *real_pw, *colon_pw;
+    char *invalid_pw;
+    int res;
+
+    if ((res = ap_get_basic_auth_pw(r, &sent_pw)))
+	return res;
+
+    if (!sec->auth_dbmpwfile)
+	return DECLINED;
+
+    if (!(real_pw = get_dbm_pw(r, c->user, sec->auth_dbmpwfile))) {
+	if (!(sec->auth_dbmauthoritative))
+	    return DECLINED;
+	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+		    "DBM user %s not found: %s", c->user, r->filename);
+	ap_note_basic_auth_failure(r);
+	return AUTH_REQUIRED;
+    }
+    /* Password is up to first : if exists */
+    colon_pw = strchr(real_pw, ':');
+    if (colon_pw) {
+	*colon_pw = '\0';
+    }
+    invalid_pw = ap_validate_password(sent_pw, real_pw);
+    if (invalid_pw != NULL) {
+	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+		      "DBM user %s: authentication failure for \"%s\": %s",
+		      c->user, r->uri, invalid_pw);
+	ap_note_basic_auth_failure(r);
+	return AUTH_REQUIRED;
+    }
+    return OK;
+}
+
+/* Checking ID */
+
+static int dbm_check_auth(request_rec *r)
+{
+    dbm_auth_config_rec *sec =
+    (dbm_auth_config_rec *) ap_get_module_config(r->per_dir_config,
+					      &dbm_auth_module);
+    char *user = r->connection->user;
+    int m = r->method_number;
+
+    const array_header *reqs_arr = ap_requires(r);
+    require_line *reqs = reqs_arr ? (require_line *) reqs_arr->elts : NULL;
+
+    register int x;
+    const char *t;
+    char *w;
+
+    if (!sec->auth_dbmgrpfile)
+	return DECLINED;
+    if (!reqs_arr)
+	return DECLINED;
+
+    for (x = 0; x < reqs_arr->nelts; x++) {
+
+	if (!(reqs[x].method_mask & (1 << m)))
+	    continue;
+
+	t = reqs[x].requirement;
+	w = ap_getword_white(r->pool, &t);
+
+	if (!strcmp(w, "group") && sec->auth_dbmgrpfile) {
+	    const char *orig_groups, *groups;
+	    char *v;
+
+	    if (!(groups = get_dbm_grp(r, user, sec->auth_dbmgrpfile))) {
+		if (!(sec->auth_dbmauthoritative))
+		    return DECLINED;
+		ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+			    "user %s not in DBM group file %s: %s",
+			    user, sec->auth_dbmgrpfile, r->filename);
+		ap_note_basic_auth_failure(r);
+		return AUTH_REQUIRED;
+	    }
+	    orig_groups = groups;
+	    while (t[0]) {
+		w = ap_getword_white(r->pool, &t);
+		groups = orig_groups;
+		while (groups[0]) {
+		    v = ap_getword(r->pool, &groups, ',');
+		    if (!strcmp(v, w))
+			return OK;
+		}
+	    }
+	    ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+			"user %s not in right group: %s",
+			user, r->filename);
+	    ap_note_basic_auth_failure(r);
+	    return AUTH_REQUIRED;
+	}
+    }
+
+    return DECLINED;
+}
+
+
+module MODULE_VAR_EXPORT dbm_auth_module =
+{
+    STANDARD_MODULE_STUFF,
+    NULL,			/* initializer */
+    create_dbm_auth_dir_config,	/* dir config creater */
+    NULL,			/* dir merger --- default is to override */
+    NULL,			/* server config */
+    NULL,			/* merge server config */
+    dbm_auth_cmds,		/* command table */
+    NULL,			/* handlers */
+    NULL,			/* filename translation */
+    dbm_authenticate_basic_user,	/* check_user_id */
+    dbm_check_auth,		/* check auth */
+    NULL,			/* check access */
+    NULL,			/* type_checker */
+    NULL,			/* fixups */
+    NULL,			/* logger */
+    NULL,			/* header parser */
+    NULL,			/* child_init */
+    NULL,			/* child_exit */
+    NULL			/* post read-request */
+};
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_autoindex.c apache_1.3.33/src/modules/standard/mod_autoindex.c
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_autoindex.c	Fri Feb 20 21:37:40 2004
+++ apache_1.3.33/src/modules/standard/mod_autoindex.c	Mon Jul 18 15:22:19 2005
@@ -20,6 +20,7 @@
  * 3/23/93
  * 
  * Adapted to Apache by rst.
+ * StudlyIndexing by Johnie Ingram <johnie@netgod.net>
  */
 
 #include "httpd.h"
@@ -56,6 +57,8 @@
 #define FOLDERS_FIRST 512
 #define TRACK_MODIFIED 1024
 #define SORT_NOCASE 2048
+#define STUDLY_INDEXING 4096
+#define INDEXOPT_INDEXES 8192
 
 #define K_PAD 1
 #define K_NOPAD 0
@@ -120,6 +123,17 @@
     array_header *ign_list;
     array_header *hdr_list;
     array_header *rdme_list;
+    array_header *side_list;
+    array_header *main_list;
+    array_header *ftr_list;
+
+    char *body_col;
+    char *text_col;
+    char *hdr_col;
+    char *rdme_col;
+    char *side_col;
+    char *main_col;
+    char *ftr_col;
 
 } autoindex_config_rec;
 
@@ -153,11 +167,20 @@
  * We include the DOCTYPE because we may be using features therefrom (i.e.,
  * HEIGHT and WIDTH attributes on the icons if we're FancyIndexing).
  */
-static void emit_preamble(request_rec *r, char *title)
+static void emit_preamble(request_rec *r, char *title,
+                          autoindex_config_rec *autoindex_conf)
 {
-    ap_rvputs(r, DOCTYPE_HTML_3_2,
+    ap_rvputs(r, DOCTYPE_HTML_4_0T,
 	      "<HTML>\n <HEAD>\n  <TITLE>Index of ", title,
-	      "</TITLE>\n </HEAD>\n <BODY>\n", NULL);
+	      "</TITLE>\n <META NAME=\"generator\", CONTENT=\"mod_autoindex\"> "
+	      "</HEAD>\n <BODY bgcolor=\"",
+              autoindex_conf->body_col ?: "#ffffff", "\" text=\"",
+              autoindex_conf->text_col ?: "#000000", "\"", NULL);
+    if (autoindex_conf->opts & STUDLY_INDEXING) {
+	ap_rvputs(r, " leftmargin=\"0\" topmargin=\"0\" \n "
+		"marginwidth=\"0\" marginheight=\"0\"", NULL);
+    }
+    ap_rputs(">\n\n", r);
 }
 
 static void push_item(array_header *arr, char *type, char *to, char *path,
@@ -297,6 +320,27 @@
     return NULL;
 }
 
+static const char *add_sidebar(cmd_parms *cmd, void *d, char *name)
+{
+    push_item(((autoindex_config_rec *) d)->side_list, 0, NULL, cmd->path,
+	      name);
+    return NULL;
+}
+
+static const char *add_body(cmd_parms *cmd, void *d, char *name)
+{
+    push_item(((autoindex_config_rec *) d)->main_list, 0, NULL, cmd->path,
+	      name);
+    return NULL;
+}
+
+static const char *add_footer(cmd_parms *cmd, void *d, char *name)
+{
+    push_item(((autoindex_config_rec *) d)->ftr_list, 0, NULL, cmd->path,
+	      name);
+    return NULL;
+}
+
 /* A legacy directive, FancyIndexing is superseded by the IndexOptions
  * keyword.  But for compatibility..
  */
@@ -342,6 +386,12 @@
 	if (!strcasecmp(w, "FancyIndexing")) {
 	    option = FANCY_INDEXING;
 	}
+	else if (!strcasecmp(w, "StudlyIndexing")) {
+            /* automatic FancyIndexing on, NameWidth=*, etc. */
+	    option = STUDLY_INDEXING + FANCY_INDEXING
+              + ICONS_ARE_LINKS + SUPPRESS_DESC;
+            d_cfg->name_adjust = K_ADJUST;
+	}
 	else if (!strcasecmp(w, "IconsAreLinks")) {
 	    option = ICONS_ARE_LINKS;
 	}
@@ -363,16 +413,19 @@
         else if (!strcasecmp(w, "SuppressColumnSorting")) {
             option = SUPPRESS_COLSORT;
 	}
-        else if (!strcasecmp(w, "FoldersFirst")) {
-            option = FOLDERS_FIRST;
+	else if (!strcasecmp(w, "FoldersFirst")) {
+	    option = FOLDERS_FIRST;
 	}
 	else if (!strcasecmp(w, "TrackModified")) {
-            option = TRACK_MODIFIED;
+	    option = TRACK_MODIFIED;
 	}
 	else if (!strcasecmp(w, "IgnoreCase")) {
-            option = SORT_NOCASE;
+	    option = SORT_NOCASE;
+	}
+	else if (!strcasecmp(w, "Indexes")) {
+            option = INDEXOPT_INDEXES;
 	}
-        else if (!strcasecmp(w, "None")) {
+	else if (!strcasecmp(w, "None")) {
 	    if (action != '\0') {
 		return "Cannot combine '+' or '-' with 'None' keyword";
 	    }
@@ -458,7 +511,49 @@
 		d_cfg->desc_adjust = K_NOADJUST;
 	    }
 	}
-        else {
+	else if (!strncasecmp(w, "BodyColor=", 10)) {
+	    if (action == '-') {
+		return "Cannot combine '-' with BodyColor=#xxxxxx";
+	    }
+	    d_cfg->body_col = ap_pstrdup(d_cfg->desc_list->pool, &w[10]);
+	}
+	else if (!strncasecmp(w, "TextColor=", 10)) {
+	    if (action == '-') {
+		return "Cannot combine '-' with TextColor=#xxxxxx";
+	    }
+	    d_cfg->text_col = ap_pstrdup(d_cfg->desc_list->pool, &w[10]);
+	}
+	else if (!strncasecmp(w, "HeaderColor=", 12)) {
+	    if (action == '-') {
+		return "Cannot combine '-' with HeaderColor=#xxxxxx";
+	    }
+	    d_cfg->hdr_col = ap_pstrdup(d_cfg->desc_list->pool, &w[12]);
+	}
+	else if (!strncasecmp(w, "ReadmeColor=", 12)) {
+	    if (action == '-') {
+		return "Cannot combine '-' with ReadmeColor=#xxxxxx";
+	    }
+	    d_cfg->rdme_col = ap_pstrdup(d_cfg->desc_list->pool, &w[12]);
+	}
+	else if (!strncasecmp(w, "SidebarColor=", 13)) {
+	    if (action == '-') {
+		return "Cannot combine '-' with SidebarColor=#xxxxxx";
+	    }
+	    d_cfg->side_col = ap_pstrdup(d_cfg->desc_list->pool, &w[13]);
+	}
+	else if (!strncasecmp(w, "MainColor=", 10)) {
+	    if (action == '-') {
+		return "Cannot combine '-' with MainColor=#xxxxxx";
+	    }
+	    d_cfg->main_col = ap_pstrdup(d_cfg->desc_list->pool, &w[10]);
+	}
+	else if (!strncasecmp(w, "FooterColor=", 12)) {
+	    if (action == '-') {
+		return "Cannot combine '-' with FooterColor=#xxxxxx";
+	    }
+	    d_cfg->ftr_col = ap_pstrdup(d_cfg->desc_list->pool, &w[12]);
+	}
+	else {
 	    return "Invalid directory indexing option";
 	}
 	if (action == '\0') {
@@ -552,6 +647,9 @@
      "Descriptive text followed by one or more filenames"},
     {"HeaderName", add_header, NULL, DIR_CMD_PERMS, TAKE1, "a filename"},
     {"ReadmeName", add_readme, NULL, DIR_CMD_PERMS, TAKE1, "a filename"},
+    {"SidebarName", add_sidebar, NULL, DIR_CMD_PERMS, TAKE1, "a filename"},
+    {"BodyName", add_body, NULL, DIR_CMD_PERMS, TAKE1, "a filename"},
+    {"FooterName", add_footer, NULL, DIR_CMD_PERMS, TAKE1, "a filename"},
     {"FancyIndexing", fancy_indexing, NULL, DIR_CMD_PERMS, FLAG,
      "Limited to 'on' or 'off' (superseded by IndexOptions FancyIndexing)"},
     {"DefaultIcon", ap_set_string_slot,
@@ -577,6 +675,9 @@
     new->ign_list = ap_make_array(p, 4, sizeof(struct item));
     new->hdr_list = ap_make_array(p, 4, sizeof(struct item));
     new->rdme_list = ap_make_array(p, 4, sizeof(struct item));
+    new->side_list = ap_make_array(p, 4, sizeof(struct item));
+    new->main_list = ap_make_array(p, 4, sizeof(struct item));
+    new->ftr_list = ap_make_array(p, 4, sizeof(struct item));
     new->opts = 0;
     new->incremented_opts = 0;
     new->decremented_opts = 0;
@@ -603,6 +704,9 @@
     new->desc_list = ap_append_arrays(p, add->desc_list, base->desc_list);
     new->icon_list = ap_append_arrays(p, add->icon_list, base->icon_list);
     new->rdme_list = ap_append_arrays(p, add->rdme_list, base->rdme_list);
+    new->side_list = ap_append_arrays(p, add->side_list, base->side_list);
+    new->main_list = ap_append_arrays(p, add->main_list, base->main_list);
+    new->ftr_list = ap_append_arrays(p, add->ftr_list, base->ftr_list);
     if (add->opts & NO_OPTIONS) {
 	/*
 	 * If the current directory says 'no options' then we also
@@ -672,6 +776,22 @@
 
     new->default_order = (add->default_order != NULL)
 	? add->default_order : base->default_order;
+
+    new->body_col = (add->body_col != NULL)
+	? add->body_col : base->body_col;
+    new->text_col = (add->text_col != NULL)
+	? add->text_col : base->text_col;
+    new->hdr_col = (add->hdr_col != NULL)
+	? add->hdr_col : base->hdr_col;
+    new->rdme_col = (add->rdme_col != NULL)
+	? add->rdme_col : base->rdme_col;
+    new->side_col = (add->side_col != NULL)
+	? add->side_col : base->side_col;
+    new->main_col = (add->main_col != NULL)
+	? add->main_col : base->main_col;
+    new->ftr_col = (add->ftr_col != NULL)
+	? add->ftr_col : base->ftr_col;
+
     return new;
 }
 
@@ -746,7 +866,10 @@
 #define find_icon(d,p,t) find_item(p,d->icon_list,t)
 #define find_alt(d,p,t) find_item(p,d->alt_list,t)
 #define find_header(d,p) find_item(p,d->hdr_list,0)
+#define find_sidebar(d,p) find_item(p,d->side_list,0)
 #define find_readme(d,p) find_item(p,d->rdme_list,0)
+#define find_main(d,p) find_item(p,d->main_list,0)
+#define find_footer(d,p) find_item(p,d->ftr_list,0)
 
 static char *find_default_icon(autoindex_config_rec *d, char *bogus_name)
 {
@@ -897,12 +1020,13 @@
 /*
  * emit a plain text file
  */
-static void do_emit_plain(request_rec *r, FILE *f)
+static void do_emit_plain(request_rec *r, FILE *f, int autoindex_opts)
 {
     char buf[IOBUFSIZE + 1];
     int i, n, c, ch;
 
-    ap_rputs("<PRE>\n", r);
+    if (! (autoindex_opts & STUDLY_INDEXING))
+      ap_rputs("<PRE>\n", r);
     while (!feof(f)) {
 	do {
 	    n = fread(buf, sizeof(char), IOBUFSIZE, f);
@@ -934,7 +1058,50 @@
 	    c = i + 1;
 	}
     }
-    ap_rputs("</PRE>\n", r);
+    if (! (autoindex_opts & STUDLY_INDEXING))
+      ap_rputs("</PRE>\n", r);
+}
+
+/*
+ * If there's a file, send a subrequest to look for it.  If it's
+ * found and a text file, handle it and return 0, otherwise return -1.
+ */
+static int do_emit_fancy(request_rec *r, const char *fname, int autoindex_opts)
+{
+    FILE *f;
+    request_rec *rr = NULL;
+
+    if ((fname != NULL)
+	&& (rr = ap_sub_req_lookup_uri(fname, r))
+        && (rr->status == HTTP_OK)
+	&& (rr->filename != NULL)
+	&& S_ISREG(rr->finfo.st_mode)) {
+	/*
+	 * Check for the two specific cases we allow: text/html and
+	 * text/anything-else.  The former is allowed to be processed for
+	 * SSIs.
+	 */
+	if (rr->content_type != NULL) {
+	    if (!strcasecmp(ap_field_noparam(r->pool, rr->content_type),
+			    "text/html")) {
+		if (ap_run_sub_req(rr) == OK) {
+		    /* worked... */
+                    return 0;
+		}
+	    }
+	    else if (!strncasecmp("text/", rr->content_type, 5)) {
+		if ((f = ap_pfopen(r->pool, rr->filename, "r")) != 0) {
+		    do_emit_plain(r, f, autoindex_opts);
+		    ap_pfclose(r->pool, f);
+		    return 0;
+		}
+	    }
+	}
+    }
+    if (rr != NULL) {
+	ap_destroy_sub_req(rr);
+    }
+    return -1;
 }
 
 /* See mod_include */
@@ -950,8 +1117,9 @@
  * instead of a text document, meaning nothing will be displayed, but
  * oh well.
  */
-static void emit_head(request_rec *r, char *header_fname, int suppress_amble,
-		      char *title)
+static void emit_head(request_rec *r, char *header_fname, 
+                      autoindex_config_rec *autoindex_conf,
+                      int autoindex_opts, char *title)
 {
     FILE *f;
     request_rec *rr = NULL;
@@ -992,8 +1160,8 @@
 		emit_amble = 0;
 		emit_H1 = 0;
 
-		if (! suppress_amble) {
-		    emit_preamble(r, title);
+		if (! (autoindex_opts & SUPPRESS_PREAMBLE)) {
+		    emit_preamble(r, title, autoindex_conf);
 		}
 
 		/* See mod_include */
@@ -1007,7 +1175,7 @@
 		 */
 		if (ap_run_sub_req(rr) != OK) {
 		    /* It didn't work */
-		    emit_amble = suppress_amble;
+		    emit_amble = autoindex_opts & SUPPRESS_PREAMBLE;
 		    emit_H1 = 1;
 		}
 		ap_table_unset(r->notes, PARENT_STRING);	/* cleanup */
@@ -1020,9 +1188,9 @@
 		 * where it belongs.
 		 */
 		if ((f = ap_pfopen(r->pool, rr->filename, "r")) != 0) {
-		    emit_preamble(r, title);
+		    emit_preamble(r, title, autoindex_conf);
 		    emit_amble = 0;
-		    do_emit_plain(r, f);
+		    do_emit_plain(r, f, autoindex_opts);
 		    ap_pfclose(r->pool, f);
 		    emit_H1 = 0;
 		}
@@ -1042,10 +1210,28 @@
     }
 
     if (emit_amble) {
-	emit_preamble(r, title);
+	emit_preamble(r, title, autoindex_conf);
     }
+
+    if (autoindex_opts & STUDLY_INDEXING) {
+	ap_rvputs(r, "<TABLE cellpadding=\"5\" cellspacing=\"5\" "
+              "width=\"100%\">\n<tbody>\n", NULL);
+    }
+
     if (emit_H1) {
-	ap_rvputs(r, "<H1>Index of ", title, "</H1>\n", NULL);
+	if (autoindex_opts & STUDLY_INDEXING)
+	    ap_rvputs(r, "\n<TR valign=\"top\">\n"
+		    "<TD class=\"header\" bgcolor=\"",
+		    autoindex_conf->hdr_col ?: "#ffffff",
+		    "\" colspan=\"2\">\n", NULL);
+	ap_rputs("<TABLE><TR><TD bgcolor=\"#ffffff\" "
+		"class=\"title\">\n", r);
+	ap_rvputs(r, "<FONT size=\"+3\" "
+		"face=\"Helvetica,Arial,sans-serif\">\n<B>Index of ",
+		title, "</B></FONT>\n", NULL);
+	ap_rputs("\n</TD></TR></TABLE>", r);
+	if (autoindex_opts & STUDLY_INDEXING)
+	    ap_rvputs(r, "</TD>\n</TR>\n", NULL);
     }
     if (rr != NULL) {
 	ap_destroy_sub_req(rr);
@@ -1062,7 +1248,8 @@
  * instead of a text document, meaning nothing will be displayed, but
  * oh well.
  */
-static void emit_tail(request_rec *r, char *readme_fname, int suppress_amble)
+static void emit_tail(request_rec *r, char *readme_fname,
+                      autoindex_config_rec *autoindex_conf, int autoindex_opts)
 {
     FILE *f;
     request_rec *rr = NULL;
@@ -1107,7 +1294,7 @@
 		if (ap_run_sub_req(rr) == OK) {
 		    /* worked... */
 		    suppress_sig = 1;
-		    suppress_post = suppress_amble;
+		    suppress_post = autoindex_opts & SUPPRESS_PREAMBLE;
 		}
 		ap_table_unset(r->notes, PARENT_STRING);	/* cleanup */
 	    }
@@ -1116,7 +1303,7 @@
 		 * If we can open the file, suppress the signature.
 		 */
 		if ((f = ap_pfopen(r->pool, rr->filename, "r")) != 0) {
-		    do_emit_plain(r, f);
+		    do_emit_plain(r, f, autoindex_opts & STUDLY_INDEXING);
 		    ap_pfclose(r->pool, f);
 		    suppress_sig = 1;
 		}
@@ -1135,7 +1322,21 @@
         ap_table_setn(hdrs, "Accept-Encoding", r_accept_enc);
     }
 
+    if (autoindex_opts & STUDLY_INDEXING && !suppress_post) {
+	ap_rvputs(r, "\n<TR valign=\"top\">\n<TD class=\"footer\" "
+		"colspan=\"2\" bgcolor=\"",
+		autoindex_conf->ftr_col ?: "#ffffff", "\">\n", NULL);
+	if (do_emit_fancy (r, find_footer(autoindex_conf, r),
+				autoindex_opts) == 0) {
+	    suppress_sig = 1;
+	}
+	ap_rputs("</TD>\n</TR>\n\n</TBODY></TABLE>\n<P>\n", r);
+    }
     if (!suppress_sig) {
+	if (autoindex_opts & STUDLY_INDEXING)
+	    ap_rputs ("<BR><IMG src=\"/icons/linux-pengo-small.gif\"\n"
+			"width=\"110\" height=\"44\" align=\"right\""
+			"alt=\"\">", r);
 	ap_rputs(ap_psignature("", r), r);
     }
     if (!suppress_post) {
@@ -1368,6 +1569,11 @@
     char *name_scratch;
     char *pad_scratch;
 
+    if (autoindex_opts & STUDLY_INDEXING) {
+        if (do_emit_fancy (r, find_main(d, r), autoindex_opts) == 0)
+          return;
+    }
+
     if (name[0] == '\0') {
 	name = "/";
     }
@@ -1400,7 +1606,8 @@
     if (autoindex_opts & FANCY_INDEXING) {
 	ap_rputs("<PRE>", r);
 	if ((tp = find_default_icon(d, "^^BLANKICON^^"))) {
-	    ap_rvputs(r, "<IMG SRC=\"", ap_escape_html(scratch, tp),
+	    ap_rvputs(r, "<IMG border=\"0\" src=\"",
+                      ap_escape_html(scratch, tp),
 		   "\" ALT=\"     \"", NULL);
 	    if (d->icon_width && d->icon_height) {
 		ap_rprintf
@@ -1432,7 +1639,7 @@
             emit_link(r, "Description", K_DESC, keyid, direction,
                       static_columns);
 	}
-	ap_rputs("\n<HR>\n", r);
+	ap_rputs("\n<HR noshade align=\"left\" width=\"80%\">\n", r);
     }
     else {
 	ap_rputs("<UL>", r);
@@ -1464,7 +1671,7 @@
 		ap_rvputs(r, "<A HREF=\"", anchor, "\">", NULL);
 	    }
 	    if ((ar[x]->icon) || d->default_icon) {
-		ap_rvputs(r, "<IMG SRC=\"",
+		ap_rvputs(r, "<IMG border=\"0\" src=\"", 
 			  ap_escape_html(scratch,
 					 ar[x]->icon ? ar[x]->icon
 					             : d->default_icon),
@@ -1674,7 +1881,7 @@
 	*title_endp-- = '\0';
     }
 
-    emit_head(r, find_header(autoindex_conf, r),
+    emit_head(r, find_header(autoindex_conf, r), autoindex_conf,
 	      autoindex_opts & SUPPRESS_PREAMBLE, title_name);
 
     /*
@@ -1736,15 +1943,27 @@
 	qsort((void *) ar, num_ent, sizeof(struct ent *),
 	      (int (*)(const void *, const void *)) dsortf);
     }
+    if (autoindex_opts & STUDLY_INDEXING) {
+	ap_rputs("\n<TR valign=\"top\">\n", r);
+	ap_rvputs(r, "\n<TD class=\"sidebar\" bgcolor=\"",
+		  autoindex_conf->side_col ?: "#ffffff",
+		  "\" width=\"5%\">\n", NULL);
+	do_emit_fancy (r, find_sidebar(autoindex_conf, r), autoindex_opts);
+	ap_rputs("</TD>\n", r);
+	ap_rvputs(r, "\n<TD class=\"body\" bgcolor=\"",
+		  autoindex_conf->main_col ?: "#ffffff", "\">\n", NULL);
+    }
     output_directories(ar, num_ent, autoindex_conf, r, autoindex_opts, keyid,
 		       direction);
     ap_pclosedir(r->pool, d);
 
-    if (autoindex_opts & FANCY_INDEXING) {
-	ap_rputs("<HR>\n", r);
+    if (autoindex_opts & STUDLY_INDEXING) {
+	ap_rputs("</TD class=\"body\">\n\n</TR>\n", r);
+    }
+    else if (autoindex_opts & FANCY_INDEXING) {
+	ap_rputs("<HR noshade align=\"left\" width=\"80%\">\n", r);
     }
-    emit_tail(r, find_readme(autoindex_conf, r),
-	      autoindex_opts & SUPPRESS_PREAMBLE);
+    emit_tail(r, find_readme(autoindex_conf, r), autoindex_conf, autoindex_opts);
 
     ap_kill_timeout(r);
     return 0;
@@ -1755,7 +1974,7 @@
 static int handle_autoindex(request_rec *r)
 {
     autoindex_config_rec *d;
-    int allow_opts = ap_allow_options(r);
+    int opt_indexes = ap_allow_options(r) & OPT_INDEXES;
 
     d = (autoindex_config_rec *) ap_get_module_config(r->per_dir_config,
 						      &autoindex_module);
@@ -1766,8 +1985,12 @@
     }
 
     /* OK, nothing easy.  Trot out the heavy artillery... */
+    if ((d->incremented_opts & INDEXOPT_INDEXES) ||
+	(d->opts & INDEXOPT_INDEXES)) opt_indexes = 1;
+    if ((d->decremented_opts & INDEXOPT_INDEXES) &&
+	!(d->opts & INDEXOPT_INDEXES)) opt_indexes = 0;
 
-    if (allow_opts & OPT_INDEXES) {
+    if (opt_indexes) {
 	/* KLUDGE --- make the sub_req lookups happen in the right directory.
 	 * Fixing this in the sub_req_lookup functions themselves is difficult,
 	 * and would probably break virtual includes...
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_autoindex.c.orig apache_1.3.33/src/modules/standard/mod_autoindex.c.orig
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_autoindex.c.orig	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/modules/standard/mod_autoindex.c.orig	Mon Jul 18 15:22:19 2005
@@ -0,0 +1,2038 @@
+/* Copyright 1999-2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * mod_autoindex.c: Handles the on-the-fly html index generation
+ * 
+ * Rob McCool
+ * 3/23/93
+ * 
+ * Adapted to Apache by rst.
+ * StudlyIndexing by Johnie Ingram <johnie@netgod.net>
+ */
+
+#include "httpd.h"
+#include "http_config.h"
+#include "http_core.h"
+#include "http_request.h"
+#include "http_protocol.h"
+#include "http_log.h"
+#include "http_main.h"
+#include "util_script.h"
+#include "fnmatch.h"
+
+module MODULE_VAR_EXPORT autoindex_module;
+
+/****************************************************************
+ *
+ * Handling configuration directives...
+ */
+
+#define HRULE 1
+#define NO_HRULE 0
+#define FRONT_MATTER 1
+#define END_MATTER 0
+
+#define FANCY_INDEXING 1	/* Indexing options */
+#define ICONS_ARE_LINKS 2
+#define SCAN_HTML_TITLES 4
+#define SUPPRESS_LAST_MOD 8
+#define SUPPRESS_SIZE 16
+#define SUPPRESS_DESC 32
+#define SUPPRESS_PREAMBLE 64
+#define SUPPRESS_COLSORT 128
+#define NO_OPTIONS 256
+#define FOLDERS_FIRST 512
+#define TRACK_MODIFIED 1024
+#define SORT_NOCASE 2048
+#define STUDLY_INDEXING 4096
+#define INDEXOPT_INDEXES 8192
+
+#define K_PAD 1
+#define K_NOPAD 0
+
+#define K_NOADJUST 0
+#define K_ADJUST 1
+#define K_UNSET 2
+
+/*
+ * Define keys for sorting.
+ */
+#define K_NAME 'N'		/* Sort by file name (default) */
+#define K_LAST_MOD 'M'		/* Last modification date */
+#define K_SIZE 'S'		/* Size (absolute, not as displayed) */
+#define K_DESC 'D'		/* Description */
+
+#define D_ASCENDING 'A'
+#define D_DESCENDING 'D'
+
+/*
+ * These are the dimensions of the default icons supplied with Apache.
+ */
+#define DEFAULT_ICON_WIDTH 20
+#define DEFAULT_ICON_HEIGHT 22
+
+/*
+ * Other default dimensions.
+ */
+#define DEFAULT_NAME_WIDTH 23
+#define DEFAULT_DESC_WIDTH 23
+
+struct item {
+    char *type;
+    char *apply_to;
+    char *apply_path;
+    char *data;
+};
+
+typedef struct ai_desc_t {
+    char *pattern;
+    char *description;
+    int full_path;
+    int wildcards;
+} ai_desc_t;
+
+typedef struct autoindex_config_struct {
+    char *default_icon;
+    int opts;
+    int incremented_opts;
+    int decremented_opts;
+    int name_width;
+    int name_adjust;
+    int desc_width;
+    int desc_adjust;
+    int icon_width;
+    int icon_height;
+    char *default_order;
+
+    array_header *icon_list;
+    array_header *alt_list;
+    array_header *desc_list;
+    array_header *ign_list;
+    array_header *hdr_list;
+    array_header *rdme_list;
+    array_header *side_list;
+    array_header *main_list;
+    array_header *ftr_list;
+
+    char *body_col;
+    char *text_col;
+    char *hdr_col;
+    char *rdme_col;
+    char *side_col;
+    char *main_col;
+    char *ftr_col;
+
+} autoindex_config_rec;
+
+static char c_by_encoding, c_by_type, c_by_path;
+
+#define BY_ENCODING &c_by_encoding
+#define BY_TYPE &c_by_type
+#define BY_PATH &c_by_path
+
+/*
+ * Return true if the specified string refers to the parent directory (i.e.,
+ * matches ".." or "../").  Hopefully this one call is significantly less
+ * expensive than multiple strcmp() calls.
+ */
+static ap_inline int is_parent(const char *name)
+{
+    /*
+     * Now, IFF the first two bytes are dots, and the third byte is either
+     * EOS (\0) or a slash followed by EOS, we have a match.
+     */
+    if (((name[0] == '.') && (name[1] == '.'))
+	&& ((name[2] == '\0')
+	    || ((name[2] == '/') && (name[3] == '\0')))) {
+        return 1;
+    }
+    return 0;
+}
+
+/*
+ * This routine puts the standard HTML header at the top of the index page.
+ * We include the DOCTYPE because we may be using features therefrom (i.e.,
+ * HEIGHT and WIDTH attributes on the icons if we're FancyIndexing).
+ */
+static void emit_preamble(request_rec *r, char *title,
+                          autoindex_config_rec *autoindex_conf)
+{
+    ap_rvputs(r, DOCTYPE_HTML_4_0T,
+	      "<HTML>\n <HEAD>\n  <TITLE>Index of ", title,
+	      "</TITLE>\n </HEAD>\n <BODY bgcolor=\"",
+              autoindex_conf->body_col ?: "#ffffff", "\" text=\"",
+              autoindex_conf->text_col ?: "#000000", "\"", NULL);
+    if (autoindex_conf->opts & STUDLY_INDEXING) {
+	ap_rvputs(r, " leftmargin=\"0\" topmargin=\"0\" \n "
+		"marginwidth=\"0\" marginheight=\"0\"", NULL);
+    }
+    ap_rputs(">\n\n", r);
+}
+
+static void push_item(array_header *arr, char *type, char *to, char *path,
+		      char *data)
+{
+    struct item *p = (struct item *) ap_push_array(arr);
+
+    if (!to) {
+	to = "";
+    }
+    if (!path) {
+	path = "";
+    }
+
+    p->type = type;
+    p->data = data ? ap_pstrdup(arr->pool, data) : NULL;
+    p->apply_path = ap_pstrcat(arr->pool, path, "*", NULL);
+
+    if ((type == BY_PATH) && (!ap_is_matchexp(to))) {
+	p->apply_to = ap_pstrcat(arr->pool, "*", to, NULL);
+    }
+    else if (to) {
+	p->apply_to = ap_pstrdup(arr->pool, to);
+    }
+    else {
+	p->apply_to = NULL;
+    }
+}
+
+static const char *add_alt(cmd_parms *cmd, void *d, char *alt, char *to)
+{
+    if (cmd->info == BY_PATH) {
+        if (!strcmp(to, "**DIRECTORY**")) {
+	    to = "^^DIRECTORY^^";
+	}
+    }
+    if (cmd->info == BY_ENCODING) {
+	ap_str_tolower(to);
+    }
+
+    push_item(((autoindex_config_rec *) d)->alt_list, cmd->info, to,
+	      cmd->path, alt);
+    return NULL;
+}
+
+static const char *add_icon(cmd_parms *cmd, void *d, char *icon, char *to)
+{
+    char *iconbak = ap_pstrdup(cmd->pool, icon);
+
+    if (icon[0] == '(') {
+	char *alt;
+	char *cl = strchr(iconbak, ')');
+
+	if (cl == NULL) {
+	    return "missing closing paren";
+	}
+	alt = ap_getword_nc(cmd->pool, &iconbak, ',');
+	*cl = '\0';				/* Lose closing paren */
+	add_alt(cmd, d, &alt[1], to);
+    }
+    if (cmd->info == BY_PATH) {
+        if (!strcmp(to, "**DIRECTORY**")) {
+	    to = "^^DIRECTORY^^";
+	}
+    }
+    if (cmd->info == BY_ENCODING) {
+	ap_str_tolower(to);
+    }
+
+    push_item(((autoindex_config_rec *) d)->icon_list, cmd->info, to,
+	      cmd->path, iconbak);
+    return NULL;
+}
+
+/*
+ * Add description text for a filename pattern.  If the pattern has
+ * wildcards already (or we need to add them), add leading and
+ * trailing wildcards to it to ensure substring processing.  If the
+ * pattern contains a '/' anywhere, force wildcard matching mode,
+ * add a slash to the prefix so that "bar/bletch" won't be matched
+ * by "foobar/bletch", and make a note that there's a delimiter;
+ * the matching routine simplifies to just the actual filename
+ * whenever it can.  This allows definitions in parent directories
+ * to be made for files in subordinate ones using relative paths.
+ */
+
+/*
+ * Absent a strcasestr() function, we have to force wildcards on
+ * systems for which "AAA" and "aaa" mean the same file.
+ */
+#ifdef CASE_BLIND_FILESYSTEM
+#define WILDCARDS_REQUIRED 1
+#else
+#define WILDCARDS_REQUIRED 0
+#endif
+
+static const char *add_desc(cmd_parms *cmd, void *d, char *desc, char *to)
+{
+    autoindex_config_rec *dcfg = (autoindex_config_rec *) d;
+    ai_desc_t *desc_entry;
+    char *prefix = "";
+
+    desc_entry = (ai_desc_t *) ap_push_array(dcfg->desc_list);
+    desc_entry->full_path = (strchr(to, '/') == NULL) ? 0 : 1;
+    desc_entry->wildcards = (WILDCARDS_REQUIRED
+			     || desc_entry->full_path
+			     || ap_is_fnmatch(to));
+    if (desc_entry->wildcards) {
+	prefix = desc_entry->full_path ? "*/" : "*";
+	desc_entry->pattern = ap_pstrcat(dcfg->desc_list->pool,
+					 prefix, to, "*", NULL);
+    }
+    else {
+	desc_entry->pattern = ap_pstrdup(dcfg->desc_list->pool, to);
+    }
+    desc_entry->description = ap_pstrdup(dcfg->desc_list->pool, desc);
+    return NULL;
+}
+
+static const char *add_ignore(cmd_parms *cmd, void *d, char *ext)
+{
+    push_item(((autoindex_config_rec *) d)->ign_list, 0, ext, cmd->path, NULL);
+    return NULL;
+}
+
+static const char *add_header(cmd_parms *cmd, void *d, char *name)
+{
+    push_item(((autoindex_config_rec *) d)->hdr_list, 0, NULL, cmd->path,
+	      name);
+    return NULL;
+}
+
+static const char *add_readme(cmd_parms *cmd, void *d, char *name)
+{
+    push_item(((autoindex_config_rec *) d)->rdme_list, 0, NULL, cmd->path,
+	      name);
+    return NULL;
+}
+
+static const char *add_sidebar(cmd_parms *cmd, void *d, char *name)
+{
+    push_item(((autoindex_config_rec *) d)->side_list, 0, NULL, cmd->path,
+	      name);
+    return NULL;
+}
+
+static const char *add_body(cmd_parms *cmd, void *d, char *name)
+{
+    push_item(((autoindex_config_rec *) d)->main_list, 0, NULL, cmd->path,
+	      name);
+    return NULL;
+}
+
+static const char *add_footer(cmd_parms *cmd, void *d, char *name)
+{
+    push_item(((autoindex_config_rec *) d)->ftr_list, 0, NULL, cmd->path,
+	      name);
+    return NULL;
+}
+
+/* A legacy directive, FancyIndexing is superseded by the IndexOptions
+ * keyword.  But for compatibility..
+ */
+static const char *fancy_indexing(cmd_parms *cmd, void *d, int arg)
+{
+    int curopts;
+    int newopts;
+    autoindex_config_rec *cfg;
+
+    cfg = (autoindex_config_rec *) d;
+    curopts = cfg->opts;
+    if (curopts & NO_OPTIONS) {
+	return "FancyIndexing directive conflicts with existing "
+	       "IndexOptions None";
+    }
+    newopts = (arg ? (curopts | FANCY_INDEXING) : (curopts & ~FANCY_INDEXING));
+    cfg->opts = newopts;
+    return NULL;
+}
+
+static const char *add_opts(cmd_parms *cmd, void *d, const char *optstr)
+{
+    char *w;
+    int opts;
+    int opts_add;
+    int opts_remove;
+    char action;
+    autoindex_config_rec *d_cfg = (autoindex_config_rec *) d;
+
+    opts = d_cfg->opts;
+    opts_add = d_cfg->incremented_opts;
+    opts_remove = d_cfg->decremented_opts;
+    while (optstr[0]) {
+	int option = 0;
+
+	w = ap_getword_conf(cmd->pool, &optstr);
+	if ((*w == '+') || (*w == '-')) {
+	    action = *(w++);
+	}
+	else {
+	    action = '\0';
+	}
+	if (!strcasecmp(w, "FancyIndexing")) {
+	    option = FANCY_INDEXING;
+	}
+	else if (!strcasecmp(w, "StudlyIndexing")) {
+            /* automatic FancyIndexing on, NameWidth=*, etc. */
+	    option = STUDLY_INDEXING + FANCY_INDEXING
+              + ICONS_ARE_LINKS + SUPPRESS_DESC;
+            d_cfg->name_adjust = K_ADJUST;
+	}
+	else if (!strcasecmp(w, "IconsAreLinks")) {
+	    option = ICONS_ARE_LINKS;
+	}
+	else if (!strcasecmp(w, "ScanHTMLTitles")) {
+	    option = SCAN_HTML_TITLES;
+	}
+	else if (!strcasecmp(w, "SuppressLastModified")) {
+	    option = SUPPRESS_LAST_MOD;
+	}
+	else if (!strcasecmp(w, "SuppressSize")) {
+	    option = SUPPRESS_SIZE;
+	}
+	else if (!strcasecmp(w, "SuppressDescription")) {
+	    option = SUPPRESS_DESC;
+	}
+	else if (!strcasecmp(w, "SuppressHTMLPreamble")) {
+	    option = SUPPRESS_PREAMBLE;
+	}
+        else if (!strcasecmp(w, "SuppressColumnSorting")) {
+            option = SUPPRESS_COLSORT;
+	}
+	else if (!strcasecmp(w, "FoldersFirst")) {
+	    option = FOLDERS_FIRST;
+	}
+	else if (!strcasecmp(w, "TrackModified")) {
+	    option = TRACK_MODIFIED;
+	}
+	else if (!strcasecmp(w, "IgnoreCase")) {
+	    option = SORT_NOCASE;
+	}
+	else if (!strcasecmp(w, "Indexes")) {
+            option = INDEXOPT_INDEXES;
+	}
+	else if (!strcasecmp(w, "None")) {
+	    if (action != '\0') {
+		return "Cannot combine '+' or '-' with 'None' keyword";
+	    }
+	    opts = NO_OPTIONS;
+	    opts_add = 0;
+	    opts_remove = 0;
+	}
+	else if (!strcasecmp(w, "IconWidth")) {
+	    if (action != '-') {
+		d_cfg->icon_width = DEFAULT_ICON_WIDTH;
+	    }
+	    else {
+		d_cfg->icon_width = 0;
+	    }
+	}
+	else if (!strncasecmp(w, "IconWidth=", 10)) {
+	    if (action == '-') {
+		return "Cannot combine '-' with IconWidth=n";
+	    }
+	    d_cfg->icon_width = atoi(&w[10]);
+	}
+	else if (!strcasecmp(w, "IconHeight")) {
+	    if (action != '-') {
+		d_cfg->icon_height = DEFAULT_ICON_HEIGHT;
+	    }
+	    else {
+		d_cfg->icon_height = 0;
+	    }
+	}
+	else if (!strncasecmp(w, "IconHeight=", 11)) {
+	    if (action == '-') {
+		return "Cannot combine '-' with IconHeight=n";
+	    }
+	    d_cfg->icon_height = atoi(&w[11]);
+	}
+	else if (!strcasecmp(w, "NameWidth")) {
+	    if (action != '-') {
+		return "NameWidth with no value may only appear as "
+		       "'-NameWidth'";
+	    }
+	    d_cfg->name_width = DEFAULT_NAME_WIDTH;
+	    d_cfg->name_adjust = K_NOADJUST;
+	}
+	else if (!strncasecmp(w, "NameWidth=", 10)) {
+	    if (action == '-') {
+		return "Cannot combine '-' with NameWidth=n";
+	    }
+	    if (w[10] == '*') {
+		d_cfg->name_adjust = K_ADJUST;
+	    }
+	    else {
+		int width = atoi(&w[10]);
+
+		if (width < 5) {
+		    return "NameWidth value must be greater than 5";
+		}
+		d_cfg->name_width = width;
+		d_cfg->name_adjust = K_NOADJUST;
+	    }
+	}
+	else if (!strcasecmp(w, "DescriptionWidth")) {
+	    if (action != '-') {
+		return "DescriptionWidth with no value may only appear as "
+		       "'-DescriptionWidth'";
+	    }
+	    d_cfg->desc_width = DEFAULT_DESC_WIDTH;
+	    d_cfg->desc_adjust = K_NOADJUST;
+	}
+	else if (!strncasecmp(w, "DescriptionWidth=", 17)) {
+	    if (action == '-') {
+		return "Cannot combine '-' with DescriptionWidth=n";
+	    }
+	    if (w[17] == '*') {
+		d_cfg->desc_adjust = K_ADJUST;
+	    }
+	    else {
+		int width = atoi(&w[17]);
+
+		if (width < 12) {
+		    return "DescriptionWidth value must be greater than 12";
+		}
+		d_cfg->desc_width = width;
+		d_cfg->desc_adjust = K_NOADJUST;
+	    }
+	}
+	else if (!strncasecmp(w, "BodyColor=", 10)) {
+	    if (action == '-') {
+		return "Cannot combine '-' with BodyColor=#xxxxxx";
+	    }
+	    d_cfg->body_col = ap_pstrdup(d_cfg->desc_list->pool, &w[10]);
+	}
+	else if (!strncasecmp(w, "TextColor=", 10)) {
+	    if (action == '-') {
+		return "Cannot combine '-' with TextColor=#xxxxxx";
+	    }
+	    d_cfg->text_col = ap_pstrdup(d_cfg->desc_list->pool, &w[10]);
+	}
+	else if (!strncasecmp(w, "HeaderColor=", 12)) {
+	    if (action == '-') {
+		return "Cannot combine '-' with HeaderColor=#xxxxxx";
+	    }
+	    d_cfg->hdr_col = ap_pstrdup(d_cfg->desc_list->pool, &w[12]);
+	}
+	else if (!strncasecmp(w, "ReadmeColor=", 12)) {
+	    if (action == '-') {
+		return "Cannot combine '-' with ReadmeColor=#xxxxxx";
+	    }
+	    d_cfg->rdme_col = ap_pstrdup(d_cfg->desc_list->pool, &w[12]);
+	}
+	else if (!strncasecmp(w, "SidebarColor=", 13)) {
+	    if (action == '-') {
+		return "Cannot combine '-' with SidebarColor=#xxxxxx";
+	    }
+	    d_cfg->side_col = ap_pstrdup(d_cfg->desc_list->pool, &w[13]);
+	}
+	else if (!strncasecmp(w, "MainColor=", 10)) {
+	    if (action == '-') {
+		return "Cannot combine '-' with MainColor=#xxxxxx";
+	    }
+	    d_cfg->main_col = ap_pstrdup(d_cfg->desc_list->pool, &w[10]);
+	}
+	else if (!strncasecmp(w, "FooterColor=", 12)) {
+	    if (action == '-') {
+		return "Cannot combine '-' with FooterColor=#xxxxxx";
+	    }
+	    d_cfg->ftr_col = ap_pstrdup(d_cfg->desc_list->pool, &w[12]);
+	}
+	else {
+	    return "Invalid directory indexing option";
+	}
+	if (action == '\0') {
+	    opts |= option;
+	    opts_add = 0;
+	    opts_remove = 0;
+	}
+	else if (action == '+') {
+	    opts_add |= option;
+	    opts_remove &= ~option;
+	}
+	else {
+	    opts_remove |= option;
+	    opts_add &= ~option;
+	}
+    }
+    if ((opts & NO_OPTIONS) && (opts & ~NO_OPTIONS)) {
+	return "Cannot combine other IndexOptions keywords with 'None'";
+    }
+    d_cfg->incremented_opts = opts_add;
+    d_cfg->decremented_opts = opts_remove;
+    d_cfg->opts = opts;
+    return NULL;
+}
+
+static const char *set_default_order(cmd_parms *cmd, void *m, char *direction,
+				     char *key)
+{
+    char temp[4];
+    autoindex_config_rec *d_cfg = (autoindex_config_rec *) m;
+
+    ap_cpystrn(temp, "k=d", sizeof(temp));
+    if (!strcasecmp(direction, "Ascending")) {
+	temp[2] = D_ASCENDING;
+    }
+    else if (!strcasecmp(direction, "Descending")) {
+	temp[2] = D_DESCENDING;
+    }
+    else {
+	return "First keyword must be 'Ascending' or 'Descending'";
+    }
+
+    if (!strcasecmp(key, "Name")) {
+	temp[0] = K_NAME;
+    }
+    else if (!strcasecmp(key, "Date")) {
+	temp[0] = K_LAST_MOD;
+    }
+    else if (!strcasecmp(key, "Size")) {
+	temp[0] = K_SIZE;
+    }
+    else if (!strcasecmp(key, "Description")) {
+	temp[0] = K_DESC;
+    }
+    else {
+	return "Second keyword must be 'Name', 'Date', 'Size', or "
+	    "'Description'";
+    }
+
+    if (d_cfg->default_order == NULL) {
+	d_cfg->default_order = ap_palloc(cmd->pool, 4);
+	d_cfg->default_order[3] = '\0';
+    }
+    ap_cpystrn(d_cfg->default_order, temp, sizeof(temp));
+    return NULL;
+}
+
+#define DIR_CMD_PERMS OR_INDEXES
+
+static const command_rec autoindex_cmds[] =
+{
+    {"AddIcon", add_icon, BY_PATH, DIR_CMD_PERMS, ITERATE2,
+     "an icon URL followed by one or more filenames"},
+    {"AddIconByType", add_icon, BY_TYPE, DIR_CMD_PERMS, ITERATE2,
+     "an icon URL followed by one or more MIME types"},
+    {"AddIconByEncoding", add_icon, BY_ENCODING, DIR_CMD_PERMS, ITERATE2,
+     "an icon URL followed by one or more content encodings"},
+    {"AddAlt", add_alt, BY_PATH, DIR_CMD_PERMS, ITERATE2,
+     "alternate descriptive text followed by one or more filenames"},
+    {"AddAltByType", add_alt, BY_TYPE, DIR_CMD_PERMS, ITERATE2,
+     "alternate descriptive text followed by one or more MIME types"},
+    {"AddAltByEncoding", add_alt, BY_ENCODING, DIR_CMD_PERMS, ITERATE2,
+     "alternate descriptive text followed by one or more content encodings"},
+    {"IndexOptions", add_opts, NULL, DIR_CMD_PERMS, RAW_ARGS,
+     "one or more index options"},
+    {"IndexOrderDefault", set_default_order, NULL, DIR_CMD_PERMS, TAKE2,
+     "{Ascending,Descending} {Name,Size,Description,Date}"},
+    {"IndexIgnore", add_ignore, NULL, DIR_CMD_PERMS, ITERATE,
+     "one or more file extensions"},
+    {"AddDescription", add_desc, BY_PATH, DIR_CMD_PERMS, ITERATE2,
+     "Descriptive text followed by one or more filenames"},
+    {"HeaderName", add_header, NULL, DIR_CMD_PERMS, TAKE1, "a filename"},
+    {"ReadmeName", add_readme, NULL, DIR_CMD_PERMS, TAKE1, "a filename"},
+    {"SidebarName", add_sidebar, NULL, DIR_CMD_PERMS, TAKE1, "a filename"},
+    {"BodyName", add_body, NULL, DIR_CMD_PERMS, TAKE1, "a filename"},
+    {"FooterName", add_footer, NULL, DIR_CMD_PERMS, TAKE1, "a filename"},
+    {"FancyIndexing", fancy_indexing, NULL, DIR_CMD_PERMS, FLAG,
+     "Limited to 'on' or 'off' (superseded by IndexOptions FancyIndexing)"},
+    {"DefaultIcon", ap_set_string_slot,
+     (void *) XtOffsetOf(autoindex_config_rec, default_icon),
+     DIR_CMD_PERMS, TAKE1, "an icon URL"},
+    {NULL}
+};
+
+static void *create_autoindex_config(pool *p, char *dummy)
+{
+    autoindex_config_rec *new =
+    (autoindex_config_rec *) ap_pcalloc(p, sizeof(autoindex_config_rec));
+
+    new->icon_width = 0;
+    new->icon_height = 0;
+    new->name_width = DEFAULT_NAME_WIDTH;
+    new->name_adjust = K_UNSET;
+    new->desc_width = DEFAULT_DESC_WIDTH;
+    new->desc_adjust = K_UNSET;
+    new->icon_list = ap_make_array(p, 4, sizeof(struct item));
+    new->alt_list = ap_make_array(p, 4, sizeof(struct item));
+    new->desc_list = ap_make_array(p, 4, sizeof(ai_desc_t));
+    new->ign_list = ap_make_array(p, 4, sizeof(struct item));
+    new->hdr_list = ap_make_array(p, 4, sizeof(struct item));
+    new->rdme_list = ap_make_array(p, 4, sizeof(struct item));
+    new->side_list = ap_make_array(p, 4, sizeof(struct item));
+    new->main_list = ap_make_array(p, 4, sizeof(struct item));
+    new->ftr_list = ap_make_array(p, 4, sizeof(struct item));
+    new->opts = 0;
+    new->incremented_opts = 0;
+    new->decremented_opts = 0;
+    new->default_order = NULL;
+
+    return (void *) new;
+}
+
+static void *merge_autoindex_configs(pool *p, void *basev, void *addv)
+{
+    autoindex_config_rec *new;
+    autoindex_config_rec *base = (autoindex_config_rec *) basev;
+    autoindex_config_rec *add = (autoindex_config_rec *) addv;
+
+    new = (autoindex_config_rec *) ap_pcalloc(p, sizeof(autoindex_config_rec));
+    new->default_icon = add->default_icon ? add->default_icon
+                                          : base->default_icon;
+    new->icon_height = add->icon_height ? add->icon_height : base->icon_height;
+    new->icon_width = add->icon_width ? add->icon_width : base->icon_width;
+
+    new->alt_list = ap_append_arrays(p, add->alt_list, base->alt_list);
+    new->ign_list = ap_append_arrays(p, add->ign_list, base->ign_list);
+    new->hdr_list = ap_append_arrays(p, add->hdr_list, base->hdr_list);
+    new->desc_list = ap_append_arrays(p, add->desc_list, base->desc_list);
+    new->icon_list = ap_append_arrays(p, add->icon_list, base->icon_list);
+    new->rdme_list = ap_append_arrays(p, add->rdme_list, base->rdme_list);
+    new->side_list = ap_append_arrays(p, add->side_list, base->side_list);
+    new->main_list = ap_append_arrays(p, add->main_list, base->main_list);
+    new->ftr_list = ap_append_arrays(p, add->ftr_list, base->ftr_list);
+    if (add->opts & NO_OPTIONS) {
+	/*
+	 * If the current directory says 'no options' then we also
+	 * clear any incremental mods from being inheritable further down.
+	 */
+	new->opts = NO_OPTIONS;
+	new->incremented_opts = 0;
+	new->decremented_opts = 0;
+    }
+    else {
+	/*
+	 * If there were any non-incremental options selected for
+	 * this directory, they dominate and we don't inherit *anything.*
+	 * Contrariwise, we *do* inherit if the only settings here are
+	 * incremental ones.
+	 */
+	if (add->opts == 0) {
+	    new->incremented_opts = (base->incremented_opts 
+				     | add->incremented_opts)
+		                    & ~add->decremented_opts;
+	    new->decremented_opts = (base->decremented_opts
+				     | add->decremented_opts);
+	    /*
+	     * We may have incremental settings, so make sure we don't
+	     * inadvertently inherit an IndexOptions None from above.
+	     */
+	    new->opts = (base->opts & ~NO_OPTIONS);
+	}
+	else {
+	    /*
+	     * There are local non-incremental settings, which clear
+	     * all inheritance from above.  They *are* the new base settings.
+	     */
+	    new->opts = add->opts;;
+	}
+	/*
+	 * We're guaranteed that there'll be no overlap between
+	 * the add-options and the remove-options.
+	 */
+	new->opts |= new->incremented_opts;
+	new->opts &= ~new->decremented_opts;
+    }
+    /*
+     * Inherit the NameWidth settings if there aren't any specific to
+     * the new location; otherwise we'll end up using the defaults set in the
+     * config-rec creation routine.
+     */
+    if (add->name_adjust == K_UNSET) {
+	new->name_width = base->name_width;
+	new->name_adjust = base->name_adjust;
+    }
+    else {
+	new->name_width = add->name_width;
+	new->name_adjust = add->name_adjust;
+    }
+    /*
+     * Likewise for DescriptionWidth.
+     */
+    if (add->desc_adjust == K_UNSET) {
+	new->desc_width = base->desc_width;
+	new->desc_adjust = base->desc_adjust;
+    }
+    else {
+	new->desc_width = add->desc_width;
+	new->desc_adjust = add->desc_adjust;
+    }
+
+    new->default_order = (add->default_order != NULL)
+	? add->default_order : base->default_order;
+
+    new->body_col = (add->body_col != NULL)
+	? add->body_col : base->body_col;
+    new->text_col = (add->text_col != NULL)
+	? add->text_col : base->text_col;
+    new->hdr_col = (add->hdr_col != NULL)
+	? add->hdr_col : base->hdr_col;
+    new->rdme_col = (add->rdme_col != NULL)
+	? add->rdme_col : base->rdme_col;
+    new->side_col = (add->side_col != NULL)
+	? add->side_col : base->side_col;
+    new->main_col = (add->main_col != NULL)
+	? add->main_col : base->main_col;
+    new->ftr_col = (add->ftr_col != NULL)
+	? add->ftr_col : base->ftr_col;
+
+    return new;
+}
+
+/****************************************************************
+ *
+ * Looking things up in config entries...
+ */
+
+/* Structure used to hold entries when we're actually building an index */
+
+struct ent {
+    char *name;
+    char *icon;
+    char *alt;
+    char *desc;
+    off_t size;
+    time_t lm;
+    struct ent *next;
+    int ascending;
+    int isdir;
+    int checkdir;
+    int ignorecase;
+    char key;
+};
+
+static char *find_item(request_rec *r, array_header *list, int path_only)
+{
+    const char *content_type = ap_field_noparam(r->pool, r->content_type);
+    const char *content_encoding = r->content_encoding;
+    char *path = r->filename;
+
+    struct item *items = (struct item *) list->elts;
+    int i;
+
+    for (i = 0; i < list->nelts; ++i) {
+	struct item *p = &items[i];
+
+	/* Special cased for ^^DIRECTORY^^ and ^^BLANKICON^^ */
+	if ((path[0] == '^') || (!ap_strcmp_match(path, p->apply_path))) {
+	    if (!*(p->apply_to)) {
+		return p->data;
+	    }
+	    else if (p->type == BY_PATH || path[0] == '^') {
+	        if (!ap_strcmp_match(path, p->apply_to)) {
+		    return p->data;
+		}
+	    }
+	    else if (!path_only) {
+		if (!content_encoding) {
+		    if (p->type == BY_TYPE) {
+			if (content_type
+			    && !ap_strcasecmp_match(content_type,
+						    p->apply_to)) {
+			    return p->data;
+			}
+		    }
+		}
+		else {
+		    if (p->type == BY_ENCODING) {
+			if (!ap_strcasecmp_match(content_encoding,
+						 p->apply_to)) {
+			    return p->data;
+			}
+		    }
+		}
+	    }
+	}
+    }
+    return NULL;
+}
+
+#define find_icon(d,p,t) find_item(p,d->icon_list,t)
+#define find_alt(d,p,t) find_item(p,d->alt_list,t)
+#define find_header(d,p) find_item(p,d->hdr_list,0)
+#define find_sidebar(d,p) find_item(p,d->side_list,0)
+#define find_readme(d,p) find_item(p,d->rdme_list,0)
+#define find_main(d,p) find_item(p,d->main_list,0)
+#define find_footer(d,p) find_item(p,d->ftr_list,0)
+
+static char *find_default_icon(autoindex_config_rec *d, char *bogus_name)
+{
+    request_rec r;
+
+    /* Bleah.  I tried to clean up find_item, and it lead to this bit
+     * of ugliness.   Note that the fields initialized are precisely
+     * those that find_item looks at...
+     */
+
+    r.filename = bogus_name;
+    r.content_type = r.content_encoding = NULL;
+
+    return find_item(&r, d->icon_list, 1);
+}
+
+/*
+ * Look through the list of pattern/description pairs and return the first one
+ * if any) that matches the filename in the request.  If multiple patterns
+ * match, only the first one is used; since the order in the array is the
+ * same as the order in which directives were processed, earlier matching
+ * directives will dominate.
+ */
+
+#ifdef CASE_BLIND_FILESYSTEM
+#define MATCH_FLAGS FNM_CASE_BLIND
+#else
+#define MATCH_FLAGS 0
+#endif
+
+static char *find_desc(autoindex_config_rec *dcfg, request_rec *r)
+{
+    int i;
+    ai_desc_t *list = (ai_desc_t *) dcfg->desc_list->elts;
+    const char *filename_full = r->filename;
+    const char *filename_only;
+    const char *filename;
+
+    /*
+     * If the filename includes a path, extract just the name itself
+     * for the simple matches.
+     */
+    if ((filename_only = strrchr(filename_full, '/')) == NULL) {
+	filename_only = filename_full;
+    }
+    else {
+	filename_only++;
+    }
+    for (i = 0; i < dcfg->desc_list->nelts; ++i) {
+	ai_desc_t *tuple = &list[i];
+	int found;
+
+	/*
+	 * Only use the full-path filename if the pattern contains '/'s.
+	 */
+	filename = (tuple->full_path) ? filename_full : filename_only;
+	/*
+	 * Make the comparison using the cheapest method; only do
+	 * wildcard checking if we must.
+	 */
+	if (tuple->wildcards) {
+	    found = (ap_fnmatch(tuple->pattern, filename, MATCH_FLAGS) == 0);
+	}
+	else {
+	    found = (strstr(filename, tuple->pattern) != NULL);
+	}
+	if (found) {
+	    return tuple->description;
+	}
+    }
+    return NULL;
+}
+
+static int ignore_entry(autoindex_config_rec *d, char *path)
+{
+    array_header *list = d->ign_list;
+    struct item *items = (struct item *) list->elts;
+    char *tt;
+    int i;
+
+    if ((tt = strrchr(path, '/')) == NULL) {
+	tt = path;
+    }
+    else {
+	tt++;
+    }
+
+    for (i = 0; i < list->nelts; ++i) {
+	struct item *p = &items[i];
+	char *ap;
+
+	if ((ap = strrchr(p->apply_to, '/')) == NULL) {
+	    ap = p->apply_to;
+	}
+	else {
+	    ap++;
+	}
+
+#ifndef CASE_BLIND_FILESYSTEM
+	if (!ap_strcmp_match(path, p->apply_path)
+	    && !ap_strcmp_match(tt, ap)) {
+	    return 1;
+	}
+#else  /* !CASE_BLIND_FILESYSTEM */
+	/*
+	 * On some platforms, the match must be case-blind.  This is really
+	 * a factor of the filesystem involved, but we can't detect that
+	 * reliably - so we have to granularise at the OS level.
+	 */
+	if (!ap_strcasecmp_match(path, p->apply_path)
+	    && !ap_strcasecmp_match(tt, ap)) {
+	    return 1;
+	}
+#endif /* !CASE_BLIND_FILESYSTEM */
+    }
+    return 0;
+}
+
+/*****************************************************************
+ *
+ * Actually generating output
+ */
+
+/*
+ * Elements of the emitted document:
+ *	Preamble
+ *		Emitted unless SUPPRESS_PREAMBLE is set AND ap_run_sub_req
+ *		succeeds for the (content_type == text/html) header file.
+ *	Header file
+ *		Emitted if found (and able).
+ *	H1 tag line
+ *		Emitted if a header file is NOT emitted.
+ *	Directory stuff
+ *		Always emitted.
+ *	HR
+ *		Emitted if FANCY_INDEXING is set.
+ *	Readme file
+ *		Emitted if found (and able).
+ *	ServerSig
+ *		Emitted if ServerSignature is not Off AND a readme file
+ *		is NOT emitted.
+ *	Postamble
+ *		Emitted unless SUPPRESS_PREAMBLE is set AND ap_run_sub_req
+ *		succeeds for the (content_type == text/html) readme file.
+ */
+
+
+/*
+ * emit a plain text file
+ */
+static void do_emit_plain(request_rec *r, FILE *f, int autoindex_opts)
+{
+    char buf[IOBUFSIZE + 1];
+    int i, n, c, ch;
+
+    if (! (autoindex_opts & STUDLY_INDEXING))
+      ap_rputs("<PRE>\n", r);
+    while (!feof(f)) {
+	do {
+	    n = fread(buf, sizeof(char), IOBUFSIZE, f);
+	}
+	while (n == -1 && ferror(f) && errno == EINTR);
+	if (n == -1 || n == 0) {
+	    break;
+	}
+	buf[n] = '\0';
+	c = 0;
+	while (c < n) {
+	    for (i = c; i < n; i++) {
+		if (buf[i] == '<' || buf[i] == '>' || buf[i] == '&') {
+		    break;
+		}
+	    }
+	    ch = buf[i];
+	    buf[i] = '\0';
+	    ap_rputs(&buf[c], r);
+	    if (ch == '<') {
+		ap_rputs("&lt;", r);
+	    }
+	    else if (ch == '>') {
+		ap_rputs("&gt;", r);
+	    }
+	    else if (ch == '&') {
+		ap_rputs("&amp;", r);
+	    }
+	    c = i + 1;
+	}
+    }
+    if (! (autoindex_opts & STUDLY_INDEXING))
+      ap_rputs("</PRE>\n", r);
+}
+
+/*
+ * If there's a file, send a subrequest to look for it.  If it's
+ * found and a text file, handle it and return 0, otherwise return -1.
+ */
+static int do_emit_fancy(request_rec *r, const char *fname, int autoindex_opts)
+{
+    FILE *f;
+    request_rec *rr = NULL;
+
+    if ((fname != NULL)
+	&& (rr = ap_sub_req_lookup_uri(fname, r))
+        && (rr->status == HTTP_OK)
+	&& (rr->filename != NULL)
+	&& S_ISREG(rr->finfo.st_mode)) {
+	/*
+	 * Check for the two specific cases we allow: text/html and
+	 * text/anything-else.  The former is allowed to be processed for
+	 * SSIs.
+	 */
+	if (rr->content_type != NULL) {
+	    if (!strcasecmp(ap_field_noparam(r->pool, rr->content_type),
+			    "text/html")) {
+		if (ap_run_sub_req(rr) == OK) {
+		    /* worked... */
+                    return 0;
+		}
+	    }
+	    else if (!strncasecmp("text/", rr->content_type, 5)) {
+		if ((f = ap_pfopen(r->pool, rr->filename, "r")) != 0) {
+		    do_emit_plain(r, f, autoindex_opts);
+		    ap_pfclose(r->pool, f);
+		    return 0;
+		}
+	    }
+	}
+    }
+    if (rr != NULL) {
+	ap_destroy_sub_req(rr);
+    }
+    return -1;
+}
+
+/* See mod_include */
+#define SUB_REQ_STRING	"Sub request to mod_include"
+#define PARENT_STRING	"Parent request to mod_include"
+
+/*
+ * Handle the preamble through the H1 tag line, inclusive.  Locate
+ * the file with a subrequests.  Process text/html documents by actually
+ * running the subrequest; text/xxx documents get copied verbatim,
+ * and any other content type is ignored.  This means that a non-text
+ * document (such as HEADER.gif) might get multiviewed as the result
+ * instead of a text document, meaning nothing will be displayed, but
+ * oh well.
+ */
+static void emit_head(request_rec *r, char *header_fname, 
+                      autoindex_config_rec *autoindex_conf,
+                      int autoindex_opts, char *title)
+{
+    FILE *f;
+    request_rec *rr = NULL;
+    int emit_amble = 1;
+    int emit_H1 = 1;
+    const char *r_accept;
+    const char *r_accept_enc;
+    table *hdrs = r->headers_in;
+
+    /*
+     * If there's a header file, send a subrequest to look for it.  If it's
+     * found and html do the subrequest, otherwise handle it
+     */
+    r_accept = ap_table_get(hdrs, "Accept");
+    r_accept_enc = ap_table_get(hdrs, "Accept-Encoding");
+    ap_table_setn(hdrs, "Accept", "text/html, text/plain;q=.5, text/*;q=.1");
+    ap_table_unset(hdrs, "Accept-Encoding");
+
+    /*
+     * If there's a header file, send a subrequest to look for it.  If it's
+     * found and a text file, handle it -- otherwise fall through and
+     * pretend there's nothing there.
+     */
+    if ((header_fname != NULL)
+	&& (rr = ap_sub_req_lookup_uri(header_fname, r))
+	&& (rr->status == HTTP_OK)
+	&& (rr->filename != NULL)
+	&& S_ISREG(rr->finfo.st_mode)) {
+	/*
+	 * Check for the two specific cases we allow: text/html and
+	 * text/anything-else.  The former is allowed to be processed for
+	 * SSIs.
+	 */
+	if (rr->content_type != NULL) {
+	    if (!strcasecmp(ap_field_noparam(r->pool, rr->content_type),
+			    "text/html")) {
+		/* Hope everything will work... */
+		emit_amble = 0;
+		emit_H1 = 0;
+
+		if (! (autoindex_opts & SUPPRESS_PREAMBLE)) {
+		    emit_preamble(r, title, autoindex_conf);
+		}
+
+		/* See mod_include */
+		ap_table_add(r->notes, PARENT_STRING, "");
+		ap_table_add(rr->notes, SUB_REQ_STRING, "");
+
+		/*
+		 * If there's a problem running the subrequest, display the
+		 * preamble if we didn't do it before -- the header file
+		 * didn't get displayed.
+		 */
+		if (ap_run_sub_req(rr) != OK) {
+		    /* It didn't work */
+		    emit_amble = autoindex_opts & SUPPRESS_PREAMBLE;
+		    emit_H1 = 1;
+		}
+		ap_table_unset(r->notes, PARENT_STRING);	/* cleanup */
+	    }
+	    else if (!strncasecmp("text/", rr->content_type, 5)) {
+		/*
+		 * If we can open the file, prefix it with the preamble
+		 * regardless; since we'll be sending a <PRE> block around
+		 * the file's contents, any HTML header it had won't end up
+		 * where it belongs.
+		 */
+		if ((f = ap_pfopen(r->pool, rr->filename, "r")) != 0) {
+		    emit_preamble(r, title, autoindex_conf);
+		    emit_amble = 0;
+		    do_emit_plain(r, f, autoindex_opts);
+		    ap_pfclose(r->pool, f);
+		    emit_H1 = 0;
+		}
+	    }
+	}
+    }
+
+    if (r_accept) {
+        ap_table_setn(hdrs, "Accept", r_accept);
+    }
+    else {
+        ap_table_unset(hdrs, "Accept");
+    }
+
+    if (r_accept_enc) {
+        ap_table_setn(hdrs, "Accept-Encoding", r_accept_enc);
+    }
+
+    if (emit_amble) {
+	emit_preamble(r, title, autoindex_conf);
+    }
+
+    if (autoindex_opts & STUDLY_INDEXING) {
+	ap_rvputs(r, "<TABLE cellpadding=\"5\" cellspacing=\"5\" "
+              "width=\"100%\">\n<tbody>\n", NULL);
+    }
+
+    if (emit_H1) {
+	if (autoindex_opts & STUDLY_INDEXING)
+	    ap_rvputs(r, "\n<TR valign=\"top\">\n"
+		    "<TD class=\"header\" bgcolor=\"",
+		    autoindex_conf->hdr_col ?: "#ffffff",
+		    "\" colspan=\"2\">\n", NULL);
+	ap_rputs("<TABLE><TR><TD bgcolor=\"#ffffff\" "
+		"class=\"title\">\n", r);
+	ap_rvputs(r, "<FONT size=\"+3\" "
+		"face=\"Helvetica,Arial,sans-serif\">\n<B>Index of ",
+		title, "</B></FONT>\n", NULL);
+	ap_rputs("\n</TD></TR></TABLE>", r);
+	if (autoindex_opts & STUDLY_INDEXING)
+	    ap_rvputs(r, "</TD>\n</TR>\n", NULL);
+    }
+    if (rr != NULL) {
+	ap_destroy_sub_req(rr);
+    }
+}
+
+
+/*
+ * Handle the Readme file through the postamble, inclusive.  Locate
+ * the file with a subrequests.  Process text/html documents by actually
+ * running the subrequest; text/xxx documents get copied verbatim,
+ * and any other content type is ignored.  This means that a non-text
+ * document (such as FOOTER.gif) might get multiviewed as the result
+ * instead of a text document, meaning nothing will be displayed, but
+ * oh well.
+ */
+static void emit_tail(request_rec *r, char *readme_fname,
+                      autoindex_config_rec *autoindex_conf, int autoindex_opts)
+{
+    FILE *f;
+    request_rec *rr = NULL;
+    int suppress_post = 0;
+    int suppress_sig = 0;
+    const char *r_accept;
+    const char *r_accept_enc;
+    table *hdrs = r->headers_in;
+
+    /*
+     * If there's a readme file, send a subrequest to look for it.  If it's
+     * found and html do the subrequest, otherwise handle it
+     */
+    r_accept = ap_table_get(hdrs, "Accept");
+    r_accept_enc = ap_table_get(hdrs, "Accept-Encoding");
+    ap_table_setn(hdrs, "Accept", "text/html, text/plain;q=.5, text/*;q=.1");
+    ap_table_unset(hdrs, "Accept-Encoding");
+
+    /*
+     * If there's a readme file, send a subrequest to look for it.  If it's
+     * found and a text file, handle it -- otherwise fall through and
+     * pretend there's nothing there.
+     */
+    if ((readme_fname != NULL)
+	&& (rr = ap_sub_req_lookup_uri(readme_fname, r))
+	&& (rr->status == HTTP_OK)
+	&& (rr->filename != NULL)
+	&& S_ISREG(rr->finfo.st_mode)) {
+	/*
+	 * Check for the two specific cases we allow: text/html and
+	 * text/anything-else.  The former is allowed to be processed for
+	 * SSIs.
+	 */
+	if (rr->content_type != NULL) {
+	    if (!strcasecmp(ap_field_noparam(r->pool, rr->content_type),
+			    "text/html")) {
+
+		/* See mod_include */
+		ap_table_add(r->notes, PARENT_STRING, "");
+		ap_table_add(rr->notes, SUB_REQ_STRING, "");
+
+		if (ap_run_sub_req(rr) == OK) {
+		    /* worked... */
+		    suppress_sig = 1;
+		    suppress_post = autoindex_opts & SUPPRESS_PREAMBLE;
+		}
+		ap_table_unset(r->notes, PARENT_STRING);	/* cleanup */
+	    }
+	    else if (!strncasecmp("text/", rr->content_type, 5)) {
+		/*
+		 * If we can open the file, suppress the signature.
+		 */
+		if ((f = ap_pfopen(r->pool, rr->filename, "r")) != 0) {
+		    do_emit_plain(r, f, autoindex_opts & STUDLY_INDEXING);
+		    ap_pfclose(r->pool, f);
+		    suppress_sig = 1;
+		}
+	    }
+	}
+    }
+    
+    if (r_accept) {
+        ap_table_setn(hdrs, "Accept", r_accept);
+    }
+    else {
+        ap_table_unset(hdrs, "Accept");
+    }
+
+    if (r_accept_enc) {
+        ap_table_setn(hdrs, "Accept-Encoding", r_accept_enc);
+    }
+
+    if (autoindex_opts & STUDLY_INDEXING && !suppress_post) {
+	ap_rvputs(r, "\n<TR valign=\"top\">\n<TD class=\"footer\" "
+		"colspan=\"2\" bgcolor=\"",
+		autoindex_conf->ftr_col ?: "#ffffff", "\">\n", NULL);
+	if (do_emit_fancy (r, find_footer(autoindex_conf, r),
+				autoindex_opts) == 0) {
+	    suppress_sig = 1;
+	}
+	ap_rputs("</TD>\n</TR>\n\n</TBODY></TABLE>\n<P>\n", r);
+    }
+    if (!suppress_sig) {
+	if (autoindex_opts & STUDLY_INDEXING)
+	    ap_rputs ("<BR><IMG src=\"/icons/linux-pengo-small.gif\"\n"
+			"width=\"110\" height=\"44\" align=\"right\""
+			"alt=\"\">", r);
+	ap_rputs(ap_psignature("", r), r);
+    }
+    if (!suppress_post) {
+	ap_rputs("</BODY></HTML>\n", r);
+    }
+    if (rr != NULL) {
+	ap_destroy_sub_req(rr);
+    }
+}
+
+
+static char *find_title(request_rec *r)
+{
+    char titlebuf[MAX_STRING_LEN], *find = "<TITLE>";
+    FILE *thefile = NULL;
+    int x, y, n, p;
+
+    if (r->status != HTTP_OK) {
+	return NULL;
+    }
+    if ((r->content_type != NULL)
+	&& (!strcasecmp(ap_field_noparam(r->pool, r->content_type),
+			"text/html")
+	    || !strcmp(r->content_type, INCLUDES_MAGIC_TYPE))
+	&& !r->content_encoding) {
+        if (!(thefile = ap_pfopen(r->pool, r->filename, "r"))) {
+	    return NULL;
+	}
+	n = fread(titlebuf, sizeof(char), MAX_STRING_LEN - 1, thefile);
+	if (n <= 0) {
+	    ap_pfclose(r->pool, thefile);
+	    return NULL;
+	}
+	titlebuf[n] = '\0';
+	for (x = 0, p = 0; titlebuf[x]; x++) {
+	    if (ap_toupper(titlebuf[x]) == find[p]) {
+		if (!find[++p]) {
+		    if ((p = ap_ind(&titlebuf[++x], '<')) != -1) {
+			titlebuf[x + p] = '\0';
+		    }
+		    /* Scan for line breaks for Tanmoy's secretary */
+		    for (y = x; titlebuf[y]; y++) {
+			if ((titlebuf[y] == CR) || (titlebuf[y] == LF)) {
+			    if (y == x) {
+				x++;
+			    }
+			    else {
+				titlebuf[y] = ' ';
+			    }
+			}
+		    }
+		    ap_pfclose(r->pool, thefile);
+		    return ap_pstrdup(r->pool, &titlebuf[x]);
+		}
+	    }
+	    else {
+		p = 0;
+	    }
+	}
+	ap_pfclose(r->pool, thefile);
+    }
+    return NULL;
+}
+
+static struct ent *make_autoindex_entry(char *name, int autoindex_opts,
+					autoindex_config_rec *d,
+					request_rec *r, char keyid,
+					char direction)
+{
+    struct ent *p;
+
+    if ((name[0] == '.') && (!name[1])) {
+	return (NULL);
+    }
+
+    if (ignore_entry(d, ap_make_full_path(r->pool, r->filename, name))) {
+        return (NULL);
+    }
+
+    p = (struct ent *) ap_pcalloc(r->pool, sizeof(struct ent));
+    p->name = ap_pstrdup(r->pool, name);
+    p->size = -1;
+    p->icon = NULL;
+    p->alt = NULL;
+    p->desc = NULL;
+    p->lm = -1;
+    p->isdir = 0;
+    /*
+     * It's obnoxious to have to include this in every entry, but the qsort()
+     * comparison routine only takes two arguments..  The alternative would
+     * add another function call to each invocation.  Let's use memory
+     * rather than CPU.
+     */
+    p->checkdir = ((d->opts & FOLDERS_FIRST) != 0);
+    p->ignorecase = ((d->opts & SORT_NOCASE) != 0);
+    p->key = ap_toupper(keyid);
+    p->ascending = (ap_toupper(direction) == D_ASCENDING);
+
+    if (autoindex_opts & FANCY_INDEXING) {
+	request_rec *rr = ap_sub_req_lookup_file(name, r);
+
+	if (rr->finfo.st_mode != 0) {
+	    p->lm = rr->finfo.st_mtime;
+	    if (S_ISDIR(rr->finfo.st_mode)) {
+		p->isdir = 1;
+	        if (!(p->icon = find_icon(d, rr, 1))) {
+		    p->icon = find_default_icon(d, "^^DIRECTORY^^");
+		}
+		if (!(p->alt = find_alt(d, rr, 1))) {
+		    p->alt = "DIR";
+		}
+		p->size = -1;
+		p->name = ap_pstrcat(r->pool, name, "/", NULL);
+	    }
+	    else {
+		p->icon = find_icon(d, rr, 0);
+		p->alt = find_alt(d, rr, 0);
+		p->size = rr->finfo.st_size;
+	    }
+	}
+
+	p->desc = find_desc(d, rr);
+
+	if ((!p->desc) && (autoindex_opts & SCAN_HTML_TITLES)) {
+	    p->desc = ap_pstrdup(r->pool, find_title(rr));
+	}
+
+	ap_destroy_sub_req(rr);
+    }
+    /*
+     * We don't need to take any special action for the file size key.  If
+     * we did, it would go here.
+     */
+    if (keyid == K_LAST_MOD) {
+        if (p->lm < 0) {
+	    p->lm = 0;
+	}
+    }
+    return (p);
+}
+
+static char *terminate_description(autoindex_config_rec *d, char *desc,
+				   int autoindex_opts, int desc_width)
+{
+    int maxsize = desc_width;
+    register int x;
+
+    /*
+     * If there's no DescriptionWidth in effect, default to the old
+     * behaviour of adjusting the description size depending upon
+     * what else is being displayed.  Otherwise, stick with the
+     * setting.
+     */
+    if (d->desc_adjust == K_UNSET) {
+	if (autoindex_opts & SUPPRESS_LAST_MOD) {
+	    maxsize += 19;
+	}
+	if (autoindex_opts & SUPPRESS_SIZE) {
+	    maxsize += 7;
+	}
+    }
+
+    for (x = 0; desc[x] && ((maxsize > 0) || (desc[x] == '<')); x++) {
+	if (desc[x] == '<') {
+	    while (desc[x] != '>') {
+		if (!desc[x]) {
+		    maxsize = 0;
+		    break;
+		}
+		++x;
+	    }
+	}
+ 	else if (desc[x] == '&') {
+ 	    /* entities like &auml; count as one character */
+ 	    --maxsize;
+ 	    for ( ; desc[x] != ';'; ++x) {
+ 		if (desc[x] == '\0') {
+                     maxsize = 0;
+                     break;
+		}
+	    }
+        }
+	else {
+	    --maxsize;
+	}
+    }
+    if (!maxsize && desc[x] != '\0') {
+	desc[x - 1] = '>';	/* Grump. */
+	desc[x] = '\0';		/* Double Grump! */
+    }
+    return desc;
+}
+
+/*
+ * Emit the anchor for the specified field.  If a field is the key for the
+ * current request, the link changes its meaning to reverse the order when
+ * selected again.  Non-active fields always start in ascending order.
+ */
+static void emit_link(request_rec *r, char *anchor, char fname, char curkey,
+                      char curdirection, int nosort)
+{
+    char qvalue[5];
+    int reverse;
+
+    if (!nosort) {
+	qvalue[0] = '?';
+	qvalue[1] = fname;
+	qvalue[2] = '=';
+	qvalue[4] = '\0';
+	reverse = ((curkey == fname) && (curdirection == D_ASCENDING));
+	qvalue[3] = reverse ? D_DESCENDING : D_ASCENDING;
+	ap_rvputs(r, "<A HREF=\"", qvalue, "\">", anchor, "</A>", NULL);
+    }
+    else {
+        ap_rputs(anchor, r);
+    }
+}
+
+static void output_directories(struct ent **ar, int n,
+			       autoindex_config_rec *d, request_rec *r,
+			       int autoindex_opts, char keyid, char direction)
+{
+    int x;
+    char *name = r->uri;
+    char *tp;
+    int static_columns = (autoindex_opts & SUPPRESS_COLSORT);
+    pool *scratch = ap_make_sub_pool(r->pool);
+    int name_width;
+    int desc_width;
+    char *name_scratch;
+    char *pad_scratch;
+
+    if (autoindex_opts & STUDLY_INDEXING) {
+        if (do_emit_fancy (r, find_main(d, r), autoindex_opts) == 0)
+          return;
+    }
+
+    if (name[0] == '\0') {
+	name = "/";
+    }
+
+    desc_width = d->desc_width;
+    if (d->desc_adjust == K_ADJUST) {
+	for (x = 0; x < n; x++) {
+	    if (ar[x]->desc != NULL) {
+		int t = strlen(ar[x]->desc);
+		if (t > desc_width) {
+		    desc_width = t;
+		}
+	    }
+	}
+    }
+    name_width = d->name_width;
+    if (d->name_adjust == K_ADJUST) {
+	for (x = 0; x < n; x++) {
+	    int t = strlen(ar[x]->name);
+	    if (t > name_width) {
+		name_width = t;
+	    }
+	}
+    }
+    name_scratch = ap_palloc(r->pool, name_width + 1);
+    pad_scratch = ap_palloc(r->pool, name_width + 1);
+    memset(pad_scratch, ' ', name_width);
+    pad_scratch[name_width] = '\0';
+
+    if (autoindex_opts & FANCY_INDEXING) {
+	ap_rputs("<PRE>", r);
+	if ((tp = find_default_icon(d, "^^BLANKICON^^"))) {
+	    ap_rvputs(r, "<IMG border=\"0\" src=\"",
+                      ap_escape_html(scratch, tp),
+		   "\" ALT=\"     \"", NULL);
+	    if (d->icon_width && d->icon_height) {
+		ap_rprintf
+		    (
+			r,
+			" HEIGHT=\"%d\" WIDTH=\"%d\"",
+			d->icon_height,
+			d->icon_width
+		    );
+	    }
+	    ap_rputs("> ", r);
+	}
+        emit_link(r, "Name", K_NAME, keyid, direction, static_columns);
+	ap_rputs(pad_scratch + 4, r);
+	/*
+	 * Emit the guaranteed-at-least-one-space-between-columns byte.
+	 */
+	ap_rputs(" ", r);
+	if (!(autoindex_opts & SUPPRESS_LAST_MOD)) {
+            emit_link(r, "Last modified", K_LAST_MOD, keyid, direction,
+                      static_columns);
+	    ap_rputs("       ", r);
+	}
+	if (!(autoindex_opts & SUPPRESS_SIZE)) {
+            emit_link(r, "Size", K_SIZE, keyid, direction, static_columns);
+	    ap_rputs("  ", r);
+	}
+	if (!(autoindex_opts & SUPPRESS_DESC)) {
+            emit_link(r, "Description", K_DESC, keyid, direction,
+                      static_columns);
+	}
+	ap_rputs("\n<HR noshade align=\"left\" width=\"80%\">\n", r);
+    }
+    else {
+	ap_rputs("<UL>", r);
+    }
+
+    for (x = 0; x < n; x++) {
+	char *anchor, *t, *t2;
+	int nwidth;
+
+	ap_clear_pool(scratch);
+
+	if (is_parent(ar[x]->name)) {
+	    t = ap_make_full_path(scratch, name, "../");
+	    ap_getparents(t);
+	    if (t[0] == '\0') {
+		t = "/";
+	    }
+	    t2 = "Parent Directory";
+	    anchor = ap_escape_html(scratch, ap_os_escape_path(scratch, t, 0));
+	}
+	else {
+	    t = ar[x]->name;
+	    t2 = t;
+	    anchor = ap_escape_html(scratch, ap_os_escape_path(scratch, t, 0));
+	}
+
+	if (autoindex_opts & FANCY_INDEXING) {
+	    if (autoindex_opts & ICONS_ARE_LINKS) {
+		ap_rvputs(r, "<A HREF=\"", anchor, "\">", NULL);
+	    }
+	    if ((ar[x]->icon) || d->default_icon) {
+		ap_rvputs(r, "<IMG border=\"0\" src=\"", 
+			  ap_escape_html(scratch,
+					 ar[x]->icon ? ar[x]->icon
+					             : d->default_icon),
+			  "\" ALT=\"[", (ar[x]->alt ? ar[x]->alt : "   "),
+			  "]\"", NULL);
+		if (d->icon_width && d->icon_height) {
+		    ap_rprintf(r, " HEIGHT=\"%d\" WIDTH=\"%d\"",
+			       d->icon_height, d->icon_width);
+		}
+		ap_rputs(">", r);
+	    }
+	    if (autoindex_opts & ICONS_ARE_LINKS) {
+		ap_rputs("</A>", r);
+	    }
+
+	    nwidth = strlen(t2);
+	    if (nwidth > name_width) {
+		memcpy(name_scratch, t2, name_width - 3);
+		name_scratch[name_width - 3] = '.';
+		name_scratch[name_width - 2] = '.';
+		name_scratch[name_width - 1] = '>';
+		name_scratch[name_width] = 0;
+		t2 = name_scratch;
+		nwidth = name_width;
+	    }
+	    ap_rvputs(r, " <A HREF=\"", anchor, "\">",
+		      ap_escape_html(scratch, t2), "</A>",
+		      pad_scratch + nwidth, NULL);
+	    /*
+	     * The blank before the storm.. er, before the next field.
+	     */
+	    ap_rputs(" ", r);
+	    if (!(autoindex_opts & SUPPRESS_LAST_MOD)) {
+		if (ar[x]->lm != -1) {
+		    char time_str[MAX_STRING_LEN];
+		    struct tm *ts = localtime(&ar[x]->lm);
+		    strftime(time_str, MAX_STRING_LEN, "%d-%b-%Y %H:%M  ", ts);
+		    ap_rputs(time_str, r);
+		}
+		else {
+		    /*Length="22-Feb-1998 23:42  " (see 4 lines above) */
+		    ap_rputs("                   ", r);
+		}
+	    }
+	    if (!(autoindex_opts & SUPPRESS_SIZE)) {
+		ap_send_size(ar[x]->size, r);
+		ap_rputs("  ", r);
+	    }
+	    if (!(autoindex_opts & SUPPRESS_DESC)) {
+		if (ar[x]->desc) {
+		    ap_rputs(terminate_description(d, ar[x]->desc,
+						   autoindex_opts,
+						   desc_width), r);
+		}
+	    }
+	}
+	else {
+	    ap_rvputs(r, "<LI><A HREF=\"", anchor, "\"> ", t2,
+		      "</A>", NULL);
+	}
+	ap_rputc('\n', r);
+    }
+    if (autoindex_opts & FANCY_INDEXING) {
+	ap_rputs("</PRE>", r);
+    }
+    else {
+	ap_rputs("</UL>", r);
+    }
+}
+
+/*
+ * Compare two file entries according to the sort criteria.  The return
+ * is essentially a signum function value.
+ */
+
+static int dsortf(struct ent **e1, struct ent **e2)
+{
+    struct ent *c1;
+    struct ent *c2;
+    int result = 0;
+    int ignorecase;
+
+    /*
+     * First, see if either of the entries is for the parent directory.
+     * If so, that *always* sorts lower than anything else.
+     */
+    if (is_parent((*e1)->name)) {
+        return -1;
+    }
+    if (is_parent((*e2)->name)) {
+        return 1;
+    }
+    /*
+     * Now see if one's a directory and one isn't, AND we're listing
+     * directories first.
+     */
+    if ((*e1)->checkdir) {
+	if ((*e1)->isdir != (*e2)->isdir) {
+	    return (*e1)->isdir ? -1 : 1;
+	}
+    }
+    /*
+     * All of our comparisons will be of the c1 entry against the c2 one,
+     * so assign them appropriately to take care of the ordering.
+     */
+    if ((*e1)->ascending) {
+        c1 = *e1;
+        c2 = *e2;
+    }
+    else {
+        c1 = *e2;
+        c2 = *e1;
+    }
+    switch (c1->key) {
+    case K_LAST_MOD:
+	if (c1->lm > c2->lm) {
+            return 1;
+        }
+        else if (c1->lm < c2->lm) {
+            return -1;
+        }
+        break;
+    case K_SIZE:
+        if (c1->size > c2->size) {
+            return 1;
+        }
+        else if (c1->size < c2->size) {
+            return -1;
+        }
+        break;
+    case K_DESC:
+        result = strcmp(c1->desc ? c1->desc : "", c2->desc ? c2->desc : "");
+        if (result) {
+            return result;
+        }
+        break;
+    }
+
+    ignorecase = c1->ignorecase;
+    if (ignorecase) {
+        result = strcasecmp(c1->name, c2->name);
+        if (result == 0) {
+            /*
+             * They're identical when treated case-insensitively, so
+             * pretend they weren't and let strcmp() put them in a
+             * deterministic order.  This means that 'ABC' and 'abc'
+             * will always appear in the same order, rather than
+             * unpredictably 'ABC abc' or 'abc ABC'.
+             */
+            ignorecase = 0;
+        }
+    }
+    if (! ignorecase) {
+        result = strcmp(c1->name, c2->name);
+    }
+    return result;
+}
+
+
+static int index_directory(request_rec *r,
+			   autoindex_config_rec *autoindex_conf)
+{
+    char *title_name = ap_escape_html(r->pool, r->uri);
+    char *title_endp;
+    char *name = r->filename;
+
+    DIR *d;
+    struct DIR_TYPE *dstruct;
+    int num_ent = 0, x;
+    struct ent *head, *p;
+    struct ent **ar = NULL;
+    const char *qstring;
+    int autoindex_opts = autoindex_conf->opts;
+    char keyid;
+    char direction;
+
+    if (!(d = ap_popendir(r->pool, name))) {
+	ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
+		    "Can't open directory for index: %s", r->filename);
+	return HTTP_FORBIDDEN;
+    }
+
+    r->content_type = "text/html";
+    if (autoindex_opts & TRACK_MODIFIED) {
+        ap_update_mtime(r, r->finfo.st_mtime);
+        ap_set_last_modified(r);
+        ap_set_etag(r);
+    }
+    ap_send_http_header(r);
+
+#ifdef CHARSET_EBCDIC
+    /* Server-generated response, converted */
+    ap_bsetflag(r->connection->client, B_EBCDIC2ASCII, r->ebcdic.conv_out = 1);
+#endif
+
+    if (r->header_only) {
+	ap_pclosedir(r->pool, d);
+	return 0;
+    }
+    ap_hard_timeout("send directory", r);
+
+    /* Spew HTML preamble */
+
+    title_endp = title_name + strlen(title_name) - 1;
+
+    while (title_endp > title_name && *title_endp == '/') {
+	*title_endp-- = '\0';
+    }
+
+    emit_head(r, find_header(autoindex_conf, r), autoindex_conf,
+	      autoindex_opts & SUPPRESS_PREAMBLE, title_name);
+
+    /*
+     * Figure out what sort of indexing (if any) we're supposed to use.
+     *
+     * If no QUERY_STRING was specified or column sorting has been
+     * explicitly disabled, we use the default specified by the
+     * IndexOrderDefault directive (if there is one); otherwise,
+     * we fall back to ascending by name.
+     */
+    qstring = r->args;
+    if ((autoindex_opts & SUPPRESS_COLSORT)
+	|| ((qstring == NULL) || (*qstring == '\0'))) {
+	qstring = autoindex_conf->default_order;
+    }
+    /*
+     * If there is no specific ordering defined for this directory,
+     * default to ascending by filename.
+     */
+    if ((qstring == NULL) || (*qstring == '\0')) {
+	keyid = K_NAME;
+	direction = D_ASCENDING;
+    }
+    else {
+	keyid = *qstring;
+	ap_getword(r->pool, &qstring, '=');
+	if (*qstring == D_DESCENDING) {
+	    direction = D_DESCENDING;
+	}
+	else {
+	    direction = D_ASCENDING;
+	}
+    }
+
+    /* 
+     * Since we don't know how many dir. entries there are, put them into a 
+     * linked list and then arrayificate them so qsort can use them. 
+     */
+    head = NULL;
+    while ((dstruct = readdir(d))) {
+	p = make_autoindex_entry(dstruct->d_name, autoindex_opts,
+				 autoindex_conf, r, keyid, direction);
+	if (p != NULL) {
+	    p->next = head;
+	    head = p;
+	    num_ent++;
+	}
+    }
+    if (num_ent > 0) {
+	ar = (struct ent **) ap_palloc(r->pool,
+				       num_ent * sizeof(struct ent *));
+	p = head;
+	x = 0;
+	while (p) {
+	    ar[x++] = p;
+	    p = p->next;
+	}
+
+	qsort((void *) ar, num_ent, sizeof(struct ent *),
+	      (int (*)(const void *, const void *)) dsortf);
+    }
+    if (autoindex_opts & STUDLY_INDEXING) {
+	ap_rputs("\n<TR valign=\"top\">\n", r);
+	ap_rvputs(r, "\n<TD class=\"sidebar\" bgcolor=\"",
+		  autoindex_conf->side_col ?: "#ffffff",
+		  "\" width=\"5%\">\n", NULL);
+	do_emit_fancy (r, find_sidebar(autoindex_conf, r), autoindex_opts);
+	ap_rputs("</TD>\n", r);
+	ap_rvputs(r, "\n<TD class=\"body\" bgcolor=\"",
+		  autoindex_conf->main_col ?: "#ffffff", "\">\n", NULL);
+    }
+    output_directories(ar, num_ent, autoindex_conf, r, autoindex_opts, keyid,
+		       direction);
+    ap_pclosedir(r->pool, d);
+
+    if (autoindex_opts & STUDLY_INDEXING) {
+	ap_rputs("</TD class=\"body\">\n\n</TR>\n", r);
+    }
+    else if (autoindex_opts & FANCY_INDEXING) {
+	ap_rputs("<HR noshade align=\"left\" width=\"80%\">\n", r);
+    }
+    emit_tail(r, find_readme(autoindex_conf, r), autoindex_conf, autoindex_opts);
+
+    ap_kill_timeout(r);
+    return 0;
+}
+
+/* The formal handler... */
+
+static int handle_autoindex(request_rec *r)
+{
+    autoindex_config_rec *d;
+    int opt_indexes = ap_allow_options(r) & OPT_INDEXES;
+
+    d = (autoindex_config_rec *) ap_get_module_config(r->per_dir_config,
+						      &autoindex_module);
+
+    r->allowed |= (1 << M_GET);
+    if (r->method_number != M_GET) {
+	return DECLINED;
+    }
+
+    /* OK, nothing easy.  Trot out the heavy artillery... */
+    if ((d->incremented_opts & INDEXOPT_INDEXES) ||
+	(d->opts & INDEXOPT_INDEXES)) opt_indexes = 1;
+    if ((d->decremented_opts & INDEXOPT_INDEXES) &&
+	!(d->opts & INDEXOPT_INDEXES)) opt_indexes = 0;
+
+    if (opt_indexes) {
+	/* KLUDGE --- make the sub_req lookups happen in the right directory.
+	 * Fixing this in the sub_req_lookup functions themselves is difficult,
+	 * and would probably break virtual includes...
+	 */
+
+	if (r->filename[strlen(r->filename) - 1] != '/') {
+	    r->filename = ap_pstrcat(r->pool, r->filename, "/", NULL);
+	}
+	return index_directory(r, d);
+    }
+    else {
+	ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+		     "Directory index forbidden by rule: %s", r->filename);
+	return HTTP_FORBIDDEN;
+    }
+}
+
+
+static const handler_rec autoindex_handlers[] =
+{
+    {DIR_MAGIC_TYPE, handle_autoindex},
+    {NULL}
+};
+
+module MODULE_VAR_EXPORT autoindex_module =
+{
+    STANDARD_MODULE_STUFF,
+    NULL,			/* initializer */
+    create_autoindex_config,	/* dir config creater */
+    merge_autoindex_configs,	/* dir merger --- default is to override */
+    NULL,			/* server config */
+    NULL,			/* merge server config */
+    autoindex_cmds,		/* command table */
+    autoindex_handlers,		/* handlers */
+    NULL,			/* filename translation */
+    NULL,			/* check_user_id */
+    NULL,			/* check auth */
+    NULL,			/* check access */
+    NULL,			/* type_checker */
+    NULL,			/* fixups */
+    NULL,			/* logger */
+    NULL,			/* header parser */
+    NULL,			/* child_init */
+    NULL,			/* child_exit */
+    NULL			/* post read-request */
+};
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_log_agent.c apache_1.3.33/src/modules/standard/mod_log_agent.c
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_log_agent.c	Fri Feb 20 21:37:40 2004
+++ apache_1.3.33/src/modules/standard/mod_log_agent.c	Mon Jul 18 15:22:19 2005
@@ -24,7 +24,7 @@
 /* OS/2 dosen't support users and groups */
 static mode_t xfer_mode = (S_IREAD | S_IWRITE);
 #else
-static mode_t xfer_mode = (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
+static mode_t xfer_mode = (S_IRUSR | S_IWUSR | S_IRGRP );
 #endif
 
 typedef struct {
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_log_config.c apache_1.3.33/src/modules/standard/mod_log_config.c
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_log_config.c	Fri Feb 20 21:37:40 2004
+++ apache_1.3.33/src/modules/standard/mod_log_config.c	Mon Jul 18 15:22:25 2005
@@ -150,7 +150,7 @@
 /* OS/2 dosen't support users and groups */
 static mode_t xfer_mode = (S_IREAD | S_IWRITE);
 #else
-static mode_t xfer_mode = (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
+static mode_t xfer_mode = (S_IRUSR | S_IWUSR | S_IRGRP );
 #endif
 
 /* POSIX.1 defines PIPE_BUF as the maximum number of bytes that is
@@ -220,6 +220,9 @@
 typedef const char *(*item_key_func) (request_rec *, char *);
 
 typedef struct {
+#ifdef EAPI
+    char ch;
+#endif
     item_key_func func;
     char *arg;
     int condition_sense;
@@ -541,15 +544,36 @@
     }
 };
 
+#ifdef EAPI
+static struct log_item_list *find_log_func(pool *p, char k)
+#else /* EAPI */
 static struct log_item_list *find_log_func(char k)
+#endif /* EAPI */
 {
     int i;
+#ifdef EAPI
+    struct log_item_list *lil;
+#endif /* EAPI */
 
     for (i = 0; log_item_keys[i].ch; ++i)
         if (k == log_item_keys[i].ch) {
             return &log_item_keys[i];
         }
 
+#ifdef EAPI
+    if (ap_hook_status(ap_psprintf(p, "ap::mod_log_config::log_%c", k)) 
+        != AP_HOOK_STATE_NOTEXISTANT) {
+        lil = (struct log_item_list *)
+              ap_pcalloc(p, sizeof(struct log_item_list));
+        if (lil == NULL)
+            return NULL;
+        lil->ch = k;
+        lil->func = NULL;
+        lil->want_orig_default = 0;
+        return lil;
+    }
+#endif /* EAPI */
+
     return NULL;
 }
 
@@ -675,7 +699,11 @@
             break;
 
         default:
+#ifdef EAPI
+            l = find_log_func(p, *s++);
+#else /* EAPI */
             l = find_log_func(*s++);
+#endif /* EAPI */
             if (!l) {
                 char dummy[2];
 
@@ -684,6 +712,9 @@
                 return ap_pstrcat(p, "Unrecognized LogFormat directive %",
                                dummy, NULL);
             }
+#ifdef EAPI
+            it->ch = s[-1];
+#endif
             it->func = l->func;
             if (it->want_orig == -1) {
                 it->want_orig = l->want_orig_default;
@@ -745,6 +776,15 @@
 
     /* We do.  Do it... */
 
+#ifdef EAPI
+    if (item->func == NULL) {
+        cp = NULL;
+        ap_hook_use(ap_psprintf(r->pool, "ap::mod_log_config::log_%c", item->ch),
+                    AP_HOOK_SIG3(ptr,ptr,ptr), AP_HOOK_DECLINE(NULL),
+                    &cp, r, item->arg);
+    }
+    else
+#endif
     cp = (*item->func) (item->want_orig ? orig : r, item->arg);
     return cp ? cp : "-";
 }
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_log_forensic.c apache_1.3.33/src/modules/standard/mod_log_forensic.c
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_log_forensic.c	Sat Aug 28 01:49:39 2004
+++ apache_1.3.33/src/modules/standard/mod_log_forensic.c	Mon Jul 18 15:22:19 2005
@@ -91,7 +91,7 @@
         char *fname = ap_server_root_relative(p, cfg->logname);
 
         if ((cfg->fd = ap_popenf_ex(p, fname, O_WRONLY | O_APPEND | O_CREAT,
-                                    S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH, 1))
+                                    S_IRUSR | S_IWUSR | S_IRGRP, 1))
             < 0) {
             ap_log_error(APLOG_MARK, APLOG_ERR, s,
                          "could not open forensic log file %s.", fname);
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_log_referer.c apache_1.3.33/src/modules/standard/mod_log_referer.c
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_log_referer.c	Fri Feb 20 21:37:40 2004
+++ apache_1.3.33/src/modules/standard/mod_log_referer.c	Mon Jul 18 15:22:19 2005
@@ -25,7 +25,7 @@
 /* OS/2 lacks support for users and groups */
 static mode_t xfer_mode = (S_IREAD | S_IWRITE);
 #else
-static mode_t xfer_mode = (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
+static mode_t xfer_mode = (S_IRUSR | S_IWUSR | S_IRGRP );
 #endif
 
 typedef struct {
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_rewrite.c apache_1.3.33/src/modules/standard/mod_rewrite.c
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_rewrite.c	Wed Oct 27 16:23:04 2004
+++ apache_1.3.33/src/modules/standard/mod_rewrite.c	Mon Jul 18 15:22:25 2005
@@ -3246,7 +3246,7 @@
 #elif defined(WIN32)
     mode_t rewritelog_mode  = ( _S_IREAD|_S_IWRITE );
 #else
-    mode_t rewritelog_mode  = ( S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH );
+    mode_t rewritelog_mode  = ( S_IRUSR|S_IWUSR|S_IRGRP );
 #endif
 
     conf = ap_get_module_config(s->module_config, &rewrite_module);
@@ -3862,6 +3862,15 @@
         }
     }
 #endif /* ndef WIN32 && NETWARE*/
+
+#ifdef EAPI
+    else {
+        ap_hook_use("ap::mod_rewrite::lookup_variable",
+                    AP_HOOK_SIG3(ptr,ptr,ptr), 
+                    AP_HOOK_DECLINE(NULL),
+                    &result, r, var);
+    }
+#endif
 
     if (result == NULL) {
         return ap_pstrdup(r->pool, "");
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_rewrite.c.orig apache_1.3.33/src/modules/standard/mod_rewrite.c.orig
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_rewrite.c.orig	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/modules/standard/mod_rewrite.c.orig	Mon Jul 18 15:22:19 2005
@@ -0,0 +1,4493 @@
+/* Copyright 1999-2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+/*                       _                            _ _
+**   _ __ ___   ___   __| |    _ __ _____      ___ __(_) |_ ___
+**  | '_ ` _ \ / _ \ / _` |   | '__/ _ \ \ /\ / / '__| | __/ _ \
+**  | | | | | | (_) | (_| |   | | |  __/\ V  V /| |  | | ||  __/
+**  |_| |_| |_|\___/ \__,_|___|_|  \___| \_/\_/ |_|  |_|\__\___|
+**                       |_____|
+**
+**  URL Rewriting Module
+**
+**  This module uses a rule-based rewriting engine (based on a
+**  regular-expression parser) to rewrite requested URLs on the fly.
+**
+**  It supports an unlimited number of additional rule conditions (which can
+**  operate on a lot of variables, even on HTTP headers) for granular
+**  matching and even external database lookups (either via plain text
+**  tables, DBM hash files or even external processes) for advanced URL
+**  substitution.
+**
+**  It operates on the full URLs (including the PATH_INFO part) both in
+**  per-server context (httpd.conf) and per-dir context (.htaccess) and even
+**  can generate QUERY_STRING parts on result.   The rewriting result finally
+**  can lead to internal subprocessing, external request redirection or even
+**  to internal proxy throughput.
+**
+**  This module was originally written in April 1996 and
+**  gifted exclusively to the The Apache Group in July 1997 by
+**
+**      Ralf S. Engelschall
+**      rse@engelschall.com
+**      www.engelschall.com
+*/
+
+
+#include "mod_rewrite.h"
+
+#ifndef NO_WRITEV
+#ifndef NETWARE
+#include <sys/types.h>
+#endif
+#include <sys/uio.h>
+#endif
+
+#ifdef NETWARE
+#include <nwsemaph.h>
+static LONG locking_sem = 0;
+#endif
+
+/*
+** +-------------------------------------------------------+
+** |                                                       |
+** |             static module configuration
+** |                                                       |
+** +-------------------------------------------------------+
+*/
+
+
+/*
+**  Our interface to the Apache server kernel:
+**
+**  o  Runtime logic of a request is as following:
+**       while(request or subrequest)
+**           foreach(stage #0...#9)
+**               foreach(module) (**)
+**                   try to run hook
+**
+**  o  the order of modules at (**) is the inverted order as
+**     given in the "Configuration" file, i.e. the last module
+**     specified is the first one called for each hook!
+**     The core module is always the last!
+**
+**  o  there are two different types of result checking and
+**     continue processing:
+**     for hook #0,#1,#4,#5,#6,#8:
+**         hook run loop stops on first modules which gives
+**         back a result != DECLINED, i.e. it usually returns OK
+**         which says "OK, module has handled this _stage_" and for #1
+**         this have not to mean "Ok, the filename is now valid".
+**     for hook #2,#3,#7,#9:
+**         all hooks are run, independend of result
+**
+**  o  at the last stage, the core module always
+**       - says "BAD_REQUEST" if r->filename does not begin with "/"
+**       - prefix URL with document_root or replaced server_root
+**         with document_root and sets r->filename
+**       - always return a "OK" independed if the file really exists
+**         or not!
+*/
+
+    /* The section for the Configure script:
+     * MODULE-DEFINITION-START
+     * Name: rewrite_module
+     * ConfigStart
+    . ./helpers/find-dbm-lib
+    if [ "x$found_dbm" = "x1" ]; then
+        echo "      enabling DBM support for mod_rewrite"
+    else
+        echo "      disabling DBM support for mod_rewrite"
+        echo "      (perhaps you need to add -ldbm, -lndbm or -lgdbm to EXTRA_LIBS)"
+        CFLAGS="$CFLAGS -DNO_DBM_REWRITEMAP"
+    fi
+     * ConfigEnd
+     * MODULE-DEFINITION-END
+     */
+
+    /* the table of commands we provide */
+static const command_rec command_table[] = {
+    { "RewriteEngine",   cmd_rewriteengine,   NULL, OR_FILEINFO, FLAG,
+      "On or Off to enable or disable (default) the whole rewriting engine" },
+    { "RewriteOptions",  cmd_rewriteoptions,  NULL, OR_FILEINFO, ITERATE,
+      "List of option strings to set" },
+    { "RewriteBase",     cmd_rewritebase,     NULL, OR_FILEINFO, TAKE1,
+      "the base URL of the per-directory context" },
+    { "RewriteCond",     cmd_rewritecond,     NULL, OR_FILEINFO, RAW_ARGS,
+      "an input string and a to be applied regexp-pattern" },
+    { "RewriteRule",     cmd_rewriterule,     NULL, OR_FILEINFO, RAW_ARGS,
+      "an URL-applied regexp-pattern and a substitution URL" },
+    { "RewriteMap",      cmd_rewritemap,      NULL, RSRC_CONF,   TAKE2,
+      "a mapname and a filename" },
+    { "RewriteLock",     cmd_rewritelock,     NULL, RSRC_CONF,   TAKE1,
+      "the filename of a lockfile used for inter-process synchronization"},
+    { "RewriteLog",      cmd_rewritelog,      NULL, RSRC_CONF,   TAKE1,
+      "the filename of the rewriting logfile" },
+    { "RewriteLogLevel", cmd_rewriteloglevel, NULL, RSRC_CONF,   TAKE1,
+      "the level of the rewriting logfile verbosity "
+      "(0=none, 1=std, .., 9=max)" },
+    { NULL }
+};
+
+    /* the table of content handlers we provide */
+static const handler_rec handler_table[] = {
+    { "redirect-handler", handler_redirect },
+    { NULL }
+};
+
+    /* the main config structure */
+module MODULE_VAR_EXPORT rewrite_module = {
+   STANDARD_MODULE_STUFF,
+   init_module,                 /* module initializer                  */
+   config_perdir_create,        /* create per-dir    config structures */
+   config_perdir_merge,         /* merge  per-dir    config structures */
+   config_server_create,        /* create per-server config structures */
+   config_server_merge,         /* merge  per-server config structures */
+   command_table,               /* table of config file commands       */
+   handler_table,               /* [#8] MIME-typed-dispatched handlers */
+   hook_uri2file,               /* [#1] URI to filename translation    */
+   NULL,                        /* [#4] validate user id from request  */
+   NULL,                        /* [#5] check if the user is ok _here_ */
+   NULL,                        /* [#3] check access by host address   */
+   hook_mimetype,               /* [#6] determine MIME type            */
+   hook_fixup,                  /* [#7] pre-run fixups                 */
+   NULL,                        /* [#9] log a transaction              */
+   NULL,                        /* [#2] header parser                  */
+   init_child,                  /* child_init                          */
+   NULL,                        /* child_exit                          */
+   NULL                         /* [#0] post read-request              */
+};
+
+    /* the cache */
+static cache *cachep;
+
+    /* whether proxy module is available or not */
+static int proxy_available;
+
+static char *lockname;
+static int lockfd = -1;
+
+/*
+** +-------------------------------------------------------+
+** |                                                       |
+** |           configuration directive handling
+** |                                                       |
+** +-------------------------------------------------------+
+*/
+
+/*
+**
+**  per-server configuration structure handling
+**
+*/
+
+static void *config_server_create(pool *p, server_rec *s)
+{
+    rewrite_server_conf *a;
+
+    a = (rewrite_server_conf *)ap_pcalloc(p, sizeof(rewrite_server_conf));
+
+    a->state           = ENGINE_DISABLED;
+    a->options         = OPTION_NONE;
+    a->rewritelogfile  = NULL;
+    a->rewritelogfp    = -1;
+    a->rewriteloglevel = 0;
+    a->rewritemaps     = ap_make_array(p, 2, sizeof(rewritemap_entry));
+    a->rewriteconds    = ap_make_array(p, 2, sizeof(rewritecond_entry));
+    a->rewriterules    = ap_make_array(p, 2, sizeof(rewriterule_entry));
+    a->server          = s;
+    a->redirect_limit  = 0; /* unset (use default) */
+
+    return (void *)a;
+}
+
+static void *config_server_merge(pool *p, void *basev, void *overridesv)
+{
+    rewrite_server_conf *a, *base, *overrides;
+
+    a         = (rewrite_server_conf *)ap_pcalloc(p, sizeof(rewrite_server_conf));
+    base      = (rewrite_server_conf *)basev;
+    overrides = (rewrite_server_conf *)overridesv;
+
+    a->state   = overrides->state;
+    a->options = overrides->options;
+    a->server  = overrides->server;
+    a->redirect_limit = overrides->redirect_limit
+                          ? overrides->redirect_limit
+                          : base->redirect_limit;
+
+    if (a->options & OPTION_INHERIT) {
+        /*
+         *  local directives override
+         *  and anything else is inherited
+         */
+        a->rewriteloglevel = overrides->rewriteloglevel != 0 
+                             ? overrides->rewriteloglevel
+                             : base->rewriteloglevel;
+        a->rewritelogfile  = overrides->rewritelogfile != NULL 
+                             ? overrides->rewritelogfile
+                             : base->rewritelogfile;
+        a->rewritelogfp    = overrides->rewritelogfp != -1 
+                             ? overrides->rewritelogfp 
+                             : base->rewritelogfp;
+        a->rewritemaps     = ap_append_arrays(p, overrides->rewritemaps,
+                                              base->rewritemaps);
+        a->rewriteconds    = ap_append_arrays(p, overrides->rewriteconds,
+                                              base->rewriteconds);
+        a->rewriterules    = ap_append_arrays(p, overrides->rewriterules,
+                                              base->rewriterules);
+    }
+    else {
+        /*
+         *  local directives override
+         *  and anything else gets defaults
+         */
+        a->rewriteloglevel = overrides->rewriteloglevel;
+        a->rewritelogfile  = overrides->rewritelogfile;
+        a->rewritelogfp    = overrides->rewritelogfp;
+        a->rewritemaps     = overrides->rewritemaps;
+        a->rewriteconds    = overrides->rewriteconds;
+        a->rewriterules    = overrides->rewriterules;
+    }
+
+    return (void *)a;
+}
+
+
+/*
+**
+**  per-directory configuration structure handling
+**
+*/
+
+static void *config_perdir_create(pool *p, char *path)
+{
+    rewrite_perdir_conf *a;
+
+    a = (rewrite_perdir_conf *)ap_pcalloc(p, sizeof(rewrite_perdir_conf));
+
+    a->state           = ENGINE_DISABLED;
+    a->options         = OPTION_NONE;
+    a->baseurl         = NULL;
+    a->rewriteconds    = ap_make_array(p, 2, sizeof(rewritecond_entry));
+    a->rewriterules    = ap_make_array(p, 2, sizeof(rewriterule_entry));
+    a->redirect_limit  = 0; /* unset (use server config) */
+
+    if (path == NULL) {
+        a->directory = NULL;
+    }
+    else {
+        /* make sure it has a trailing slash */
+        if (path[strlen(path)-1] == '/') {
+            a->directory = ap_pstrdup(p, path);
+        }
+        else {
+            a->directory = ap_pstrcat(p, path, "/", NULL);
+        }
+    }
+
+    return (void *)a;
+}
+
+static void *config_perdir_merge(pool *p, void *basev, void *overridesv)
+{
+    rewrite_perdir_conf *a, *base, *overrides;
+
+    a         = (rewrite_perdir_conf *)ap_pcalloc(p,
+                                                  sizeof(rewrite_perdir_conf));
+    base      = (rewrite_perdir_conf *)basev;
+    overrides = (rewrite_perdir_conf *)overridesv;
+
+    a->state     = overrides->state;
+    a->options   = overrides->options;
+    a->directory = overrides->directory;
+    a->baseurl   = overrides->baseurl;
+    a->redirect_limit = overrides->redirect_limit
+                          ? overrides->redirect_limit
+                          : base->redirect_limit;
+
+    if (a->options & OPTION_INHERIT) {
+        a->rewriteconds = ap_append_arrays(p, overrides->rewriteconds,
+                                           base->rewriteconds);
+        a->rewriterules = ap_append_arrays(p, overrides->rewriterules,
+                                           base->rewriterules);
+    }
+    else {
+        a->rewriteconds = overrides->rewriteconds;
+        a->rewriterules = overrides->rewriterules;
+    }
+
+    return (void *)a;
+}
+
+
+/*
+**
+**  the configuration commands
+**
+*/
+
+static const char *cmd_rewriteengine(cmd_parms *cmd,
+                                     rewrite_perdir_conf *dconf, int flag)
+{
+    rewrite_server_conf *sconf;
+
+    sconf = 
+        (rewrite_server_conf *)ap_get_module_config(cmd->server->module_config,
+                                                    &rewrite_module);
+
+    if (cmd->path == NULL) { /* is server command */
+        sconf->state = (flag ? ENGINE_ENABLED : ENGINE_DISABLED);
+    }
+    else                   /* is per-directory command */ {
+        dconf->state = (flag ? ENGINE_ENABLED : ENGINE_DISABLED);
+    }
+
+    return NULL;
+}
+
+static const char *cmd_rewriteoptions(cmd_parms *cmd,
+                                      void *in_dconf, const char *option)
+{
+    int options = 0, limit = 0;
+    char *w;
+
+    while (*option) {
+        w = ap_getword_conf(cmd->pool, &option);
+
+        if (!strcasecmp(w, "inherit")) {
+            options |= OPTION_INHERIT;
+        }
+        else if (!strncasecmp(w, "MaxRedirects=", 13)) {
+            limit = atoi(&w[13]);
+            if (limit <= 0) {
+                return "RewriteOptions: MaxRedirects takes a number greater "
+                       "than zero.";
+            }
+        }
+        else if (!strcasecmp(w, "MaxRedirects")) { /* be nice */
+            return "RewriteOptions: MaxRedirects has the format MaxRedirects"
+                   "=n.";
+        }
+        else {
+            return ap_pstrcat(cmd->pool, "RewriteOptions: unknown option '",
+                              w, "'", NULL);
+        }
+    }
+
+    /* put it into the appropriate config */
+    if (cmd->path == NULL) { /* is server command */
+        rewrite_server_conf *conf =
+            ap_get_module_config(cmd->server->module_config,
+                                 &rewrite_module);
+
+        conf->options |= options;
+        conf->redirect_limit = limit;
+    }
+    else {                  /* is per-directory command */
+        rewrite_perdir_conf *conf = in_dconf;
+
+        conf->options |= options;
+        conf->redirect_limit = limit;
+    }
+
+    return NULL;
+}
+
+static const char *cmd_rewritelog(cmd_parms *cmd, void *dconf, char *a1)
+{
+    rewrite_server_conf *sconf;
+
+    sconf = (rewrite_server_conf *)
+            ap_get_module_config(cmd->server->module_config, &rewrite_module);
+
+    sconf->rewritelogfile = a1;
+
+    return NULL;
+}
+
+static const char *cmd_rewriteloglevel(cmd_parms *cmd, void *dconf, char *a1)
+{
+    rewrite_server_conf *sconf;
+
+    sconf = (rewrite_server_conf *)
+            ap_get_module_config(cmd->server->module_config, &rewrite_module);
+
+    sconf->rewriteloglevel = atoi(a1);
+
+    return NULL;
+}
+
+static const char *cmd_rewritemap(cmd_parms *cmd, void *dconf, char *a1,
+                                  char *a2)
+{
+    rewrite_server_conf *sconf;
+    rewritemap_entry *new;
+    struct stat st;
+
+    sconf = (rewrite_server_conf *)
+            ap_get_module_config(cmd->server->module_config, &rewrite_module);
+
+    new = ap_push_array(sconf->rewritemaps);
+
+    new->name = a1;
+    new->func = NULL;
+    if (strncmp(a2, "txt:", 4) == 0) {
+        new->type      = MAPTYPE_TXT;
+        new->datafile  = a2+4;
+        new->checkfile = a2+4;
+        new->cachename = ap_psprintf(cmd->pool, "%pp:%s",
+                                     (void *)cmd->server, a1);
+    }
+    else if (strncmp(a2, "rnd:", 4) == 0) {
+        new->type      = MAPTYPE_RND;
+        new->datafile  = a2+4;
+        new->checkfile = a2+4;
+        new->cachename = ap_psprintf(cmd->pool, "%pp:%s",
+                                     (void *)cmd->server, a1);
+    }
+    else if (strncmp(a2, "dbm:", 4) == 0) {
+#ifndef NO_DBM_REWRITEMAP
+        new->type      = MAPTYPE_DBM;
+        new->datafile  = a2+4;
+        new->checkfile = ap_pstrcat(cmd->pool, a2+4, NDBM_FILE_SUFFIX, NULL);
+        new->cachename = ap_psprintf(cmd->pool, "%pp:%s",
+                                     (void *)cmd->server, a1);
+#else
+        return ap_pstrdup(cmd->pool, "RewriteMap: cannot use NDBM mapfile, "
+                          "because no NDBM support is compiled in");
+#endif
+    }
+    else if (strncmp(a2, "prg:", 4) == 0) {
+        new->type = MAPTYPE_PRG;
+        new->datafile = a2+4;
+        new->checkfile = a2+4;
+        new->cachename = NULL;
+    }
+    else if (strncmp(a2, "int:", 4) == 0) {
+        new->type      = MAPTYPE_INT;
+        new->datafile  = NULL;
+        new->checkfile = NULL;
+        new->cachename = NULL;
+        if (strcmp(a2+4, "tolower") == 0) {
+            new->func = rewrite_mapfunc_tolower;
+        }
+        else if (strcmp(a2+4, "toupper") == 0) {
+            new->func = rewrite_mapfunc_toupper;
+        }
+        else if (strcmp(a2+4, "escape") == 0) {
+            new->func = rewrite_mapfunc_escape;
+        }
+        else if (strcmp(a2+4, "unescape") == 0) {
+            new->func = rewrite_mapfunc_unescape;
+        }
+        else if (sconf->state == ENGINE_ENABLED) {
+            return ap_pstrcat(cmd->pool, "RewriteMap: internal map not found:",
+                              a2+4, NULL);
+        }
+    }
+    else {
+        new->type      = MAPTYPE_TXT;
+        new->datafile  = a2;
+        new->checkfile = a2;
+        new->cachename = ap_psprintf(cmd->pool, "%pp:%s",
+                                     (void *)cmd->server, a1);
+    }
+    new->fpin  = -1;
+    new->fpout = -1;
+
+    if (new->checkfile && (sconf->state == ENGINE_ENABLED)
+        && (stat(new->checkfile, &st) == -1)) {
+        return ap_pstrcat(cmd->pool,
+                          "RewriteMap: map file or program not found:",
+                          new->checkfile, NULL);
+    }
+
+    return NULL;
+}
+
+static const char *cmd_rewritelock(cmd_parms *cmd, void *dconf, char *a1)
+{
+    const char *error;
+
+    if ((error = ap_check_cmd_context(cmd, GLOBAL_ONLY)) != NULL)
+        return error;
+
+    lockname = a1;
+
+    return NULL;
+}
+
+static const char *cmd_rewritebase(cmd_parms *cmd, rewrite_perdir_conf *dconf,
+                                   char *a1)
+{
+    if (cmd->path == NULL || dconf == NULL) {
+        return "RewriteBase: only valid in per-directory config files";
+    }
+    if (a1[0] == '\0') {
+        return "RewriteBase: empty URL not allowed";
+    }
+    if (a1[0] != '/') {
+        return "RewriteBase: argument is not a valid URL";
+    }
+
+    dconf->baseurl = a1;
+
+    return NULL;
+}
+
+static const char *cmd_rewritecond(cmd_parms *cmd, rewrite_perdir_conf *dconf,
+                                   char *str)
+{
+    rewrite_server_conf *sconf;
+    rewritecond_entry *new;
+    regex_t *regexp;
+    char *a1;
+    char *a2;
+    char *a3;
+    char *cp;
+    const char *err;
+    int rc;
+
+    sconf = (rewrite_server_conf *)
+            ap_get_module_config(cmd->server->module_config, &rewrite_module);
+
+    /*  make a new entry in the internal temporary rewrite rule list */
+    if (cmd->path == NULL) {   /* is server command */
+        new = ap_push_array(sconf->rewriteconds);
+    }
+    else {                     /* is per-directory command */
+        new = ap_push_array(dconf->rewriteconds);
+    }
+
+    /*  parse the argument line ourself */
+    if (parseargline(str, &a1, &a2, &a3)) {
+        return ap_pstrcat(cmd->pool, "RewriteCond: bad argument line '", str,
+                          "'\n", NULL);
+    }
+
+    /*  arg1: the input string */
+    new->input = ap_pstrdup(cmd->pool, a1);
+
+    /* arg3: optional flags field
+       (this have to be first parsed, because we need to
+        know if the regex should be compiled with ICASE!) */
+    new->flags = CONDFLAG_NONE;
+    if (a3 != NULL) {
+        if ((err = cmd_rewritecond_parseflagfield(cmd->pool, new,
+                                                  a3)) != NULL) {
+            return err;
+        }
+    }
+
+    /*  arg2: the pattern
+        try to compile the regexp to test if is ok */
+    cp = a2;
+    if (cp[0] == '!') {
+        new->flags |= CONDFLAG_NOTMATCH;
+        cp++;
+    }
+
+    /* now be careful: Under the POSIX regex library
+       we can compile the pattern for case-insensitive matching,
+       under the old V8 library we have to do it self via a hack */
+    if (new->flags & CONDFLAG_NOCASE) {
+        rc = ((regexp = ap_pregcomp(cmd->pool, cp, REG_EXTENDED|REG_ICASE))
+              == NULL);
+    }
+    else {
+        rc = ((regexp = ap_pregcomp(cmd->pool, cp, REG_EXTENDED)) == NULL);
+    }
+    if (rc) {
+        return ap_pstrcat(cmd->pool,
+                          "RewriteCond: cannot compile regular expression '",
+                          a2, "'\n", NULL);
+    }
+
+    new->pattern = ap_pstrdup(cmd->pool, cp);
+    new->regexp  = regexp;
+
+    return NULL;
+}
+
+static const char *cmd_rewritecond_parseflagfield(pool *p,
+                                                  rewritecond_entry *cfg,
+                                                  char *str)
+{
+    char *cp;
+    char *cp1;
+    char *cp2;
+    char *cp3;
+    char *key;
+    char *val;
+    const char *err;
+
+    if (str[0] != '[' || str[strlen(str)-1] != ']') {
+        return "RewriteCond: bad flag delimiters";
+    }
+
+    cp = str+1;
+    str[strlen(str)-1] = ','; /* for simpler parsing */
+    for ( ; *cp != '\0'; ) {
+        /* skip whitespaces */
+        for ( ; (*cp == ' ' || *cp == '\t') && *cp != '\0'; cp++)
+            ;
+        if (*cp == '\0') {
+            break;
+        }
+        cp1 = cp;
+        if ((cp2 = strchr(cp, ',')) != NULL) {
+            cp = cp2+1;
+            for ( ; (*(cp2-1) == ' ' || *(cp2-1) == '\t'); cp2--)
+                ;
+            *cp2 = '\0';
+            if ((cp3 = strchr(cp1, '=')) != NULL) {
+                *cp3 = '\0';
+                key = cp1;
+                val = cp3+1;
+            }
+            else {
+                key = cp1;
+                val = "";
+            }
+            if ((err = cmd_rewritecond_setflag(p, cfg, key, val)) != NULL) {
+                return err;
+            }
+        }
+        else {
+            break;
+        }
+    }
+
+    return NULL;
+}
+
+static const char *cmd_rewritecond_setflag(pool *p, rewritecond_entry *cfg,
+                                           char *key, char *val)
+{
+    if (   strcasecmp(key, "nocase") == 0
+        || strcasecmp(key, "NC") == 0    ) {
+        cfg->flags |= CONDFLAG_NOCASE;
+    }
+    else if (   strcasecmp(key, "ornext") == 0
+             || strcasecmp(key, "OR") == 0    ) {
+        cfg->flags |= CONDFLAG_ORNEXT;
+    }
+    else {
+        return ap_pstrcat(p, "RewriteCond: unknown flag '", key, "'\n", NULL);
+    }
+    return NULL;
+}
+
+static const char *cmd_rewriterule(cmd_parms *cmd, rewrite_perdir_conf *dconf,
+                                   char *str)
+{
+    rewrite_server_conf *sconf;
+    rewriterule_entry *new;
+    regex_t *regexp;
+    char *a1;
+    char *a2;
+    char *a3;
+    char *cp;
+    const char *err;
+    int mode;
+
+    sconf = (rewrite_server_conf *)
+            ap_get_module_config(cmd->server->module_config, &rewrite_module);
+
+    /*  make a new entry in the internal rewrite rule list */
+    if (cmd->path == NULL) {   /* is server command */
+        new = ap_push_array(sconf->rewriterules);
+    }
+    else {                     /* is per-directory command */
+        new = ap_push_array(dconf->rewriterules);
+    }
+
+    /*  parse the argument line ourself */
+    if (parseargline(str, &a1, &a2, &a3)) {
+        return ap_pstrcat(cmd->pool, "RewriteRule: bad argument line '", str,
+                          "'\n", NULL);
+    }
+
+    /* arg3: optional flags field */
+    new->forced_mimetype     = NULL;
+    new->forced_responsecode = HTTP_MOVED_TEMPORARILY;
+    new->flags  = RULEFLAG_NONE;
+    new->env[0] = NULL;
+    new->skip   = 0;
+    if (a3 != NULL) {
+        if ((err = cmd_rewriterule_parseflagfield(cmd->pool, new,
+                                                  a3)) != NULL) {
+            return err;
+        }
+    }
+
+    /*  arg1: the pattern
+     *  try to compile the regexp to test if is ok
+     */
+    cp = a1;
+    if (cp[0] == '!') {
+        new->flags |= RULEFLAG_NOTMATCH;
+        cp++;
+    }
+    mode = REG_EXTENDED;
+    if (new->flags & RULEFLAG_NOCASE) {
+        mode |= REG_ICASE;
+    }
+    if ((regexp = ap_pregcomp(cmd->pool, cp, mode)) == NULL) {
+        return ap_pstrcat(cmd->pool,
+                          "RewriteRule: cannot compile regular expression '",
+                          a1, "'\n", NULL);
+    }
+    new->pattern = ap_pstrdup(cmd->pool, cp);
+    new->regexp  = regexp;
+
+    /*  arg2: the output string
+     *  replace the $<N> by \<n> which is needed by the currently
+     *  used Regular Expression library
+     */
+    new->output = ap_pstrdup(cmd->pool, a2);
+
+    /* now, if the server or per-dir config holds an
+     * array of RewriteCond entries, we take it for us
+     * and clear the array
+     */
+    if (cmd->path == NULL) {  /* is server command */
+        new->rewriteconds   = sconf->rewriteconds;
+        sconf->rewriteconds = ap_make_array(cmd->pool, 2,
+                                            sizeof(rewritecond_entry));
+    }
+    else {                    /* is per-directory command */
+        new->rewriteconds   = dconf->rewriteconds;
+        dconf->rewriteconds = ap_make_array(cmd->pool, 2,
+                                            sizeof(rewritecond_entry));
+    }
+
+    return NULL;
+}
+
+static const char *cmd_rewriterule_parseflagfield(pool *p,
+                                                  rewriterule_entry *cfg,
+                                                  char *str)
+{
+    char *cp;
+    char *cp1;
+    char *cp2;
+    char *cp3;
+    char *key;
+    char *val;
+    const char *err;
+
+    if (str[0] != '[' || str[strlen(str)-1] != ']') {
+        return "RewriteRule: bad flag delimiters";
+    }
+
+    cp = str+1;
+    str[strlen(str)-1] = ','; /* for simpler parsing */
+    for ( ; *cp != '\0'; ) {
+        /* skip whitespaces */
+        for ( ; (*cp == ' ' || *cp == '\t') && *cp != '\0'; cp++)
+            ;
+        if (*cp == '\0') {
+            break;
+        }
+        cp1 = cp;
+        if ((cp2 = strchr(cp, ',')) != NULL) {
+            cp = cp2+1;
+            for ( ; (*(cp2-1) == ' ' || *(cp2-1) == '\t'); cp2--)
+                ;
+            *cp2 = '\0';
+            if ((cp3 = strchr(cp1, '=')) != NULL) {
+                *cp3 = '\0';
+                key = cp1;
+                val = cp3+1;
+            }
+            else {
+                key = cp1;
+                val = "";
+            }
+            if ((err = cmd_rewriterule_setflag(p, cfg, key, val)) != NULL) {
+                return err;
+            }
+        }
+        else {
+            break;
+        }
+    }
+
+    return NULL;
+}
+
+static const char *cmd_rewriterule_setflag(pool *p, rewriterule_entry *cfg,
+                                           char *key, char *val)
+{
+    int status = 0;
+    int i;
+
+    if (   strcasecmp(key, "redirect") == 0
+        || strcasecmp(key, "R") == 0       ) {
+        cfg->flags |= RULEFLAG_FORCEREDIRECT;
+        if (strlen(val) > 0) {
+            if (strcasecmp(val, "permanent") == 0) {
+                status = HTTP_MOVED_PERMANENTLY;
+            }
+            else if (strcasecmp(val, "temp") == 0) {
+                status = HTTP_MOVED_TEMPORARILY;
+            }
+            else if (strcasecmp(val, "seeother") == 0) {
+                status = HTTP_SEE_OTHER;
+            }
+            else if (ap_isdigit(*val)) {
+                status = atoi(val);
+            }
+            if (!ap_is_HTTP_REDIRECT(status)) {
+                return "RewriteRule: invalid HTTP response code "
+                       "for flag 'R'";
+            }
+            cfg->forced_responsecode = status;
+        }
+    }
+    else if (   strcasecmp(key, "noescape") == 0
+        || strcasecmp(key, "NE") == 0       ) {
+        cfg->flags |= RULEFLAG_NOESCAPE;
+    }
+    else if (   strcasecmp(key, "last") == 0
+             || strcasecmp(key, "L") == 0   ) {
+        cfg->flags |= RULEFLAG_LASTRULE;
+    }
+    else if (   strcasecmp(key, "next") == 0
+             || strcasecmp(key, "N") == 0   ) {
+        cfg->flags |= RULEFLAG_NEWROUND;
+    }
+    else if (   strcasecmp(key, "chain") == 0
+             || strcasecmp(key, "C") == 0    ) {
+        cfg->flags |= RULEFLAG_CHAIN;
+    }
+    else if (   strcasecmp(key, "type") == 0
+             || strcasecmp(key, "T") == 0   ) {
+        cfg->forced_mimetype = ap_pstrdup(p, val);
+        ap_str_tolower(cfg->forced_mimetype);
+    }
+    else if (   strcasecmp(key, "env") == 0
+             || strcasecmp(key, "E") == 0   ) {
+        for (i = 0; (cfg->env[i] != NULL) && (i < MAX_ENV_FLAGS); i++)
+            ;
+        if (i < MAX_ENV_FLAGS) {
+            cfg->env[i] = ap_pstrdup(p, val);
+            cfg->env[i+1] = NULL;
+        }
+        else {
+            return "RewriteRule: too many environment flags 'E'";
+        }
+    }
+    else if (   strcasecmp(key, "nosubreq") == 0
+             || strcasecmp(key, "NS") == 0      ) {
+        cfg->flags |= RULEFLAG_IGNOREONSUBREQ;
+    }
+    else if (   strcasecmp(key, "proxy") == 0
+             || strcasecmp(key, "P") == 0      ) {
+        cfg->flags |= RULEFLAG_PROXY;
+    }
+    else if (   strcasecmp(key, "passthrough") == 0
+             || strcasecmp(key, "PT") == 0      ) {
+        cfg->flags |= RULEFLAG_PASSTHROUGH;
+    }
+    else if (   strcasecmp(key, "skip") == 0
+             || strcasecmp(key, "S") == 0   ) {
+        cfg->skip = atoi(val);
+    }
+    else if (   strcasecmp(key, "forbidden") == 0
+             || strcasecmp(key, "F") == 0   ) {
+        cfg->flags |= RULEFLAG_FORBIDDEN;
+    }
+    else if (   strcasecmp(key, "gone") == 0
+             || strcasecmp(key, "G") == 0   ) {
+        cfg->flags |= RULEFLAG_GONE;
+    }
+    else if (   strcasecmp(key, "qsappend") == 0
+             || strcasecmp(key, "QSA") == 0   ) {
+        cfg->flags |= RULEFLAG_QSAPPEND;
+    }
+    else if (   strcasecmp(key, "nocase") == 0
+             || strcasecmp(key, "NC") == 0    ) {
+        cfg->flags |= RULEFLAG_NOCASE;
+    }
+    else {
+        return ap_pstrcat(p, "RewriteRule: unknown flag '", key, "'\n", NULL);
+    }
+    return NULL;
+}
+
+
+/*
+**
+**  Global Module Initialization
+**  [called from read_config() after all
+**  config commands were already called]
+**
+*/
+
+static void init_module(server_rec *s, pool *p)
+{
+    /* check if proxy module is available */
+    proxy_available = (ap_find_linked_module("mod_proxy.c") != NULL);
+
+    /* create the rewriting lockfile in the parent */
+    rewritelock_create(s, p);
+    ap_register_cleanup(p, (void *)s, rewritelock_remove, ap_null_cleanup);
+
+    /* step through the servers and
+     * - open each rewriting logfile
+     * - open the RewriteMap prg:xxx programs
+     */
+    for (; s; s = s->next) {
+        open_rewritelog(s, p);
+        run_rewritemap_programs(s, p);
+    }
+}
+
+
+/*
+**
+**  Per-Child Module Initialization
+**  [called after a child process is spawned]
+**
+*/
+
+static void init_child(server_rec *s, pool *p)
+{
+     /* open the rewriting lockfile */
+     rewritelock_open(s, p);
+
+     /* create the lookup cache */
+     cachep = init_cache(p);
+}
+
+
+/*
+** +-------------------------------------------------------+
+** |                                                       |
+** |                     runtime hooks
+** |                                                       |
+** +-------------------------------------------------------+
+*/
+
+/*
+**
+**  URI-to-filename hook
+**
+**  [used for the rewriting engine triggered by
+**  the per-server 'RewriteRule' directives]
+**
+*/
+
+static int hook_uri2file(request_rec *r)
+{
+    void *sconf;
+    rewrite_server_conf *conf;
+    const char *var;
+    const char *thisserver;
+    char *thisport;
+    const char *thisurl;
+    char buf[512];
+    char docroot[512];
+    const char *ccp;
+    unsigned int port;
+    int rulestatus;
+    int n;
+    int l;
+
+    /*
+     *  retrieve the config structures
+     */
+    sconf = r->server->module_config;
+    conf  = (rewrite_server_conf *)ap_get_module_config(sconf,
+                                                        &rewrite_module);
+
+    /*
+     *  only do something under runtime if the engine is really enabled,
+     *  else return immediately!
+     */
+    if (conf->state == ENGINE_DISABLED) {
+        return DECLINED;
+    }
+
+    /*
+     *  check for the ugly API case of a virtual host section where no
+     *  mod_rewrite directives exists. In this situation we became no chance
+     *  by the API to setup our default per-server config so we have to
+     *  on-the-fly assume we have the default config. But because the default
+     *  config has a disabled rewriting engine we are lucky because can
+     *  just stop operating now.
+     */
+    if (conf->server != r->server) {
+        return DECLINED;
+    }
+
+    /*
+     *  add the SCRIPT_URL variable to the env. this is a bit complicated
+     *  due to the fact that apache uses subrequests and internal redirects
+     */
+
+    if (r->main == NULL) {
+         var = ap_pstrcat(r->pool, "REDIRECT_", ENVVAR_SCRIPT_URL, NULL);
+         var = ap_table_get(r->subprocess_env, var);
+         if (var == NULL) {
+             ap_table_setn(r->subprocess_env, ENVVAR_SCRIPT_URL, r->uri);
+         }
+         else {
+             ap_table_setn(r->subprocess_env, ENVVAR_SCRIPT_URL, var);
+         }
+    }
+    else {
+         var = ap_table_get(r->main->subprocess_env, ENVVAR_SCRIPT_URL);
+         ap_table_setn(r->subprocess_env, ENVVAR_SCRIPT_URL, var);
+    }
+
+    /*
+     *  create the SCRIPT_URI variable for the env
+     */
+
+    /* add the canonical URI of this URL */
+    thisserver = ap_get_server_name(r);
+    port = ap_get_server_port(r);
+    if (ap_is_default_port(port, r)) {
+        thisport = "";
+    }
+    else {
+        ap_snprintf(buf, sizeof(buf), ":%u", port);
+        thisport = buf;
+    }
+    thisurl = ap_table_get(r->subprocess_env, ENVVAR_SCRIPT_URL);
+
+    /* set the variable */
+    var = ap_pstrcat(r->pool, ap_http_method(r), "://", thisserver, thisport,
+                     thisurl, NULL);
+    ap_table_setn(r->subprocess_env, ENVVAR_SCRIPT_URI, var);
+
+    /* if filename was not initially set,
+     * we start with the requested URI
+     */
+    if (r->filename == NULL) {
+        r->filename = ap_pstrdup(r->pool, r->uri);
+        rewritelog(r, 2, "init rewrite engine with requested uri %s",
+                   r->filename);
+    }
+
+    /*
+     *  now apply the rules ...
+     */
+    rulestatus = apply_rewrite_list(r, conf->rewriterules, NULL);
+    if (rulestatus) {
+        unsigned skip;
+
+        if (strlen(r->filename) > 6 &&
+            strncmp(r->filename, "proxy:", 6) == 0) {
+            /* it should be go on as an internal proxy request */
+
+            /* check if the proxy module is enabled, so
+             * we can actually use it!
+             */
+            if (!proxy_available) {
+                ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+                             "attempt to make remote request from mod_rewrite "
+                             "without proxy enabled: %s", r->filename);
+                return FORBIDDEN;
+            }
+
+            /* make sure the QUERY_STRING and
+             * PATH_INFO parts get incorporated
+             */
+            if (r->path_info != NULL) {
+                r->filename = ap_pstrcat(r->pool, r->filename,
+                                         r->path_info, NULL);
+            }
+            if (r->args != NULL &&
+                r->uri == r->unparsed_uri) {
+                /* see proxy_http:proxy_http_canon() */
+                r->filename = ap_pstrcat(r->pool, r->filename,
+                                         "?", r->args, NULL);
+            }
+
+            /* now make sure the request gets handled by the proxy handler */
+            r->proxyreq = PROXY_PASS;
+            r->handler  = "proxy-server";
+
+            rewritelog(r, 1, "go-ahead with proxy request %s [OK]",
+                       r->filename);
+            return OK;
+        }
+        else if ((skip = is_absolute_uri(r->filename)) > 0) {
+            /* it was finally rewritten to a remote URL */
+
+            if (rulestatus != ACTION_NOESCAPE) {
+                rewritelog(r, 1, "escaping %s for redirect", r->filename);
+                r->filename = escape_absolute_uri(r->pool, r->filename, skip);
+            }
+
+            /* append the QUERY_STRING part */
+            if (r->args) {
+                r->filename = ap_pstrcat(r->pool, r->filename, "?",
+                                         (rulestatus == ACTION_NOESCAPE)
+                                           ? r->args
+                                           : ap_escape_uri(r->pool, r->args),
+                                         NULL);
+            }
+
+            /* determine HTTP redirect response code */
+            if (ap_is_HTTP_REDIRECT(r->status)) {
+                n = r->status;
+                r->status = HTTP_OK; /* make Apache kernel happy */
+            }
+            else {
+                n = REDIRECT;
+            }
+
+            /* now do the redirection */
+            ap_table_setn(r->headers_out, "Location", r->filename);
+            rewritelog(r, 1, "redirect to %s [REDIRECT/%d]", r->filename, n);
+            return n;
+        }
+        else if (strlen(r->filename) > 10 &&
+                 strncmp(r->filename, "forbidden:", 10) == 0) {
+            /* This URLs is forced to be forbidden for the requester */
+            return FORBIDDEN;
+        }
+        else if (strlen(r->filename) > 5 &&
+                 strncmp(r->filename, "gone:", 5) == 0) {
+            /* This URLs is forced to be gone */
+            return HTTP_GONE;
+        }
+        else if (strlen(r->filename) > 12 &&
+                 strncmp(r->filename, "passthrough:", 12) == 0) {
+            /*
+             * Hack because of underpowered API: passing the current
+             * rewritten filename through to other URL-to-filename handlers
+             * just as it were the requested URL. This is to enable
+             * post-processing by mod_alias, etc.  which always act on
+             * r->uri! The difference here is: We do not try to
+             * add the document root
+             */
+            r->uri = ap_pstrdup(r->pool, r->filename+12);
+            return DECLINED;
+        }
+        else {
+            /* it was finally rewritten to a local path */
+
+            /* expand "/~user" prefix */
+#if !defined(WIN32) && !defined(NETWARE)
+            r->filename = expand_tildepaths(r, r->filename);
+#endif
+            rewritelog(r, 2, "local path result: %s", r->filename);
+
+            /* the filename must be either an absolute local path or an
+             * absolute local URL.
+             */
+            if (   *r->filename != '/'
+                && !ap_os_is_path_absolute(r->filename)) {
+                return BAD_REQUEST;
+            }
+
+            /* if there is no valid prefix, we have
+             * to emulate the translator from the core and
+             * prefix the filename with document_root
+             *
+             * NOTICE:
+             * We cannot leave out the prefix_stat because
+             * - when we always prefix with document_root
+             *   then no absolute path can be created, e.g. via
+             *   emulating a ScriptAlias directive, etc.
+             * - when we always NOT prefix with document_root
+             *   then the files under document_root have to
+             *   be references directly and document_root
+             *   gets never used and will be a dummy parameter -
+             *   this is also bad
+             *
+             * BUT:
+             * Under real Unix systems this is no problem,
+             * because we only do stat() on the first directory
+             * and this gets cached by the kernel for along time!
+             */
+            n = prefix_stat(r->filename, r->pool);
+            if (n == 0) {
+                if ((ccp = ap_document_root(r)) != NULL) {
+                    l = ap_cpystrn(docroot, ccp, sizeof(docroot)) - docroot;
+
+                    /* always NOT have a trailing slash */
+                    if (docroot[l-1] == '/') {
+                        docroot[l-1] = '\0';
+                    }
+                    if (r->server->path
+                        && !strncmp(r->filename, r->server->path,
+                                    r->server->pathlen)) {
+                        r->filename = ap_pstrcat(r->pool, docroot,
+                                                 (r->filename +
+                                                  r->server->pathlen), NULL);
+                    }
+                    else {
+                        r->filename = ap_pstrcat(r->pool, docroot, 
+                                                 r->filename, NULL);
+                    }
+                    rewritelog(r, 2, "prefixed with document_root to %s",
+                               r->filename);
+                }
+            }
+
+            rewritelog(r, 1, "go-ahead with %s [OK]", r->filename);
+            return OK;
+        }
+    }
+    else {
+        rewritelog(r, 1, "pass through %s", r->filename);
+        return DECLINED;
+    }
+}
+
+
+/*
+**
+**  MIME-type hook
+**
+**  [used to support the forced-MIME-type feature]
+**
+*/
+
+static int hook_mimetype(request_rec *r)
+{
+    const char *t;
+
+    /* now check if we have to force a MIME-type */
+    t = ap_table_get(r->notes, REWRITE_FORCED_MIMETYPE_NOTEVAR);
+    if (t == NULL) {
+        return DECLINED;
+    }
+    else {
+        rewritelog(r, 1, "force filename %s to have MIME-type '%s'",
+                   r->filename, t);
+        r->content_type = t;
+        return OK;
+    }
+}
+
+
+/*
+**
+**  Fixup hook
+**
+**  [used for the rewriting engine triggered by
+**  the per-directory 'RewriteRule' directives]
+**
+*/
+
+static int hook_fixup(request_rec *r)
+{
+    rewrite_perdir_conf *dconf;
+    char *cp;
+    char *cp2;
+    const char *ccp;
+    char *prefix;
+    int l;
+    int rulestatus;
+    int n;
+    char *ofilename;
+
+    dconf = (rewrite_perdir_conf *)ap_get_module_config(r->per_dir_config,
+                                                        &rewrite_module);
+
+    /* if there is no per-dir config we return immediately */
+    if (dconf == NULL) {
+        return DECLINED;
+    }
+
+    /* we shouldn't do anything in subrequests */
+    if (r->main != NULL) {
+        return DECLINED;
+    }
+
+    /* if there are no real (i.e. no RewriteRule directives!)
+       per-dir config of us, we return also immediately */
+    if (dconf->directory == NULL) {
+        return DECLINED;
+    }
+
+    /*
+     *  only do something under runtime if the engine is really enabled,
+     *  for this directory, else return immediately!
+     */
+    if (dconf->state == ENGINE_DISABLED) {
+        return DECLINED;
+    }
+
+    /*
+     *  Do the Options check after engine check, so
+     *  the user is able to explicitely turn RewriteEngine Off.
+     */
+    if (!(ap_allow_options(r) & (OPT_SYM_LINKS | OPT_SYM_OWNER))) {
+        /* FollowSymLinks is mandatory! */
+        ap_log_rerror(APLOG_MARK, APLOG_NOERRNO|APLOG_ERR, r,
+                     "Options FollowSymLinks or SymLinksIfOwnerMatch is off "
+                     "which implies that RewriteRule directive is forbidden: "
+                     "%s", r->filename);
+        return FORBIDDEN;
+    }
+
+    /*
+     *  remember the current filename before rewriting for later check
+     *  to prevent deadlooping because of internal redirects
+     *  on final URL/filename which can be equal to the inital one.
+     */
+    ofilename = r->filename;
+
+    /*
+     *  now apply the rules ...
+     */
+    rulestatus = apply_rewrite_list(r, dconf->rewriterules, dconf->directory);
+    if (rulestatus) {
+        unsigned skip;
+
+        if (strlen(r->filename) > 6 &&
+            strncmp(r->filename, "proxy:", 6) == 0) {
+            /* it should go on as an internal proxy request */
+
+            /* make sure the QUERY_STRING and
+             * PATH_INFO parts get incorporated
+             * (r->path_info was already appended by the
+             * rewriting engine because of the per-dir context!)
+             */
+            if (r->args != NULL) {
+                r->filename = ap_pstrcat(r->pool, r->filename,
+                                         "?", r->args, NULL);
+            }
+
+            /* now make sure the request gets handled by the proxy handler */
+            r->proxyreq = PROXY_PASS;
+            r->handler  = "proxy-server";
+
+            rewritelog(r, 1, "[per-dir %s] go-ahead with proxy request "
+                       "%s [OK]", dconf->directory, r->filename);
+            return OK;
+        }
+        else if ((skip = is_absolute_uri(r->filename)) > 0) {
+            /* it was finally rewritten to a remote URL */
+
+            /* because we are in a per-dir context
+             * first try to replace the directory with its base-URL
+             * if there is a base-URL available
+             */
+            if (dconf->baseurl != NULL) {
+                /* skip 'scheme://' */
+                cp = r->filename + skip;
+
+                if ((cp = strchr(cp, '/')) != NULL && *(++cp)) {
+                    rewritelog(r, 2,
+                               "[per-dir %s] trying to replace "
+                               "prefix %s with %s",
+                               dconf->directory, dconf->directory,
+                               dconf->baseurl);
+
+                    /* I think, that hack needs an explanation:
+                     * well, here is it:
+                     * mod_rewrite was written for unix systems, were
+                     * absolute file-system paths start with a slash.
+                     * URL-paths _also_ start with slashes, so they
+                     * can be easily compared with system paths.
+                     *
+                     * the following assumes, that the actual url-path
+                     * may be prefixed by the current directory path and
+                     * tries to replace the system path with the RewriteBase
+                     * URL.
+                     * That assumption is true if we use a RewriteRule like
+                     *
+                     * RewriteRule ^foo bar [R]
+                     *
+                     * (see apply_rewrite_rule function)
+                     * However on systems that don't have a / as system
+                     * root this will never match, so we skip the / after the
+                     * hostname and compare/substitute only the stuff after it.
+                     *
+                     * (note that cp was already increased to the right value)
+                     */
+                    cp2 = subst_prefix_path(r, cp, (*dconf->directory == '/')
+                                                   ? dconf->directory + 1
+                                                   : dconf->directory,
+                                            dconf->baseurl + 1);
+                    if (strcmp(cp2, cp) != 0) {
+                        *cp = '\0';
+                        r->filename = ap_pstrcat(r->pool, r->filename,
+                                                 cp2, NULL);
+                    }
+                }
+            }
+
+            /* now prepare the redirect... */
+            if (rulestatus != ACTION_NOESCAPE) {
+                rewritelog(r, 1, "[per-dir %s] escaping %s for redirect",
+                           dconf->directory, r->filename);
+                r->filename = escape_absolute_uri(r->pool, r->filename, skip);
+            }
+
+            /* append the QUERY_STRING part */
+            if (r->args) {
+                r->filename = ap_pstrcat(r->pool, r->filename, "?",
+                                         (rulestatus == ACTION_NOESCAPE)
+                                           ? r->args
+                                           : ap_escape_uri(r->pool, r->args),
+                                         NULL);
+            }
+
+            /* determine HTTP redirect response code */
+            if (ap_is_HTTP_REDIRECT(r->status)) {
+                n = r->status;
+                r->status = HTTP_OK; /* make Apache kernel happy */
+            }
+            else {
+                n = REDIRECT;
+            }
+
+            /* now do the redirection */
+            ap_table_setn(r->headers_out, "Location", r->filename);
+            rewritelog(r, 1, "[per-dir %s] redirect to %s [REDIRECT/%d]",
+                       dconf->directory, r->filename, n);
+            return n;
+        }
+        else if (strlen(r->filename) > 10 &&
+                 strncmp(r->filename, "forbidden:", 10) == 0) {
+            /* This URL is forced to be forbidden for the requester */
+            return FORBIDDEN;
+        }
+        else if (strlen(r->filename) > 5 &&
+                 strncmp(r->filename, "gone:", 5) == 0) {
+            /* This URL is forced to be gone */
+            return HTTP_GONE;
+        }
+        else {
+            /* it was finally rewritten to a local path */
+
+            /* if someone used the PASSTHROUGH flag in per-dir
+             * context we just ignore it. It is only useful
+             * in per-server context
+             */
+            if (strlen(r->filename) > 12 &&
+                strncmp(r->filename, "passthrough:", 12) == 0) {
+                r->filename = ap_pstrdup(r->pool, r->filename+12);
+            }
+
+            /* the filename must be either an absolute local path or an
+             * absolute local URL.
+             */
+            if (   *r->filename != '/'
+                && !ap_os_is_path_absolute(r->filename)) {
+                return BAD_REQUEST;
+            }
+
+            /* Check for deadlooping:
+             * At this point we KNOW that at least one rewriting
+             * rule was applied, but when the resulting URL is
+             * the same as the initial URL, we are not allowed to
+             * use the following internal redirection stuff because
+             * this would lead to a deadloop.
+             */
+            if (strcmp(r->filename, ofilename) == 0) {
+                rewritelog(r, 1, "[per-dir %s] initial URL equal rewritten "
+                           "URL: %s [IGNORING REWRITE]",
+                           dconf->directory, r->filename);
+                return OK;
+            }
+
+            /* if there is a valid base-URL then substitute
+             * the per-dir prefix with this base-URL if the
+             * current filename still is inside this per-dir
+             * context. If not then treat the result as a
+             * plain URL
+             */
+            if (dconf->baseurl != NULL) {
+                rewritelog(r, 2,
+                           "[per-dir %s] trying to replace prefix %s with %s",
+                           dconf->directory, dconf->directory, dconf->baseurl);
+                r->filename = subst_prefix_path(r, r->filename,
+                                                dconf->directory,
+                                                dconf->baseurl);
+            }
+            else {
+                /* if no explicit base-URL exists we assume
+                 * that the directory prefix is also a valid URL
+                 * for this webserver and only try to remove the
+                 * document_root if it is prefix
+                 */
+                if ((ccp = ap_document_root(r)) != NULL) {
+                    prefix = ap_pstrdup(r->pool, ccp);
+                    /* always NOT have a trailing slash */
+                    l = strlen(prefix);
+                    if (prefix[l-1] == '/') {
+                        prefix[l-1] = '\0';
+                        l--;
+                    }
+                    if (strncmp(r->filename, prefix, l) == 0) {
+                        rewritelog(r, 2,
+                                   "[per-dir %s] strip document_root "
+                                   "prefix: %s -> %s",
+                                   dconf->directory, r->filename,
+                                   r->filename+l);
+                        r->filename = ap_pstrdup(r->pool, r->filename+l);
+                    }
+                }
+            }
+
+            /* now initiate the internal redirect */
+            rewritelog(r, 1, "[per-dir %s] internal redirect with %s "
+                       "[INTERNAL REDIRECT]", dconf->directory, r->filename);
+            r->filename = ap_pstrcat(r->pool, "redirect:", r->filename, NULL);
+            r->handler = "redirect-handler";
+            return OK;
+        }
+    }
+    else {
+        rewritelog(r, 1, "[per-dir %s] pass through %s", 
+                   dconf->directory, r->filename);
+        return DECLINED;
+    }
+}
+
+
+/*
+**
+**  Content-Handlers
+**
+**  [used for redirect support]
+**
+*/
+
+static int handler_redirect(request_rec *r)
+{
+    /* just make sure that we are really meant! */
+    if (strncmp(r->filename, "redirect:", 9) != 0) {
+        return DECLINED;
+    }
+
+    if (is_redirect_limit_exceeded(r)) {
+        ap_log_rerror(APLOG_MARK, APLOG_ERR|APLOG_NOERRNO, r,
+                      "mod_rewrite: maximum number of internal redirects "
+                      "reached. Assuming configuration error. Use "
+                      "'RewriteOptions MaxRedirects' to increase the limit "
+                      "if neccessary.");
+        return HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    /* now do the internal redirect */
+    ap_internal_redirect(ap_pstrcat(r->pool, r->filename+9,
+                                    r->args ? "?" : NULL, r->args, NULL), r);
+
+    /* and return gracefully */
+    return OK;
+}
+
+/*
+ * check whether redirect limit is reached
+ */
+static int is_redirect_limit_exceeded(request_rec *r)
+{
+    request_rec *top = r;
+    rewrite_request_conf *reqc;
+    rewrite_perdir_conf *dconf;
+
+    /* we store it in the top request */
+    while (top->main) {
+        top = top->main;
+    }
+    while (top->prev) {
+        top = top->prev;
+    }
+
+    /* fetch our config */
+    reqc = (rewrite_request_conf *) ap_get_module_config(top->request_config,
+                                                         &rewrite_module);
+
+    /* no config there? create one. */
+    if (!reqc) {
+        rewrite_server_conf *sconf;
+
+        reqc = ap_palloc(top->pool, sizeof(rewrite_request_conf));
+        sconf = ap_get_module_config(r->server->module_config, &rewrite_module);
+
+        reqc->redirects = 0;
+        reqc->redirect_limit = sconf->redirect_limit
+                                 ? sconf->redirect_limit
+                                 : REWRITE_REDIRECT_LIMIT;
+
+        /* associate it with this request */
+        ap_set_module_config(top->request_config, &rewrite_module, reqc);
+    }
+
+    /* allow to change the limit during redirects. */
+    dconf = (rewrite_perdir_conf *)ap_get_module_config(r->per_dir_config,
+                                                        &rewrite_module);
+
+    /* 0 == unset; take server conf ... */
+    if (dconf->redirect_limit) {
+        reqc->redirect_limit = dconf->redirect_limit;
+    }
+
+    ap_log_rerror(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, r,
+                  "mod_rewrite's internal redirect status: %d/%d.",
+                  reqc->redirects, reqc->redirect_limit);
+
+    /* and now give the caller a hint */
+    return (reqc->redirects++ >= reqc->redirect_limit);
+}
+
+
+/*
+** +-------------------------------------------------------+
+** |                                                       |
+** |                  the rewriting engine
+** |                                                       |
+** +-------------------------------------------------------+
+*/
+
+/*
+ *  Apply a complete rule set,
+ *  i.e. a list of rewrite rules
+ */
+static int apply_rewrite_list(request_rec *r, array_header *rewriterules,
+                              char *perdir)
+{
+    rewriterule_entry *entries;
+    rewriterule_entry *p;
+    int i;
+    int changed;
+    int rc;
+    int s;
+
+    /*
+     *  Iterate over all existing rules
+     */
+    entries = (rewriterule_entry *)rewriterules->elts;
+    changed = 0;
+    loop:
+    for (i = 0; i < rewriterules->nelts; i++) {
+        p = &entries[i];
+
+        /*
+         *  Ignore this rule on subrequests if we are explicitly
+         *  asked to do so or this is a proxy-throughput or a
+         *  forced redirect rule.
+         */
+        if (r->main != NULL &&
+            (p->flags & RULEFLAG_IGNOREONSUBREQ ||
+             p->flags & RULEFLAG_PROXY          ||
+             p->flags & RULEFLAG_FORCEREDIRECT    )) {
+            continue;
+        }
+
+        /*
+         *  Apply the current rule.
+         */
+        rc = apply_rewrite_rule(r, p, perdir);
+        if (rc) {
+            /*
+             *  Indicate a change if this was not a match-only rule.
+             */
+            if (rc != 2) {
+                changed = ((p->flags & RULEFLAG_NOESCAPE)
+                           ? ACTION_NOESCAPE : ACTION_NORMAL);
+            }
+
+            /*
+             *  Pass-Through Feature (`RewriteRule .. .. [PT]'):
+             *  Because the Apache 1.x API is very limited we
+             *  need this hack to pass the rewritten URL to other
+             *  modules like mod_alias, mod_userdir, etc.
+             */
+            if (p->flags & RULEFLAG_PASSTHROUGH) {
+                rewritelog(r, 2, "forcing '%s' to get passed through "
+                           "to next API URI-to-filename handler", r->filename);
+                r->filename = ap_pstrcat(r->pool, "passthrough:",
+                                         r->filename, NULL);
+                changed = ACTION_NORMAL;
+                break;
+            }
+
+            /*
+             *  Rule has the "forbidden" flag set which means that
+             *  we stop processing and indicate this to the caller.
+             */
+            if (p->flags & RULEFLAG_FORBIDDEN) {
+                rewritelog(r, 2, "forcing '%s' to be forbidden", r->filename);
+                r->filename = ap_pstrcat(r->pool, "forbidden:",
+                                         r->filename, NULL);
+                changed = ACTION_NORMAL;
+                break;
+            }
+
+            /*
+             *  Rule has the "gone" flag set which means that
+             *  we stop processing and indicate this to the caller.
+             */
+            if (p->flags & RULEFLAG_GONE) {
+                rewritelog(r, 2, "forcing '%s' to be gone", r->filename);
+                r->filename = ap_pstrcat(r->pool, "gone:", r->filename, NULL);
+                changed = ACTION_NORMAL;
+                break;
+            }
+
+            /*
+             *  Stop processing also on proxy pass-through and
+             *  last-rule and new-round flags.
+             */
+            if (p->flags & RULEFLAG_PROXY) {
+                break;
+            }
+            if (p->flags & RULEFLAG_LASTRULE) {
+                break;
+            }
+
+            /*
+             *  On "new-round" flag we just start from the top of
+             *  the rewriting ruleset again.
+             */
+            if (p->flags & RULEFLAG_NEWROUND) {
+                goto loop;
+            }
+
+            /*
+             *  If we are forced to skip N next rules, do it now.
+             */
+            if (p->skip > 0) {
+                s = p->skip;
+                while (   i < rewriterules->nelts
+                       && s > 0) {
+                    i++;
+                    p = &entries[i];
+                    s--;
+                }
+            }
+        }
+        else {
+            /*
+             *  If current rule is chained with next rule(s),
+             *  skip all this next rule(s)
+             */
+            while (   i < rewriterules->nelts
+                   && p->flags & RULEFLAG_CHAIN) {
+                i++;
+                p = &entries[i];
+            }
+        }
+    }
+    return changed;
+}
+
+/*
+ *  Apply a single(!) rewrite rule
+ */
+static int apply_rewrite_rule(request_rec *r, rewriterule_entry *p,
+                              char *perdir)
+{
+    char *uri;
+    char *output;
+    const char *vary;
+    char newuri[MAX_STRING_LEN];
+    regex_t *regexp;
+    regmatch_t regmatch[AP_MAX_REG_MATCH];
+    backrefinfo *briRR = NULL;
+    backrefinfo *briRC = NULL;
+    int prefixstrip;
+    int failed;
+    array_header *rewriteconds;
+    rewritecond_entry *conds;
+    rewritecond_entry *c;
+    int i;
+    int rc;
+
+    /*
+     *  Initialisation
+     */
+    uri     = r->filename;
+    regexp  = p->regexp;
+    output  = p->output;
+
+    /*
+     *  Add (perhaps splitted away) PATH_INFO postfix to URL to
+     *  make sure we really match against the complete URL.
+     */
+    if (perdir != NULL && r->path_info != NULL && r->path_info[0] != '\0') {
+        rewritelog(r, 3, "[per-dir %s] add path-info postfix: %s -> %s%s",
+                   perdir, uri, uri, r->path_info);
+        uri = ap_pstrcat(r->pool, uri, r->path_info, NULL);
+    }
+
+    /*
+     *  On per-directory context (.htaccess) strip the location
+     *  prefix from the URL to make sure patterns apply only to
+     *  the local part.  Additionally indicate this special
+     *  threatment in the logfile.
+     */
+    prefixstrip = 0;
+    if (perdir != NULL) {
+        if (   strlen(uri) >= strlen(perdir)
+            && strncmp(uri, perdir, strlen(perdir)) == 0) {
+            rewritelog(r, 3, "[per-dir %s] strip per-dir prefix: %s -> %s",
+                       perdir, uri, uri+strlen(perdir));
+            uri = uri+strlen(perdir);
+            prefixstrip = 1;
+        }
+    }
+
+    /*
+     *  Try to match the URI against the RewriteRule pattern
+     *  and exit immeddiately if it didn't apply.
+     */
+    if (perdir == NULL) {
+        rewritelog(r, 3, "applying pattern '%s' to uri '%s'",
+                   p->pattern, uri);
+    }
+    else {
+        rewritelog(r, 3, "[per-dir %s] applying pattern '%s' to uri '%s'",
+                   perdir, p->pattern, uri);
+    }
+    rc = (ap_regexec(regexp, uri, AP_MAX_REG_MATCH, regmatch, 0) == 0);
+    if (! (( rc && !(p->flags & RULEFLAG_NOTMATCH)) ||
+           (!rc &&  (p->flags & RULEFLAG_NOTMATCH))   ) ) {
+        return 0;
+    }
+
+    /*
+     *  Else create the RewriteRule `regsubinfo' structure which
+     *  holds the substitution information.
+     */
+    briRR = (backrefinfo *)ap_palloc(r->pool, sizeof(backrefinfo));
+    if (!rc && (p->flags & RULEFLAG_NOTMATCH)) {
+        /*  empty info on negative patterns  */
+        briRR->source = "";
+        briRR->nsub   = 0;
+    }
+    else {
+        briRR->source = ap_pstrdup(r->pool, uri);
+        briRR->nsub   = regexp->re_nsub;
+        memcpy((void *)(briRR->regmatch), (void *)(regmatch),
+               sizeof(regmatch));
+    }
+
+    /*
+     *  Initiallally create the RewriteCond backrefinfo with
+     *  empty backrefinfo, i.e. not subst parts
+     *  (this one is adjusted inside apply_rewrite_cond() later!!)
+     */
+    briRC = (backrefinfo *)ap_pcalloc(r->pool, sizeof(backrefinfo));
+    briRC->source = "";
+    briRC->nsub   = 0;
+
+    /*
+     *  Ok, we already know the pattern has matched, but we now
+     *  additionally have to check for all existing preconditions
+     *  (RewriteCond) which have to be also true. We do this at
+     *  this very late stage to avoid unnessesary checks which
+     *  would slow down the rewriting engine!!
+     */
+    rewriteconds = p->rewriteconds;
+    conds = (rewritecond_entry *)rewriteconds->elts;
+    failed = 0;
+    for (i = 0; i < rewriteconds->nelts; i++) {
+        c = &conds[i];
+        rc = apply_rewrite_cond(r, c, perdir, briRR, briRC);
+        if (c->flags & CONDFLAG_ORNEXT) {
+            /*
+             *  The "OR" case
+             */
+            if (rc == 0) {
+                /*  One condition is false, but another can be
+                 *  still true, so we have to continue...
+                 */
+                ap_table_unset(r->notes, VARY_KEY_THIS);
+                continue;
+            }
+            else {
+                /*  One true condition is enough in "or" case, so
+                 *  skip the other conditions which are "ornext"
+                 *  chained
+                 */
+                while (   i < rewriteconds->nelts
+                       && c->flags & CONDFLAG_ORNEXT) {
+                    i++;
+                    c = &conds[i];
+                }
+                continue;
+            }
+        }
+        else {
+            /*
+             *  The "AND" case, i.e. no "or" flag,
+             *  so a single failure means total failure.
+             */
+            if (rc == 0) {
+                failed = 1;
+                break;
+            }
+        }
+        vary = ap_table_get(r->notes, VARY_KEY_THIS);
+        if (vary != NULL) {
+            ap_table_merge(r->notes, VARY_KEY, vary);
+            ap_table_unset(r->notes, VARY_KEY_THIS);
+        }
+    }
+    /*  if any condition fails the complete rule fails  */
+    if (failed) {
+        ap_table_unset(r->notes, VARY_KEY);
+        ap_table_unset(r->notes, VARY_KEY_THIS);
+        return 0;
+    }
+
+    /*
+     * Regardless of what we do next, we've found a match.  Check to see
+     * if any of the request header fields were involved, and add them
+     * to the Vary field of the response.
+     */
+    if ((vary = ap_table_get(r->notes, VARY_KEY)) != NULL) {
+        ap_table_merge(r->headers_out, "Vary", vary);
+        ap_table_unset(r->notes, VARY_KEY);
+    }
+
+    /*
+     *  If this is a pure matching rule (`RewriteRule <pat> -')
+     *  we stop processing and return immediately. The only thing
+     *  we have not to forget are the environment variables
+     *  (`RewriteRule <pat> - [E=...]')
+     */
+    if (strcmp(output, "-") == 0) {
+	do_expand_env(r, p->env, briRR, briRC);
+        if (p->forced_mimetype != NULL) {
+            if (perdir == NULL) {
+                /* In the per-server context we can force the MIME-type
+                 * the correct way by notifying our MIME-type hook handler
+                 * to do the job when the MIME-type API stage is reached.
+                 */
+                rewritelog(r, 2, "remember %s to have MIME-type '%s'",
+                           r->filename, p->forced_mimetype);
+                ap_table_setn(r->notes, REWRITE_FORCED_MIMETYPE_NOTEVAR,
+                              p->forced_mimetype);
+            }
+            else {
+                /* In per-directory context we operate in the Fixup API hook
+                 * which is after the MIME-type hook, so our MIME-type handler
+                 * has no chance to set r->content_type. And because we are
+                 * in the situation where no substitution takes place no
+                 * sub-request will happen (which could solve the
+                 * restriction). As a workaround we do it ourself now
+                 * immediately although this is not strictly API-conforming.
+                 * But it's the only chance we have...
+                 */
+                rewritelog(r, 1, "[per-dir %s] force %s to have MIME-type "
+                           "'%s'", perdir, r->filename, p->forced_mimetype);
+                r->content_type = p->forced_mimetype;
+            }
+        }
+        return 2;
+    }
+
+    /*
+     *  Ok, now we finally know all patterns have matched and
+     *  that there is something to replace, so we create the
+     *  substitution URL string in `newuri'.
+     */
+    do_expand(r, output, newuri, sizeof(newuri), briRR, briRC);
+    if (perdir == NULL) {
+        rewritelog(r, 2, "rewrite %s -> %s", uri, newuri);
+    }
+    else {
+        rewritelog(r, 2, "[per-dir %s] rewrite %s -> %s", perdir, uri, newuri);
+    }
+
+    /*
+     *  Additionally do expansion for the environment variable
+     *  strings (`RewriteRule .. .. [E=<string>]').
+     */
+    do_expand_env(r, p->env, briRR, briRC);
+
+    /*
+     *  Now replace API's knowledge of the current URI:
+     *  Replace r->filename with the new URI string and split out
+     *  an on-the-fly generated QUERY_STRING part into r->args
+     */
+    r->filename = ap_pstrdup(r->pool, newuri);
+    splitout_queryargs(r, p->flags & RULEFLAG_QSAPPEND);
+
+    /*
+     *  Add the previously stripped per-directory location
+     *  prefix if the new URI is not a new one for this
+     *  location, i.e. if it's not an absolute URL (!) path nor
+     *  a fully qualified URL scheme.
+     */
+    if (prefixstrip && *r->filename != '/'
+	&& !is_absolute_uri(r->filename)) {
+        rewritelog(r, 3, "[per-dir %s] add per-dir prefix: %s -> %s%s",
+                   perdir, r->filename, perdir, r->filename);
+        r->filename = ap_pstrcat(r->pool, perdir, r->filename, NULL);
+    }
+
+    /*
+     *  If this rule is forced for proxy throughput
+     *  (`RewriteRule ... ... [P]') then emulate mod_proxy's
+     *  URL-to-filename handler to be sure mod_proxy is triggered
+     *  for this URL later in the Apache API. But make sure it is
+     *  a fully-qualified URL. (If not it is qualified with
+     *  ourself).
+     */
+    if (p->flags & RULEFLAG_PROXY) {
+        fully_qualify_uri(r);
+        if (perdir == NULL) {
+            rewritelog(r, 2, "forcing proxy-throughput with %s", r->filename);
+        }
+        else {
+            rewritelog(r, 2, "[per-dir %s] forcing proxy-throughput with %s",
+                       perdir, r->filename);
+        }
+        r->filename = ap_pstrcat(r->pool, "proxy:", r->filename, NULL);
+        return 1;
+    }
+
+    /*
+     *  If this rule is explicitly forced for HTTP redirection
+     *  (`RewriteRule .. .. [R]') then force an external HTTP
+     *  redirect. But make sure it is a fully-qualified URL. (If
+     *  not it is qualified with ourself).
+     */
+    if (p->flags & RULEFLAG_FORCEREDIRECT) {
+        fully_qualify_uri(r);
+        if (perdir == NULL) {
+            rewritelog(r, 2,
+                       "explicitly forcing redirect with %s", r->filename);
+        }
+        else {
+            rewritelog(r, 2,
+                       "[per-dir %s] explicitly forcing redirect with %s",
+                       perdir, r->filename);
+        }
+        r->status = p->forced_responsecode;
+        return 1;
+    }
+
+    /*
+     *  Special Rewriting Feature: Self-Reduction
+     *  We reduce the URL by stripping a possible
+     *  http[s]://<ourhost>[:<port>] prefix, i.e. a prefix which
+     *  corresponds to ourself. This is to simplify rewrite maps
+     *  and to avoid recursion, etc. When this prefix is not a
+     *  coincidence then the user has to use [R] explicitly (see
+     *  above).
+     */
+    reduce_uri(r);
+
+    /*
+     *  If this rule is still implicitly forced for HTTP
+     *  redirection (`RewriteRule .. <scheme>://...') then
+     *  directly force an external HTTP redirect.
+     */
+    if (is_absolute_uri(r->filename)) {
+        if (perdir == NULL) {
+            rewritelog(r, 2,
+                       "implicitly forcing redirect (rc=%d) with %s",
+                       p->forced_responsecode, r->filename);
+        }
+        else {
+            rewritelog(r, 2, "[per-dir %s] implicitly forcing redirect "
+                       "(rc=%d) with %s", perdir, p->forced_responsecode,
+                       r->filename);
+        }
+        r->status = p->forced_responsecode;
+        return 1;
+    }
+
+    /*
+     *  Finally we had to remember if a MIME-type should be
+     *  forced for this URL (`RewriteRule .. .. [T=<type>]')
+     *  Later in the API processing phase this is forced by our
+     *  MIME API-hook function. This time its no problem even for
+     *  the per-directory context (where the MIME-type hook was
+     *  already processed) because a sub-request happens ;-)
+     */
+    if (p->forced_mimetype != NULL) {
+        ap_table_setn(r->notes, REWRITE_FORCED_MIMETYPE_NOTEVAR,
+                      p->forced_mimetype);
+        if (perdir == NULL) {
+            rewritelog(r, 2, "remember %s to have MIME-type '%s'",
+                       r->filename, p->forced_mimetype);
+        }
+        else {
+            rewritelog(r, 2,
+                       "[per-dir %s] remember %s to have MIME-type '%s'",
+                       perdir, r->filename, p->forced_mimetype);
+        }
+    }
+
+    /*
+     *  Puuhhhhhhhh... WHAT COMPLICATED STUFF ;_)
+     *  But now we're done for this particular rule.
+     */
+    return 1;
+}
+
+static int apply_rewrite_cond(request_rec *r, rewritecond_entry *p,
+                              char *perdir, backrefinfo *briRR,
+                              backrefinfo *briRC)
+{
+    char input[MAX_STRING_LEN];
+    struct stat sb;
+    request_rec *rsub;
+    regmatch_t regmatch[AP_MAX_REG_MATCH];
+    int rc;
+
+    /*
+     *   Construct the string we match against
+     */
+
+    do_expand(r, p->input, input, sizeof(input), briRR, briRC);
+
+    /*
+     *   Apply the patterns
+     */
+
+    rc = 0;
+    if (strcmp(p->pattern, "-f") == 0) {
+        if (stat(input, &sb) == 0) {
+            if (S_ISREG(sb.st_mode)) {
+                rc = 1;
+            }
+        }
+    }
+    else if (strcmp(p->pattern, "-s") == 0) {
+        if (stat(input, &sb) == 0) {
+            if (S_ISREG(sb.st_mode) && sb.st_size > 0) {
+                rc = 1;
+            }
+        }
+    }
+    else if (strcmp(p->pattern, "-l") == 0) {
+#if !defined(OS2) && !defined(WIN32)  && !defined(NETWARE)
+        if (lstat(input, &sb) == 0) {
+            if (S_ISLNK(sb.st_mode)) {
+                rc = 1;
+            }
+        }
+#endif
+    }
+    else if (strcmp(p->pattern, "-d") == 0) {
+        if (stat(input, &sb) == 0) {
+            if (S_ISDIR(sb.st_mode)) {
+                rc = 1;
+            }
+        }
+    }
+    else if (strcmp(p->pattern, "-U") == 0) {
+        /* avoid infinite subrequest recursion */
+        if (strlen(input) > 0 && subreq_ok(r)) {
+
+            /* run a URI-based subrequest */
+            rsub = ap_sub_req_lookup_uri(input, r);
+
+            /* URI exists for any result up to 3xx, redirects allowed */
+            if (rsub->status < 400)
+                rc = 1;
+
+            /* log it */
+            rewritelog(r, 5, "RewriteCond URI (-U) check: "
+                       "path=%s -> status=%d", input, rsub->status);
+
+            /* cleanup by destroying the subrequest */
+            ap_destroy_sub_req(rsub);
+        }
+    }
+    else if (strcmp(p->pattern, "-F") == 0) {
+        /* avoid infinite subrequest recursion */
+        if (strlen(input) > 0 && subreq_ok(r)) {
+
+            /* process a file-based subrequest:
+             * this differs from -U in that no path translation is done.
+             */
+            rsub = ap_sub_req_lookup_file(input, r);
+
+            /* file exists for any result up to 2xx, no redirects */
+            if (rsub->status < 300 &&
+                /* double-check that file exists since default result is 200 */
+                stat(rsub->filename, &sb) == 0) {
+                rc = 1;
+            }
+
+            /* log it */
+            rewritelog(r, 5, "RewriteCond file (-F) check: path=%s "
+                       "-> file=%s status=%d", input, rsub->filename, 
+                       rsub->status);
+
+            /* cleanup by destroying the subrequest */
+            ap_destroy_sub_req(rsub);
+        }
+    }
+    else if (strlen(p->pattern) > 1 && *(p->pattern) == '>') {
+        rc = (compare_lexicography(input, p->pattern+1) == 1 ? 1 : 0);
+    }
+    else if (strlen(p->pattern) > 1 && *(p->pattern) == '<') {
+        rc = (compare_lexicography(input, p->pattern+1) == -1 ? 1 : 0);
+    }
+    else if (strlen(p->pattern) > 1 && *(p->pattern) == '=') {
+        if (strcmp(p->pattern+1, "\"\"") == 0) {
+            rc = (*input == '\0');
+        }
+        else {
+            rc = (strcmp(input, p->pattern+1) == 0 ? 1 : 0);
+        }
+    }
+    else {
+        /* it is really a regexp pattern, so apply it */
+        rc = (ap_regexec(p->regexp, input, AP_MAX_REG_MATCH, regmatch,0) == 0);
+
+        /* if it isn't a negated pattern and really matched
+           we update the passed-through regex subst info structure */
+        if (rc && !(p->flags & CONDFLAG_NOTMATCH)) {
+            briRC->source = ap_pstrdup(r->pool, input);
+            briRC->nsub   = p->regexp->re_nsub;
+            memcpy((void *)(briRC->regmatch), (void *)(regmatch),
+                   sizeof(regmatch));
+        }
+    }
+
+    /* if this is a non-matching regexp, just negate the result */
+    if (p->flags & CONDFLAG_NOTMATCH) {
+        rc = !rc;
+    }
+
+    rewritelog(r, 4, "RewriteCond: input='%s' pattern='%s%s' => %s",
+               input, (p->flags & CONDFLAG_NOTMATCH ? "!" : ""),
+               p->pattern, rc ? "matched" : "not-matched");
+
+    /* end just return the result */
+    return rc;
+}
+
+
+/*
+** +-------------------------------------------------------+
+** |                                                       |
+** |              URL transformation functions
+** |                                                       |
+** +-------------------------------------------------------+
+*/
+
+
+/*
+**
+**  perform all the expansions on the input string
+**  leaving the result in the supplied buffer
+**
+*/
+
+static void do_expand(request_rec *r, char *input, char *buffer, int nbuf,
+		       backrefinfo *briRR, backrefinfo *briRC)
+{
+    char *inp, *outp;
+    size_t span, space;
+
+    /*
+     * for security reasons this expansion must be perfomed in a
+     * single pass, otherwise an attacker can arrange for the result
+     * of an earlier expansion to include expansion specifiers that
+     * are interpreted by a later expansion, producing results that
+     * were not intended by the administrator.
+     */
+
+    inp = input;
+    outp = buffer;
+    space = nbuf - 1; /* room for '\0' */
+
+    for (;;) {
+	span = strcspn(inp, "\\$%");
+	if (span > space) {
+	    span = space;
+	}
+	memcpy(outp, inp, span);
+	inp += span;
+	outp += span;
+	space -= span;
+	if (space == 0 || *inp == '\0') {
+	    break;
+	}
+	/* now we have a '\', '$', or '%' */
+        if (inp[0] == '\\') {
+            if (inp[1] != '\0') {
+                inp++;
+                goto skip;
+            }
+        }
+	else if (inp[1] == '{') {
+	    char *endp;
+	    endp = find_closing_bracket(inp+2, '{', '}');
+	    if (endp == NULL) {
+		goto skip;
+	    }
+	    /*
+	     * These lookups may be recursive in a very convoluted
+	     * fashion -- see the LA-U and LA-F variable expansion
+	     * prefixes -- so we copy lookup keys to a separate buffer
+	     * rather than adding zero bytes in order to use them in
+	     * place.
+	     */
+	    if (inp[0] == '$') {
+		/* ${...} map lookup expansion */
+		/*
+		 * To make rewrite maps useful the lookup key and
+		 * default values must be expanded, so we make
+		 * recursive calls to do the work. For security
+		 * reasons we must never expand a string that includes
+		 * verbatim data from the network. The recursion here
+		 * isn't a problem because the result of expansion is
+		 * only passed to lookup_map() so it cannot be
+		 * re-expanded, only re-looked-up. Another way of
+		 * looking at it is that the recursion is entirely
+		 * driven by the syntax of the nested curly brackets.
+		 */
+		char *map, *key, *dflt, *result;
+		char xkey[MAX_STRING_LEN];
+		char xdflt[MAX_STRING_LEN];
+		key = find_char_in_brackets(inp+2, ':', '{', '}');
+		if (key == NULL) {
+		    goto skip;
+                }
+		map  = ap_pstrndup(r->pool, inp+2, key-inp-2);
+		dflt = find_char_in_brackets(key+1, '|', '{', '}');
+		if (dflt == NULL) {
+		    key  = ap_pstrndup(r->pool, key+1, endp-key-1);
+		    dflt = "";
+		}
+                else {
+		    key  = ap_pstrndup(r->pool, key+1, dflt-key-1);
+		    dflt = ap_pstrndup(r->pool, dflt+1, endp-dflt-1);
+		}
+		do_expand(r, key,  xkey,  sizeof(xkey),  briRR, briRC);
+		result = lookup_map(r, map, xkey);
+		if (result) {
+		    span = ap_cpystrn(outp, result, space) - outp;
+		} else {
+		    do_expand(r, dflt, xdflt, sizeof(xdflt), briRR, briRC);
+		    span = ap_cpystrn(outp, xdflt, space) - outp;
+		}
+	    }
+	    else if (inp[0] == '%') {
+		/* %{...} variable lookup expansion */
+		char *var;
+		var  = ap_pstrndup(r->pool, inp+2, endp-inp-2);
+		span = ap_cpystrn(outp, lookup_variable(r, var), space) - outp;
+	    }
+	    else {
+		span = 0;
+	    }
+	    inp = endp+1;
+	    outp += span;
+	    space -= span;
+	    continue;
+	}
+	else if (ap_isdigit(inp[1])) {
+	    int n = inp[1] - '0';
+	    backrefinfo *bri = NULL;
+	    if (inp[0] == '$') {
+		/* $N RewriteRule regexp backref expansion */
+		bri = briRR;
+	    }
+	    else if (inp[0] == '%') {
+		/* %N RewriteCond regexp backref expansion */
+		bri = briRC;
+	    }
+	    /* see ap_pregsub() in src/main/util.c */
+            if (bri && n < AP_MAX_REG_MATCH &&
+		bri->regmatch[n].rm_eo > bri->regmatch[n].rm_so) {
+		span = bri->regmatch[n].rm_eo - bri->regmatch[n].rm_so;
+		if (span > space) {
+		    span = space;
+		}
+		memcpy(outp, bri->source + bri->regmatch[n].rm_so, span);
+		outp += span;
+		space -= span;
+	    }
+	    inp += 2;
+	    continue;
+	}
+    skip:
+	*outp++ = *inp++;
+	space--;
+    }
+    *outp++ = '\0';
+}
+
+
+/*
+**
+**  perform all the expansions on the environment variables
+**
+*/
+
+static void do_expand_env(request_rec *r, char *env[],
+			  backrefinfo *briRR, backrefinfo *briRC)
+{
+    int i;
+    char buf[MAX_STRING_LEN];
+
+    for (i = 0; env[i] != NULL; i++) {
+	do_expand(r, env[i], buf, sizeof(buf), briRR, briRC);
+	add_env_variable(r, buf);
+    }
+}
+
+
+/*
+**
+**  split out a QUERY_STRING part from
+**  the current URI string
+**
+*/
+
+static void splitout_queryargs(request_rec *r, int qsappend)
+{
+    char *q;
+    char *olduri;
+
+    /* don't touch, unless it's an http or mailto URL.
+     * See RFC 1738 and RFC 2368.
+     */
+    if (   is_absolute_uri(r->filename)
+        && strncasecmp(r->filename, "http", 4)
+        && strncasecmp(r->filename, "mailto", 6)) {
+        r->args = NULL; /* forget the query that's still flying around */
+        return;
+    }
+
+    q = strchr(r->filename, '?');
+    if (q != NULL) {
+        olduri = ap_pstrdup(r->pool, r->filename);
+        *q++ = '\0';
+        if (qsappend) {
+            r->args = ap_pstrcat(r->pool, q, "&", r->args, NULL);
+        }
+        else {
+            r->args = ap_pstrdup(r->pool, q);
+        }
+        if (strlen(r->args) == 0) {
+            r->args = NULL;
+            rewritelog(r, 3, "split uri=%s -> uri=%s, args=<none>", olduri,
+                       r->filename);
+        }
+        else {
+            if (r->args[strlen(r->args)-1] == '&') {
+                r->args[strlen(r->args)-1] = '\0';
+            }
+            rewritelog(r, 3, "split uri=%s -> uri=%s, args=%s", olduri,
+                       r->filename, r->args);
+        }
+    }
+
+    return;
+}
+
+
+/*
+**
+**  strip 'http[s]://ourhost/' from URI
+**
+*/
+
+static void reduce_uri(request_rec *r)
+{
+    char *cp;
+    unsigned short port;
+    char *portp;
+    char *hostp;
+    char *url;
+    char c;
+    char host[LONG_STRING_LEN];
+    char buf[MAX_STRING_LEN];
+    char *olduri;
+    int l;
+
+    cp = ap_http_method(r);
+    l  = strlen(cp);
+    if (   (int)strlen(r->filename) > l+3 
+        && strncasecmp(r->filename, cp, l) == 0
+        && r->filename[l]   == ':'
+        && r->filename[l+1] == '/'
+        && r->filename[l+2] == '/'             ) {
+        /* there was really a rewrite to a remote path */
+
+        olduri = ap_pstrdup(r->pool, r->filename); /* save for logging */
+
+        /* cut the hostname and port out of the URI */
+        ap_cpystrn(buf, r->filename+(l+3), sizeof(buf));
+        hostp = buf;
+        for (cp = hostp; *cp != '\0' && *cp != '/' && *cp != ':'; cp++)
+            ;
+        if (*cp == ':') {
+            /* set host */
+            *cp++ = '\0';
+            ap_cpystrn(host, hostp, sizeof(host));
+            /* set port */
+            portp = cp;
+            for (; *cp != '\0' && *cp != '/'; cp++)
+                ;
+            c = *cp;
+            *cp = '\0';
+            port = atoi(portp);
+            *cp = c;
+            /* set remaining url */
+            url = cp;
+        }
+        else if (*cp == '/') {
+            /* set host */
+            *cp = '\0';
+            ap_cpystrn(host, hostp, sizeof(host));
+            *cp = '/';
+            /* set port */
+            port = ap_default_port(r);
+            /* set remaining url */
+            url = cp;
+        }
+        else {
+            /* set host */
+            ap_cpystrn(host, hostp, sizeof(host));
+            /* set port */
+            port = ap_default_port(r);
+            /* set remaining url */
+            url = "/";
+        }
+
+        /* now check whether we could reduce it to a local path... */
+        if (ap_matches_request_vhost(r, host, port)) {
+            /* this is our host, so only the URL remains */
+            r->filename = ap_pstrdup(r->pool, url);
+            rewritelog(r, 3, "reduce %s -> %s", olduri, r->filename);
+        }
+    }
+    return;
+}
+
+
+/*
+**
+**  add 'http[s]://ourhost[:ourport]/' to URI
+**  if URI is still not fully qualified
+**
+*/
+
+static void fully_qualify_uri(request_rec *r)
+{
+    char buf[32];
+    const char *thisserver;
+    char *thisport;
+    int port;
+
+    if (!is_absolute_uri(r->filename)) {
+
+        thisserver = ap_get_server_name(r);
+        port = ap_get_server_port(r);
+        if (ap_is_default_port(port,r)) {
+            thisport = "";
+        }
+        else {
+            ap_snprintf(buf, sizeof(buf), ":%u", port);
+            thisport = buf;
+        }
+
+        if (r->filename[0] == '/') {
+            r->filename = ap_psprintf(r->pool, "%s://%s%s%s",
+                                      ap_http_method(r), thisserver,
+                                      thisport, r->filename);
+        }
+        else {
+            r->filename = ap_psprintf(r->pool, "%s://%s%s/%s",
+                                      ap_http_method(r), thisserver,
+                                      thisport, r->filename);
+        }
+    }
+    return;
+}
+
+
+/* return number of chars of the scheme (incl. '://')
+ * if the URI is absolute (includes a scheme etc.)
+ * otherwise 0.
+ *
+ * NOTE: If you add new schemes here, please have a
+ *       look at escape_absolute_uri and splitout_queryargs.
+ *       Not every scheme takes query strings and some schemes
+ *       may be handled in a special way.
+ *
+ * XXX: we should consider a scheme registry, perhaps with
+ *      appropriate escape callbacks to allow other modules
+ *      to extend mod_rewrite at runtime.
+ */
+static unsigned is_absolute_uri(char *uri)
+{
+    /* fast exit */
+    if (*uri == '/' || strlen(uri) <= 5) {
+        return 0;
+    }
+
+    switch (*uri++) {
+    case 'f':
+    case 'F':
+        if (!strncasecmp(uri, "tp://", 5)) {        /* ftp://    */
+            return 6;
+        }
+        break;
+
+    case 'g':
+    case 'G':
+        if (!strncasecmp(uri, "opher://", 8)) {     /* gopher:// */
+            return 9;
+        }
+        break;
+
+    case 'h':
+    case 'H':
+        if (!strncasecmp(uri, "ttp://", 6)) {       /* http://   */
+            return 7;
+        }
+        else if (!strncasecmp(uri, "ttps://", 7)) { /* https://  */
+            return 8;
+        }
+        break;
+
+    case 'l':
+    case 'L':
+        if (!strncasecmp(uri, "dap://", 6)) {       /* ldap://   */
+            return 7;
+        }
+        break;
+
+    case 'm':
+    case 'M':
+        if (!strncasecmp(uri, "ailto:", 6)) {       /* mailto:   */
+            return 7;
+        }
+        break;
+
+    case 'n':
+    case 'N':
+        if (!strncasecmp(uri, "ews:", 4)) {         /* news:     */
+            return 5;
+        }
+        else if (!strncasecmp(uri, "ntp://", 6)) {  /* nntp://   */
+            return 7;
+        }
+        break;
+    }
+
+    return 0;
+}
+
+
+/* escape absolute uri, which may or may not be path oriented.
+ * So let's handle them differently.
+ */
+static char *escape_absolute_uri(ap_pool *p, char *uri, unsigned scheme)
+{
+    char *cp;
+
+    /* be safe.
+     * NULL should indicate elsewhere, that something's wrong
+     */
+    if (!scheme || strlen(uri) < scheme) {
+        return NULL;
+    }
+
+    cp = uri + scheme;
+
+    /* scheme with authority part? */
+    if (cp[-1] == '/') {
+        /* skip host part */
+        while (*cp && *cp != '/') {
+            ++cp;
+        }
+
+        /* nothing after the hostpart. ready! */
+        if (!*cp || !*++cp) {
+            return ap_pstrdup(p, uri);
+        }
+
+        /* remember the hostname stuff */
+        scheme = cp - uri;
+
+        /* special thing for ldap.
+         * The parts are separated by question marks. From RFC 2255:
+         *     ldapurl = scheme "://" [hostport] ["/"
+         *               [dn ["?" [attributes] ["?" [scope]
+         *               ["?" [filter] ["?" extensions]]]]]]
+         */
+        if (!strncasecmp(uri, "ldap", 4)) {
+            char *token[5];
+            int c = 0;
+
+            token[0] = cp = ap_pstrdup(p, cp);
+            while (*cp && c < 5) {
+                if (*cp == '?') {
+                    token[++c] = cp + 1;
+                    *cp = '\0';
+                }
+                ++cp;
+            }
+
+            return ap_pstrcat(p, ap_pstrndup(p, uri, scheme),
+                                         ap_escape_uri(p, token[0]),
+                              (c >= 1) ? "?" : NULL,
+                              (c >= 1) ? ap_escape_uri(p, token[1]) : NULL,
+                              (c >= 2) ? "?" : NULL,
+                              (c >= 2) ? ap_escape_uri(p, token[2]) : NULL,
+                              (c >= 3) ? "?" : NULL,
+                              (c >= 3) ? ap_escape_uri(p, token[3]) : NULL,
+                              (c >= 4) ? "?" : NULL,
+                              (c >= 4) ? ap_escape_uri(p, token[4]) : NULL,
+                              NULL);
+        }
+    }
+
+    /* Nothing special here. Apply normal escaping. */
+    return ap_pstrcat(p, ap_pstrndup(p, uri, scheme),
+                      ap_escape_uri(p, cp), NULL);
+}
+
+/*
+**
+**  Expand tilde-paths (/~user) through
+**  Unix /etc/passwd database information
+**
+*/
+#if !defined(WIN32) && !defined(NETWARE)
+static char *expand_tildepaths(request_rec *r, char *uri)
+{
+    char user[LONG_STRING_LEN];
+    struct passwd *pw;
+    char *newuri;
+    int i, j;
+
+    newuri = uri;
+    if (uri != NULL && strlen(uri) > 2 && uri[0] == '/' && uri[1] == '~') {
+        /* cut out the username */
+        for (j = 0, i = 2; j < sizeof(user)-1
+               && uri[i] != '\0'
+               && uri[i] != '/'  ; ) {
+            user[j++] = uri[i++];
+        }
+        user[j] = '\0';
+
+        /* lookup username in systems passwd file */
+        if ((pw = getpwnam(user)) != NULL) {
+            /* ok, user was found, so expand the ~user string */
+            if (uri[i] != '\0') {
+                /* ~user/anything...  has to be expanded */
+                if (pw->pw_dir[strlen(pw->pw_dir)-1] == '/') {
+                    pw->pw_dir[strlen(pw->pw_dir)-1] = '\0';
+                }
+                newuri = ap_pstrcat(r->pool, pw->pw_dir, uri+i, NULL);
+            }
+            else {
+                /* only ~user has to be expanded */
+                newuri = ap_pstrdup(r->pool, pw->pw_dir);
+            }
+        }
+    }
+    return newuri;
+}
+#endif
+
+
+
+/*
+** +-------------------------------------------------------+
+** |                                                       |
+** |              DBM hashfile support
+** |                                                       |
+** +-------------------------------------------------------+
+*/
+
+
+static char *lookup_map(request_rec *r, char *name, char *key)
+{
+    void *sconf;
+    rewrite_server_conf *conf;
+    array_header *rewritemaps;
+    rewritemap_entry *entries;
+    rewritemap_entry *s;
+    char *value;
+    struct stat st;
+    int i;
+
+    /* get map configuration */
+    sconf = r->server->module_config;
+    conf  = (rewrite_server_conf *)ap_get_module_config(sconf, 
+                                                        &rewrite_module);
+    rewritemaps = conf->rewritemaps;
+
+    entries = (rewritemap_entry *)rewritemaps->elts;
+    for (i = 0; i < rewritemaps->nelts; i++) {
+        s = &entries[i];
+        if (strcmp(s->name, name) == 0) {
+            if (s->type == MAPTYPE_TXT) {
+                if (stat(s->checkfile, &st) == -1) {
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
+                                 "mod_rewrite: can't access text RewriteMap "
+                                 "file %s", s->checkfile);
+                    rewritelog(r, 1, "can't open RewriteMap file, "
+                               "see error log");
+                    return NULL;
+                }
+                value = get_cache_string(cachep, s->cachename, CACHEMODE_TS,
+                                         st.st_mtime, key);
+                if (value == NULL) {
+                    rewritelog(r, 6, "cache lookup FAILED, forcing new "
+                               "map lookup");
+                    if ((value =
+                         lookup_map_txtfile(r, s->datafile, key)) != NULL) {
+                        rewritelog(r, 5, "map lookup OK: map=%s key=%s[txt] "
+                                   "-> val=%s", s->name, key, value);
+                        set_cache_string(cachep, s->cachename, CACHEMODE_TS,
+                                         st.st_mtime, key, value);
+                        return value;
+                    }
+                    else {
+                        rewritelog(r, 5, "map lookup FAILED: map=%s[txt] "
+                                   "key=%s", s->name, key);
+                        set_cache_string(cachep, s->cachename, CACHEMODE_TS,
+                                         st.st_mtime, key, "");
+                        return NULL;
+                    }
+                }
+                else {
+                    rewritelog(r, 5, "cache lookup OK: map=%s[txt] key=%s "
+                               "-> val=%s", s->name, key, value);
+                    return value[0] != '\0' ? value : NULL;
+                }
+            }
+            else if (s->type == MAPTYPE_DBM) {
+#ifndef NO_DBM_REWRITEMAP
+                if (stat(s->checkfile, &st) == -1) {
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
+                                 "mod_rewrite: can't access DBM RewriteMap "
+                                 "file %s", s->checkfile);
+                    rewritelog(r, 1, "can't open DBM RewriteMap file, "
+                               "see error log");
+                    return NULL;
+                }
+                value = get_cache_string(cachep, s->cachename, CACHEMODE_TS,
+                                         st.st_mtime, key);
+                if (value == NULL) {
+                    rewritelog(r, 6,
+                               "cache lookup FAILED, forcing new map lookup");
+                    if ((value =
+                         lookup_map_dbmfile(r, s->datafile, key)) != NULL) {
+                        rewritelog(r, 5, "map lookup OK: map=%s[dbm] key=%s "
+                                   "-> val=%s", s->name, key, value);
+                        set_cache_string(cachep, s->cachename, CACHEMODE_TS,
+                                         st.st_mtime, key, value);
+                        return value;
+                    }
+                    else {
+                        rewritelog(r, 5, "map lookup FAILED: map=%s[dbm] "
+                                   "key=%s", s->name, key);
+                        set_cache_string(cachep, s->cachename, CACHEMODE_TS,
+                                         st.st_mtime, key, "");
+                        return NULL;
+                    }
+                }
+                else {
+                    rewritelog(r, 5, "cache lookup OK: map=%s[dbm] key=%s "
+                               "-> val=%s", s->name, key, value);
+                    return value[0] != '\0' ? value : NULL;
+                }
+#else
+                return NULL;
+#endif
+            }
+            else if (s->type == MAPTYPE_PRG) {
+                if ((value =
+                     lookup_map_program(r, s->fpin, s->fpout, key)) != NULL) {
+                    rewritelog(r, 5, "map lookup OK: map=%s key=%s -> val=%s",
+                               s->name, key, value);
+                    return value;
+                }
+                else {
+                    rewritelog(r, 5, "map lookup FAILED: map=%s key=%s",
+                               s->name, key);
+                }
+            }
+            else if (s->type == MAPTYPE_INT) {
+                if ((value = lookup_map_internal(r, s->func, key)) != NULL) {
+                    rewritelog(r, 5, "map lookup OK: map=%s key=%s -> val=%s",
+                               s->name, key, value);
+                    return value;
+                }
+                else {
+                    rewritelog(r, 5, "map lookup FAILED: map=%s key=%s",
+                               s->name, key);
+                }
+            }
+            else if (s->type == MAPTYPE_RND) {
+                if (stat(s->checkfile, &st) == -1) {
+                    ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
+                                 "mod_rewrite: can't access text RewriteMap "
+                                 "file %s", s->checkfile);
+                    rewritelog(r, 1, "can't open RewriteMap file, "
+                               "see error log");
+                    return NULL;
+                }
+                value = get_cache_string(cachep, s->cachename, CACHEMODE_TS,
+                                         st.st_mtime, key);
+                if (value == NULL) {
+                    rewritelog(r, 6, "cache lookup FAILED, forcing new "
+                               "map lookup");
+                    if ((value =
+                         lookup_map_txtfile(r, s->datafile, key)) != NULL) {
+                        rewritelog(r, 5, "map lookup OK: map=%s key=%s[txt] "
+                                   "-> val=%s", s->name, key, value);
+                        set_cache_string(cachep, s->cachename, CACHEMODE_TS,
+                                         st.st_mtime, key, value);
+                    }
+                    else {
+                        rewritelog(r, 5, "map lookup FAILED: map=%s[txt] "
+                                   "key=%s", s->name, key);
+                        set_cache_string(cachep, s->cachename, CACHEMODE_TS,
+                                         st.st_mtime, key, "");
+                        return NULL;
+                    }
+                }
+                else {
+                    rewritelog(r, 5, "cache lookup OK: map=%s[txt] key=%s "
+                               "-> val=%s", s->name, key, value);
+                }
+                if (value[0] != '\0') {
+                   value = select_random_value_part(r, value);
+                   rewritelog(r, 5, "randomly choosen the subvalue `%s'", value);
+                }
+                else {
+                    value = NULL;
+                }
+                return value;
+            }
+        }
+    }
+    return NULL;
+}
+
+static char *lookup_map_txtfile(request_rec *r, char *file, char *key)
+{
+    FILE *fp = NULL;
+    char line[1024];
+    char *value = NULL;
+    char *cpT;
+    size_t skip;
+    char *curkey;
+    char *curval;
+
+    if ((fp = ap_pfopen(r->pool, file, "r")) == NULL) {
+       return NULL;
+    }
+
+    while (fgets(line, sizeof(line), fp) != NULL) {
+        if (line[0] == '#')
+            continue; /* ignore comments */
+        cpT = line;
+        curkey = cpT;
+        skip = strcspn(cpT," \t\r\n");
+        if (skip == 0)
+            continue; /* ignore lines that start with a space, tab, CR, or LF */
+        cpT += skip;
+        *cpT = '\0';
+        if (strcmp(curkey, key) != 0)
+            continue; /* key does not match... */
+            
+        /* found a matching key; now extract and return the value */
+        ++cpT;
+        skip = strspn(cpT, " \t\r\n");
+        cpT += skip;
+        curval = cpT;
+        skip = strcspn(cpT, " \t\r\n");
+        if (skip == 0)
+            continue; /* no value... */
+        cpT += skip;
+        *cpT = '\0';
+        value = ap_pstrdup(r->pool, curval);
+        break;
+    }
+    ap_pfclose(r->pool, fp);
+    return value;
+}
+
+#ifndef NO_DBM_REWRITEMAP
+static char *lookup_map_dbmfile(request_rec *r, char *file, char *key)
+{
+    DBM *dbmfp = NULL;
+    datum dbmkey;
+    datum dbmval;
+    char *value;
+
+    if (!(dbmfp = dbm_open(file, O_RDONLY, 0666))) {
+        return NULL;
+    }
+
+    dbmkey.dptr  = key;
+    dbmkey.dsize = strlen(key);
+
+    dbmval = dbm_fetch(dbmfp, dbmkey);
+    if (dbmval.dptr) {
+        value = ap_palloc(r->pool, dbmval.dsize + 1);
+        memcpy(value, dbmval.dptr, dbmval.dsize);
+        value[dbmval.dsize] = '\0';
+    }
+    else {
+        value = NULL;
+    }
+
+    dbm_close(dbmfp);
+
+    return value;
+}
+#endif
+
+static char *lookup_map_program(request_rec *r, int fpin, int fpout, char *key)
+{
+    char buf[LONG_STRING_LEN];
+    char c;
+    int i;
+#ifndef NO_WRITEV
+    struct iovec iov[2];
+#endif
+
+    /* when `RewriteEngine off' was used in the per-server
+     * context then the rewritemap-programs were not spawned.
+     * In this case using such a map (usually in per-dir context)
+     * is useless because it is not available.
+     *
+     * newlines in the key leave bytes in the pipe and cause
+     * bad things to happen (next map lookup will use the chars
+     * after the \n instead of the new key etc etc - in other words,
+     * the Rewritemap falls out of sync with the requests).
+     */
+    if (fpin == -1 || fpout == -1 || strchr(key, '\n')) {
+        return NULL;
+    }
+ 
+    /* take the lock */
+    rewritelock_alloc(r);
+
+    /* write out the request key */
+#ifdef NO_WRITEV
+    write(fpin, key, strlen(key));
+    write(fpin, "\n", 1);
+#else
+    iov[0].iov_base = key;
+    iov[0].iov_len = strlen(key);
+    iov[1].iov_base = "\n";
+    iov[1].iov_len = 1;
+    writev(fpin, iov, 2);
+#endif
+
+    /* read in the response value */
+    i = 0;
+    while (read(fpout, &c, 1) == 1 && (i < LONG_STRING_LEN-1)) {
+        if (c == '\n') {
+            break;
+        }
+        buf[i++] = c;
+    }
+    buf[i] = '\0';
+
+    /* give the lock back */
+    rewritelock_free(r);
+
+    if (strcasecmp(buf, "NULL") == 0) {
+        return NULL;
+    }
+    else {
+        return ap_pstrdup(r->pool, buf);
+    }
+}
+
+static char *lookup_map_internal(request_rec *r,
+                                 char *(*func)(request_rec *, char *),
+                                 char *key)
+{
+    /* currently we just let the function convert
+       the key to a corresponding value */
+    return func(r, key);
+}
+
+static char *rewrite_mapfunc_toupper(request_rec *r, char *key)
+{
+    char *value, *cp;
+
+    for (cp = value = ap_pstrdup(r->pool, key); cp != NULL && *cp != '\0';
+         cp++) {
+        *cp = ap_toupper(*cp);
+    }
+    return value;
+}
+
+static char *rewrite_mapfunc_tolower(request_rec *r, char *key)
+{
+    char *value, *cp;
+
+    for (cp = value = ap_pstrdup(r->pool, key); cp != NULL && *cp != '\0';
+         cp++) {
+        *cp = ap_tolower(*cp);
+    }
+    return value;
+}
+
+static char *rewrite_mapfunc_escape(request_rec *r, char *key)
+{
+    char *value;
+
+    value = ap_escape_uri(r->pool, key);
+    return value;
+}
+
+static char *rewrite_mapfunc_unescape(request_rec *r, char *key)
+{
+    char *value;
+
+    value = ap_pstrdup(r->pool, key);
+    ap_unescape_url(value);
+    return value;
+}
+
+static int rewrite_rand_init_done = 0;
+
+static void rewrite_rand_init(void)
+{
+    if (!rewrite_rand_init_done) {
+        srand((unsigned)(getpid()));
+        rewrite_rand_init_done = 1;
+    }
+    return;
+}
+
+static int rewrite_rand(int l, int h)
+{
+    rewrite_rand_init();
+
+    /* Get [0,1) and then scale to the appropriate range. Note that using
+     * a floating point value ensures that we use all bits of the rand()
+     * result. Doing an integer modulus would only use the lower-order bits
+     * which may not be as uniformly random.
+     */
+    return (int)(((double)(rand() % RAND_MAX) / RAND_MAX) * (h - l + 1) + l);
+}
+
+static char *select_random_value_part(request_rec *r, char *value)
+{
+    char *buf;
+    int n, i, k;
+
+    /*  count number of distinct values  */
+    for (n = 1, i = 0; value[i] != '\0'; i++) {
+        if (value[i] == '|') {
+            n++;
+        }
+    }
+
+    /*  when only one value we have no option to choose  */
+    if (n == 1) {
+        return value;
+    }
+
+    /*  else randomly select one  */
+    k = rewrite_rand(1, n);
+
+    /*  and grep it out  */
+    for (n = 1, i = 0; value[i] != '\0'; i++) {
+        if (n == k) {
+            break;
+        }
+        if (value[i] == '|') {
+            n++;
+        }
+    }
+    buf = ap_pstrdup(r->pool, &value[i]);
+    for (i = 0; buf[i] != '\0' && buf[i] != '|'; i++)
+        ;
+    buf[i] = '\0';
+    return buf;
+}
+
+
+/*
+** +-------------------------------------------------------+
+** |                                                       |
+** |              rewriting logfile support
+** |                                                       |
+** +-------------------------------------------------------+
+*/
+
+
+static void open_rewritelog(server_rec *s, pool *p)
+{
+    rewrite_server_conf *conf;
+    char *fname;
+    piped_log *pl;
+    int    rewritelog_flags = ( O_WRONLY|O_APPEND|O_CREAT );
+#if defined(NETWARE)
+    mode_t rewritelog_mode  = ( S_IREAD|S_IWRITE );
+#elif defined(WIN32)
+    mode_t rewritelog_mode  = ( _S_IREAD|_S_IWRITE );
+#else
+    mode_t rewritelog_mode  = ( S_IRUSR|S_IWUSR|S_IRGRP );
+#endif
+
+    conf = ap_get_module_config(s->module_config, &rewrite_module);
+
+    if (conf->rewritelogfile == NULL) {
+        return;
+    }
+    if (*(conf->rewritelogfile) == '\0') {
+        return;
+    }
+    if (conf->rewritelogfp > 0) {
+        return; /* virtual log shared w/ main server */
+    }
+
+    fname = ap_server_root_relative(p, conf->rewritelogfile);
+
+    if (*conf->rewritelogfile == '|') {
+        if ((pl = ap_open_piped_log(p, conf->rewritelogfile+1)) == NULL) {
+            ap_log_error(APLOG_MARK, APLOG_ERR, s, 
+                         "mod_rewrite: could not open reliable pipe "
+                         "to RewriteLog filter %s", conf->rewritelogfile+1);
+            exit(1);
+        }
+        conf->rewritelogfp = ap_piped_log_write_fd(pl);
+    }
+    else if (*conf->rewritelogfile != '\0') {
+        if ((conf->rewritelogfp = ap_popenf_ex(p, fname, rewritelog_flags,
+                                            rewritelog_mode, 1)) < 0) {
+            ap_log_error(APLOG_MARK, APLOG_ERR, s, 
+
+                         "mod_rewrite: could not open RewriteLog "
+                         "file %s", fname);
+            exit(1);
+        }
+    }
+    return;
+}
+
+static void rewritelog(request_rec *r, int level, const char *text, ...)
+{
+    rewrite_server_conf *conf;
+    conn_rec *conn;
+    char *str1;
+    char str2[512];
+    char str3[1024];
+    char type[20];
+    char redir[20];
+    va_list ap;
+    int i;
+    request_rec *req;
+    char *ruser;
+    const char *rhost;
+
+    va_start(ap, text);
+    conf = ap_get_module_config(r->server->module_config, &rewrite_module);
+    conn = r->connection;
+
+    if (conf->rewritelogfp < 0) {
+        return;
+    }
+    if (conf->rewritelogfile == NULL) {
+        return;
+    }
+    if (*(conf->rewritelogfile) == '\0') {
+        return;
+    }
+
+    if (level > conf->rewriteloglevel) {
+        return;
+    }
+
+    if (conn->user == NULL) {
+        ruser = "-";
+    }
+    else if (strlen(conn->user) != 0) {
+        ruser = conn->user;
+    }
+    else {
+        ruser = "\"\"";
+    }
+
+    rhost = ap_get_remote_host(conn, r->server->module_config, 
+                               REMOTE_NOLOOKUP);
+    if (rhost == NULL) {
+        rhost = "UNKNOWN-HOST";
+    }
+
+    str1 = ap_pstrcat(r->pool, rhost, " ",
+                      (conn->remote_logname != NULL ?
+                      conn->remote_logname : "-"), " ",
+                      ruser, NULL);
+    ap_vsnprintf(str2, sizeof(str2), text, ap);
+
+    if (r->main == NULL) {
+        strcpy(type, "initial");
+    }
+    else {
+        strcpy(type, "subreq");
+    }
+
+    for (i = 0, req = r; req->prev != NULL; req = req->prev) {
+        i++;
+    }
+    if (i == 0) {
+        redir[0] = '\0';
+    }
+    else {
+        ap_snprintf(redir, sizeof(redir), "/redir#%d", i);
+    }
+
+    ap_snprintf(str3, sizeof(str3),
+                "%s %s [%s/sid#%lx][rid#%lx/%s%s] (%d) %s\n", str1,
+                current_logtime(r), ap_get_server_name(r),
+                (unsigned long)(r->server), (unsigned long)r,
+                type, redir, level, str2);
+
+    fd_lock(r, conf->rewritelogfp);
+    write(conf->rewritelogfp, str3, strlen(str3));
+    fd_unlock(r, conf->rewritelogfp);
+
+    va_end(ap);
+    return;
+}
+
+static char *current_logtime(request_rec *r)
+{
+    int timz;
+    struct tm *t;
+    char tstr[80];
+    char sign;
+
+    t = ap_get_gmtoff(&timz);
+    sign = (timz < 0 ? '-' : '+');
+    if (timz < 0) {
+        timz = -timz;
+    }
+
+    strftime(tstr, 80, "[%d/%b/%Y:%H:%M:%S ", t);
+    ap_snprintf(tstr + strlen(tstr), 80-strlen(tstr), "%c%.2d%.2d]",
+                sign, timz/60, timz%60);
+    return ap_pstrdup(r->pool, tstr);
+}
+
+
+
+
+/*
+** +-------------------------------------------------------+
+** |                                                       |
+** |              rewriting lockfile support
+** |                                                       |
+** +-------------------------------------------------------+
+*/
+
+#if defined(NETWARE)
+#define REWRITELOCK_MODE ( S_IREAD|S_IWRITE )
+#elif defined(WIN32)
+#define REWRITELOCK_MODE ( _S_IREAD|_S_IWRITE )
+#else
+#define REWRITELOCK_MODE ( S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH )
+#endif
+
+static void rewritelock_create(server_rec *s, pool *p)
+{
+    /* only operate if a lockfile is used */
+    if (lockname == NULL || *(lockname) == '\0') {
+        return;
+    }
+
+    /* fixup the path, especially for rewritelock_remove() */
+    lockname = ap_server_root_relative(p, lockname);
+
+    /* create the lockfile */
+    unlink(lockname);
+    if ((lockfd = ap_popenf_ex(p, lockname, O_WRONLY|O_CREAT,
+                                         REWRITELOCK_MODE, 1)) < 0) {
+        ap_log_error(APLOG_MARK, APLOG_ERR, s,
+                     "mod_rewrite: Parent could not create RewriteLock "
+                     "file %s", lockname);
+        exit(1);
+    }
+#if !defined(OS2) && !defined(WIN32) && !defined(NETWARE)
+    /* make sure the childs have access to this file */
+    if (geteuid() == 0 /* is superuser */)
+        chown(lockname, ap_user_id, -1 /* no gid change */);
+#endif
+
+#ifdef NETWARE
+	locking_sem = OpenLocalSemaphore (1);
+#endif
+
+    return;
+}
+
+static void rewritelock_open(server_rec *s, pool *p)
+{
+    /* only operate if a lockfile is used */
+    if (lockname == NULL || *(lockname) == '\0') {
+        return;
+    }
+
+    /* open the lockfile (once per child) to get a unique fd */
+    if ((lockfd = ap_popenf_ex(p, lockname, O_WRONLY,
+                                         REWRITELOCK_MODE, 1)) < 0) {
+        ap_log_error(APLOG_MARK, APLOG_ERR, s,
+                     "mod_rewrite: Child could not open RewriteLock "
+                     "file %s", lockname);
+        exit(1);
+    }
+    return;
+}
+
+static void rewritelock_remove(void *data)
+{
+    /* only operate if a lockfile is used */
+    if (lockname == NULL || *(lockname) == '\0') {
+        return;
+    }
+
+    /* remove the lockfile */
+    unlink(lockname);
+    lockname = NULL;
+    lockfd = -1;
+#ifdef NETWARE
+	CloseLocalSemaphore (locking_sem);
+#endif
+
+}
+
+static void rewritelock_alloc(request_rec *r)
+{
+    if (lockfd != -1) {
+        fd_lock(r, lockfd);
+    }
+    return;
+}
+
+static void rewritelock_free(request_rec *r)
+{
+    if (lockfd != -1) {
+        fd_unlock(r, lockfd);
+    }
+    return;
+}
+
+
+/*
+** +-------------------------------------------------------+
+** |                                                       |
+** |                  program map support
+** |                                                       |
+** +-------------------------------------------------------+
+*/
+
+static void run_rewritemap_programs(server_rec *s, pool *p)
+{
+    rewrite_server_conf *conf;
+    FILE *fpin;
+    FILE *fpout;
+    FILE *fperr;
+    array_header *rewritemaps;
+    rewritemap_entry *entries;
+    rewritemap_entry *map;
+    int i;
+    int rc;
+
+    conf = ap_get_module_config(s->module_config, &rewrite_module);
+
+    /*  If the engine isn't turned on,
+     *  don't even try to do anything.
+     */
+    if (conf->state == ENGINE_DISABLED) {
+        return;
+    }
+
+    rewritemaps = conf->rewritemaps;
+    entries = (rewritemap_entry *)rewritemaps->elts;
+    for (i = 0; i < rewritemaps->nelts; i++) {
+        map = &entries[i];
+        if (map->type != MAPTYPE_PRG) {
+            continue;
+        }
+        if (map->datafile == NULL
+            || *(map->datafile) == '\0'
+            || map->fpin  != -1
+            || map->fpout != -1        ) {
+            continue;
+        }
+        fpin  = NULL;
+        fpout = NULL;
+        rc = ap_spawn_child(p, rewritemap_program_child,
+                            (void *)map->datafile, kill_after_timeout,
+                            &fpin, &fpout, &fperr);
+        if (rc == 0 || fpin == NULL || fpout == NULL) {
+            ap_log_error(APLOG_MARK, APLOG_ERR, s,
+                         "mod_rewrite: could not fork child for "
+                         "RewriteMap process");
+            exit(1);
+        }
+        map->fpin  = fileno(fpin);
+        map->fpout = fileno(fpout);
+        map->fperr = fileno(fperr);
+    }
+    return;
+}
+
+/* child process code */
+static int rewritemap_program_child(void *cmd, child_info *pinfo)
+{
+    int child_pid = 1;
+
+    /*
+     * Prepare for exec
+     */
+    ap_cleanup_for_exec();
+#ifdef SIGHUP
+    signal(SIGHUP, SIG_IGN);
+#endif
+
+    /*
+     * Exec() the child program
+     */
+#if defined(WIN32)
+    /* MS Windows */
+    {
+        char pCommand[MAX_STRING_LEN];
+        STARTUPINFO si;
+        PROCESS_INFORMATION pi;
+
+        ap_snprintf(pCommand, sizeof(pCommand), "%s /C %s", SHELL_PATH, cmd);
+
+        memset(&si, 0, sizeof(si));
+        memset(&pi, 0, sizeof(pi));
+
+        si.cb          = sizeof(si);
+        si.dwFlags     = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
+        si.wShowWindow = SW_HIDE;
+        si.hStdInput   = pinfo->hPipeInputRead;
+        si.hStdOutput  = pinfo->hPipeOutputWrite;
+        si.hStdError   = pinfo->hPipeErrorWrite;
+
+        if (CreateProcess(NULL, pCommand, NULL, NULL, TRUE, 0, 
+                          NULL, NULL, &si, &pi)) {
+            CloseHandle(pi.hProcess);
+            CloseHandle(pi.hThread);
+            child_pid = pi.dwProcessId;
+        }
+    }
+#elif defined(NETWARE)
+   /* Need something here!!! Spawn???? */
+#elif defined(OS2)
+    /* IBM OS/2 */
+    execl(SHELL_PATH, SHELL_PATH, "/c", (char *)cmd, NULL);
+#else
+    /* Standard Unix */
+    execl(SHELL_PATH, SHELL_PATH, "-c", (char *)cmd, NULL);
+#endif
+    return(child_pid);
+}
+
+
+
+
+/*
+** +-------------------------------------------------------+
+** |                                                       |
+** |             environment variable support
+** |                                                       |
+** +-------------------------------------------------------+
+*/
+
+
+static char *lookup_variable(request_rec *r, char *var)
+{
+    const char *result;
+    char resultbuf[LONG_STRING_LEN];
+    time_t tc;
+    struct tm *tm;
+    request_rec *rsub;
+#ifndef WIN32
+    struct passwd *pw;
+    struct group *gr;
+    struct stat finfo;
+#endif
+
+    result = NULL;
+
+    /* HTTP headers */
+    if (strcasecmp(var, "HTTP_USER_AGENT") == 0) {
+        result = lookup_header(r, "User-Agent");
+    }
+    else if (strcasecmp(var, "HTTP_REFERER") == 0) {
+        result = lookup_header(r, "Referer");
+    }
+    else if (strcasecmp(var, "HTTP_COOKIE") == 0) {
+        result = lookup_header(r, "Cookie");
+    }
+    else if (strcasecmp(var, "HTTP_FORWARDED") == 0) {
+        result = lookup_header(r, "Forwarded");
+    }
+    else if (strcasecmp(var, "HTTP_HOST") == 0) {
+        result = lookup_header(r, "Host");
+    }
+    else if (strcasecmp(var, "HTTP_PROXY_CONNECTION") == 0) {
+        result = lookup_header(r, "Proxy-Connection");
+    }
+    else if (strcasecmp(var, "HTTP_ACCEPT") == 0) {
+        result = lookup_header(r, "Accept");
+    }
+    /* all other headers from which we are still not know about */
+    else if (strlen(var) > 5 && strncasecmp(var, "HTTP:", 5) == 0) {
+        result = lookup_header(r, var+5);
+    }
+
+    /* connection stuff */
+    else if (strcasecmp(var, "REMOTE_ADDR") == 0) {
+        result = r->connection->remote_ip;
+    }
+    else if (strcasecmp(var, "REMOTE_PORT") == 0) {
+        return ap_psprintf(r->pool, "%d",
+                           ntohs(r->connection->remote_addr.sin_port));
+    }
+    else if (strcasecmp(var, "REMOTE_HOST") == 0) {
+        result = (char *)ap_get_remote_host(r->connection,
+                                         r->per_dir_config, REMOTE_NAME);
+    }
+    else if (strcasecmp(var, "REMOTE_USER") == 0) {
+        result = r->connection->user;
+    }
+    else if (strcasecmp(var, "REMOTE_IDENT") == 0) {
+        result = (char *)ap_get_remote_logname(r);
+    }
+
+    /* request stuff */
+    else if (strcasecmp(var, "THE_REQUEST") == 0) { /* non-standard */
+        result = r->the_request;
+    }
+    else if (strcasecmp(var, "REQUEST_METHOD") == 0) {
+        result = r->method;
+    }
+    else if (strcasecmp(var, "REQUEST_URI") == 0) { /* non-standard */
+        result = r->uri;
+    }
+    else if (strcasecmp(var, "SCRIPT_FILENAME") == 0 ||
+             strcasecmp(var, "REQUEST_FILENAME") == 0  ) {
+        result = r->filename;
+    }
+    else if (strcasecmp(var, "PATH_INFO") == 0) {
+        result = r->path_info;
+    }
+    else if (strcasecmp(var, "QUERY_STRING") == 0) {
+        result = r->args;
+    }
+    else if (strcasecmp(var, "AUTH_TYPE") == 0) {
+        result = r->connection->ap_auth_type;
+    }
+    else if (strcasecmp(var, "IS_SUBREQ") == 0) { /* non-standard */
+        result = (r->main != NULL ? "true" : "false");
+    }
+
+    /* internal server stuff */
+    else if (strcasecmp(var, "DOCUMENT_ROOT") == 0) {
+        result = ap_document_root(r);
+    }
+    else if (strcasecmp(var, "SERVER_ADMIN") == 0) {
+        result = r->server->server_admin;
+    }
+    else if (strcasecmp(var, "SERVER_NAME") == 0) {
+        result = ap_get_server_name(r);
+    }
+    else if (strcasecmp(var, "SERVER_ADDR") == 0) { /* non-standard */
+        result = r->connection->local_ip;
+    }
+    else if (strcasecmp(var, "SERVER_PORT") == 0) {
+        ap_snprintf(resultbuf, sizeof(resultbuf), "%u", ap_get_server_port(r));
+        result = resultbuf;
+    }
+    else if (strcasecmp(var, "SERVER_PROTOCOL") == 0) {
+        result = r->protocol;
+    }
+    else if (strcasecmp(var, "SERVER_SOFTWARE") == 0) {
+        result = ap_get_server_version();
+    }
+    else if (strcasecmp(var, "API_VERSION") == 0) { /* non-standard */
+        ap_snprintf(resultbuf, sizeof(resultbuf), "%d:%d",
+                    MODULE_MAGIC_NUMBER_MAJOR, MODULE_MAGIC_NUMBER_MINOR);
+        result = resultbuf;
+    }
+
+    /* underlaying Unix system stuff */
+    else if (strcasecmp(var, "TIME_YEAR") == 0) {
+        tc = time(NULL);
+        tm = localtime(&tc);
+        ap_snprintf(resultbuf, sizeof(resultbuf), "%02d%02d",
+                    (tm->tm_year / 100) + 19, tm->tm_year % 100);
+        result = resultbuf;
+    }
+#define MKTIMESTR(format, tmfield) \
+    tc = time(NULL); \
+    tm = localtime(&tc); \
+    ap_snprintf(resultbuf, sizeof(resultbuf), format, tm->tmfield); \
+    result = resultbuf;
+    else if (strcasecmp(var, "TIME_MON") == 0) {
+        MKTIMESTR("%02d", tm_mon+1)
+    }
+    else if (strcasecmp(var, "TIME_DAY") == 0) {
+        MKTIMESTR("%02d", tm_mday)
+    }
+    else if (strcasecmp(var, "TIME_HOUR") == 0) {
+        MKTIMESTR("%02d", tm_hour)
+    }
+    else if (strcasecmp(var, "TIME_MIN") == 0) {
+        MKTIMESTR("%02d", tm_min)
+    }
+    else if (strcasecmp(var, "TIME_SEC") == 0) {
+        MKTIMESTR("%02d", tm_sec)
+    }
+    else if (strcasecmp(var, "TIME_WDAY") == 0) {
+        MKTIMESTR("%d", tm_wday)
+    }
+    else if (strcasecmp(var, "TIME") == 0) {
+        tc = time(NULL);
+        tm = localtime(&tc);
+        ap_snprintf(resultbuf, sizeof(resultbuf),
+                    "%02d%02d%02d%02d%02d%02d%02d", (tm->tm_year / 100) + 19,
+                    (tm->tm_year % 100), tm->tm_mon+1, tm->tm_mday,
+                    tm->tm_hour, tm->tm_min, tm->tm_sec);
+        result = resultbuf;
+        rewritelog(r, 1, "RESULT='%s'", result);
+    }
+
+    /* all other env-variables from the parent Apache process */
+    else if (strlen(var) > 4 && strncasecmp(var, "ENV:", 4) == 0) {
+        /* first try the internal Apache notes structure */
+        result = ap_table_get(r->notes, var+4);
+        /* second try the internal Apache env structure  */
+        if (result == NULL) {
+            result = ap_table_get(r->subprocess_env, var+4);
+        }
+        /* third try the external OS env */
+        if (result == NULL) {
+            result = getenv(var+4);
+        }
+    }
+
+#define LOOKAHEAD(subrecfunc) \
+        if ( \
+          /* filename is safe to use */ \
+          r->filename != NULL \
+              /* - and we're either not in a subrequest */ \
+              && ( r->main == NULL \
+                  /* - or in a subrequest where paths are non-NULL... */ \
+                    || ( r->main->uri != NULL && r->uri != NULL \
+                        /*   ...and sub and main paths differ */ \
+                        && strcmp(r->main->uri, r->uri) != 0))) { \
+            /* process a file-based subrequest */ \
+            rsub = subrecfunc(r->filename, r); \
+            /* now recursively lookup the variable in the sub_req */ \
+            result = lookup_variable(rsub, var+5); \
+            /* copy it up to our scope before we destroy sub_req's pool */ \
+            result = ap_pstrdup(r->pool, result); \
+            /* cleanup by destroying the subrequest */ \
+            ap_destroy_sub_req(rsub); \
+            /* log it */ \
+            rewritelog(r, 5, "lookahead: path=%s var=%s -> val=%s", \
+                       r->filename, var+5, result); \
+            /* return ourself to prevent re-pstrdup */ \
+            return (char *)result; \
+        }
+
+    /* look-ahead for parameter through URI-based sub-request */
+    else if (strlen(var) > 5 && strncasecmp(var, "LA-U:", 5) == 0) {
+        LOOKAHEAD(ap_sub_req_lookup_uri)
+    }
+    /* look-ahead for parameter through file-based sub-request */
+    else if (strlen(var) > 5 && strncasecmp(var, "LA-F:", 5) == 0) {
+        LOOKAHEAD(ap_sub_req_lookup_file)
+    }
+
+#if !defined(WIN32) && !defined(NETWARE)
+    /* Win32 has a rather different view of file ownerships.
+       For now, just forget it */
+
+    /* file stuff */
+    else if (strcasecmp(var, "SCRIPT_USER") == 0) {
+        result = "<unknown>";
+        if (r->finfo.st_mode != 0) {
+            if ((pw = getpwuid(r->finfo.st_uid)) != NULL) {
+                result = pw->pw_name;
+            }
+        }
+        else {
+            if (stat(r->filename, &finfo) == 0) {
+                if ((pw = getpwuid(finfo.st_uid)) != NULL) {
+                    result = pw->pw_name;
+                }
+            }
+        }
+    }
+    else if (strcasecmp(var, "SCRIPT_GROUP") == 0) {
+        result = "<unknown>";
+        if (r->finfo.st_mode != 0) {
+            if ((gr = getgrgid(r->finfo.st_gid)) != NULL) {
+                result = gr->gr_name;
+            }
+        }
+        else {
+            if (stat(r->filename, &finfo) == 0) {
+                if ((gr = getgrgid(finfo.st_gid)) != NULL) {
+                    result = gr->gr_name;
+                }
+            }
+        }
+    }
+#endif /* ndef WIN32 && NETWARE*/
+
+    if (result == NULL) {
+        return ap_pstrdup(r->pool, "");
+    }
+    else {
+        return ap_pstrdup(r->pool, result);
+    }
+}
+
+static char *lookup_header(request_rec *r, const char *name)
+{
+    array_header *hdrs_arr;
+    table_entry *hdrs;
+    int i;
+
+    hdrs_arr = ap_table_elts(r->headers_in);
+    hdrs = (table_entry *)hdrs_arr->elts;
+    for (i = 0; i < hdrs_arr->nelts; ++i) {
+        if (hdrs[i].key == NULL) {
+            continue;
+        }
+        if (strcasecmp(hdrs[i].key, name) == 0) {
+            ap_table_merge(r->notes, VARY_KEY_THIS, name);
+            return hdrs[i].val;
+        }
+    }
+    return NULL;
+}
+
+
+
+
+/*
+** +-------------------------------------------------------+
+** |                                                       |
+** |                    caching support
+** |                                                       |
+** +-------------------------------------------------------+
+*/
+
+
+static cache *init_cache(pool *p)
+{
+    cache *c;
+
+    c = (cache *)ap_palloc(p, sizeof(cache));
+    c->pool = ap_make_sub_pool(p);
+    c->lists = ap_make_array(c->pool, 2, sizeof(cachelist));
+    return c;
+}
+
+static void set_cache_string(cache *c, char *res, int mode, time_t t,
+                             char *key, char *value)
+{
+    cacheentry ce;
+
+    ce.time  = t;
+    ce.key   = key;
+    ce.value = value;
+    store_cache_string(c, res, &ce);
+    return;
+}
+
+static char *get_cache_string(cache *c, char *res, int mode,
+                              time_t t, char *key)
+{
+    cacheentry *ce;
+
+    ce = retrieve_cache_string(c, res, key);
+    if (ce == NULL) {
+        return NULL;
+    }
+    if (mode & CACHEMODE_TS) {
+        if (t != ce->time) {
+            return NULL;
+        }
+    }
+    else if (mode & CACHEMODE_TTL) {
+        if (t > ce->time) {
+            return NULL;
+        }
+    }
+    return ce->value;
+}
+
+static int cache_tlb_hash(char *key)
+{
+    unsigned long n;
+    char *p;
+
+    n = 0;
+    for (p = key; *p != '\0'; p++) {
+        n = ((n << 5) + n) ^ (unsigned long)(*p++);
+    }
+
+    return (int)(n % CACHE_TLB_ROWS);
+}
+
+static cacheentry *cache_tlb_lookup(cachetlbentry *tlb, cacheentry *elt,
+                                    char *key)
+{
+    int ix = cache_tlb_hash(key);
+    int i;
+    int j;
+
+    for (i=0; i < CACHE_TLB_COLS; ++i) {
+        j = tlb[ix].t[i];
+        if (j < 0)
+            return NULL;
+        if (strcmp(elt[j].key, key) == 0)
+            return &elt[j];
+    }
+    return NULL;
+}
+
+static void cache_tlb_replace(cachetlbentry *tlb, cacheentry *elt,
+                              cacheentry *e)
+{
+    int ix = cache_tlb_hash(e->key);
+    int i;
+
+    tlb = &tlb[ix];
+
+    for (i=1; i < CACHE_TLB_COLS; ++i)
+        tlb->t[i] = tlb->t[i-1];
+
+    tlb->t[0] = e - elt;
+}
+
+static void store_cache_string(cache *c, char *res, cacheentry *ce)
+{
+    int i;
+    int j;
+    cachelist *l;
+    cacheentry *e;
+    cachetlbentry *t;
+    int found_list;
+
+    found_list = 0;
+    /* first try to edit an existing entry */
+    for (i = 0; i < c->lists->nelts; i++) {
+        l = &(((cachelist *)c->lists->elts)[i]);
+        if (strcmp(l->resource, res) == 0) {
+            found_list = 1;
+
+            e = cache_tlb_lookup((cachetlbentry *)l->tlb->elts,
+                                 (cacheentry *)l->entries->elts, ce->key);
+            if (e != NULL) {
+                e->time  = ce->time;
+                e->value = ap_pstrdup(c->pool, ce->value);
+                return;
+            }
+
+            for (j = 0; j < l->entries->nelts; j++) {
+                e = &(((cacheentry *)l->entries->elts)[j]);
+                if (strcmp(e->key, ce->key) == 0) {
+                    e->time  = ce->time;
+                    e->value = ap_pstrdup(c->pool, ce->value);
+                  cache_tlb_replace((cachetlbentry *)l->tlb->elts,
+                                    (cacheentry *)l->entries->elts, e);
+                    return;
+                }
+            }
+        }
+    }
+
+    /* create a needed new list */
+    if (!found_list) {
+        l = ap_push_array(c->lists);
+        l->resource = ap_pstrdup(c->pool, res);
+        l->entries  = ap_make_array(c->pool, 2, sizeof(cacheentry));
+        l->tlb      = ap_make_array(c->pool, CACHE_TLB_ROWS,
+                                    sizeof(cachetlbentry));
+        for (i=0; i<CACHE_TLB_ROWS; ++i) {
+            t = &((cachetlbentry *)l->tlb->elts)[i];
+                for (j=0; j<CACHE_TLB_COLS; ++j)
+                    t->t[j] = -1;
+        }
+    }
+
+    /* create the new entry */
+    for (i = 0; i < c->lists->nelts; i++) {
+        l = &(((cachelist *)c->lists->elts)[i]);
+        if (strcmp(l->resource, res) == 0) {
+            e = ap_push_array(l->entries);
+            e->time  = ce->time;
+            e->key   = ap_pstrdup(c->pool, ce->key);
+            e->value = ap_pstrdup(c->pool, ce->value);
+            cache_tlb_replace((cachetlbentry *)l->tlb->elts,
+                              (cacheentry *)l->entries->elts, e);
+            return;
+        }
+    }
+
+    /* not reached, but when it is no problem... */
+    return;
+}
+
+static cacheentry *retrieve_cache_string(cache *c, char *res, char *key)
+{
+    int i;
+    int j;
+    cachelist *l;
+    cacheentry *e;
+
+    for (i = 0; i < c->lists->nelts; i++) {
+        l = &(((cachelist *)c->lists->elts)[i]);
+        if (strcmp(l->resource, res) == 0) {
+
+            e = cache_tlb_lookup((cachetlbentry *)l->tlb->elts,
+                                 (cacheentry *)l->entries->elts, key);
+            if (e != NULL)
+                return e;
+
+            for (j = 0; j < l->entries->nelts; j++) {
+                e = &(((cacheentry *)l->entries->elts)[j]);
+                if (strcmp(e->key, key) == 0) {
+                    return e;
+                }
+            }
+        }
+    }
+    return NULL;
+}
+
+
+
+
+/*
+** +-------------------------------------------------------+
+** |                                                       |
+** |                    misc functions
+** |                                                       |
+** +-------------------------------------------------------+
+*/
+
+/*
+ * substitute the prefix path 'match' in 'input' with 'subst'
+ * (think of RewriteBase which substitutes the physical path with
+ *  the virtual path)
+ */
+
+static char *subst_prefix_path(request_rec *r, char *input, char *match,
+                               const char *subst)
+{
+    size_t len = strlen(match);
+
+    if (len && match[len - 1] == '/') {
+        --len;
+    }
+
+    if (!strncmp(input, match, len) && input[len++] == '/') {
+        size_t slen, outlen;
+        char *output;
+
+        rewritelog(r, 5, "strip matching prefix: %s -> %s", input, input+len);
+
+        slen = strlen(subst);
+        if (slen && subst[slen - 1] != '/') {
+            ++slen;
+        }
+
+        outlen = strlen(input) + slen - len;
+        output = ap_palloc(r->pool, outlen + 1); /* don't forget the \0 */
+
+        memcpy(output, subst, slen);
+        if (slen && !output[slen-1]) {
+            output[slen-1] = '/';
+        }
+        memcpy(output+slen, input+len, outlen - slen);
+        output[outlen] = '\0';
+
+        rewritelog(r, 4, "add subst prefix: %s -> %s", input+len, output);
+
+        return output;
+    }
+
+    /* prefix didn't match */
+    return input;
+}
+
+
+/*
+**
+**  own command line parser which don't have the '\\' problem
+**
+*/
+
+static int parseargline(char *str, char **a1, char **a2, char **a3)
+{
+    char *cp;
+    int isquoted;
+
+#define SKIP_WHITESPACE(cp) \
+    for ( ; *cp == ' ' || *cp == '\t'; ) { \
+        cp++; \
+    };
+
+#define CHECK_QUOTATION(cp,isquoted) \
+    isquoted = 0; \
+    if (*cp == '"') { \
+        isquoted = 1; \
+        cp++; \
+    }
+
+#define DETERMINE_NEXTSTRING(cp,isquoted) \
+    for ( ; *cp != '\0'; cp++) { \
+        if (   (isquoted    && (*cp     == ' ' || *cp     == '\t')) \
+            || (*cp == '\\' && (*(cp+1) == ' ' || *(cp+1) == '\t'))) { \
+            cp++; \
+            continue; \
+        } \
+        if (   (!isquoted && (*cp == ' ' || *cp == '\t')) \
+            || (isquoted  && *cp == '"')                  ) { \
+            break; \
+        } \
+    }
+
+    cp = str;
+    SKIP_WHITESPACE(cp);
+
+    /*  determine first argument */
+    CHECK_QUOTATION(cp, isquoted);
+    *a1 = cp;
+    DETERMINE_NEXTSTRING(cp, isquoted);
+    if (*cp == '\0') {
+        return 1;
+    }
+    *cp++ = '\0';
+
+    SKIP_WHITESPACE(cp);
+
+    /*  determine second argument */
+    CHECK_QUOTATION(cp, isquoted);
+    *a2 = cp;
+    DETERMINE_NEXTSTRING(cp, isquoted);
+    if (*cp == '\0') {
+        *cp++ = '\0';
+        *a3 = NULL;
+        return 0;
+    }
+    *cp++ = '\0';
+
+    SKIP_WHITESPACE(cp);
+
+    /* again check if there are only two arguments */
+    if (*cp == '\0') {
+        *cp++ = '\0';
+        *a3 = NULL;
+        return 0;
+    }
+
+    /*  determine second argument */
+    CHECK_QUOTATION(cp, isquoted);
+    *a3 = cp;
+    DETERMINE_NEXTSTRING(cp, isquoted);
+    *cp++ = '\0';
+
+    return 0;
+}
+
+
+static void add_env_variable(request_rec *r, char *s)
+{
+    char var[MAX_STRING_LEN];
+    char val[MAX_STRING_LEN];
+    char *cp;
+    int n;
+
+    if ((cp = strchr(s, ':')) != NULL) {
+        n = ((cp-s) > MAX_STRING_LEN-1 ? MAX_STRING_LEN-1 : (cp-s));
+        memcpy(var, s, n);
+        var[n] = '\0';
+        ap_cpystrn(val, cp+1, sizeof(val));
+        ap_table_set(r->subprocess_env, var, val);
+        rewritelog(r, 5, "setting env variable '%s' to '%s'", var, val);
+    }
+}
+
+
+/*
+**
+**  check that a subrequest won't cause infinite recursion
+**
+*/
+
+static int subreq_ok(request_rec *r)
+{
+    /*
+     * either not in a subrequest, or in a subrequest
+     * and URIs aren't NULL and sub/main URIs differ
+     */
+    return (r->main == NULL ||
+	    (r->main->uri != NULL && r->uri != NULL &&
+	     strcmp(r->main->uri, r->uri) != 0));
+}
+
+
+/*
+**
+**  stat() for only the prefix of a path
+**
+*/
+
+static int prefix_stat(const char *path, ap_pool *pool)
+{
+    const char *curpath = path;
+    char *root;
+    char *slash;
+    char *statpath;
+    struct stat sb;
+
+    if (!ap_os_is_path_absolute(curpath)) {
+        return 0;
+    }
+
+    /* need to be a bit tricky here.
+     * Actually we're looking for the first path segment ...
+     */
+    if (*curpath != '/') {
+        /* be safe: +1 = '\0'; +1 = possible additional '\0'
+         * from ap_make_dirstr_prefix
+         */
+        root = ap_palloc(pool, strlen(curpath) + 2);
+        slash = ap_make_dirstr_prefix(root, curpath, 1);
+        curpath += strlen(root);
+    }
+    else {
+#if defined(HAVE_UNC_PATHS)
+    /* Check for UNC names. */
+        if (curpath[1] == '/') {
+            slash = strchr(curpath + 2, '/');
+
+            /* XXX not sure here. Be safe for now */
+            if (!slash) {
+                return 0;
+            }
+            root = ap_pstrndup(pool, curpath, slash - curpath + 1);
+            curpath += strlen(root);
+        }
+        else {
+#endif /* UNC */
+            root = "/";
+            ++curpath;
+#if defined(HAVE_UNC_PATHS)
+        }
+#endif
+    }
+
+    /* let's recognize slashes only, the mod_rewrite semantics are opaque
+     * enough.
+     */
+    if ((slash = strchr(curpath, '/')) != NULL) {
+        statpath = ap_pstrcat(pool, root,
+                              ap_pstrndup(pool, curpath, slash - curpath),
+                              NULL);
+    }
+    else {
+        statpath = ap_pstrcat(pool, root, curpath, NULL);
+    }
+
+    if (stat(statpath, &sb) == 0) {
+        return 1;
+    }
+
+    return 0;
+}
+
+
+/*
+**
+**  File locking
+**
+*/
+
+#ifdef USE_FCNTL
+static struct flock   lock_it;
+static struct flock unlock_it;
+#endif
+
+static void fd_lock(request_rec *r, int fd)
+{
+    int rc;
+
+#ifdef USE_FCNTL
+    lock_it.l_whence = SEEK_SET; /* from current point */
+    lock_it.l_start  = 0;        /* -"- */
+    lock_it.l_len    = 0;        /* until end of file */
+    lock_it.l_type   = F_WRLCK;  /* set exclusive/write lock */
+    lock_it.l_pid    = 0;        /* pid not actually interesting */
+
+    while (   ((rc = fcntl(fd, F_SETLKW, &lock_it)) < 0)
+              && (errno == EINTR)                               ) {
+        continue;
+    }
+#endif
+#ifdef USE_FLOCK
+    while (   ((rc = flock(fd, LOCK_EX)) < 0)
+              && (errno == EINTR)               ) {
+        continue;
+    }
+#endif
+#ifdef USE_LOCKING
+    /* Lock the first byte, always, assume we want to append
+       and seek to the end afterwards */
+    lseek(fd, 0, SEEK_SET);
+    rc = _locking(fd, _LK_LOCK, 1);
+    lseek(fd, 0, SEEK_END);
+#endif
+#ifdef NETWARE
+	if ((locking_sem != 0) && (TimedWaitOnLocalSemaphore (locking_sem, 10000) != 0))
+		rc = -1;
+	else
+		rc = 1;
+#endif
+
+    if (rc < 0) {
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
+                     "mod_rewrite: failed to lock file descriptor");
+        exit(1);
+    }
+    return;
+}
+
+static void fd_unlock(request_rec *r, int fd)
+{
+    int rc;
+
+#ifdef USE_FCNTL
+    unlock_it.l_whence = SEEK_SET; /* from current point */
+    unlock_it.l_start  = 0;        /* -"- */
+    unlock_it.l_len    = 0;        /* until end of file */
+    unlock_it.l_type   = F_UNLCK;  /* unlock */
+    unlock_it.l_pid    = 0;        /* pid not actually interesting */
+
+    rc = fcntl(fd, F_SETLKW, &unlock_it);
+#endif
+#ifdef USE_FLOCK
+    rc = flock(fd, LOCK_UN);
+#endif
+#ifdef USE_LOCKING
+    lseek(fd, 0, SEEK_SET);
+    rc = _locking(fd, _LK_UNLCK, 1);
+    lseek(fd, 0, SEEK_END);
+#endif
+#ifdef NETWARE
+	if (locking_sem)
+		SignalLocalSemaphore (locking_sem);
+	rc = 1;
+#endif
+
+    if (rc < 0) {
+        ap_log_rerror(APLOG_MARK, APLOG_ERR, r,
+                     "mod_rewrite: failed to unlock file descriptor");
+        exit(1);
+    }
+}
+
+/*
+**
+**  Lexicographic Compare
+**
+*/
+
+static int compare_lexicography(char *cpNum1, char *cpNum2)
+{
+    int i;
+    int n1, n2;
+
+    n1 = strlen(cpNum1);
+    n2 = strlen(cpNum2);
+    if (n1 > n2) {
+        return 1;
+    }
+    if (n1 < n2) {
+        return -1;
+    }
+    for (i = 0; i < n1; i++) {
+        if (cpNum1[i] > cpNum2[i]) {
+            return 1;
+        }
+        if (cpNum1[i] < cpNum2[i]) {
+            return -1;
+        }
+    }
+    return 0;
+}
+
+/*
+**
+**  Bracketed expression handling
+**  s points after the opening bracket
+**
+*/
+
+static char *find_closing_bracket(char *s, int left, int right)
+{
+    int depth;
+
+    for (depth = 1; *s; ++s) {
+	if (*s == right && --depth == 0) {
+	    return s;
+	}
+	else if (*s == left) {
+	    ++depth;
+	}
+    }
+    return NULL;
+}
+
+static char *find_char_in_brackets(char *s, int c, int left, int right)
+{
+    int depth;
+
+    for (depth = 1; *s; ++s) {
+	if (*s == c && depth == 1) {
+	    return s;
+	}
+	else if (*s == right && --depth == 0) {
+	    return NULL;
+	}
+	else if (*s == left) {
+	    ++depth;
+	}
+    }
+    return NULL;
+}
+
+/*EOF*/
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_rewrite.h apache_1.3.33/src/modules/standard/mod_rewrite.h
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_rewrite.h	Fri Aug 20 23:22:25 2004
+++ apache_1.3.33/src/modules/standard/mod_rewrite.h	Mon Jul 18 15:22:18 2005
@@ -87,7 +87,14 @@
      * so we also need to know the file extension
      */
 #ifndef NO_DBM_REWRITEMAP
+#ifndef DB_DBM_HSEARCH
+#define DB_DBM_HSEARCH 0
+#endif
+#if DB_DBM_HSEARCH != 0
+#include <db.h>
+#else
 #include <ndbm.h>
+#endif
 #if defined(DBM_SUFFIX)
 #define NDBM_FILE_SUFFIX DBM_SUFFIX
 #elif defined(__FreeBSD__) || (defined(DB_LOCK) && defined(DB_SHMEM))
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_rewrite.h.orig apache_1.3.33/src/modules/standard/mod_rewrite.h.orig
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_rewrite.h.orig	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/modules/standard/mod_rewrite.h.orig	Fri Aug 20 23:22:25 2004
@@ -0,0 +1,474 @@
+/* Copyright 1999-2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#ifndef _MOD_REWRITE_H
+#define _MOD_REWRITE_H 1
+
+/*
+**                       _                            _ _
+**   _ __ ___   ___   __| |    _ __ _____      ___ __(_) |_ ___
+**  | '_ ` _ \ / _ \ / _` |   | '__/ _ \ \ /\ / / '__| | __/ _ \
+**  | | | | | | (_) | (_| |   | | |  __/\ V  V /| |  | | ||  __/
+**  |_| |_| |_|\___/ \__,_|___|_|  \___| \_/\_/ |_|  |_|\__\___|
+**                       |_____|
+**
+**  URL Rewriting Module
+**
+**  This module uses a rule-based rewriting engine (based on a
+**  regular-expression parser) to rewrite requested URLs on the fly.
+**
+**  It supports an unlimited number of additional rule conditions (which can
+**  operate on a lot of variables, even on HTTP headers) for granular
+**  matching and even external database lookups (either via plain text
+**  tables, DBM hash files or even external processes) for advanced URL
+**  substitution.
+**
+**  It operates on the full URLs (including the PATH_INFO part) both in
+**  per-server context (httpd.conf) and per-dir context (.htaccess) and even
+**  can generate QUERY_STRING parts on result.   The rewriting result finally
+**  can lead to internal subprocessing, external request redirection or even
+**  to internal proxy throughput.
+**
+**  This module was originally written in April 1996 and
+**  gifted exclusively to the The Apache Group in July 1997 by
+**
+**      Ralf S. Engelschall
+**      rse@engelschall.com
+**      www.engelschall.com
+*/
+
+
+    /* Include from the underlaying Unix system ... */
+#include <string.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <time.h>
+#include <signal.h>
+#include <errno.h>
+#include <ctype.h>
+#ifndef NETWARE
+#include <sys/types.h>
+#endif
+#include <sys/stat.h>
+
+    /* Include from the Apache server ... */
+#define CORE_PRIVATE
+#include "httpd.h"
+#include "http_config.h"
+#include "http_conf_globals.h"
+#include "http_request.h"
+#include "http_core.h"
+#include "http_log.h"
+#include "http_vhost.h"
+
+    /*
+     * The key in the r->notes table wherein we store our accumulated
+     * Vary values, and the one used for per-condition checks in a chain.
+     */
+#define VARY_KEY "rewrite-Vary"
+#define VARY_KEY_THIS "rewrite-Vary-this"
+
+    /* The NDBM support:
+     * We support only NDBM files.
+     * But we have to stat the file for the mtime,
+     * so we also need to know the file extension
+     */
+#ifndef NO_DBM_REWRITEMAP
+#include <ndbm.h>
+#if defined(DBM_SUFFIX)
+#define NDBM_FILE_SUFFIX DBM_SUFFIX
+#elif defined(__FreeBSD__) || (defined(DB_LOCK) && defined(DB_SHMEM))
+#define NDBM_FILE_SUFFIX ".db"
+#else
+#define NDBM_FILE_SUFFIX ".pag"
+#endif
+#endif
+
+
+    /* The locking support:
+     * Try to determine whether we should use fcntl() or flock().
+     * Would be better ap_config.h could provide this... :-(
+     * Small monkey business to ensure that fcntl is preferred,
+     * unless we specified USE_FLOCK_SERIALIZED_ACCEPT during compile.
+     */
+#if defined(HAVE_FCNTL_SERIALIZED_ACCEPT) && !defined(USE_FLOCK_SERIALIZED_ACCEPT)
+#define USE_FCNTL 1
+#include <fcntl.h>
+#elif defined(HAVE_FLOCK_SERIALIZED_ACCEPT)
+#define USE_FLOCK 1
+#include <sys/file.h>
+#endif
+#if !defined(USE_FCNTL) && !defined(USE_FLOCK)
+#define USE_FLOCK 1
+#if !defined(MPE) && !defined(WIN32) && !defined(__TANDEM) && !defined(NETWARE)
+#include <sys/file.h>
+#endif
+#ifndef LOCK_UN
+#undef USE_FLOCK
+#define USE_FCNTL 1
+#include <fcntl.h>
+#endif
+#endif
+#if defined(AIX) || defined(AIXIA64)
+#undef USE_FLOCK
+#define USE_FCNTL 1
+#include <fcntl.h>
+#endif
+#ifdef WIN32
+#undef USE_FCNTL
+#define USE_LOCKING
+#include <sys/locking.h>
+#endif
+
+
+/*
+**
+**  Some defines
+**
+*/
+
+#define ENVVAR_SCRIPT_URL "SCRIPT_URL"
+#define ENVVAR_SCRIPT_URI "SCRIPT_URI"
+
+#ifndef SUPPORT_DBM_REWRITEMAP
+#define SUPPORT_DBM_REWRITEMAP 0
+#endif
+
+#define REWRITE_FORCED_MIMETYPE_NOTEVAR "rewrite-forced-mimetype"
+
+#define CONDFLAG_NONE               1<<0
+#define CONDFLAG_NOCASE             1<<1
+#define CONDFLAG_NOTMATCH           1<<2
+#define CONDFLAG_ORNEXT             1<<3
+
+#define RULEFLAG_NONE               1<<0
+#define RULEFLAG_FORCEREDIRECT      1<<1
+#define RULEFLAG_LASTRULE           1<<2
+#define RULEFLAG_NEWROUND           1<<3
+#define RULEFLAG_CHAIN              1<<4
+#define RULEFLAG_IGNOREONSUBREQ     1<<5
+#define RULEFLAG_NOTMATCH           1<<6
+#define RULEFLAG_PROXY              1<<7
+#define RULEFLAG_PASSTHROUGH        1<<8
+#define RULEFLAG_FORBIDDEN          1<<9
+#define RULEFLAG_GONE               1<<10
+#define RULEFLAG_QSAPPEND           1<<11
+#define RULEFLAG_NOCASE             1<<12
+#define RULEFLAG_NOESCAPE           1<<13
+
+#define ACTION_NORMAL               1<<0
+#define ACTION_NOESCAPE             1<<1
+
+#define MAPTYPE_TXT                 1<<0
+#define MAPTYPE_DBM                 1<<1
+#define MAPTYPE_PRG                 1<<2
+#define MAPTYPE_INT                 1<<3
+#define MAPTYPE_RND                 1<<4
+
+#define ENGINE_DISABLED             1<<0
+#define ENGINE_ENABLED              1<<1
+
+#define OPTION_NONE                 1<<0
+#define OPTION_INHERIT              1<<1
+
+#define CACHEMODE_TS                1<<0
+#define CACHEMODE_TTL               1<<1
+
+#define CACHE_TLB_ROWS 1024
+#define CACHE_TLB_COLS 4
+
+#ifndef FALSE
+#define FALSE 0
+#define TRUE  !FALSE
+#endif
+
+#ifndef NO
+#define NO    FALSE
+#define YES   TRUE
+#endif
+
+#ifndef RAND_MAX
+#define RAND_MAX 32767
+#endif
+
+#ifndef LONG_STRING_LEN
+#define LONG_STRING_LEN 2048
+#endif
+
+#define MAX_ENV_FLAGS 15
+
+/* default maximum number of internal redirects */
+#define REWRITE_REDIRECT_LIMIT 10
+
+/*
+**
+**  our private data structures we handle with
+**
+*/
+
+    /* the list structures for holding the mapfile information
+     * and the rewrite rules
+     */
+typedef struct {
+    char *name;                    /* the name of the map */
+    char *datafile;                /* filename for map data files */
+    char *checkfile;               /* filename to check for map existence */
+    int   type;                    /* the type of the map */
+    int   fpin;                    /* in  file pointer for program maps */
+    int   fpout;                   /* out file pointer for program maps */
+    int   fperr;                   /* err file pointer for program maps */
+    char *(*func)(request_rec *,   /* function pointer for internal maps */
+                  char *);
+    char *cachename;               /* name for the cache */
+} rewritemap_entry;
+
+typedef struct {
+    char    *input;                /* Input string of RewriteCond */
+    char    *pattern;              /* the RegExp pattern string */
+    regex_t *regexp;
+    int      flags;                /* Flags which control the match */
+} rewritecond_entry;
+
+typedef struct {
+    array_header *rewriteconds;    /* the corresponding RewriteCond entries */
+    char    *pattern;              /* the RegExp pattern string */
+    regex_t *regexp;               /* the RegExp pattern compilation */
+    char    *output;               /* the Substitution string */
+    int      flags;                /* Flags which control the substitution */
+    char    *forced_mimetype;      /* forced MIME type of substitution */
+    int      forced_responsecode;  /* forced HTTP redirect response status */
+    char    *env[MAX_ENV_FLAGS+1]; /* added environment variables */
+    int      skip;                 /* number of next rules to skip */
+} rewriterule_entry;
+
+
+    /* the per-server or per-virtual-server configuration
+     * statically generated once on startup for every server
+     */
+typedef struct {
+    int           state;           /* the RewriteEngine state */
+    int           options;         /* the RewriteOption state */
+    char         *rewritelogfile;  /* the RewriteLog filename */
+    int           rewritelogfp;    /* the RewriteLog open filepointer */
+    int           rewriteloglevel; /* the RewriteLog level of verbosity */
+    array_header *rewritemaps;     /* the RewriteMap entries */
+    array_header *rewriteconds;    /* the RewriteCond entries (temporary) */
+    array_header *rewriterules;    /* the RewriteRule entries */
+    server_rec   *server;          /* the corresponding server indicator */
+    int          redirect_limit;   /* maximum number of internal redirects */
+} rewrite_server_conf;
+
+
+    /* the per-directory configuration
+     * generated on-the-fly by Apache server for current request
+     */
+typedef struct {
+    int           state;           /* the RewriteEngine state */
+    int           options;         /* the RewriteOption state */
+    array_header *rewriteconds;    /* the RewriteCond entries (temporary) */
+    array_header *rewriterules;    /* the RewriteRule entries */
+    char         *directory;       /* the directory where it applies */
+    char         *baseurl;         /* the base-URL  where it applies */
+    int          redirect_limit;   /* maximum number of internal redirects */
+} rewrite_perdir_conf;
+
+    /* the per-request configuration
+     */
+typedef struct {
+    int           redirects;       /* current number of redirects */
+    int           redirect_limit;  /* maximum number of redirects */
+} rewrite_request_conf;
+
+
+    /* the cache structures,
+     * a 4-way hash table with LRU functionality
+     */
+typedef struct cacheentry {
+    time_t time;
+    char  *key;
+    char  *value;
+} cacheentry;
+
+typedef struct tlbentry {
+    int t[CACHE_TLB_COLS];
+} cachetlbentry;
+
+typedef struct cachelist {
+    char         *resource;
+    array_header *entries;
+    array_header *tlb;
+} cachelist;
+
+typedef struct cache {
+    pool         *pool;
+    array_header *lists;
+} cache;
+
+
+    /* the regex structure for the
+     * substitution of backreferences
+     */
+typedef struct backrefinfo {
+    char *source;
+    int nsub;
+    regmatch_t regmatch[AP_MAX_REG_MATCH];
+} backrefinfo;
+
+
+/*
+**
+**  forward declarations
+**
+*/
+
+    /* config structure handling */
+static void *config_server_create(pool *p, server_rec *s);
+static void *config_server_merge (pool *p, void *basev, void *overridesv);
+static void *config_perdir_create(pool *p, char *path);
+static void *config_perdir_merge (pool *p, void *basev, void *overridesv);
+
+    /* config directive handling */
+static const char *cmd_rewriteengine(cmd_parms *cmd,
+                                     rewrite_perdir_conf *dconf, int flag);
+static const char *cmd_rewriteoptions(cmd_parms *cmd,
+                                      void *in_dconf,
+                                      const char *option);
+static const char *cmd_rewritelog     (cmd_parms *cmd, void *dconf, char *a1);
+static const char *cmd_rewriteloglevel(cmd_parms *cmd, void *dconf, char *a1);
+static const char *cmd_rewritemap     (cmd_parms *cmd, void *dconf, char *a1,
+                                       char *a2);
+static const char *cmd_rewritelock(cmd_parms *cmd, void *dconf, char *a1);
+static const char *cmd_rewritebase(cmd_parms *cmd, rewrite_perdir_conf *dconf,
+                                   char *a1);
+static const char *cmd_rewritecond(cmd_parms *cmd, rewrite_perdir_conf *dconf,
+                                   char *str);
+static const char *cmd_rewritecond_parseflagfield(pool *p,
+                                                  rewritecond_entry *new,
+                                                  char *str);
+static const char *cmd_rewritecond_setflag(pool *p, rewritecond_entry *cfg,
+                                           char *key, char *val);
+static const char *cmd_rewriterule(cmd_parms *cmd, rewrite_perdir_conf *dconf,
+                                   char *str);
+static const char *cmd_rewriterule_parseflagfield(pool *p,
+                                                  rewriterule_entry *new,
+                                                  char *str);
+static const char *cmd_rewriterule_setflag(pool *p, rewriterule_entry *cfg,
+                                           char *key, char *val);
+
+    /* initialisation */
+static void init_module(server_rec *s, pool *p);
+static void init_child(server_rec *s, pool *p);
+
+    /* runtime hooks */
+static int hook_uri2file   (request_rec *r);
+static int hook_mimetype   (request_rec *r);
+static int hook_fixup      (request_rec *r);
+static int handler_redirect(request_rec *r);
+
+    /* rewriting engine */
+static int apply_rewrite_list(request_rec *r, array_header *rewriterules,
+                              char *perdir);
+static int apply_rewrite_rule(request_rec *r, rewriterule_entry *p,
+                              char *perdir);
+static int apply_rewrite_cond(request_rec *r, rewritecond_entry *p,
+                              char *perdir, backrefinfo *briRR,
+                              backrefinfo *briRC);
+
+static void do_expand(request_rec *r, char *input, char *buffer, int nbuf,
+		       backrefinfo *briRR, backrefinfo *briRC);
+static void do_expand_env(request_rec *r, char *env[],
+			  backrefinfo *briRR, backrefinfo *briRC);
+
+    /* URI transformation function */
+static void  splitout_queryargs(request_rec *r, int qsappend);
+static void  fully_qualify_uri(request_rec *r);
+static void  reduce_uri(request_rec *r);
+static unsigned is_absolute_uri(char *uri);
+static char *escape_absolute_uri(ap_pool *p, char *uri, unsigned scheme);
+static char *expand_tildepaths(request_rec *r, char *uri);
+
+    /* rewrite map support functions */
+static char *lookup_map(request_rec *r, char *name, char *key);
+static char *lookup_map_txtfile(request_rec *r, char *file, char *key);
+#ifndef NO_DBM_REWRITEMAP
+static char *lookup_map_dbmfile(request_rec *r, char *file, char *key);
+#endif
+static char *lookup_map_program(request_rec *r, int fpin,
+                                int fpout, char *key);
+static char *lookup_map_internal(request_rec *r,
+                                 char *(*func)(request_rec *r, char *key),
+                                 char *key);
+static char *rewrite_mapfunc_toupper(request_rec *r, char *key);
+static char *rewrite_mapfunc_tolower(request_rec *r, char *key);
+static char *rewrite_mapfunc_escape(request_rec *r, char *key);
+static char *rewrite_mapfunc_unescape(request_rec *r, char *key);
+static char *select_random_value_part(request_rec *r, char *value);
+static void  rewrite_rand_init(void);
+static int   rewrite_rand(int l, int h);
+
+    /* rewriting logfile support */
+static void  open_rewritelog(server_rec *s, pool *p);
+static void  rewritelog(request_rec *r, int level, const char *text, ...)
+                        __attribute__((format(printf,3,4)));
+static char *current_logtime(request_rec *r);
+
+    /* rewriting lockfile support */
+static void rewritelock_create(server_rec *s, pool *p);
+static void rewritelock_open(server_rec *s, pool *p);
+static void rewritelock_remove(void *data);
+static void rewritelock_alloc(request_rec *r);
+static void rewritelock_free(request_rec *r);
+
+    /* program map support */
+static void  run_rewritemap_programs(server_rec *s, pool *p);
+static int   rewritemap_program_child(void *cmd, child_info *pinfo);
+
+    /* env variable support */
+static char *lookup_variable(request_rec *r, char *var);
+static char *lookup_header(request_rec *r, const char *name);
+
+    /* caching functions */
+static cache *init_cache(pool *p);
+static char  *get_cache_string(cache *c, char *res, int mode, time_t mtime,
+                               char *key);
+static void   set_cache_string(cache *c, char *res, int mode, time_t mtime,
+                               char *key, char *value);
+static cacheentry *retrieve_cache_string(cache *c, char *res, char *key);
+static void   store_cache_string(cache *c, char *res, cacheentry *ce);
+
+    /* misc functions */
+static char  *subst_prefix_path(request_rec *r, char *input, char *match,
+                                const char *subst);
+static int    parseargline(char *str, char **a1, char **a2, char **a3);
+static int    prefix_stat(const char *path, ap_pool *pool);
+static void   add_env_variable(request_rec *r, char *s);
+static int    subreq_ok(request_rec *r);
+static int    is_redirect_limit_exceeded(request_rec *r);
+
+    /* File locking */
+static void fd_lock(request_rec *r, int fd);
+static void fd_unlock(request_rec *r, int fd);
+
+    /* Lexicographic Comparison */
+static int compare_lexicography(char *cpNum1, char *cpNum2);
+
+    /* Bracketed expression handling */
+static char *find_closing_bracket(char *s, int left, int right);
+static char *find_char_in_brackets(char *s, int c, int left, int right);
+
+#endif /* _MOD_REWRITE_H */
+
+/*EOF*/
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_so.c apache_1.3.33/src/modules/standard/mod_so.c
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_so.c	Wed Sep  8 15:35:12 2004
+++ apache_1.3.33/src/modules/standard/mod_so.c	Mon Jul 18 15:22:25 2005
@@ -266,11 +266,24 @@
      * Make sure the found module structure is really a module structure
      * 
      */
+#ifdef EAPI
+    if (   modp->magic != MODULE_MAGIC_COOKIE_AP13 
+        && modp->magic != MODULE_MAGIC_COOKIE_EAPI) {
+#else
     if (modp->magic != MODULE_MAGIC_COOKIE) {
+#endif
         return ap_pstrcat(cmd->pool, "API module structure `", modname,
                           "' in file ", szModuleFile, " is garbled -"
                           " perhaps this is not an Apache module DSO?", NULL);
     }
+#ifdef EAPI
+    if (modp->magic == MODULE_MAGIC_COOKIE_AP13) {
+        ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, NULL,
+                     "Loaded DSO %s uses plain Apache 1.3 API, "
+                     "this module might crash under EAPI! "
+                     "(please recompile it with -DEAPI)", filename);
+    }
+#endif
 
     /* 
      * Add this module to the Apache core structures
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_so.c.orig apache_1.3.33/src/modules/standard/mod_so.c.orig
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_so.c.orig	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/modules/standard/mod_so.c.orig	Wed Sep  8 15:35:12 2004
@@ -0,0 +1,374 @@
+/* Copyright 1999-2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* 
+ * This module is used to load Apache modules at runtime. This means that the
+ * server functionality can be extended without recompiling and even without
+ * taking the server down at all. Only a HUP or USR1 signal needs to be send
+ * to the server to reload the dynamically loaded modules.
+ *
+ * To use, you'll first need to build your module as a shared library, then
+ * update your configuration (httpd.conf) to get the Apache core to load the
+ * module at start-up.
+ *
+ * The easiest way to build a module as a shared library is to use the
+ * `SharedModule' command in the Configuration file, instead of `AddModule'.
+ * You should also change the file extension from `.o' to `.so'. So, for
+ * example, to build the status module as a shared library edit Configuration
+ * and change
+ *   AddModule    modules/standard/mod_status.o
+ * to
+ *   SharedModule modules/standard/mod_status.so
+ *
+ * Run Configure and make. Now Apache's httpd binary will _not_ include
+ * mod_status. Instead a shared object called mod_status.so will be build, in
+ * the modules/standard directory. You can build most of the modules as shared
+ * libraries like this.
+ *
+ * To use the shared module, move the .so file(s) into an appropriate
+ * directory. You might like to create a directory called "modules" under you
+ * server root for this (e.g. /usr/local/httpd/modules). 
+ *
+ * Then edit your conf/httpd.conf file, and add LoadModule lines. For
+ * example
+ *   LoadModule  status_module   modules/mod_status.so
+ *
+ * The first argument is the module's structure name (look at the end of the
+ * module source to find this). The second option is the path to the module
+ * file, relative to the server root.  Put these directives right at the top
+ * of your httpd.conf file.
+ *
+ * Now you can start Apache. A message will be logged at "debug" level to your
+ * error_log to confirm that the module(s) are loaded (use "LogLevel debug"
+ * directive to get these log messages).
+ *
+ * If you edit the LoadModule directives while the server is live you can get
+ * Apache to re-load the modules by sending it a HUP or USR1 signal as normal.
+ * You can use this to dynamically change the capability of your server
+ * without bringing it down.
+ *
+ * Because currently there is only limited built-in support in the Configure
+ * script for creating the shared library files (`.so'), please consult your
+ * vendors cc(1), ld(1) and dlopen(3) manpages to find out the appropriate
+ * compiler and linker flags and insert them manually into the Configuration
+ * file under CFLAGS_SHLIB, LDFLAGS_SHLIB and LDFLAGS_SHLIB_EXPORT.
+ *
+ * If you still have problems figuring out the flags both try the paper
+ *     http://developer.netscape.com/library/documentation/enterprise
+ *                                          /unix/svrplug.htm#1013807
+ * or install a Perl 5 interpreter on your platform and then run the command
+ *
+ *     $ perl -V:usedl -V:ccdlflags -V:cccdlflags -V:lddlflags
+ *
+ * This gives you what type of dynamic loading Perl 5 uses on your platform
+ * and which compiler and linker flags Perl 5 uses to create the shared object
+ * files.
+ *
+ * Another location where you can find useful hints is the `ltconfig' script
+ * of the GNU libtool 1.2 package. Search for your platform name inside the
+ * various "case" constructs.
+ *
+ */
+
+
+#define CORE_PRIVATE
+#include "httpd.h"
+#include "http_config.h"
+#include "http_log.h"
+
+module MODULE_VAR_EXPORT so_module;
+
+
+/*
+ * Server configuration to keep track of actually
+ * loaded modules and the corresponding module name.
+ */
+
+typedef struct moduleinfo {
+    char *name;
+    module *modp;
+} moduleinfo;
+
+typedef struct so_server_conf {
+    array_header *loaded_modules;
+} so_server_conf;
+
+static void *so_sconf_create(pool *p, server_rec *s)
+{
+    so_server_conf *soc;
+
+    soc = (so_server_conf *)ap_pcalloc(p, sizeof(so_server_conf));
+    soc->loaded_modules = ap_make_array(p, DYNAMIC_MODULE_LIMIT, 
+                                     sizeof(moduleinfo));
+#ifndef NO_DLOPEN
+    ap_os_dso_init();
+#endif
+
+    return (void *)soc;
+}
+
+#ifndef NO_DLOPEN
+
+/*
+ * This is the cleanup for a loaded shared object. It unloads the module.
+ * This is called as a cleanup function from the core.
+ */
+
+static void unload_module(moduleinfo *modi)
+{
+    /* only unload if module information is still existing */
+    if (modi->modp == NULL)
+        return;
+
+    /* remove the module pointer from the core structure */
+    ap_remove_loaded_module(modi->modp);
+
+    /* unload the module space itself */
+#ifdef NETWARE
+    ap_os_dso_unsym((ap_os_dso_handle_t)modi->modp->dynamic_load_handle, modi->name);
+#endif
+    ap_os_dso_unload((ap_os_dso_handle_t)modi->modp->dynamic_load_handle);
+
+    /* destroy the module information */
+    modi->modp = NULL;
+    modi->name = NULL;
+}
+
+/* 
+ * This is the cleanup routine for files loaded by
+ * load_file(). Unfortunately we don't keep a record of the filename
+ * that was loaded, so we can't report the unload for debug purposes
+ * or include the filename in error message.
+ */
+
+static void unload_file(void *handle)
+{
+    ap_os_dso_unload((ap_os_dso_handle_t)handle);
+}
+
+/* 
+ * This is called for the directive LoadModule and actually loads
+ * a shared object file into the address space of the server process.
+ */
+
+static const char *load_module(cmd_parms *cmd, void *dummy, 
+                               char *modname, char *filename)
+{
+    ap_os_dso_handle_t modhandle;
+    module *modp;
+    const char *szModuleFile=ap_server_root_relative(cmd->pool, filename);
+    so_server_conf *sconf;
+    moduleinfo *modi;
+    moduleinfo *modie;
+    int i;
+
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) {
+        return err;
+    }
+    
+    /* 
+     * check for already existing module
+     * If it already exists, we have nothing to do 
+     * Check both dynamically-loaded modules and statically-linked modules.
+     */
+    sconf = (so_server_conf *)ap_get_module_config(cmd->server->module_config, 
+	                                        &so_module);
+    modie = (moduleinfo *)sconf->loaded_modules->elts;
+    for (i = 0; i < sconf->loaded_modules->nelts; i++) {
+        modi = &modie[i];
+        if (modi->name != NULL && strcmp(modi->name, modname) == 0) {
+            ap_log_error(APLOG_MARK, APLOG_WARNING|APLOG_NOERRNO, cmd->server,
+                          "module %s is already loaded, skipping", modname);
+            return NULL;
+        }
+    }
+
+    for (i = 0; ap_preloaded_modules[i]; i++) {
+        const char *preload_name;
+        size_t preload_len;
+        size_t thismod_len;
+
+        modp = ap_preloaded_modules[i];
+
+        /* make sure we're comparing apples with apples
+         * make sure name of preloaded module is mod_FOO.c
+         * make sure name of structure being loaded is FOO_module
+         */
+
+        if (memcmp(modp->name, "mod_", 4)) {
+            continue;
+        }
+
+        preload_name = modp->name + strlen("mod_");
+        preload_len = strlen(preload_name) - 2;
+
+        if (strlen(modname) <= strlen("_module")) {
+            continue;
+        }
+        thismod_len = strlen(modname) - strlen("_module");
+        if (strcmp(modname + thismod_len, "_module")) {
+            continue;
+        }
+
+        if (thismod_len != preload_len) {
+            continue;
+        }
+
+        if (!memcmp(modname, preload_name, preload_len)) {
+            return ap_pstrcat(cmd->pool, "module ", modname,
+                              " is built-in and can't be loaded",
+                              NULL);
+        }
+    }
+
+    modi = ap_push_array(sconf->loaded_modules);
+    modi->name = modname;
+
+    /*
+     * Load the file into the Apache address space
+     */
+    if (!(modhandle = ap_os_dso_load(szModuleFile))) {
+	const char *my_error = ap_os_dso_error();
+	return ap_pstrcat (cmd->pool, "Cannot load ", szModuleFile,
+			" into server: ", 
+			my_error ? my_error : "(reason unknown)",
+			NULL);
+    }
+    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, NULL,
+		"loaded module %s", modname);
+
+    /*
+     * Retrieve the pointer to the module structure through the module name:
+     * First with the hidden variant (prefix `AP_') and then with the plain
+     * symbol name.
+     */
+    if (!(modp = (module *)(ap_os_dso_sym(modhandle, modname)))) {
+	return ap_pstrcat(cmd->pool, "Can't locate API module structure `", modname,
+		       "' in file ", szModuleFile, ": ", ap_os_dso_error(), NULL);
+    }
+    modi->modp = modp;
+    modp->dynamic_load_handle = (void *)modhandle;
+
+    /* 
+     * Make sure the found module structure is really a module structure
+     * 
+     */
+    if (modp->magic != MODULE_MAGIC_COOKIE) {
+        return ap_pstrcat(cmd->pool, "API module structure `", modname,
+                          "' in file ", szModuleFile, " is garbled -"
+                          " perhaps this is not an Apache module DSO?", NULL);
+    }
+
+    /* 
+     * Add this module to the Apache core structures
+     */
+    ap_add_loaded_module(modp);
+
+    /* 
+     * Register a cleanup in the config pool (normally pconf). When
+     * we do a restart (or shutdown) this cleanup will cause the
+     * shared object to be unloaded.
+     */
+    ap_register_cleanup(cmd->pool, modi, 
+		     (void (*)(void*))unload_module, ap_null_cleanup);
+
+    /* 
+     * Finally we need to run the configuration process for the module
+     */
+    ap_single_module_configure(cmd->pool, cmd->server, modp);
+
+    return NULL;
+}
+
+/* 
+ * This implements the LoadFile directive and loads an arbitrary
+ * shared object file into the adress space of the server process.
+ */
+
+static const char *load_file(cmd_parms *cmd, void *dummy, char *filename)
+{
+    ap_os_dso_handle_t handle;
+    char *file;
+
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) {
+        return err;
+    }
+    
+    file = ap_server_root_relative(cmd->pool, filename);
+    
+    if (!(handle = ap_os_dso_load(file))) {
+	const char *my_error = ap_os_dso_error();
+	return ap_pstrcat (cmd->pool, "Cannot load ", filename, 
+			" into server:", 
+			my_error ? my_error : "(reason unknown)",
+			NULL);
+    }
+    
+    ap_log_error(APLOG_MARK, APLOG_DEBUG|APLOG_NOERRNO, NULL,
+		"loaded file %s", filename);
+
+    ap_register_cleanup(cmd->pool, (void *)handle, unload_file, ap_null_cleanup);
+
+    return NULL;
+}
+
+#else /* not NO_DLOPEN */
+
+static const char *load_file(cmd_parms *cmd, void *dummy, char *filename)
+{
+    fprintf(stderr, "WARNING: LoadFile not supported on this platform\n");
+    return NULL;
+}
+
+static const char *load_module(cmd_parms *cmd, void *dummy, 
+	                       char *modname, char *filename)
+{
+    fprintf(stderr, "WARNING: LoadModule not supported on this platform\n");
+    return NULL;
+}
+
+#endif /* NO_DLOPEN */
+
+static const command_rec so_cmds[] = {
+    { "LoadModule", load_module, NULL, RSRC_CONF, TAKE2,
+      "a module name and the name of a shared object file to load it from"},
+    { "LoadFile", load_file, NULL, RSRC_CONF, ITERATE,
+      "shared object file or library to load into the server at runtime"},
+    { NULL }
+};
+
+module MODULE_VAR_EXPORT so_module = {
+   STANDARD_MODULE_STUFF,
+   NULL,			/* initializer */
+   NULL,			/* create per-dir config */
+   NULL,			/* merge per-dir config */
+   so_sconf_create,		/* server config */
+   NULL,			/* merge server config */
+   so_cmds,			/* command table */
+   NULL,			/* handlers */
+   NULL,			/* filename translation */
+   NULL,			/* check_user_id */
+   NULL,			/* check auth */
+   NULL,			/* check access */
+   NULL,			/* type_checker */
+   NULL,			/* fixer_upper */
+   NULL,			/* logger */
+   NULL,			/* header parser */
+   NULL,			/* child_init */
+   NULL,			/* child_exit */
+   NULL				/* post read-request */
+};
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_status.c apache_1.3.33/src/modules/standard/mod_status.c
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/modules/standard/mod_status.c	Fri Feb 20 21:38:27 2004
+++ apache_1.3.33/src/modules/standard/mod_status.c	Mon Jul 18 15:22:25 2005
@@ -651,12 +651,23 @@
 			    ap_rprintf(r,
 			     "<td>?<td nowrap>?<td nowrap>..reading.. </tr>\n\n");
 			else
+#ifndef NO_PRETTYPRINT
+			    ap_rprintf(r,
+			     "<td nowrap><font face=\"Arial,Helvetica\" size=\"-1\">%s</font>"
+			     "<td nowrap><font face=\"Arial,Helvetica\" size=\"-1\">%s</font>"
+			     "<td nowrap><font face=\"Arial,Helvetica\" size=\"-1\">%s</font>"
+			     "</tr>\n\n",
+			     score_record.client,
+			     vhost ? vhost->server_hostname : "(unavailable)",
+			     ap_escape_html(r->pool, score_record.request));
+#else
 			    ap_rprintf(r,
 			     "<td>%s<td nowrap>%s<td nowrap>%s</tr>\n\n",
 			     ap_escape_html(r->pool, score_record.client),
 			     vhost ? ap_escape_html(r->pool, 
 				vhost->server_hostname) : "(unavailable)",
 			     ap_escape_html(r->pool, score_record.request));
+#endif
 		    }		/* no_table_report */
 		}			/* !short_report */
 	    }			/* if (<active child>) */
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/ab.8 apache_1.3.33/src/support/ab.8
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/ab.8	Fri Feb 20 23:13:04 2004
+++ apache_1.3.33/src/support/ab.8	Mon Jul 18 15:22:19 2005
@@ -185,7 +185,7 @@
 percentage (from 1% to 100%) the time (in milli seconds) it took
 to serve that percentage of the requests. This is usually more
 usefull than the 'gnuplot' file; as the results are already
-'binned'.
+\&'binned'.
 
 .TP 12
 .B \-v 
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/ab.c apache_1.3.33/src/support/ab.c
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/ab.c	Fri Feb 20 23:02:24 2004
+++ apache_1.3.33/src/support/ab.c	Mon Jul 18 15:22:18 2005
@@ -948,7 +948,8 @@
     FD_CLR(c->fd, &writebits);
 
     /* connect again */
-    start_connect(c);
+    if(done < requests)
+	start_connect(c);
     return;
 }
 
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/ab.c.orig apache_1.3.33/src/support/ab.c.orig
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/ab.c.orig	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/support/ab.c.orig	Fri Feb 20 23:02:24 2004
@@ -0,0 +1,1673 @@
+/* Copyright 1999-2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+   ** This program is based on ZeusBench V1.0 written by Adam Twiss
+   ** which is Copyright (c) 1996 by Zeus Technology Ltd. http://www.zeustech.net/
+   **
+   ** This software is provided "as is" and any express or implied waranties,
+   ** including but not limited to, the implied warranties of merchantability and
+   ** fitness for a particular purpose are disclaimed.  In no event shall
+   ** Zeus Technology Ltd. be liable for any direct, indirect, incidental, special,
+   ** exemplary, or consequential damaged (including, but not limited to,
+   ** procurement of substitute good or services; loss of use, data, or profits;
+   ** or business interruption) however caused and on theory of liability.  Whether
+   ** in contract, strict liability or tort (including negligence or otherwise)
+   ** arising in any way out of the use of this software, even if advised of the
+   ** possibility of such damage.
+   **
+ */
+
+/*
+   ** HISTORY:
+   **    - Originally written by Adam Twiss <adam@zeus.co.uk>, March 1996
+   **      with input from Mike Belshe <mbelshe@netscape.com> and
+   **      Michael Campanella <campanella@stevms.enet.dec.com>
+   **    - Enhanced by Dean Gaudet <dgaudet@apache.org>, November 1997
+   **    - Cleaned up by Ralf S. Engelschall <rse@apache.org>, March 1998
+   **    - POST and verbosity by Kurt Sussman <kls@merlot.com>, August 1998
+   **    - HTML table output added by David N. Welton <davidw@prosa.it>, January 1999
+   **    - Added Cookie, Arbitrary header and auth support. <dirkx@webweaving.org>, April 1999
+   ** Version 1.3d
+   **    - Increased version number - as some of the socket/error handling has
+   **      fundamentally changed - and will give fundamentally different results
+   **      in situations where a server is dropping requests. Therefore you can
+   **      no longer compare results of AB as easily. Hence the inc of the version.
+   **      They should be closer to the truth though. Sander & <dirkx@covalent.net>, End 2000.
+   **    - Fixed proxy functionality, added median/mean statistics, added gnuplot
+   **      output option, added _experimental/rudimentary_ SSL support. Added
+   **      confidence guestimators and warnings. Sander & <dirkx@covalent.net>, End 2000
+   **    - Fixed serious int overflow issues which would cause realistic (longer
+   **      than a few minutes) run's to have wrong (but believable) results. Added
+   **	   trapping of connection errors which influenced measurements.
+   **	   Contributed by Sander Temme - Early 2001
+   **
+ */
+ /*
+  * BUGS:
+  *
+  * - uses strcpy/etc.
+  * - has various other poor buffer attacks related to the lazy parsing of
+  *   response headers from the server
+  * - doesn't implement much of HTTP/1.x, only accepts certain forms of
+  *   responses
+  * - (performance problem) heavy use of strstr shows up top in profile
+  *   only an issue for loopback usage
+  * - SSL implementation is a joke. Compile with:
+  *	CFLAGS="-DUSE_SSL -I/usr/local/include" \
+  *		LIBS="-L/usr/local/lib -lssl -lcrypto" \
+  *		configure --your-other-options
+  */
+
+
+#define VERSION "1.3d"
+
+/* -------------------------------------------------------------------- */
+
+/* affects include files on Solaris */
+#define BSD_COMP
+
+/* allow compilation outside an Apache build tree */
+#ifdef NO_APACHE_INCLUDES
+#include <sys/time.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <fcntl.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netdb.h>
+#include <errno.h>
+#include <sys/ioctl.h>
+#include <string.h>
+#include <signal.h>
+#include <sys/types.h>
+#include <sys/uio.h>
+
+#define ap_select       select
+#else				/* (!)NO_APACHE_INCLUDES */
+#include "ap_config.h"
+#include "ap.h"
+#ifdef CHARSET_EBCDIC
+#include "ebcdic.h"
+#endif
+#include <fcntl.h>
+#ifndef MPE
+#include <sys/time.h>
+#endif
+
+#ifndef NO_WRITEV
+#include <sys/types.h>
+#include <sys/uio.h>
+#endif
+
+#endif				/* NO_APACHE_INCLUDES */
+
+#ifdef	USE_SSL
+#if ((!defined(RSAREF)) && (!defined(SYSSSL)))
+/* Libraries on most systems.. */
+#include <openssl/rsa.h>
+#include <openssl/crypto.h>
+#include <openssl/x509.h>
+#include <openssl/pem.h>
+#include <openssl/err.h>
+#include <openssl/ssl.h>
+#else
+/* Libraries for RSAref and SYSSSL */
+#include <rsa.h>
+#include <crypto.h>
+#include <x509.h>
+#include <pem.h>
+#include <err.h>
+#include <ssl.h>
+#endif
+#endif
+
+#include <math.h>
+/* ------------------- DEFINITIONS -------------------------- */
+
+/* maximum number of requests on a time limited test */
+#define MAX_REQUESTS 50000
+
+/* good old state hostname */
+#define STATE_UNCONNECTED 0
+#define STATE_CONNECTING  1
+#define STATE_READ        2
+
+#define CBUFFSIZE       512
+
+struct connection {
+    int fd;
+    int state;
+    int read;			/* amount of bytes read */
+    int bread;			/* amount of body read */
+    int length;			/* Content-Length value used for keep-alive */
+    char cbuff[CBUFFSIZE];	/* a buffer to store server response header */
+    int cbx;			/* offset in cbuffer */
+    int keepalive;		/* non-zero if a keep-alive request */
+    int gotheader;		/* non-zero if we have the entire header in
+				 * cbuff */
+    struct timeval start,	/* Start of connection */
+            connect,		/* Connected, start writing */
+            endwrite,		/* Request written */
+            beginread,		/* First byte of input */
+            done;		/* Connection closed */
+
+#ifdef USE_SSL
+    SSL *ssl;
+#endif
+};
+
+struct data {
+#ifdef USE_SSL
+    /* XXX insert timings for ssl */
+#endif
+    int read;			/* number of bytes read */
+    long starttime;		/* start time of connection in seconds since
+				 * Jan. 1, 1970 */
+    long waittime;		/* Between writing request and reading
+				 * response */
+    long ctime;			/* time in ms to connect */
+    long time;			/* time in ms for connection */
+};
+
+#define ap_min(a,b) ((a)<(b))?(a):(b)
+#define ap_max(a,b) ((a)>(b))?(a):(b)
+#define _rnd(x) ((long)(x+0.5))
+
+/* --------------------- GLOBALS ---------------------------- */
+
+int verbosity = 0;		/* no verbosity by default */
+int percentile = 1;		/* Show percentile served */
+int confidence = 1;		/* Show confidence estimator and warnings */
+int posting = 0;		/* GET by default */
+long requests = 1;		/* Number of requests to make */
+int heartbeatres = 100;		/* How often do we say we're alive */
+int concurrency = 1;		/* Number of multiple requests to make */
+int tlimit = 0;			/* time limit in cs */
+int keepalive = 0;		/* try and do keepalive connections */
+char servername[1024];		/* name that server reports */
+char hostname[1024];		/* host name */
+char proxyhost[1024];		/* proxy host name */
+int proxyport = 0;		/* proxy port */
+int isproxy = 0;
+char path[1024];		/* path name */
+char postfile[1024];		/* name of file containing post data */
+char *postdata;			/* *buffer containing data from postfile */
+char *gnuplot;			/* GNUplot file */
+char *csvperc;			/* CSV Percentile file */
+char url[1024];
+char fullurl[1024];
+char colonport[1024];
+int postlen = 0;		/* length of data to be POSTed */
+char content_type[1024];	/* content type to put in POST header */
+char cookie[1024],		/* optional cookie line */
+     auth[1024],		/* optional (basic/uuencoded)
+				 * authentification */
+     hdrs[4096];		/* optional arbitrary headers */
+int port = 80;			/* port number */
+
+int use_html = 0;		/* use html in the report */
+char *tablestring;
+char *trstring;
+char *tdstring;
+
+int doclen = 0;			/* the length the document should be */
+long totalread = 0;		/* total number of bytes read */
+long totalbread = 0;		/* totoal amount of entity body read */
+long totalposted = 0;		/* total number of bytes posted, inc. headers */
+long done = 0;			/* number of requests we have done */
+long doneka = 0;		/* number of keep alive connections done */
+long good = 0, bad = 0;		/* number of good and bad requests */
+long epipe = 0;			/* number of broken pipe writes */
+
+#ifdef USE_SSL
+int ssl = 0;
+SSL_CTX *ctx;
+#endif
+/* store error cases */
+int err_length = 0, err_conn = 0, err_except = 0;
+int err_response = 0;
+
+struct timeval start, endtime;
+
+/* global request (and its length) */
+char request[1024];
+int reqlen;
+
+/* one global throw-away buffer to read stuff into */
+char buffer[8192];
+
+struct connection *con;		/* connection array */
+struct data *stats;		/* date for each request */
+
+fd_set readbits, writebits;	/* bits for select */
+struct sockaddr_in server;	/* server addr structure */
+
+#ifndef BEOS
+#define ab_close(s) close(s)
+#define ab_read(a,b,c) read(a,b,c)
+#define ab_write(a,b,c) write(a,b,c)
+#else
+#define ab_close(s) closesocket(s)
+#define ab_read(a,b,c) recv(a,b,c,0)
+#define ab_write(a,b,c) send(a,b,c,0)
+#endif
+
+static void close_connection(struct connection * c);
+#if (defined(NO_WRITEV) || defined(USE_SSL))
+#define USE_S_WRITE
+static int s_write(struct connection * c, char *buff, int len);
+#endif
+
+/* --------------------------------------------------------- */
+
+/* simple little function to perror and exit */
+
+static void err(char *s)
+{
+    if (errno) {
+	perror(s);
+    }
+    else {
+	fprintf(stderr,"%s", s);
+    }
+    exit(errno ? errno : 1);
+}
+
+/* --------------------------------------------------------- */
+
+/*
+ * write out request to a connection - assumes we can write (small) request
+ * out in one go into our new socket buffer
+ */
+
+static void write_request(struct connection * c)
+{
+/* XXX this sucks - SSL mode and writev() do not mix
+ *     another artificial difference.
+ */
+#ifndef USE_S_WRITE
+    struct iovec out[2];
+    int outcnt = 1;
+#endif
+    int snd = 0;
+    gettimeofday(&c->connect, 0);
+#ifndef USE_S_WRITE
+    out[0].iov_base = request;
+    out[0].iov_len = reqlen;
+
+    if (posting > 0) {
+	out[1].iov_base = postdata;
+	out[1].iov_len = postlen;
+	outcnt = 2;
+	totalposted += (reqlen + postlen);
+    }
+    snd = writev(c->fd, out, outcnt);
+#else
+    snd = s_write(c, request, reqlen);
+    if (posting > 0) {
+        snd += s_write(c, postdata, postlen);
+        totalposted += (reqlen + postlen);
+    }
+#endif
+    if (snd < 0) {
+	bad++; 
+	err_conn++;
+        close_connection(c);
+	return;
+    } else
+    if (snd != (reqlen + postlen)) {
+	/* We cannot cope with this. */
+	fprintf(stderr,"The entire post RQ could not be transmitted to the socket.\n");
+	exit(1);
+    }
+    FD_SET(c->fd, &readbits);
+    FD_CLR(c->fd, &writebits);
+    c->state = STATE_READ;
+    gettimeofday(&c->endwrite, 0);
+}
+
+/* --------------------------------------------------------- */
+
+/*  Do actual data writing */
+
+#ifdef USE_S_WRITE
+static int s_write(struct connection * c, char *buff, int len)
+{
+	int left = len;
+    do {
+	int n;
+#ifdef USE_SSL
+	if (ssl) {
+	    n = SSL_write(c->ssl, buff, left);
+	    if (n < 0) {
+		int e = SSL_get_error(c->ssl, n);
+		/* XXXX probably wrong !!! */
+		if ((e != SSL_ERROR_WANT_READ) && (e != SSL_ERROR_WANT_WRITE))
+		    n = -1;
+		else
+		    n = 0;
+	    };
+	}
+	else
+#endif
+    n = ab_write(c->fd, buff, left);
+
+	if (n < 0) {
+	    switch (errno) {
+	    case EAGAIN:
+		break;
+	    case EPIPE:
+		/* We've tried to write to a broken pipe. */
+		epipe++;
+		close_connection(c);
+		return len-left;
+	    default:
+#ifdef USE_SSL
+		if (ssl) {
+			fprintf(stderr,"Error writing: ");
+	    		ERR_print_errors_fp(stderr);
+		} else
+#endif
+			perror("write");
+		exit(1);
+	    }
+	}
+	else if (n) {
+	    if (verbosity >= 3)
+		printf(" --> write(%x) %d (%d)\n", (unsigned char) buff[0], n, left);
+	    buff += n;
+	    left -= n;
+	};
+    } while (left > 0);
+    
+	return len - left;
+}
+#endif
+
+/* --------------------------------------------------------- */
+
+/* make an fd non blocking */
+
+static void nonblock(int fd)
+{
+    int i = 1;
+#ifdef BEOS
+    setsockopt(fd, SOL_SOCKET, SO_NONBLOCK, &i, sizeof(i));
+#else
+    ioctl(fd, FIONBIO, &i);
+#endif
+}
+
+/* --------------------------------------------------------- */
+
+/* returns the time in ms between two timevals */
+
+static int timedif(struct timeval a, struct timeval b)
+{
+    register int us, s;
+
+    us = a.tv_usec - b.tv_usec;
+    us /= 1000;
+    s = a.tv_sec - b.tv_sec;
+    s *= 1000;
+    return s + us;
+}
+
+/* --------------------------------------------------------- */
+
+/* calculate and output results */
+
+static int compradre(struct data * a, struct data * b)
+{
+    if ((a->ctime) < (b->ctime))
+	return -1;
+    if ((a->ctime) > (b->ctime))
+	return +1;
+    return 0;
+}
+
+static int comprando(struct data * a, struct data * b)
+{
+    if ((a->time) < (b->time))
+	return -1;
+    if ((a->time) > (b->time))
+	return +1;
+    return 0;
+}
+
+static int compri(struct data * a, struct data * b)
+{
+    int p = a->time - a->ctime;
+    int q = b->time - b->ctime;
+    if (p < q)
+	return -1;
+    if (p > q)
+	return +1;
+    return 0;
+}
+
+static int compwait(struct data * a, struct data * b)
+{
+    if ((a->waittime) < (b->waittime))
+	return -1;
+    if ((a->waittime) > (b->waittime))
+	return 1;
+    return 0;
+}
+
+static void output_results(void)
+{
+    long timetaken;
+    long i;
+
+    gettimeofday(&endtime, 0);
+    timetaken = timedif(endtime, start);
+
+    printf("\r                                                                           \r");
+    printf("Server Software:        %s\n", servername);
+    printf("Server Hostname:        %s\n", hostname);
+    printf("Server Port:            %d\n", port);
+    printf("\n");
+    printf("Document Path:          %s\n", path);
+    printf("Document Length:        %d bytes\n", doclen);
+    printf("\n");
+    printf("Concurrency Level:      %d\n", concurrency);
+    printf("Time taken for tests:   %ld.%03ld seconds\n",
+	   timetaken / 1000, timetaken % 1000);
+    printf("Complete requests:      %ld\n", done);
+    printf("Failed requests:        %ld\n", bad);
+    if (bad)
+	printf("   (Connect: %d, Length: %d, Exceptions: %d)\n",
+	       err_conn, err_length, err_except);
+    printf("Broken pipe errors:     %ld\n", epipe);
+    if (err_response)
+	printf("Non-2xx responses:      %d\n", err_response);
+    if (keepalive)
+	printf("Keep-Alive requests:    %ld\n", doneka);
+    printf("Total transferred:      %ld bytes\n", totalread);
+    if (posting > 0)
+	printf("Total POSTed:           %ld\n", totalposted);
+    printf("HTML transferred:       %ld bytes\n", totalbread);
+
+    /* avoid divide by zero */
+    if (timetaken) {
+	printf("Requests per second:    %.2f [#/sec] (mean)\n", 1000 * (float) (done) / timetaken);
+	printf("Time per request:       %.2f [ms] (mean)\n", concurrency * timetaken / (float) done);
+	printf("Time per request:       %.2f [ms] (mean, across all concurrent requests)\n", timetaken / (float) done);
+	printf("Transfer rate:          %.2f [Kbytes/sec] received\n",
+	       (float) (totalread) / timetaken);
+	if (posting > 0) {
+	    printf("                        %.2f kb/s sent\n",
+		   (float) (totalposted) / timetaken);
+	    printf("                        %.2f kb/s total\n",
+		   (float) (totalread + totalposted) / timetaken);
+	}
+    }
+    if (requests>1) {
+	/* work out connection times */
+	double totalcon = 0, total = 0, totald = 0, totalwait = 0;
+	long mincon = 9999999, mintot = 999999, mind = 99999, minwait = 99999;
+	long maxcon = 0, maxtot = 0, maxd = 0, maxwait = 0;
+	long meancon = 0, meantot = 0, meand = 0, meanwait = 0;
+	double sdtot = 0, sdcon = 0, sdd = 0, sdwait = 0;
+
+	for (i = 0; i < requests; i++) {
+	    struct data s = stats[i];
+	    mincon = ap_min(mincon, s.ctime);
+	    mintot = ap_min(mintot, s.time);
+	    mind = ap_min(mintot, s.time - s.ctime);
+	    minwait = ap_min(minwait, s.waittime);
+
+	    maxcon = ap_max(maxcon, s.ctime);
+	    maxtot = ap_max(maxtot, s.time);
+	    maxd = ap_max(maxd, s.time - s.ctime);
+	    maxwait = ap_max(maxwait, s.waittime);
+
+	    totalcon += s.ctime;
+	    total += s.time;
+	    totald += s.time - s.ctime;
+	    totalwait += s.waittime;
+	};
+	totalcon /= requests;
+	total /= requests;
+	totald /= requests;
+	totalwait /= requests;
+
+	for (i = 0; i < requests; i++) {
+	    struct data s = stats[i];
+	    int a;
+	    a = (s.time - total);
+	    sdtot += a * a;
+	    a = (s.ctime - totalcon);
+	    sdcon += a * a;
+	    a = (s.time - s.ctime - totald);
+	    sdd += a * a;
+	    a = (s.waittime - totalwait);
+	    sdwait += a * a;
+	};
+
+	sdtot = (requests > 1) ? sqrt(sdtot / (requests - 1)) : 0;
+	sdcon = (requests > 1) ? sqrt(sdcon / (requests - 1)) : 0;
+	sdd = (requests > 1) ? sqrt(sdd / (requests - 1)) : 0;
+	sdwait = (requests > 1) ? sqrt(sdwait / (requests - 1)) : 0;
+
+	if (gnuplot) {
+	    FILE *out = fopen(gnuplot, "w");
+	    if (!out) {
+		perror("Cannot open gnuplot output file");
+		exit(1);
+	    };
+	    fprintf(out, "starttime\tseconds\tctime\tdtime\tttime\twait\n");
+	    for (i = 0; i < requests; i++) {
+		time_t sttime;
+		char *tmstring;
+		sttime = stats[i].starttime;
+		tmstring = ctime(&sttime);
+		tmstring[strlen(tmstring) - 1] = '\0';	/* ctime returns a
+							 * string with a
+							 * trailing newline */
+		fprintf(out, "%s\t%ld\t%ld\t%ld\t%ld\t%ld\n",
+			tmstring,
+			sttime,
+			stats[i].ctime,
+			stats[i].time - stats[i].ctime,
+			stats[i].time,
+			stats[i].waittime);
+	    }
+	    fclose(out);
+	};
+
+	/*
+	 * XXX: what is better; this hideous cast of the copare function; or
+	 * the four warnings during compile ? dirkx just does not know and
+	 * hates both
+	 */
+	qsort(stats, requests, sizeof(struct data),
+	      (int (*) (const void *, const void *)) compradre);
+	if ((requests > 1) && (requests % 2))
+	    meancon = (stats[requests / 2].ctime + stats[requests / 2 + 1].ctime) / 2;
+	else
+	    meancon = stats[requests / 2].ctime;
+
+	qsort(stats, requests, sizeof(struct data),
+	      (int (*) (const void *, const void *)) compri);
+	if ((requests > 1) && (requests % 2))
+	    meand = (stats[requests / 2].time + stats[requests / 2 + 1].time \
+	    -stats[requests / 2].ctime - stats[requests / 2 + 1].ctime) / 2;
+	else
+	    meand = stats[requests / 2].time - stats[requests / 2].ctime;
+
+	qsort(stats, requests, sizeof(struct data),
+	      (int (*) (const void *, const void *)) compwait);
+	if ((requests > 1) && (requests % 2))
+	    meanwait = (stats[requests / 2].waittime + stats[requests / 2 + 1].waittime) / 2;
+	else
+	    meanwait = stats[requests / 2].waittime;
+
+	qsort(stats, requests, sizeof(struct data),
+	      (int (*) (const void *, const void *)) comprando);
+	if ((requests > 1) && (requests % 2))
+	    meantot = (stats[requests / 2].time + stats[requests / 2 + 1].time) / 2;
+	else
+	    meantot = stats[requests / 2].time;
+
+
+	printf("\nConnnection Times (ms)\n");
+
+	if (confidence) {
+	    printf("              min  mean[+/-sd] median   max\n");
+	    printf("Connect:    %5ld %5ld %6.1f  %5ld %5ld\n",
+		   mincon, _rnd(totalcon), sdcon, meancon, maxcon);
+	    printf("Processing: %5ld %5ld %6.1f  %5ld %5ld\n",
+		   mind, _rnd(totald), sdd, meand, maxd);
+	    printf("Waiting:    %5ld %5ld %6.1f  %5ld %5ld\n",
+		   minwait, _rnd(totalwait), sdwait, meanwait, maxwait);
+	    printf("Total:      %5ld %5ld %6.1f  %5ld %5ld\n", mintot, _rnd(total), sdtot, meantot, maxtot);
+
+#define     SANE(what,avg,mean,sd) \
+            { \
+		double d = avg - mean; \
+		if (d < 0) d = -d; \
+		if (d > 2 * sd ) \
+			printf("ERROR: The median and mean for " what " are more than twice the standard\n" \
+			    "       deviation apart. These results are NOT reliable.\n"); \
+		else if (d > sd ) \
+			printf("WARING: The median and mean for " what " are not within a normal deviation\n" \
+			    "        These results are propably not that reliable.\n"); \
+	    }
+	    SANE("the initial connection time", totalcon, meancon, sdcon);
+	    SANE("the processing time", totald, meand, sdd);
+	    SANE("the waiting time", totalwait, meanwait, sdwait);
+	    SANE("the total time", total, meantot, sdtot);
+	}
+	else {
+	    printf("              min   avg   max\n");
+	    printf("Connect:    %5ld %5ld %5ld\n", mincon, _rnd(totalcon), maxcon);
+	    printf("Processing: %5ld %5ld %5ld\n", mind, _rnd(totald), maxd);
+	    printf("Total:      %5ld %5ld %5ld\n", mintot, _rnd(total), maxtot);
+	};
+
+	/* Sorted on total connect times */
+	if (percentile && (requests > 1)) {
+	    printf("\nPercentage of the requests served within a certain time (ms)\n");
+	    printf("  50%%  %5ld\n", stats[(int) (requests * 0.50)].time);
+	    printf("  66%%  %5ld\n", stats[(int) (requests * 0.66)].time);
+	    printf("  75%%  %5ld\n", stats[(int) (requests * 0.75)].time);
+	    printf("  80%%  %5ld\n", stats[(int) (requests * 0.80)].time);
+	    printf("  90%%  %5ld\n", stats[(int) (requests * 0.90)].time);
+	    printf("  95%%  %5ld\n", stats[(int) (requests * 0.95)].time);
+	    printf("  98%%  %5ld\n", stats[(int) (requests * 0.98)].time);
+	    printf("  99%%  %5ld\n", stats[(int) (requests * 0.99)].time);
+	    printf(" 100%%  %5ld (last request)\n", stats[(int) (requests - 1)].time);
+	    \
+	};
+	if (csvperc) {
+	    FILE *out = fopen(csvperc, "w");
+	    if (!out) {
+		perror("Cannot open CSV output file");
+		exit(1);
+	    };
+	    fprintf(out, "" "Percentage served" "," "Time in ms" "\n");
+	    for (i = 0; i < 100; i++) {
+		double d;
+		if (i == 0)
+		    d = stats[0].time;
+		else if (i == 100)
+		    d = stats[requests - 1].time;
+		else
+		    d = stats[(int) (0.5 + requests * i / 100.0)].time;
+		fprintf(out, "%ld,%f\n", i, d);
+	    }
+	    fclose(out);
+	};
+    }
+}
+
+/* --------------------------------------------------------- */
+
+/* calculate and output results in HTML  */
+
+static void output_html_results(void)
+{
+    long timetaken;
+    long i;
+
+    gettimeofday(&endtime, 0);
+    timetaken = timedif(endtime, start);
+
+    printf("\n\n<table %s>\n", tablestring);
+    printf("<tr %s><th colspan=2 %s>Server Software:</th>"
+	   "<td colspan=2 %s>%s</td></tr>\n",
+	   trstring, tdstring, tdstring, servername);
+    printf("<tr %s><th colspan=2 %s>Server Hostname:</th>"
+	   "<td colspan=2 %s>%s</td></tr>\n",
+	   trstring, tdstring, tdstring, hostname);
+    printf("<tr %s><th colspan=2 %s>Server Port:</th>"
+	   "<td colspan=2 %s>%d</td></tr>\n",
+	   trstring, tdstring, tdstring, port);
+    printf("<tr %s><th colspan=2 %s>Document Path:</th>"
+	   "<td colspan=2 %s>%s</td></tr>\n",
+	   trstring, tdstring, tdstring, path);
+    printf("<tr %s><th colspan=2 %s>Document Length:</th>"
+	   "<td colspan=2 %s>%d bytes</td></tr>\n",
+	   trstring, tdstring, tdstring, doclen);
+    printf("<tr %s><th colspan=2 %s>Concurrency Level:</th>"
+	   "<td colspan=2 %s>%d</td></tr>\n",
+	   trstring, tdstring, tdstring, concurrency);
+    printf("<tr %s><th colspan=2 %s>Time taken for tests:</th>"
+	   "<td colspan=2 %s>%ld.%03ld seconds</td></tr>\n",
+	   trstring, tdstring, tdstring, timetaken / 1000, timetaken % 1000);
+    printf("<tr %s><th colspan=2 %s>Complete requests:</th>"
+	   "<td colspan=2 %s>%ld</td></tr>\n",
+	   trstring, tdstring, tdstring, done);
+    printf("<tr %s><th colspan=2 %s>Failed requests:</th>"
+	   "<td colspan=2 %s>%ld</td></tr>\n",
+	   trstring, tdstring, tdstring, bad);
+    if (bad)
+	printf("<tr %s><td colspan=4 %s >   (Connect: %d, Length: %d, Exceptions: %d)</td></tr>\n",
+	       trstring, tdstring, err_conn, err_length, err_except);
+    if (err_response)
+	printf("<tr %s><th colspan=2 %s>Non-2xx responses:</th>"
+	       "<td colspan=2 %s>%d</td></tr>\n",
+	       trstring, tdstring, tdstring, err_response);
+    if (keepalive)
+	printf("<tr %s><th colspan=2 %s>Keep-Alive requests:</th>"
+	       "<td colspan=2 %s>%ld</td></tr>\n",
+	       trstring, tdstring, tdstring, doneka);
+    printf("<tr %s><th colspan=2 %s>Total transferred:</th>"
+	   "<td colspan=2 %s>%ld bytes</td></tr>\n",
+	   trstring, tdstring, tdstring, totalread);
+    if (posting > 0)
+	printf("<tr %s><th colspan=2 %s>Total POSTed:</th>"
+	       "<td colspan=2 %s>%ld</td></tr>\n",
+	       trstring, tdstring, tdstring, totalposted);
+    printf("<tr %s><th colspan=2 %s>HTML transferred:</th>"
+	   "<td colspan=2 %s>%ld bytes</td></tr>\n",
+	   trstring, tdstring, tdstring, totalbread);
+
+    /* avoid divide by zero */
+    if (timetaken) {
+	printf("<tr %s><th colspan=2 %s>Requests per second:</th>"
+	       "<td colspan=2 %s>%.2f</td></tr>\n",
+	   trstring, tdstring, tdstring, 1000 * (float) (done) / timetaken);
+	printf("<tr %s><th colspan=2 %s>Transfer rate:</th>"
+	       "<td colspan=2 %s>%.2f kb/s received</td></tr>\n",
+	     trstring, tdstring, tdstring, (float) (totalread) / timetaken);
+	if (posting > 0) {
+	    printf("<tr %s><td colspan=2 %s>&nbsp;</td>"
+		   "<td colspan=2 %s>%.2f kb/s sent</td></tr>\n",
+		   trstring, tdstring, tdstring,
+		   (float) (totalposted) / timetaken);
+	    printf("<tr %s><td colspan=2 %s>&nbsp;</td>"
+		   "<td colspan=2 %s>%.2f kb/s total</td></tr>\n",
+		   trstring, tdstring, tdstring,
+		   (float) (totalread + totalposted) / timetaken);
+	}
+    } {
+	/* work out connection times */
+	long totalcon = 0, total = 0;
+	long mincon = 9999999, mintot = 999999;
+	long maxcon = 0, maxtot = 0;
+
+	for (i = 0; i < requests; i++) {
+	    struct data s = stats[i];
+	    mincon = ap_min(mincon, s.ctime);
+	    mintot = ap_min(mintot, s.time);
+	    maxcon = ap_max(maxcon, s.ctime);
+	    maxtot = ap_max(maxtot, s.time);
+	    totalcon += s.ctime;
+	    total += s.time;
+	}
+
+	if (requests > 0) {	/* avoid division by zero (if 0 requests) */
+	    printf("<tr %s><th %s colspan=4>Connnection Times (ms)</th></tr>\n",
+		   trstring, tdstring);
+	    printf("<tr %s><th %s>&nbsp;</th> <th %s>min</th>   <th %s>avg</th>   <th %s>max</th></tr>\n",
+		   trstring, tdstring, tdstring, tdstring, tdstring);
+	    printf("<tr %s><th %s>Connect:</th>"
+		   "<td %s>%5ld</td>"
+		   "<td %s>%5ld</td>"
+		   "<td %s>%5ld</td></tr>\n",
+		   trstring, tdstring, tdstring, mincon, tdstring, totalcon / requests, tdstring, maxcon);
+	    printf("<tr %s><th %s>Processing:</th>"
+		   "<td %s>%5ld</td>"
+		   "<td %s>%5ld</td>"
+		   "<td %s>%5ld</td></tr>\n",
+		   trstring, tdstring, tdstring, mintot - mincon, tdstring,
+		   (total / requests) - (totalcon / requests), tdstring, maxtot - maxcon);
+	    printf("<tr %s><th %s>Total:</th>"
+		   "<td %s>%5ld</td>"
+		   "<td %s>%5ld</td>"
+		   "<td %s>%5ld</td></tr>\n",
+		   trstring, tdstring, tdstring, mintot, tdstring, total / requests, tdstring, maxtot);
+	}
+	printf("</table>\n");
+    }
+}
+
+/* --------------------------------------------------------- */
+
+/* start asnchronous non-blocking connection */
+
+static void start_connect(struct connection * c)
+{
+    const char *what = "none";
+
+    c->read = 0;
+    c->bread = 0;
+    c->keepalive = 0;
+    c->cbx = 0;
+    c->gotheader = 0;
+
+    c->fd = socket(AF_INET, SOCK_STREAM, 0);
+    if (c->fd < 0) {
+	what = "SOCKET";
+	goto _bad;
+    };
+
+#ifdef USE_SSL
+    /*
+     * XXX move nonblocker - so that measnurement needs to have its OWN
+     * state engine OR cannot be compared to http.
+     */
+    if (!ssl)
+#endif
+	nonblock(c->fd);
+
+again:
+    gettimeofday(&c->start, 0);
+    if (connect(c->fd, (struct sockaddr *) & server, sizeof(server)) < 0) {
+	if (errno != EINPROGRESS) {
+	    what = "CONNECT";
+	    goto _bad;
+	};
+    }
+    c->state = STATE_CONNECTING;
+
+#ifdef USE_SSL
+    /* XXX no proper freeing in error's */
+    /*
+     * XXX no proper choise of completely new connection or one which reuses
+     * (older) session keys. Fundamentally unrealistic.
+     */
+    if (ssl) {
+	int e;
+	if (!(c->ssl = SSL_new(ctx))) {
+	    fprintf(stderr, "Failed to set up new SSL context ");
+	    ERR_print_errors_fp(stderr);
+	    goto _bad;
+	};
+	SSL_set_connect_state(c->ssl);
+	if ((e = SSL_set_fd(c->ssl, c->fd)) == -1) {
+	    fprintf(stderr, "SSL fd init failed ");
+	    ERR_print_errors_fp(stderr);
+	    goto _bad;
+	};
+	if ((e = SSL_connect(c->ssl)) == -1) {
+	    fprintf(stderr, "SSL connect failed ");
+	    ERR_print_errors_fp(stderr);
+	    goto _bad;
+	};
+	if (verbosity >= 1)
+	    fprintf(stderr, "SSL connection OK: %s\n", SSL_get_cipher(c->ssl));
+    }
+#endif
+#ifdef USE_SSL
+    if (ssl)
+	nonblock(c->fd);
+#endif
+    FD_SET(c->fd, &writebits);
+    return;
+
+_bad:
+    ab_close(c->fd);
+    err_conn++;
+    bad++;
+    if (bad > 10) {
+	err("\nTest aborted after 10 failures\n\n");
+    }
+    goto again;
+}
+
+/* --------------------------------------------------------- */
+
+/* close down connection and save stats */
+
+static void close_connection(struct connection * c)
+{
+    if (c->read == 0 && c->keepalive) {
+	/*
+	 * server has legitimately shut down an idle keep alive request
+	 */
+	good--;			/* connection never happened */
+    }
+    else {
+	if (good == 1) {
+	    /* first time here */
+	    doclen = c->bread;
+	}
+	else if (c->bread != doclen) {
+	    bad++;
+	    err_length++;
+	}
+	/* save out time */
+	if (done < requests) {
+	    struct data s;
+	    if ((done) && (heartbeatres) && (!(done % heartbeatres))) {
+		fprintf(stderr, "Completed %ld requests\n", done);
+		fflush(stderr);
+	    }
+	    gettimeofday(&c->done, 0);
+	    s.read = c->read;
+	    s.starttime = c->start.tv_sec;
+	    s.ctime = timedif(c->connect, c->start);
+	    s.waittime = timedif(c->beginread, c->endwrite);
+	    s.time = timedif(c->done, c->start);
+	    stats[done++] = s;
+	}
+    }
+
+    ab_close(c->fd);
+    FD_CLR(c->fd, &readbits);
+    FD_CLR(c->fd, &writebits);
+
+    /* connect again */
+    start_connect(c);
+    return;
+}
+
+/* --------------------------------------------------------- */
+
+/* read data from connection */
+
+static void read_connection(struct connection * c)
+{
+    int r;
+    char *part;
+    char respcode[4];		/* 3 digits and null */
+
+    gettimeofday(&c->beginread, 0);
+#ifdef USE_SSL
+    if (ssl) {
+	r = SSL_read(c->ssl, buffer, sizeof(buffer));
+	/* XXX fundamentally worng .. */
+	if (r < 0 && SSL_get_error(c->ssl, r) == SSL_ERROR_WANT_READ) {
+	    r = -1;
+	    errno = EAGAIN;
+	}
+    }
+    else
+#endif
+	r = ab_read(c->fd, buffer, sizeof(buffer));
+
+    if (r == 0 || (r < 0 && errno != EAGAIN)) {
+	good++;
+	close_connection(c);
+	return;
+    }
+    if (r < 0 && errno == EAGAIN)
+	return;
+
+    c->read += r;
+    totalread += r;
+
+    if (!c->gotheader) {
+	char *s;
+	int l = 4;
+	int space = CBUFFSIZE - c->cbx - 1;	/* -1 to allow for 0
+						 * terminator */
+	int tocopy = (space < r) ? space : r;
+#ifndef CHARSET_EBCDIC
+	memcpy(c->cbuff + c->cbx, buffer, tocopy);
+#else				/* CHARSET_EBCDIC */
+	ascii2ebcdic(c->cbuff + c->cbx, buffer, tocopy);
+#endif				/* CHARSET_EBCDIC */
+	c->cbx += tocopy;
+	space -= tocopy;
+	c->cbuff[c->cbx] = 0;	/* terminate for benefit of strstr */
+	if (verbosity >= 4) {
+	    printf("LOG: header received:\n%s\n", c->cbuff);
+	}
+	s = strstr(c->cbuff, "\r\n\r\n");
+	/*
+	 * this next line is so that we talk to NCSA 1.5 which blatantly
+	 * breaks the http specification
+	 */
+	if (!s) {
+	    s = strstr(c->cbuff, "\n\n");
+	    l = 2;
+	}
+	if (!s) {
+	    /* read rest next time */
+	    if (space)
+		return;
+	    else {
+		/*
+		 * header is in invalid or too big - close connection
+		 */
+		ab_close(c->fd);
+		if (bad++ > 10) {
+		    err("\nTest aborted after 10 failures\n\n");
+		}
+		FD_CLR(c->fd, &writebits);
+		start_connect(c);
+	    }
+	}
+	else {
+	    /* have full header */
+	    if (!good) {
+		/*
+		 * this is first time, extract some interesting info
+		 */
+		char *p, *q;
+		int qlen;
+		p = strstr(c->cbuff, "Server:");
+		q = servername; qlen = sizeof(servername);
+		if (p) {
+		    p += 8;
+		    while (*p > 32 && qlen-- > 1) 
+			*q++ = *p++;
+		}
+		*q = 0;
+	    }
+	    /*
+	     * XXX: this parsing isn't even remotely HTTP compliant... but in
+	     * the interest of speed it doesn't totally have to be, it just
+	     * needs to be extended to handle whatever servers folks want to
+	     * test against. -djg
+	     */
+
+	    /* check response code */
+	    part = strstr(c->cbuff, "HTTP");	/* really HTTP/1.x_ */
+            if (part && strlen(part) > strlen("HTTP/1.x_")) {
+                strncpy(respcode, (part + strlen("HTTP/1.x_")), 3);
+                respcode[3] = '\0';
+            }
+            else {
+                strcpy(respcode, "500");
+            }
+
+	    if (respcode[0] != '2') {
+		err_response++;
+		if (verbosity >= 2)
+		    printf("WARNING: Response code not 2xx (%s)\n", respcode);
+	    }
+	    else if (verbosity >= 3) {
+		printf("LOG: Response code = %s\n", respcode);
+	    }
+	    c->gotheader = 1;
+	    *s = 0;		/* terminate at end of header */
+	    if (keepalive &&
+		(strstr(c->cbuff, "Keep-Alive")
+		 || strstr(c->cbuff, "keep-alive"))) {	/* for benefit of MSIIS */
+		char *cl;
+		cl = strstr(c->cbuff, "Content-Length:");
+		/* handle NCSA, which sends Content-length: */
+		if (!cl)
+		    cl = strstr(c->cbuff, "Content-length:");
+		if (cl) {
+		    c->keepalive = 1;
+		    c->length = atoi(cl + 16);
+		}
+	    }
+	    c->bread += c->cbx - (s + l - c->cbuff) + r - tocopy;
+	    totalbread += c->bread;
+	}
+    }
+    else {
+	/* outside header, everything we have read is entity body */
+	c->bread += r;
+	totalbread += r;
+    }
+
+    /*
+     * cater for the case where we're using keepalives and doing HEAD
+     * requests
+     */
+    if (c->keepalive && ((c->bread >= c->length) || (posting < 0))) {
+	/* finished a keep-alive connection */
+	good++;
+	doneka++;
+	/* save out time */
+	if (good == 1) {
+	    /* first time here */
+	    doclen = c->bread;
+	}
+	else if (c->bread != doclen) {
+	    bad++;
+	    err_length++;
+	}
+	if (done < requests) {
+	    struct data s;
+	    if ((done) && (heartbeatres) && (!(done % heartbeatres))) {
+		fprintf(stderr, "Completed %ld requests\n", done);
+		fflush(stderr);
+	    }
+	    gettimeofday(&c->done, 0);
+	    s.read = c->read;
+	    s.starttime = c->start.tv_sec;
+	    s.ctime = timedif(c->connect, c->start);
+	    s.waittime = timedif(c->beginread, c->endwrite);
+	    s.time = timedif(c->done, c->start);
+	    stats[done++] = s;
+	}
+	c->keepalive = 0;
+	c->length = 0;
+	c->gotheader = 0;
+	c->cbx = 0;
+	c->read = c->bread = 0;
+	write_request(c);
+	c->start = c->connect;	/* zero connect time with keep-alive */
+    }
+}
+
+/* --------------------------------------------------------- */
+
+/* run the tests */
+
+static void test(void)
+{
+    struct timeval timeout, now;
+    fd_set sel_read, sel_except, sel_write;
+    long i;
+    int connectport;
+    char * connecthost;
+    char * url_on_request;
+
+    /* There are four hostname's involved:
+     * The 'hostname' from the URL, the
+     * hostname of the proxy, the value which
+     * is to go into the Host: header and
+     * the hostname we connect to over TCP.
+     */
+    if (isproxy) {
+	/* Connect to proxyhost:proxyport
+         * And set Host: to the hostname and
+	 * if not default :port of the URL.
+	 * See RFC2616 - $14.23. But then in
+	 * $5.2.1 it says that the Host: field
+	 * when passed on MUST be ignored. So	
+	 * perhaps we should NOT send any
+	 * when we are proxying.
+	 */
+	connecthost  = proxyhost;
+	connectport = proxyport;
+    	url_on_request = fullurl;
+    }
+    else {
+	/* When there is no proxy: 
+	 * use the hostname to connect to,
+	 * use the hostname in the Host:
+	 * header; and do not quote a full
+	 * URL in the GET/POST line.
+	 */
+	connecthost  = hostname;
+	connectport = port;
+    	url_on_request = path;
+    }
+    
+    if (!use_html) {
+	printf("Benchmarking %s (be patient)%s",
+	       hostname, (heartbeatres ? "\n" : "..."));
+	fflush(stdout);
+    }
+    {
+	/* get server information */
+	struct hostent *he;
+	he = gethostbyname(connecthost);
+	if (!he) {
+	    char theerror[1024];
+	    ap_snprintf(theerror, sizeof(theerror),
+                        "Bad hostname: %s\n", connecthost);
+	    err(theerror);
+	}
+	server.sin_family = he->h_addrtype;
+	server.sin_port = htons(connectport);
+	server.sin_addr.s_addr = ((unsigned long *) (he->h_addr_list[0]))[0];
+    }
+
+    con = malloc(concurrency * sizeof(struct connection));
+    memset(con, 0, concurrency * sizeof(struct connection));
+
+    stats = malloc(requests * sizeof(struct data));
+
+    FD_ZERO(&readbits);
+    FD_ZERO(&writebits);
+
+    /* setup request */
+    if (posting <= 0) {
+	ap_snprintf(request, sizeof(request), 
+                    "%s %s HTTP/1.0\r\n"
+                    "User-Agent: ApacheBench/%s\r\n"
+                    "%s" "%s" "%s"
+                    "Host: %s%s\r\n"
+                    "Accept: */*\r\n"
+                    "%s" "\r\n",
+                    (posting == 0) ? "GET" : "HEAD",
+                    url_on_request,
+                    VERSION,
+                    keepalive ? "Connection: Keep-Alive\r\n" : "",
+                    cookie, auth, 
+                    hostname,colonport, hdrs);
+    }
+    else {
+        ap_snprintf(request, sizeof(request),
+                    "POST %s HTTP/1.0\r\n"
+                    "User-Agent: ApacheBench/%s\r\n"
+                    "%s" "%s" "%s"
+                    "Host: %s%s\r\n"
+                    "Accept: */*\r\n"
+                    "Content-length: %d\r\n"
+                    "Content-type: %s\r\n"
+                    "%s"
+                    "\r\n",
+                    url_on_request,
+                    VERSION,
+                    keepalive ? "Connection: Keep-Alive\r\n" : "",
+                    cookie, auth,
+                    hostname, colonport, postlen,
+                    (content_type[0]) ? content_type : "text/plain", hdrs);
+    }
+
+    if (verbosity >= 2)
+	printf("INFO: POST header == \n---\n%s\n---\n", request);
+
+    reqlen = strlen(request);
+
+#ifdef CHARSET_EBCDIC
+    ebcdic2ascii(request, request, reqlen);
+#endif				/* CHARSET_EBCDIC */
+
+    /* ok - lets start */
+    gettimeofday(&start, 0);
+
+    /* initialise lots of requests */
+    for (i = 0; i < concurrency; i++)
+	start_connect(&con[i]);
+
+    while (done < requests) {
+	int n;
+	/* setup bit arrays */
+	memcpy(&sel_except, &readbits, sizeof(readbits));
+	memcpy(&sel_read, &readbits, sizeof(readbits));
+	memcpy(&sel_write, &writebits, sizeof(readbits));
+
+	/* check for time limit expiry */
+	gettimeofday(&now, 0);
+	if (tlimit && timedif(now, start) >= (tlimit * 1000)) {
+	    requests = done;	/* so stats are correct */
+	}
+	/* Timeout of 30 seconds. */
+	timeout.tv_sec = 120;
+	timeout.tv_usec = 0;
+	n = ap_select(FD_SETSIZE, &sel_read, &sel_write, &sel_except, &timeout);
+	if (!n) {
+	    err("\nServer timed out\n\n");
+	}
+	if (n < 1)
+	    err("select");
+
+	for (i = 0; i < concurrency; i++) {
+	    int s = con[i].fd;
+	    if (FD_ISSET(s, &sel_except)) {
+		bad++;
+		err_except++;
+		start_connect(&con[i]);
+		continue;
+	    }
+	    if (FD_ISSET(s, &sel_read))
+		read_connection(&con[i]);
+	    if (FD_ISSET(s, &sel_write))
+		write_request(&con[i]);
+	}
+    }
+
+    if (heartbeatres)
+	fprintf(stderr, "Finished %ld requests\n", done);
+    else
+	printf("..done\n");
+
+    if (use_html)
+	output_html_results();
+    else
+	output_results();
+}
+
+/* ------------------------------------------------------- */
+
+/* display copyright information */
+static void copyright(void)
+{
+    if (!use_html) {
+	printf("This is ApacheBench, Version %s\n", VERSION " <$Revision: 1.1 $> apache-1.3");
+	printf("Copyright (c) 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/\n");
+	printf("Copyright (c) 1998-2002 The Apache Software Foundation, http://www.apache.org/\n");
+	printf("\n");
+    }
+    else {
+	printf("<p>\n");
+	printf(" This is ApacheBench, Version %s <i>&lt;%s&gt;</i> apache-1.3<br>\n", VERSION, "$Revision: 1.1 $");
+	printf(" Copyright (c) 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/<br>\n");
+	printf(" Copyright (c) 1998-2002 The Apache Software Foundation, http://www.apache.org/<br>\n");
+	printf("</p>\n<p>\n");
+    }
+}
+
+/* display usage information */
+static void usage(char *progname)
+{
+    fprintf(stderr, "Usage: %s [options] [http"
+#ifdef USE_SSL
+	    "[s]"
+#endif
+	    "://]hostname[:port]/path\n", progname);
+    fprintf(stderr, "Options are:\n");
+    fprintf(stderr, "    -n requests     Number of requests to perform\n");
+    fprintf(stderr, "    -c concurrency  Number of multiple requests to make\n");
+    fprintf(stderr, "    -t timelimit    Seconds to max. wait for responses\n");
+    fprintf(stderr, "    -p postfile     File containg data to POST\n");
+    fprintf(stderr, "    -T content-type Content-type header for POSTing\n");
+    fprintf(stderr, "    -v verbosity    How much troubleshooting info to print\n");
+    fprintf(stderr, "    -w              Print out results in HTML tables\n");
+    fprintf(stderr, "    -i              Use HEAD instead of GET\n");
+    fprintf(stderr, "    -x attributes   String to insert as table attributes\n");
+    fprintf(stderr, "    -y attributes   String to insert as tr attributes\n");
+    fprintf(stderr, "    -z attributes   String to insert as td or th attributes\n");
+    fprintf(stderr, "    -C attribute    Add cookie, eg. 'Apache=1234' (repeatable)\n");
+    fprintf(stderr, "    -H attribute    Add Arbitrary header line, eg. 'Accept-Encoding: zop'\n");
+    fprintf(stderr, "                    Inserted after all normal header lines. (repeatable)\n");
+    fprintf(stderr, "    -A attribute    Add Basic WWW Authentication, the attributes\n");
+    fprintf(stderr, "                    are a colon separated username and password.\n");
+    fprintf(stderr, "    -P attribute    Add Basic Proxy Authentication, the attributes\n");
+    fprintf(stderr, "                    are a colon separated username and password.\n");
+    fprintf(stderr, "    -X proxy:port   Proxyserver and port number to use\n");
+    fprintf(stderr, "    -V              Print version number and exit\n");
+    fprintf(stderr, "    -k              Use HTTP KeepAlive feature\n");
+    fprintf(stderr, "    -d              Do not show percentiles served table.\n");
+    fprintf(stderr, "    -S              Do not show confidence estimators and warnings.\n");
+    fprintf(stderr, "    -g filename     Output collected data to gnuplot format file.\n");
+    fprintf(stderr, "    -e filename     Output CSV file with percentages served\n");
+#ifdef USE_SSL
+    fprintf(stderr, "    -s              Use httpS instead of HTTP (SSL)\n");
+#endif
+    fprintf(stderr, "    -h              Display usage information (this message)\n");
+    exit(EINVAL);
+}
+
+/* ------------------------------------------------------- */
+
+/* split URL into parts */
+
+static int parse_url(char * purl)
+{
+    char *cp;
+    char *h;
+    char *p = NULL;
+
+    if (strlen(purl) > 7 && strncmp(purl, "http://", 7) == 0)
+	purl += 7;
+    else
+#ifdef USE_SSL
+    if (strlen(purl) > 8 && strncmp(purl, "https://", 8) == 0) {
+	purl += 8;
+	ssl = 1;
+	port = 443;
+    }
+#else
+    if (strlen(purl) > 8 && strncmp(purl, "https://", 8) == 0) {
+	fprintf(stderr, "SSL not compiled in; no https support\n");
+	exit(1);
+    }
+#endif
+
+    h = purl;
+    if ((cp = strchr(purl, ':')) != NULL) {
+	*cp++ = '\0';
+	p = cp;
+	purl = cp;
+    }
+    if ((cp = strchr(purl, '/')) == NULL)
+	return 1;
+    strcpy(path, cp);
+    *cp = '\0';
+    strcpy(hostname, h);
+    if (p != NULL)
+	port = atoi(p);
+
+    if ((
+#ifdef USE_SSL
+	(ssl != 0) && (port != 443)) || ((ssl == 0) && 
+#endif
+	(port != 80))) 
+   {
+	ap_snprintf(colonport,sizeof(colonport),":%d",port);
+   } else {
+	colonport[0] = '\0';
+   }
+   return 0;
+}
+
+/* ------------------------------------------------------- */
+
+/* read data to POST from file, save contents and length */
+
+static int open_postfile(char *pfile)
+{
+    int postfd, status;
+    struct stat postfilestat;
+
+    if ((postfd = open(pfile, O_RDONLY)) == -1) {
+	printf("Invalid postfile name (%s)\n", pfile);
+	return errno;
+    }
+    if ((status = fstat(postfd, &postfilestat)) == -1) {
+	perror("Can\'t stat postfile\n");
+	return status;
+    }
+    postdata = malloc(postfilestat.st_size);
+    if (!postdata) {
+	printf("Can\'t alloc postfile buffer\n");
+	return ENOMEM;
+    }
+    if (read(postfd, postdata, postfilestat.st_size) != postfilestat.st_size) {
+	printf("error reading postfilen");
+	return EIO;
+    }
+    postlen = postfilestat.st_size;
+    return 0;
+}
+
+/* ------------------------------------------------------- */
+
+extern char *optarg;
+extern int optind, opterr, optopt;
+
+/* sort out command-line args and call test */
+int main(int argc, char **argv)
+{
+    int c, r, l;
+    char tmp[1024];
+    /* table defaults  */
+    tablestring = "";
+    trstring = "";
+    tdstring = "bgcolor=white";
+    cookie[0] = '\0';
+    auth[0] = '\0';
+    hdrs[0] = '\0';
+    proxyhost[0] = '\0';
+    optind = 1;
+    while ((c = getopt(argc, argv, "n:c:t:T:p:v:kVhwix:y:z:C:H:P:A:g:X:de:Sq"
+#ifdef USE_SSL
+		       "s"
+#endif
+		       )) > 0) {
+	switch (c) {
+#ifdef USE_SSL
+	case 's':
+	    ssl = 1;
+	    break;
+#endif
+	case 'n':
+	    requests = atoi(optarg);
+	    if (!requests) {
+		err("Invalid number of requests\n");
+	    }
+	    break;
+	case 'q':
+	    heartbeatres = 0;
+	    break;
+	case 'k':
+	    keepalive = 1;
+	    break;
+	case 'c':
+	    concurrency = atoi(optarg);
+	    break;
+	case 'g':
+	    gnuplot = strdup(optarg);
+	    break;
+	case 'd':
+	    percentile = 0;
+	    break;
+	case 'e':
+	    csvperc = strdup(optarg);
+	    break;
+	case 'S':
+	    confidence = 0;
+	    break;
+	case 'i':
+	    if (posting == 1)
+		err("Cannot mix POST and HEAD");
+
+	    posting = -1;
+	    break;
+	case 'p':
+	    if (posting != 0)
+		err("Cannot mix POST and HEAD");
+
+	    if (0 == (r = open_postfile(optarg))) {
+		posting = 1;
+	    }
+	    else if (postdata) {
+		exit(r);
+	    }
+	    break;
+	case 'v':
+	    verbosity = atoi(optarg);
+	    break;
+	case 't':
+	    tlimit = atoi(optarg);
+	    requests = MAX_REQUESTS;	/* need to size data array on
+					 * something */
+	    break;
+	case 'T':
+	    strcpy(content_type, optarg);
+	    break;
+	case 'C':
+	    strncat(cookie, "Cookie: ", sizeof(cookie)-strlen(cookie)-1);
+	    strncat(cookie, optarg, sizeof(cookie)-strlen(cookie)-1);
+	    strncat(cookie, "\r\n", sizeof(cookie)-strlen(cookie)-1);
+	    break;
+	case 'A':
+	    /*
+	     * assume username passwd already to be in colon separated form.
+	     * Ready to be uu-encoded.
+	     */
+	    while (isspace((int)*optarg))
+		optarg++;
+            if (ap_base64encode_len(strlen(optarg)) > sizeof(tmp)) {
+                fprintf(stderr, "%s: Authentication credentials too long\n",
+                        argv[0]);
+                exit(1);
+            }
+            l = ap_base64encode(tmp, optarg, strlen(optarg));
+	    tmp[l] = '\0';
+
+	    strncat(auth, "Authorization: Basic ", sizeof(auth)-strlen(auth)-1);
+	    strncat(auth, tmp, sizeof(auth)-strlen(auth)-1);
+	    strncat(auth, "\r\n", sizeof(auth)-strlen(auth)-1);
+	    break;
+	case 'P':
+	    /*
+	     * assume username passwd already to be in colon separated form.
+	     */
+	    while (isspace((int)*optarg))
+		optarg++;
+            if (ap_base64encode_len(strlen(optarg)) > sizeof(tmp)) {
+                fprintf(stderr, "%s: Proxy credentials too long\n", argv[0]);
+                exit(1);
+            }
+	    l = ap_base64encode(tmp, optarg, strlen(optarg));
+	    tmp[l] = '\0';
+
+	    strncat(auth, "Proxy-Authorization: Basic ", sizeof(auth)-strlen(auth)-1);
+	    strncat(auth, tmp, sizeof(auth)-strlen(auth)-1);
+	    strncat(auth, "\r\n", sizeof(auth)-strlen(auth)-1);
+	    break;
+	case 'X':
+	    {
+		char *p;
+		/*
+		 * assume proxy-name[:port]
+		 */
+		if ((p = strchr(optarg, ':'))) {
+		    *p = '\0';
+		    p++;
+		    proxyport = atoi(p);
+		};
+		strcpy(proxyhost, optarg);
+		isproxy = 1;
+	    }
+	    break;
+	case 'H':
+	    strncat(hdrs, optarg, sizeof(hdrs)-strlen(hdrs)-1);
+	    strncat(hdrs, "\r\n", sizeof(hdrs)-strlen(hdrs)-1);
+	    break;
+	case 'V':
+	    copyright();
+	    exit(0);
+	    break;
+	case 'w':
+	    use_html = 1;
+	    break;
+	    /*
+	     * if any of the following three are used, turn on html output
+	     * automatically
+	     */
+	case 'x':
+	    use_html = 1;
+	    tablestring = optarg;
+	    break;
+	case 'y':
+	    use_html = 1;
+	    trstring = optarg;
+	    break;
+	case 'z':
+	    use_html = 1;
+	    tdstring = optarg;
+	    break;
+	case 'h':
+	    usage(argv[0]);
+	    break;
+	default:
+	    fprintf(stderr, "%s: invalid option `%c'\n", argv[0], c);
+	    usage(argv[0]);
+	    break;
+	}
+    }
+    if (optind != argc - 1) {
+	fprintf(stderr, "%s: wrong number of arguments\n", argv[0]);
+	usage(argv[0]);
+    }
+    strcpy(url, argv[optind++]);
+    strcpy(fullurl, url);
+    if (parse_url(url)) {
+	fprintf(stderr, "%s: invalid URL\n", argv[0]);
+	usage(argv[0]);
+    }
+
+    if ((heartbeatres) && (requests > 150)) {
+	heartbeatres = requests / 10;	/* Print a line every 10% of requests */
+	if (heartbeatres < 100)
+	    heartbeatres = 100;	/* but never more often than once every 100
+				 * connections. */
+    }
+    else
+	/* if there are less than 150 requests; do not show
+	 * the little tick/tock dots.
+	 */
+	heartbeatres = 0;
+
+#ifdef USE_SSL
+    SSL_library_init();
+    if (!(ctx = SSL_CTX_new(SSLv2_client_method()))) {
+	fprintf(stderr, "Could not init SSL CTX: ");
+	ERR_print_errors_fp(stderr);
+	exit(1);
+    }
+#endif
+    signal(SIGPIPE, SIG_IGN);           /* Ignore writes to connections that
+					 * have been closed at the other end.
+					 * These writes are dealt with in the
+					 * s_write() function. */
+
+    copyright();
+    test();
+
+    exit(0);
+}
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/apxs.pl apache_1.3.33/src/support/apxs.pl
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/apxs.pl	Fri Feb 20 23:02:24 2004
+++ apache_1.3.33/src/support/apxs.pl	Mon Jul 18 15:22:25 2005
@@ -182,6 +182,7 @@
     }
 }
 
+if (0) {
 ##
 ##  Initial DSO support check
 ##
@@ -198,6 +199,7 @@
     exit(1);
 }
 }
+}
 
 ##
 ##  Operation
@@ -391,7 +393,7 @@
         }
     }
     $cmd .= $opt;
-    $cmd .= " $CFG_LIBS_SHLIB";
+#    $cmd .= " $CFG_LIBS_SHLIB";
     push(@cmds, $cmd);
 
     #   execute the commands
@@ -469,7 +471,7 @@
             $filename = "mod_${name}.c";
         }
         my $dir = $CFG_LIBEXECDIR;
-        $dir =~ s|^$CFG_PREFIX/?||;
+        $dir =~ s|^$CFG_SYSCONFDIR/?||;
         $dir =~ s|(.)$|$1/|;
         push(@lmd, sprintf("LoadModule %-18s %s", "${name}_module", "$dir$t"));
         push(@amd, sprintf("AddModule %s", $filename));
@@ -752,5 +754,11 @@
     NULL,                  /* child_init                          */
     NULL,                  /* child_exit                          */
     NULL                   /* [#0] post read-request              */
+#ifdef EAPI
+   ,NULL,                  /* EAPI: add_module                    */
+    NULL,                  /* EAPI: remove_module                 */
+    NULL,                  /* EAPI: rewrite_command               */
+    NULL                   /* EAPI: new_connection                */
+#endif
 };
 
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/apxs.pl.orig apache_1.3.33/src/support/apxs.pl.orig
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/apxs.pl.orig	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/support/apxs.pl.orig	Mon Jul 18 15:22:19 2005
@@ -0,0 +1,758 @@
+#!/usr/local/bin/perl
+#
+# Copyright 1999-2004 The Apache Software Foundation
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+##
+##  apxs -- APache eXtenSion tool
+##  Written by Ralf S. Engelschall <rse@apache.org>
+##
+
+require 5.003;
+use strict;
+package apxs;
+
+##
+##  Configuration
+##
+
+my $CFG_TARGET        = q(@TARGET@);            # substituted via Makefile.tmpl 
+my $CFG_CC            = q(@CC@);                # substituted via Makefile.tmpl
+my $CFG_CFLAGS        = q(@CFLAGS@);            # substituted via Makefile.tmpl
+my $CFG_CFLAGS_SHLIB  = q(@CFLAGS_SHLIB@);      # substituted via Makefile.tmpl
+my $CFG_LD_SHLIB      = q(@LD_SHLIB@);          # substituted via Makefile.tmpl
+my $CFG_LDFLAGS_SHLIB = q(@LDFLAGS_MOD_SHLIB@); # substituted via Makefile.tmpl 
+my $CFG_LIBS_SHLIB    = q(@LIBS_SHLIB@);        # substituted via Makefile.tmpl 
+my $CFG_PREFIX        = q(@prefix@);            # substituted via APACI install
+my $CFG_SBINDIR       = q(@sbindir@);           # substituted via APACI install
+my $CFG_INCLUDEDIR    = q(@includedir@);        # substituted via APACI install
+my $CFG_LIBEXECDIR    = q(@libexecdir@);        # substituted via APACI install
+my $CFG_SYSCONFDIR    = q(@sysconfdir@);        # substituted via APACI install
+
+##
+##  Cleanup the above stuff
+##
+$CFG_CFLAGS =~ s|^\s+||;
+$CFG_CFLAGS =~ s|\s+$||;
+$CFG_CFLAGS =~ s|\s+`.+apaci`||;
+
+##
+##  parse argument line
+##
+
+#   defaults for parameters
+my $opt_n = '';
+my $opt_g = '';
+my $opt_c = 0;
+my $opt_o = '';
+my @opt_D = ();
+my @opt_I = ();
+my @opt_L = ();
+my @opt_l = ();
+my @opt_W = ();
+my @opt_S = ();
+my $opt_e = 0;
+my $opt_i = 0;
+my $opt_a = 0;
+my $opt_A = 0;
+my $opt_q = 0;
+
+#   default for DSO file extension 
+my $dso_ext = "so";
+if ($^O eq "cygwin") {
+    $dso_ext = "dll";
+}
+
+#   this subroutine is derived from Perl's getopts.pl with the enhancement of
+#   the "+" metacharater at the format string to allow a list to be build by
+#   subsequent occurance of the same option.
+sub Getopts {
+    my ($argumentative, @ARGV) = @_;
+    my (@args, $first, $rest, $pos);
+    my ($errs) = 0;
+    local ($_);
+    local ($[) = 0;
+
+    @args = split( / */, $argumentative);
+    while(@ARGV && ($_ = $ARGV[0]) =~ /^-(.)(.*)/) {
+        ($first, $rest) = ($1,$2);
+        if ($_ =~ m|^--$|) {
+            shift(@ARGV);
+            last;
+        }
+        $pos = index($argumentative,$first);
+        if ($pos >= $[) {
+            if ($args[$pos+1] eq ':') {
+                shift(@ARGV);
+                if ($rest eq '') {
+                    unless (@ARGV) {
+                        print STDERR "apxs:Error: Incomplete option: $first (needs an argument)\n";
+                        ++$errs;
+                    }
+                    $rest = shift(@ARGV);
+                }
+                eval "\$opt_$first = \$rest;";
+            }
+            elsif ($args[$pos+1] eq '+') {
+                shift(@ARGV);
+                if ($rest eq '') {
+                    unless (@ARGV) {
+                        print STDERR "apxs:Error: Incomplete option: $first (needs an argument)\n";
+                        ++$errs;
+                    }
+                    $rest = shift(@ARGV);
+                }
+                eval "push(\@opt_$first, \$rest);";
+            }
+            else {
+                eval "\$opt_$first = 1";
+                if ($rest eq '') {
+                    shift(@ARGV);
+                }
+                else {
+                    $ARGV[0] = "-$rest";
+                }
+            }
+        }
+        else {
+            print STDERR "apxs:Error: Unknown option: $first\n";
+            ++$errs;
+            if ($rest ne '') {
+                $ARGV[0] = "-$rest";
+            }
+            else {
+                shift(@ARGV);
+            }
+        }
+    }
+    return ($errs == 0, @ARGV);
+}
+
+sub usage {
+    print STDERR "Usage: apxs -g [-S <var>=<val>] -n <modname>\n";
+    print STDERR "       apxs -q [-S <var>=<val>] <query> ...\n";
+    print STDERR "       apxs -c [-S <var>=<val>] [-o <dsofile>] [-D <name>[=<value>]]\n";
+    print STDERR "               [-I <incdir>] [-L <libdir>] [-l <libname>] [-Wc,<flags>]\n";
+    print STDERR "               [-Wl,<flags>] <files> ...\n";
+    print STDERR "       apxs -i [-S <var>=<val>] [-a] [-A] [-n <modname>] <dsofile> ...\n";
+    print STDERR "       apxs -e [-S <var>=<val>] [-a] [-A] [-n <modname>] <dsofile> ...\n";
+    exit(1);
+}
+
+#   option handling
+my $rc;
+($rc, @ARGV) = &Getopts("qn:gco:I+D+L+l+W+S+eiaA", @ARGV);
+&usage if ($rc == 0);
+&usage if ($#ARGV == -1 and not $opt_g);
+&usage if (not $opt_q and not ($opt_g and $opt_n) and not $opt_i and not $opt_c and not $opt_e);
+
+#   argument handling
+my @args = @ARGV;
+my $name = 'unknown';
+$name = $opt_n if ($opt_n ne '');
+
+#   overriding of configuration variables
+if (@opt_S) {
+    my ($opt_S);
+    foreach $opt_S (@opt_S) {
+        if ($opt_S =~ m/^([^=]+)=(.*)$/) {
+            my ($var, $val) = ($1, $2);
+            my $oldval = eval "\$CFG_$var";
+            unless ($var and $oldval) {
+                print STDERR "apxs:Error: no config variable $var\n";
+                &usage;
+            }
+	    $val=~s/"/\\"/g;
+            eval "\$CFG_${var}=\"${val}\"";
+        } else {
+            print STDERR "apxs:Error: malformatted -S option\n";
+            &usage;
+        }       
+    }
+}
+
+if (0) {
+##
+##  Initial DSO support check
+##
+if ($^O ne "MSWin32") {
+if (not -x "$CFG_SBINDIR/$CFG_TARGET") {
+    print STDERR "apxs:Error: $CFG_SBINDIR/$CFG_TARGET not found or not executable\n";
+    exit(1);
+}
+if (not grep(/mod_so/, `$CFG_SBINDIR/$CFG_TARGET -l`)) {
+    print STDERR "apxs:Error: Sorry, no DSO support for Apache available\n";
+    print STDERR "apxs:Error: under your platform. Make sure the Apache\n";
+    print STDERR "apxs:Error: module mod_so is compiled into your server\n";
+    print STDERR "apxs:Error: binary `$CFG_SBINDIR/$CFG_TARGET'.\n";
+    exit(1);
+}
+}
+}
+
+##
+##  Operation
+##
+
+#   helper function for executing a list of
+#   system command with return code checks
+sub execute_cmds {
+    my (@cmds) = @_;
+    my ($cmd, $rc);
+
+    foreach $cmd (@cmds) {
+        print STDERR "$cmd\n";
+        $rc = system("$cmd");
+        if ($rc != 0) {
+            printf(STDERR "apxs:Break: Command failed with rc=%d\n", $rc >> 8);
+            exit(1);
+        }
+    }
+}
+
+if ($opt_g) {
+    ##
+    ##  SAMPLE MODULE SOURCE GENERATION
+    ##
+
+    if (-d $name) {
+        print STDERR "apxs:Error: Directory `$name' already exists. Remove it first\n";
+        exit(1);
+    }
+
+    my $data = join('', <DATA>);
+    $data =~ s|%NAME%|$name|sg;
+    $data =~ s|%TARGET%|$CFG_TARGET|sg;
+    $data =~ s|%DSO_EXT%|$dso_ext|sg;
+
+    my ($mkf, $src) = ($data =~ m|^(.+)-=#=-\n(.+)|s);
+
+    print STDERR "Creating [DIR]  $name\n";
+    system("mkdir $name");
+    print STDERR "Creating [FILE] $name/Makefile\n";
+    open(FP, ">${name}/Makefile") || die;
+    print FP $mkf;
+    close(FP);
+    print STDERR "Creating [FILE] $name/mod_$name.c\n";
+    open(FP, ">${name}/mod_${name}.c") || die;
+    print FP $src;
+    close(FP);
+
+    exit(0);
+}
+
+if ($opt_q) {
+    ##
+    ##  QUERY INFORMATION 
+    ##
+
+    my $result = '';
+    my $arg;
+    foreach $arg (@args) {
+        my $ok = 0;
+        my $name;
+        foreach $name (qw(
+            TARGET CC CFLAGS CFLAGS_SHLIB LD_SHLIB LDFLAGS_SHLIB LIBS_SHLIB
+            PREFIX SBINDIR INCLUDEDIR LIBEXECDIR SYSCONFDIR
+        )) {
+            if ($arg eq $name or $arg eq lc($name)) {
+                my $val = eval "\$CFG_$name";
+                $result .= "${val}##";
+                $ok = 1;
+            }
+        }
+        if (not $ok) {
+            printf(STDERR "apxs:Error: Invalid query string `%s'\n", $arg);
+            exit(1);
+        }
+    }
+    $result =~ s|##$||;
+    $result =~ s|##| |g;
+    print $result;
+}
+
+if ($opt_c) {
+    ##
+    ##  DSO COMPILATION
+    ##
+
+    #   split files into sources and objects
+    my @srcs = ();
+    my @objs = ();
+    my $f;
+    foreach $f (@args) {
+        if ($f =~ m|\.c$|) {
+            push(@srcs, $f);
+        }
+        else {
+            push(@objs, $f);
+        }
+    }
+
+    #   determine output file
+    my $dso_file;
+    if ($opt_o eq '') {
+        if ($#srcs > -1) {
+            $dso_file = $srcs[0];
+            $dso_file =~ s|\.[^.]+$|.$dso_ext|;
+        }
+        elsif ($#objs > -1) {
+            $dso_file = $objs[0];
+            $dso_file =~ s|\.[^.]+$|.$dso_ext|;
+        }
+        else {
+            $dso_file = "mod_unknown.$dso_ext";
+        }
+    }
+    else {
+        $dso_file = $opt_o;
+    }
+
+    #   create compilation commands
+    my @cmds = ();
+    my $opt = '';
+    my ($opt_Wc, $opt_I, $opt_D);
+    foreach $opt_Wc (@opt_W) {
+        $opt .= "$1 " if ($opt_Wc =~ m|^\s*c,(.*)$|);
+    }
+    foreach $opt_I (@opt_I) {
+        $opt_I = '"' . $opt_I . '"' if ($opt_I =~ m|\s|);
+        $opt .= "-I$opt_I ";
+    }
+    foreach $opt_D (@opt_D) {
+        $opt .= "-D$opt_D ";
+    }
+    my $cflags = "$CFG_CFLAGS $CFG_CFLAGS_SHLIB";
+    if ($^O eq "MSWin32") {
+        my $d = $dso_file;
+        $d =~ s|\.so$||;
+        $d = '"' . $d . '"' if ($d =~ m|\s|);
+        $opt .= "-Fd$d ";
+    }
+    my $s;
+    foreach $s (@srcs) {
+        my $o = $s;
+        $s = '"' . $s . '"' if ($s =~ m|\s|);
+        if ($^O ne "MSWin32") {
+            $o =~ s|\.c$|.o|;
+            $o =~ s|^.*/||;
+            $o = '"' . $o . '"' if ($o =~ m|\s|);
+            push(@cmds, "$CFG_CC $cflags -I$CFG_INCLUDEDIR $opt -c $s");
+        } else {
+            $o =~ s|\.c$|.obj|;
+            $o =~ s|^.*/||;
+            $o = '"' . $o . '"' if ($o =~ m|\s|);
+            push(@cmds, "$CFG_CC $cflags -I\"$CFG_INCLUDEDIR\" $opt -c $s -Fo$o");
+        }
+        unshift(@objs, $o);
+    }
+
+    #   create link command
+    my $cmd;
+    if ($^O ne "MSWin32") {
+        $cmd = "$CFG_LD_SHLIB $CFG_LDFLAGS_SHLIB -o $dso_file";
+    } else {
+        $cmd = "$CFG_LD_SHLIB $CFG_LDFLAGS_SHLIB -out:\"$dso_file\"";
+    }
+    my $o;
+    foreach $o (@objs) {
+        $cmd .= " $o";
+    }
+    $opt = '';
+    my ($opt_Wl, $opt_L, $opt_l);
+    foreach $opt_Wl (@opt_W) {
+        if ($CFG_LD_SHLIB !~ m/gcc$/) {
+            $opt .= " $1" if ($opt_Wl =~ m|^\s*l,(.*)$|);
+        } else {
+            $opt .= " -W$opt_Wl";
+        }
+    }
+    foreach $opt_L (@opt_L) {
+        if ($^O ne "MSWin32") {
+            $opt .= " -L$opt_L";
+        } else {
+            $opt .= " -libpath:\"$opt_L\"";
+        }
+    }
+    foreach $opt_l (@opt_l) {
+        if ($^O ne "MSWin32") {
+            $opt .= " -l$opt_l";
+        } else {
+            $opt .= " $opt_l";
+        }
+    }
+    $cmd .= $opt;
+#    $cmd .= " $CFG_LIBS_SHLIB";
+    push(@cmds, $cmd);
+
+    #   execute the commands
+    &execute_cmds(@cmds);
+
+    #   allow one-step compilation and installation
+    if ($opt_i or $opt_e) {
+        @args = ($dso_file);
+    }
+}
+
+if ($opt_i or $opt_e) {
+    ##
+    ##  DSO INSTALLATION
+    ##
+
+    #   determine installation commands
+    #   and corresponding LoadModule/AddModule directives
+    my @lmd = ();
+    my @amd = ();
+    my @cmds = ();
+    my $f;
+    foreach $f (@args) {
+        if ($f !~ m|\.$dso_ext$|) {
+            print STDERR "apxs:Error: file $f is not a DSO\n";
+            exit(1);
+        }
+        my $t = $f;
+        if ($^O ne "MSWin32") {
+            $t =~ s|^.+/([^/]+)$|$1|;
+            if ($opt_i) {
+                push(@cmds, "cp $f $CFG_LIBEXECDIR/$t");
+                push(@cmds, "chmod 755 $CFG_LIBEXECDIR/$t");
+            }
+        }
+	else {
+            $t =~ s|^.+[/\\]([^/\\]+)$|$1|;
+            if ($opt_i) {
+                push(@cmds, "copy \"$f\" \"$CFG_LIBEXECDIR/$t\"");
+            }
+        }
+        
+        #   determine module symbolname and filename
+        my $filename = '';
+        if ($name eq 'unknown') {
+            $name = '';
+            my $base = $f;
+            $base =~ s|\.[^.]+$||;
+            if (-f "$base.c") {
+                open(FP, "<$base.c");
+                my $content = join('', <FP>);
+                close(FP);
+                if ($content =~ m|.*module\s+(?:MODULE_VAR_EXPORT\s+)?([a-zA-Z0-9_]+)_module\s*=\s*.*|s) {
+                    $name = "$1";
+                    $filename = "$base.c";
+                    $filename =~ s|^.+/||;
+                    $filename =~ s|^.+\\|| if ($^O eq "MSWin32");
+                }
+            }
+            if ($name eq '') {
+                if ($base =~ m|.*mod_([a-zA-Z0-9_]+)\..+|) {
+                    $name = "$1";
+                    $filename = $base;
+                    $filename =~ s|^.+/||;
+                    $filename =~ s|^.+\\|| if ($^O eq "MSWin32");
+                }
+            }
+            if ($name eq '') {
+                print STDERR "apxs:Error: Sorry, cannot determine bootstrap symbol name.\n";
+                print STDERR "apxs:Error: Please specify one with option `-n'.\n";
+                exit(1);
+            }
+        }
+        if ($filename eq '') {
+            $filename = "mod_${name}.c";
+        }
+        my $dir = $CFG_LIBEXECDIR;
+        $dir =~ s|^$CFG_SYSCONFDIR/?||;
+        $dir =~ s|(.)$|$1/|;
+        push(@lmd, sprintf("LoadModule %-18s %s", "${name}_module", "$dir$t"));
+        push(@amd, sprintf("AddModule %s", $filename));
+    }
+
+    #   activate module via LoadModule/AddModule directive
+    if ($opt_a or $opt_A) {
+        my $cfgbase = "$CFG_SYSCONFDIR/$CFG_TARGET";
+        if (not -f "$cfgbase.conf") {
+            print STDERR "apxs:Error: Config file $cfgbase.conf not found\n";
+            exit(1);
+        }
+
+        open(FP, "<$cfgbase.conf") || die;
+        my $content = join('', <FP>);
+        close(FP);
+
+        if ($content !~ m|\n#?\s*LoadModule\s+|) {
+            print STDERR "apxs:Error: Activation failed for custom $cfgbase.conf file.\n";
+            print STDERR "apxs:Error: At least one `LoadModule' directive already has to exist.\n";
+            exit(1);
+        }
+
+        my $lmd;
+        my $c = '';
+        $c = '#' if ($opt_A);
+        foreach $lmd (@lmd) {
+            my $what = $opt_A ? "preparing" : "activating";
+            if ($content !~ m|\n#?\s*$lmd|) {
+                # check for open <containers>, so that the new LoadModule
+                # directive always appears *outside* of an <container>.
+
+                my $before = ($content =~ m|^(.*\n)#?\s*LoadModule\s+[^\n]+\n|s)[0];
+
+                # the '()=' trick forces list context and the scalar
+                # assignment counts the number of list members (aka number
+                # of matches) then
+                my $cntopen = () = ($before =~ m|^\s*<[^/].*$|mg);
+                my $cntclose = () = ($before =~ m|^\s*</.*$|mg);
+
+                if ($cntopen == $cntclose) {
+                    # fine. Last LoadModule is contextless.
+                    $content =~ s|^(.*\n#?\s*LoadModule\s+[^\n]+\n)|$1$c$lmd\n|s;
+                }
+                elsif ($cntopen < $cntclose) {
+                    print STDERR 'Configuration file is not valid. There are '
+                                 . "sections closed before opened.\n";
+                    exit(1);
+                }
+                else {
+                    # put our cmd after the section containing the last
+                    # LoadModule.
+                    my $found =
+                    $content =~ s!\A (               # string and capture start
+                                  (?:(?:
+                                    ^\s*             # start of conf line with a
+                                    (?:[^<]|<[^/])   # directive which does not
+                                                     # start with '</'
+
+                                    .*(?:$)\n        # rest of the line.
+                                                     # the '$' is in parentheses
+                                                     # to avoid misinterpreting
+                                                     # the string "$\" as
+                                                     # perl variable.
+
+                                    )*               # catch as much as possible
+                                                     # of such lines. (including
+                                                     # zero)
+
+                                    ^\s*</.*(?:$)\n? # after the above, we
+                                                     # expect a config line with
+                                                     # a closing container (</)
+
+                                  ) {$cntopen}       # the whole pattern (bunch
+                                                     # of lines that end up with
+                                                     # a closing directive) must
+                                                     # be repeated $cntopen
+                                                     # times. That's it.
+                                                     # Simple, eh? ;-)
+
+                                  )                  # capture end
+                                 !$1$c$lmd\n!mx;
+
+                    unless ($found) {
+                        print STDERR 'Configuration file is not valid. There '
+                                     . "are sections opened and not closed.\n";
+                        exit(1);
+                    }
+                }
+            } else {
+                # replace already existing LoadModule line
+                $content =~ s|^(.*\n)#?\s*$lmd[^\n]*\n|$1$c$lmd\n|s;
+            }
+            $lmd =~ m|LoadModule\s+(.+?)_module.*|;
+            print STDERR "[$what module `$1' in $cfgbase.conf]\n";
+        }
+        my $amd;
+        foreach $amd (@amd) {
+            if ($content !~ m|\n#?\s*$amd|) {
+                # check for open <containers> etc. see above for explanations.
+
+                my $before = ($content =~ m|^(.*\n)#?\s*AddModule\s+[^\n]+\n|s)[0];
+                my $cntopen = () = ($before =~ m|^\s*<[^/].*$|mg);
+                my $cntclose = () = ($before =~ m|^\s*</.*$|mg);
+
+                if ($cntopen == $cntclose) {
+                    $content =~ s|^(.*\n#?\s*AddModule\s+[^\n]+\n)|$1$c$amd\n|s;
+                }
+                elsif ($cntopen < $cntclose) {
+                    # cannot happen here, but who knows ...
+                    print STDERR 'Configuration file is not valid. There are '
+                                 . "sections closed before opened.\n";
+                    exit(1);
+                }
+                else {
+                    unless ($content =~ s!\A((?:(?:^\s*(?:[^<]|<[^/]).*(?:$)\n)*
+                                          ^\s*</.*(?:$)\n?){$cntopen})
+                                         !$1$c$amd\n!mx) {
+                        # cannot happen here, anyway.
+                        print STDERR 'Configuration file is not valid. There '
+                                     . "are sections opened and not closed.\n";
+                        exit(1);
+                    }
+                }
+            } else {
+                # replace already existing AddModule line
+                $content =~ s|^(.*\n)#?\s*$amd[^\n]*\n|$1$c$amd\n|s;
+            }
+        }
+        if (@lmd or @amd) {
+            if (open(FP, ">$cfgbase.conf.new")) {
+                print FP $content;
+                close(FP);
+                if ($^O ne "MSWin32") {
+                    push(@cmds, "cp $cfgbase.conf $cfgbase.conf.bak");
+                    push(@cmds, "cp $cfgbase.conf.new $cfgbase.conf");
+                    push(@cmds, "rm $cfgbase.conf.new");
+                } else {
+                    $cfgbase =~ s|/|\\|g;
+                    push(@cmds, "copy \"$cfgbase.conf\" \"$cfgbase.conf.bak\"");
+                    push(@cmds, "copy \"$cfgbase.conf.new\" \"$cfgbase.conf\"");
+                    push(@cmds, "del \"$cfgbase.conf.new\"");
+                }
+            } else {
+                print STDERR "apxs:Error: unable to open configuration file\n";
+            }
+        }
+    }
+
+    #   execute the commands
+    &execute_cmds(@cmds);
+}
+
+##EOF##
+__DATA__
+##
+##  Makefile -- Build procedure for sample %NAME% Apache module
+##  Autogenerated via ``apxs -n %NAME% -g''.
+##
+
+#   the used tools
+APXS=apxs
+APACHECTL=apachectl
+
+#   additional user defines, includes and libraries
+#DEF=-Dmy_define=my_value
+#INC=-Imy/include/dir
+#LIB=-Lmy/lib/dir -lmylib
+
+#   the default target
+all: mod_%NAME%.%DSO_EXT%
+
+#   compile the DSO file
+mod_%NAME%.%DSO_EXT%: mod_%NAME%.c
+	$(APXS) -c $(DEF) $(INC) $(LIB) mod_%NAME%.c
+
+#   install the DSO file into the Apache installation
+#   and activate it in the Apache configuration
+install: all
+	$(APXS) -i -a -n '%NAME%' mod_%NAME%.%DSO_EXT%
+
+#   cleanup
+clean:
+	-rm -f mod_%NAME%.o mod_%NAME%.%DSO_EXT%
+
+#   simple test
+test: reload
+	lynx -mime_header http://localhost/%NAME%
+
+#   reload the module by installing and restarting Apache
+reload: install restart
+
+#   the general Apache start/restart/stop procedures
+start:
+	$(APACHECTL) start
+restart:
+	$(APACHECTL) restart
+stop:
+	$(APACHECTL) stop
+
+-=#=-
+/* 
+**  mod_%NAME%.c -- Apache sample %NAME% module
+**  [Autogenerated via ``apxs -n %NAME% -g'']
+**
+**  To play with this sample module, first compile it into a
+**  DSO file and install it into Apache's libexec directory 
+**  by running:
+**
+**    $ apxs -c -i mod_%NAME%.c
+**
+**  Then activate it in Apache's %TARGET%.conf file, for instance
+**  for the URL /%NAME%, as follows:
+**
+**    #   %TARGET%.conf
+**    LoadModule %NAME%_module libexec/mod_%NAME%.%DSO_EXT%
+**    <Location /%NAME%>
+**    SetHandler %NAME%
+**    </Location>
+**
+**  Then after restarting Apache via
+**
+**    $ apachectl restart
+**
+**  you immediately can request the URL /%NAME and watch for the
+**  output of this module. This can be achieved for instance via:
+**
+**    $ lynx -mime_header http://localhost/%NAME% 
+**
+**  The output should be similar to the following one:
+**
+**    HTTP/1.1 200 OK
+**    Date: Tue, 31 Mar 1998 14:42:22 GMT
+**    Server: Apache/1.3.4 (Unix)
+**    Connection: close
+**    Content-Type: text/html
+**  
+**    The sample page from mod_%NAME%.c
+*/ 
+
+#include "httpd.h"
+#include "http_config.h"
+#include "http_protocol.h"
+#include "ap_config.h"
+
+/* The sample content handler */
+static int %NAME%_handler(request_rec *r)
+{
+    r->content_type = "text/html";      
+    ap_send_http_header(r);
+    if (!r->header_only)
+        ap_rputs("The sample page from mod_%NAME%.c\n", r);
+    return OK;
+}
+
+/* Dispatch list of content handlers */
+static const handler_rec %NAME%_handlers[] = { 
+    { "%NAME%", %NAME%_handler }, 
+    { NULL, NULL }
+};
+
+/* Dispatch list for API hooks */
+module MODULE_VAR_EXPORT %NAME%_module = {
+    STANDARD_MODULE_STUFF, 
+    NULL,                  /* module initializer                  */
+    NULL,                  /* create per-dir    config structures */
+    NULL,                  /* merge  per-dir    config structures */
+    NULL,                  /* create per-server config structures */
+    NULL,                  /* merge  per-server config structures */
+    NULL,                  /* table of config file commands       */
+    %NAME%_handlers,       /* [#8] MIME-typed-dispatched handlers */
+    NULL,                  /* [#1] URI to filename translation    */
+    NULL,                  /* [#4] validate user id from request  */
+    NULL,                  /* [#5] check if the user is ok _here_ */
+    NULL,                  /* [#3] check access by host address   */
+    NULL,                  /* [#6] determine MIME type            */
+    NULL,                  /* [#7] pre-run fixups                 */
+    NULL,                  /* [#9] log a transaction              */
+    NULL,                  /* [#2] header parser                  */
+    NULL,                  /* child_init                          */
+    NULL,                  /* child_exit                          */
+    NULL                   /* [#0] post read-request              */
+};
+
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/check_forensic apache_1.3.33/src/support/check_forensic
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/check_forensic	Thu Jan 15 21:46:20 2004
+++ apache_1.3.33/src/support/check_forensic	Mon Jul 18 15:22:20 2005
@@ -7,9 +7,14 @@
 
 F=$1
 
-cut -f 1 -d '|' $F  > /tmp/fc-all.$$
-grep + < /tmp/fc-all.$$ | cut -c2- | sort > /tmp/fc-in.$$
-grep -- - < /tmp/fc-all.$$ | cut -c2- | sort > /tmp/fc-out.$$
+all=`mktemp -t fcall.XXXXXX || tempfile --prefix=fcall` || { echo "$0: Cannot create temporary file" >&2; exit 1; }
+in=`mktemp -t fcin.XXXXXX || tempfile --prefix=fcin` || { echo "$0: Cannot create temporary file" >&2; exit 1; }
+out=`mktemp -t fcout.XXXXXX || tempfile --prefix=fcout` || { echo "$0: Cannot create temporary file" >&2; exit 1; }
+trap "rm -f -- \"$all\" \"$in\" \"$out\";" 0 1 2 3 13 15
+
+cut -f 1 -d '|' $F >$all
+grep + < $all|cut -c2- | sort >$in
+grep -- - < $all cut -c2- | sort >$out
 # use -i instead of -I for GNU xargs
-join -v 1 /tmp/fc-in.$$ /tmp/fc-out.$$ | xargs -I xx egrep "^\\+xx" $F
-rm /tmp/fc-all.$$ /tmp/fc-in.$$ /tmp/fc-out.$$
+join -v 1 $in $out |xargs -ixx egrep "^\\+xx" $F
+exit 0
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/dbmmanage apache_1.3.33/src/support/dbmmanage
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/dbmmanage	Fri Feb 20 23:02:24 2004
+++ apache_1.3.33/src/support/dbmmanage	Mon Jul 18 15:22:19 2005
@@ -1,4 +1,4 @@
-#!/usr/local/bin/perl
+#!/usr/bin/perl
 #
 # Copyright 1999-2004 The Apache Software Foundation
 #
@@ -24,7 +24,7 @@
 BEGIN { @AnyDBM_File::ISA = qw(DB_File NDBM_File GDBM_File SDBM_File) }
 use strict;
 use Fcntl;
-use AnyDBM_File ();
+use DB_File ();
 
 sub usage {
     my $cmds = join "|", sort keys %dbmc::;
@@ -154,7 +154,9 @@
 my($mode, $flags) = $command =~ 
     /^(?:view|check)$/ ? (0644, O_RDONLY) : (0644, O_RDWR|O_CREAT);
 
-tie (%DB, "AnyDBM_File", $file, $flags, $mode) || die "Can't tie $file: $!";
+tie (%DB, "DB_File", $file, $flags, $mode, $DB_File::DB_HASH) ||
+    tie (%DB, "DB_File", $file, $flags, $mode, $DB_File::DB_BTREE) ||
+    die "Can't tie $file: $!";
 dbmc->$command();
 untie %DB;
 
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/htdigest.c apache_1.3.33/src/support/htdigest.c
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/htdigest.c	Fri Feb 20 23:02:24 2004
+++ apache_1.3.33/src/support/htdigest.c	Mon Jul 18 15:22:20 2005
@@ -52,7 +52,7 @@
 
 #define MAX_STRING_LEN 256
 
-char *tn;
+static char tn[MAX_STRING_LEN];
 
 
 static void getword(char *word, char *line, char stop)
@@ -124,7 +124,8 @@
     fprintf(f, "%s:%s:", user, realm);
 
     /* Do MD5 stuff */
-    sprintf(string, "%s:%s:%s", user, realm, pw);
+    memset(string, '\0',sizeof(string));
+    snprintf(string, sizeof(string)-1, "%s:%s:%s", user, realm, pw);
 
     ap_MD5Init(&context);
     ap_MD5Update(&context, (unsigned char *) string, strlen(string));
@@ -174,8 +175,8 @@
     char x[MAX_STRING_LEN];
     char command[MAX_STRING_LEN];
     int found;
+    int tfd;
 
-    tn = NULL;
     signal(SIGINT, (void (*)(int)) interrupted);
     if (argc == 5) {
 	if (strcmp(argv[1], "-c"))
@@ -199,11 +200,13 @@
     else if (argc != 4)
 	usage();
 
-    tn = tmpnam(NULL);
-    if (!(tfp = fopen(tn, "w"))) {
+    strcpy(tn, "/tmp/htdigest-XXXXXX");
+    tfd = mkstemp(tn);
+    if (tfd == -1) {
 	fprintf(stderr, "Could not open temp file.\n");
 	exit(1);
     }
+    tfp = fdopen(tfd, "w");
 
     if (!(f = fopen(argv[1], "r"))) {
 	fprintf(stderr,
@@ -239,11 +242,13 @@
     }   
     fclose(f);
     fclose(tfp);
+
+    memset(command,'\0', sizeof(command));
 #ifndef NETWARE
 #if defined(OS2) || defined(WIN32)
-    sprintf(command, "copy \"%s\" \"%s\"", tn, argv[1]);
+    snprintf(command, sizeof(command)-1, "copy \"%s\" \"%s\"", tn, argv[1]);
 #else
-    sprintf(command, "cp %s %s", tn, argv[1]);
+    snprintf(command, sizeof(command)-1, "cp %s %s", tn, argv[1]);
 #endif
     system(command);
 #else
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/htdigest.c.orig apache_1.3.33/src/support/htdigest.c.orig
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/htdigest.c.orig	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/support/htdigest.c.orig	Fri Feb 20 23:02:24 2004
@@ -0,0 +1,264 @@
+/* Copyright 1999-2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/******************************************************************************
+ ******************************************************************************
+ * NOTE! This program is not safe as a setuid executable!  Do not make it
+ * setuid!
+ ******************************************************************************
+ *****************************************************************************/
+/*
+ * htdigest.c: simple program for manipulating digest passwd file for Apache
+ *
+ * by Alexei Kosut, based on htpasswd.c, by Rob McCool
+ */
+
+#include "ap_config.h"
+#ifndef NETWARE
+#include <sys/types.h>
+#endif
+#include "ap.h"
+#include "ap_md5.h"
+#if defined(MPE) || defined(QNX) || defined(WIN32) || defined(__TANDEM) || defined(OS390) || defined(BEOS) || defined(BONE)
+#include <signal.h>
+#else
+#include <sys/signal.h>
+#endif
+
+#ifdef WIN32
+#include <conio.h>
+#define unlink _unlink
+#endif
+
+#ifdef CHARSET_EBCDIC
+#define LF '\n'
+#define CR '\r'
+#else
+#define LF 10
+#define CR 13
+#endif /* CHARSET_EBCDIC */
+
+#define MAX_STRING_LEN 256
+
+char *tn;
+
+
+static void getword(char *word, char *line, char stop)
+{
+    int x = 0, y;
+
+    for (x = 0; ((line[x]) && (line[x] != stop)); x++)
+	word[x] = line[x];
+
+    word[x] = '\0';
+    if (line[x])
+	++x;
+    y = 0;
+
+    while ((line[y++] = line[x++]));
+}
+
+static int getline(char *s, int n, FILE *f)
+{
+    register int i = 0;
+
+    while (1) {
+	s[i] = (char) fgetc(f);
+
+	if (s[i] == CR)
+	    s[i] = fgetc(f);
+
+	if ((s[i] == 0x4) || (s[i] == LF) || (i == (n - 1))) {
+	    s[i] = '\0';
+	    return (feof(f) ? 1 : 0);
+	}
+	++i;
+    }
+}
+
+static void putline(FILE *f, char *l)
+{
+    int x;
+
+    for (x = 0; l[x]; x++)
+	fputc(l[x], f);
+    fputc('\n', f);
+}
+
+
+static void add_password(char *user, char *realm, FILE *f)
+{
+    char *pw;
+    AP_MD5_CTX context;
+    unsigned char digest[16];
+    char string[MAX_STRING_LEN];
+    char pwin[MAX_STRING_LEN];
+    char pwv[MAX_STRING_LEN];
+    unsigned int i;
+
+    if (ap_getpass("New password: ", pwin, sizeof(pwin)) != 0) {
+	fprintf(stderr, "password too long");
+	exit(5);
+    }
+    ap_getpass("Re-type new password: ", pwv, sizeof(pwv));
+    if (strcmp(pwin, pwv) != 0) {
+	fprintf(stderr, "They don't match, sorry.\n");
+	if (tn) {
+	    unlink(tn);
+	}
+	exit(1);
+    }
+    pw = pwin;
+    fprintf(f, "%s:%s:", user, realm);
+
+    /* Do MD5 stuff */
+    sprintf(string, "%s:%s:%s", user, realm, pw);
+
+    ap_MD5Init(&context);
+    ap_MD5Update(&context, (unsigned char *) string, strlen(string));
+    ap_MD5Final(digest, &context);
+
+    for (i = 0; i < 16; i++)
+	fprintf(f, "%02x", digest[i]);
+
+    fprintf(f, "\n");
+}
+
+static void usage(void)
+{
+    fprintf(stderr, "Usage: htdigest [-c] passwordfile realm username\n");
+    fprintf(stderr, "The -c flag creates a new file.\n");
+    exit(1);
+}
+
+static void interrupted(void)
+{
+    fprintf(stderr, "Interrupted.\n");
+    if (tn)
+	unlink(tn);
+    exit(1);
+}
+
+
+#ifdef NETWARE
+static void copy_file(FILE *target, FILE *source)
+{
+    static char line[MAX_STRING_LEN];
+
+    while (!(getline(line, MAX_STRING_LEN, source))) {  
+	putline(target, line);
+    }
+}
+#endif
+
+int main(int argc, char *argv[])
+{
+    FILE *tfp, *f;
+    char user[MAX_STRING_LEN];
+    char realm[MAX_STRING_LEN];
+    char line[MAX_STRING_LEN];
+    char l[MAX_STRING_LEN];
+    char w[MAX_STRING_LEN];
+    char x[MAX_STRING_LEN];
+    char command[MAX_STRING_LEN];
+    int found;
+
+    tn = NULL;
+    signal(SIGINT, (void (*)(int)) interrupted);
+    if (argc == 5) {
+	if (strcmp(argv[1], "-c"))
+	    usage();
+#ifdef NETWARE
+    UnAugmentAsterisk(TRUE);
+    SetCurrentNameSpace(NW_NS_LONG);
+    SetTargetNameSpace(NW_NS_LONG);
+#endif
+	if (!(tfp = fopen(argv[2], "w"))) {
+	    fprintf(stderr, "Could not open passwd file %s for writing.\n",
+		    argv[2]);
+	    perror("fopen");
+	    exit(1);
+	}
+	printf("Adding password for %s in realm %s.\n", argv[4], argv[3]);
+	add_password(argv[4], argv[3], tfp);
+	fclose(tfp);
+	exit(0);
+    }
+    else if (argc != 4)
+	usage();
+
+    tn = tmpnam(NULL);
+    if (!(tfp = fopen(tn, "w"))) {
+	fprintf(stderr, "Could not open temp file.\n");
+	exit(1);
+    }
+
+    if (!(f = fopen(argv[1], "r"))) {
+	fprintf(stderr,
+		"Could not open passwd file %s for reading.\n", argv[1]);
+	fprintf(stderr, "Use -c option to create new one.\n");
+	exit(1);
+    }
+    ap_cpystrn(user, argv[3], sizeof(user));
+    ap_cpystrn(realm, argv[2], sizeof(realm));
+
+    found = 0;
+    while (!(getline(line, MAX_STRING_LEN, f))) {
+	if (found || (line[0] == '#') || (!line[0])) {
+	    putline(tfp, line);
+	    continue;
+	}
+	strcpy(l, line);
+	getword(w, l, ':');
+	getword(x, l, ':');
+	if (strcmp(user, w) || strcmp(realm, x)) {
+	    putline(tfp, line);
+	    continue;
+	}
+	else {
+	    printf("Changing password for user %s in realm %s\n", user, realm);
+	    add_password(user, realm, tfp);
+	    found = 1;
+	}
+    }
+    if (!found) {
+	printf("Adding user %s in realm %s\n", user, realm);
+	add_password(user, realm, tfp);
+    }   
+    fclose(f);
+    fclose(tfp);
+#ifndef NETWARE
+#if defined(OS2) || defined(WIN32)
+    sprintf(command, "copy \"%s\" \"%s\"", tn, argv[1]);
+#else
+    sprintf(command, "cp %s %s", tn, argv[1]);
+#endif
+    system(command);
+#else
+    if (!(tfp = fopen(tn, "r"))) {
+    fprintf(stderr, "Could not open temp file.\n");
+    exit(1);
+    }
+    
+    if (!(f = fopen(argv[1], "w"))) {
+    fprintf(stderr, "Could not open %s.\n", argv[1]);    
+    exit(1);    
+    }
+    
+    copy_file(f, tfp);
+#endif
+    unlink(tn);
+    return 0;
+}
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/htpasswd.c apache_1.3.33/src/support/htpasswd.c
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/htpasswd.c	Fri Feb 20 23:02:24 2004
+++ apache_1.3.33/src/support/htpasswd.c	Mon Jul 18 15:22:20 2005
@@ -81,7 +81,7 @@
  * This needs to be declared statically so the signal handler can
  * access it.
  */
-static char *tempfilename;
+static char tempfilename[MAX_STRING_LEN];
 /*
  * If our platform knows about the tmpnam() external buffer size, create
  * a buffer to pass in.  This is needed in a threaded environment, or
@@ -325,6 +325,7 @@
     char record[MAX_STRING_LEN];
     char line[MAX_STRING_LEN];
     char pwfilename[MAX_STRING_LEN];
+    char extrafields[MAX_STRING_LEN];
     char *arg;
     int found = 0;
     int alg = ALG_CRYPT;
@@ -333,10 +334,12 @@
     int noninteractive = 0;
     int i;
     int args_left = 2;
+    int tfd;
 
-    tempfilename = NULL;
     signal(SIGINT, (void (*)(int)) interrupted);
 
+    extrafields[0] = '\0'; /* be sure it is initialized properly */
+    
     /*
      * Preliminary check to make sure they provided at least
      * three arguments, we'll do better argument checking as 
@@ -411,11 +414,11 @@
 	    return ERR_OVERFLOW;
 	}
 	strcpy(pwfilename, argv[i]);
-	if (strlen(argv[i + 1]) > (sizeof(user) - 1)) {
-	    fprintf(stderr, "%s: username too long (>%lu)\n", argv[0],
-		    (unsigned long)(sizeof(user) - 1));
-	    return ERR_OVERFLOW;
-	}
+    }
+    if (strlen(argv[i + 1]) > (sizeof(user) - 1)) {
+	fprintf(stderr, "%s: username too long (>%lu)\n", argv[0],
+		(unsigned long)(sizeof(user) - 1));
+	return ERR_OVERFLOW;
     }
     strcpy(user, argv[i + 1]);
     if ((arg = strchr(user, ':')) != NULL) {
@@ -521,7 +524,8 @@
      * to add or update.  Let's do it..
      */
     errno = 0;
-    tempfilename = tmpnam(tname_buf);
+    strcpy(tempfilename, "/tmp/htpasswd-XXXXXX");
+    tfd = mkstemp(tempfilename);
     if ((tempfilename == NULL) || (*tempfilename == '\0')) {
 	fprintf(stderr, "%s: unable to generate temporary filename\n",
 		argv[0]);
@@ -531,13 +535,13 @@
 	perror("tmpnam");
 	exit(ERR_FILEPERM);
     }
-    ftemp = fopen(tempfilename, "w+");
-    if (ftemp == NULL) {
+    if (tfd == -1) {
 	fprintf(stderr, "%s: unable to create temporary file '%s'\n", argv[0],
 		tempfilename);
-	perror("fopen");
+	perror("open");
 	exit(ERR_FILEPERM);
     }
+    ftemp = fdopen(tfd, "w+");
     /*
      * If we're not creating a new file, copy records from the existing
      * one to the temporary file until we find the specified user.
@@ -565,6 +569,14 @@
 		putline(ftemp, line);
 		continue;
 	    }
+	    strcpy(scratch, line);		/* make a clean copy of line */
+	    colon = strchr(scratch, ':');	/* skip the username */
+	    colon = strchr(colon+1, ':');	/* skip the password */
+	    if (colon != NULL) {		/* if != NULL there are extrafields */
+		strcpy(extrafields,colon);	/* copy them */
+	    } else {
+		extrafields[0] = '\0';		/* if not be sure that it is empty! */
+	    }
 	    found++;
 	    break;
 	}
@@ -579,6 +591,9 @@
     /*
      * Now add the user record we created.
      */
+    if (strlen(extrafields) > 0) {
+	strcat(record,extrafields);
+    }
     putline(ftemp, record);
     /*
      * If we're updating an existing file, there may be additional
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/htpasswd.c.orig apache_1.3.33/src/support/htpasswd.c.orig
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/htpasswd.c.orig	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/support/htpasswd.c.orig	Mon Jul 18 15:22:19 2005
@@ -0,0 +1,618 @@
+/* Copyright 1999-2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/******************************************************************************
+ ******************************************************************************
+ * NOTE! This program is not safe as a setuid executable!  Do not make it
+ * setuid!
+ ******************************************************************************
+ *****************************************************************************/
+/*
+ * htpasswd.c: simple program for manipulating password file for
+ * the Apache HTTP server
+ * 
+ * Originally by Rob McCool
+ *
+ * Exit values:
+ *  0: Success
+ *  1: Failure; file access/permission problem
+ *  2: Failure; command line syntax problem (usage message issued)
+ *  3: Failure; password verification failure
+ *  4: Failure; operation interrupted (such as with CTRL/C)
+ *  5: Failure; buffer would overflow (username, filename, or computed
+ *     record too long)
+ *  6: Failure; username contains illegal or reserved characters
+ */
+
+#include "ap_config.h"
+#ifndef NETWARE
+#include <sys/types.h>
+#endif
+#include <signal.h>
+#include <errno.h>
+#include "ap.h"
+#include "ap_md5.h"
+#include "ap_sha1.h"
+
+#ifdef HAVE_CRYPT_H
+#include <crypt.h>
+#endif
+
+#ifdef WIN32
+#include <conio.h>
+#include "../os/win32/getopt.h"
+#define unlink _unlink
+#endif
+
+#ifndef CHARSET_EBCDIC
+#define LF 10
+#define CR 13
+#else /*CHARSET_EBCDIC*/
+#define LF '\n'
+#define CR '\r'
+#endif /*CHARSET_EBCDIC*/
+
+#define MAX_STRING_LEN 256
+#define ALG_PLAIN 0
+#define ALG_CRYPT 1
+#define ALG_APMD5 2
+#define ALG_APSHA 3 
+
+#define ERR_FILEPERM 1
+#define ERR_SYNTAX 2
+#define ERR_PWMISMATCH 3
+#define ERR_INTERRUPTED 4
+#define ERR_OVERFLOW 5
+#define ERR_BADUSER 6
+
+/*
+ * This needs to be declared statically so the signal handler can
+ * access it.
+ */
+static char *tempfilename;
+/*
+ * If our platform knows about the tmpnam() external buffer size, create
+ * a buffer to pass in.  This is needed in a threaded environment, or
+ * one that thinks it is (like HP-UX).
+ */
+#ifdef L_tmpnam
+static char tname_buf[L_tmpnam];
+#else
+static char *tname_buf = NULL;
+#endif
+
+/*
+ * Get a line of input from the user, not including any terminating
+ * newline.
+ */
+static int getline(char *s, int n, FILE *f)
+{
+    register int i = 0;
+
+    while (1) {
+	s[i] = (char) fgetc(f);
+
+	if (s[i] == CR) {
+	    s[i] = fgetc(f);
+	}
+
+	if ((s[i] == 0x4) || (s[i] == LF) || (i == (n - 1))) {
+	    s[i] = '\0';
+	    return (feof(f) ? 1 : 0);
+	}
+	++i;
+    }
+}
+
+static void putline(FILE *f, char *l)
+{
+    int x;
+
+    for (x = 0; l[x]; x++) {
+	fputc(l[x], f);
+    }
+    fputc('\n', f);
+}
+
+/*
+ * Make a password record from the given information.  A zero return
+ * indicates success; failure means that the output buffer contains an
+ * error message instead.
+ */
+static int mkrecord(char *user, char *record, size_t rlen, char *passwd,
+		    int alg)
+{
+    char *pw;
+    char cpw[120];
+    char pwin[MAX_STRING_LEN];
+    char pwv[MAX_STRING_LEN];
+    char salt[9];
+
+    if (passwd != NULL) {
+	pw = passwd;
+    }
+    else {
+#ifdef TPF
+        fprintf(stderr, "Invalid entry. The -b option is required on TPF.\n");
+        return usage();
+#else
+	if (ap_getpass("New password: ", pwin, sizeof(pwin)) != 0) {
+	    ap_snprintf(record, (rlen - 1), "password too long (>%lu)",
+			(unsigned long) (sizeof(pwin) - 1));
+	    return ERR_OVERFLOW;
+	}
+	ap_getpass("Re-type new password: ", pwv, sizeof(pwv));
+	if (strcmp(pwin, pwv) != 0) {
+	    ap_cpystrn(record, "password verification error", (rlen - 1));
+	    return ERR_PWMISMATCH;
+	}
+	pw = pwin;
+        memset(pwv, '\0', sizeof(pwin));
+#endif /* TPF */
+    }
+    switch (alg) {
+
+    case ALG_APSHA:
+	/* XXX cpw >= 28 + strlen(sha1) chars - fixed len SHA */
+ 	ap_sha1_base64(pw,strlen(pw),cpw);
+	break;
+
+    case ALG_APMD5: 
+        (void) srand((int) time((time_t *) NULL));
+        ap_to64(&salt[0], rand(), 8);
+        salt[8] = '\0';
+
+	ap_MD5Encode((const unsigned char *)pw, (const unsigned char *)salt,
+		     cpw, sizeof(cpw));
+	break;
+
+    case ALG_PLAIN:
+	/* XXX this len limitation is not in sync with any HTTPd len. */
+	ap_cpystrn(cpw,pw,sizeof(cpw));
+	break;
+
+    case ALG_CRYPT:
+    default:
+        (void) srand((int) time((time_t *) NULL));
+        ap_to64(&salt[0], rand(), 8);
+        salt[8] = '\0';
+
+	ap_cpystrn(cpw, (char *)crypt(pw, salt), sizeof(cpw) - 1);
+	break;
+    }
+    memset(pw, '\0', strlen(pw));
+
+    /*
+     * Check to see if the buffer is large enough to hold the username,
+     * hash, and delimiters.
+     */
+    if ((strlen(user) + 1 + strlen(cpw)) > (rlen - 1)) {
+	ap_cpystrn(record, "resultant record too long", (rlen - 1));
+	return ERR_OVERFLOW;
+    }
+    strcpy(record, user);
+    strcat(record, ":");
+    strcat(record, cpw);
+    return 0;
+}
+
+static int usage(void)
+{
+    fprintf(stderr, "Usage:\n");
+    fprintf(stderr, "\thtpasswd [-cmdps] passwordfile username\n");
+    fprintf(stderr, "\thtpasswd -b[cmdps] passwordfile username password\n\n");
+    fprintf(stderr, "\thtpasswd -n[mdps] username\n");
+    fprintf(stderr, "\thtpasswd -nb[mdps] username password\n");
+    fprintf(stderr, " -c  Create a new file.\n");
+    fprintf(stderr, " -n  Don't update file; display results on stdout.\n");
+    fprintf(stderr, " -m  Force MD5 encryption of the password"
+#if defined(WIN32) || defined(TPF) || defined(NETWARE)
+	" (default)"
+#endif
+	".\n");
+    fprintf(stderr, " -d  Force CRYPT encryption of the password"
+#if (!(defined(WIN32) || defined(TPF) || defined(NETWARE)))
+	    " (default)"
+#endif
+	    ".\n");
+    fprintf(stderr, " -p  Do not encrypt the password (plaintext).\n");
+    fprintf(stderr, " -s  Force SHA encryption of the password.\n");
+    fprintf(stderr, " -b  Use the password from the command line rather "
+	    "than prompting for it.\n");
+    fprintf(stderr,
+	    "On Windows, TPF and NetWare systems the '-m' flag is used by default.\n");
+    fprintf(stderr,
+	    "On all other systems, the '-p' flag will probably not work.\n");
+    return ERR_SYNTAX;
+}
+
+static void interrupted(void)
+{
+    fprintf(stderr, "Interrupted.\n");
+    if (tempfilename != NULL) {
+	unlink(tempfilename);
+    }
+    exit(ERR_INTERRUPTED);
+}
+
+/*
+ * Check to see if the specified file can be opened for the given
+ * access.
+ */
+static int accessible(char *fname, char *mode)
+{
+    FILE *s;
+
+    s = fopen(fname, mode);
+    if (s == NULL) {
+	return 0;
+    }
+    fclose(s);
+    return 1;
+}
+
+/*
+ * Return true if a file is readable.
+ */
+static int readable(char *fname)
+{
+    return accessible(fname, "r");
+}
+
+/*
+ * Return true if the specified file can be opened for write access.
+ */
+static int writable(char *fname)
+{
+    return accessible(fname, "a");
+}
+
+/*
+ * Return true if the named file exists, regardless of permissions.
+ */
+static int exists(char *fname)
+{
+#ifdef WIN32
+    struct _stat sbuf;
+#else
+    struct stat sbuf;
+#endif
+    int check;
+
+#ifdef WIN32
+    check = _stat(fname, &sbuf);
+#else
+    check = stat(fname, &sbuf);
+#endif
+    return ((check == -1) && (errno == ENOENT)) ? 0 : 1;
+}
+
+/*
+ * Copy from the current position of one file to the current position
+ * of another.
+ */
+static void copy_file(FILE *target, FILE *source)
+{
+    static char line[MAX_STRING_LEN];
+
+    while (fgets(line, sizeof(line), source) != NULL) {
+	fputs(line, target);
+    }
+}
+
+/*
+ * Let's do it.  We end up doing a lot of file opening and closing,
+ * but what do we care?  This application isn't run constantly.
+ */
+int main(int argc, char *argv[])
+{
+    FILE *ftemp = NULL;
+    FILE *fpw = NULL;
+    char user[MAX_STRING_LEN];
+    char password[MAX_STRING_LEN];
+    char record[MAX_STRING_LEN];
+    char line[MAX_STRING_LEN];
+    char pwfilename[MAX_STRING_LEN];
+    char extrafields[MAX_STRING_LEN];
+    char *arg;
+    int found = 0;
+    int alg = ALG_CRYPT;
+    int newfile = 0;
+    int nofile = 0;
+    int noninteractive = 0;
+    int i;
+    int args_left = 2;
+
+    tempfilename = NULL;
+    signal(SIGINT, (void (*)(int)) interrupted);
+
+    extrafields[0] = '\0'; /* be sure it is initialized properly */
+    
+    /*
+     * Preliminary check to make sure they provided at least
+     * three arguments, we'll do better argument checking as 
+     * we parse the command line.
+     */
+    if (argc < 3) {
+	return usage();
+    }
+
+    /*
+     * Go through the argument list and pick out any options.  They
+     * have to precede any other arguments.
+     */
+    for (i = 1; i < argc; i++) {
+	arg = argv[i];
+	if (*arg != '-') {
+	    break;
+	}
+	while (*++arg != '\0') {
+	    if (*arg == 'c') {
+		newfile++;
+	    }
+	    else if (*arg == 'n') {
+		nofile++;
+		args_left--;
+	    }
+	    else if (*arg == 'm') {
+		alg = ALG_APMD5;
+	    }
+	    else if (*arg == 's') {
+		alg = ALG_APSHA;
+	    }
+	    else if (*arg == 'p') {
+		alg = ALG_PLAIN;
+	    }
+	    else if (*arg == 'd') {
+		alg = ALG_CRYPT;
+	    }
+	    else if (*arg == 'b') {
+		noninteractive++;
+		args_left++;
+	    }
+	    else {
+		return usage();
+	    }
+	}
+    }
+
+    /*
+     * Make sure we still have exactly the right number of arguments left
+     * (the filename, the username, and possibly the password if -b was
+     * specified).
+     */
+    if ((argc - i) != args_left) {
+	return usage();
+    }
+#ifdef NETWARE
+    UnAugmentAsterisk(TRUE);
+    SetCurrentNameSpace(NW_NS_LONG);
+    SetTargetNameSpace(NW_NS_LONG);
+#endif
+    if (newfile && nofile) {
+	fprintf(stderr, "%s: -c and -n options conflict\n", argv[0]);
+	return ERR_SYNTAX;
+    }
+    if (nofile) {
+	i--;
+    }
+    else {
+	if (strlen(argv[i]) > (sizeof(pwfilename) - 1)) {
+	    fprintf(stderr, "%s: filename too long\n", argv[0]);
+	    return ERR_OVERFLOW;
+	}
+	strcpy(pwfilename, argv[i]);
+	if (strlen(argv[i + 1]) > (sizeof(user) - 1)) {
+	    fprintf(stderr, "%s: username too long (>%lu)\n", argv[0],
+		    (unsigned long)(sizeof(user) - 1));
+	    return ERR_OVERFLOW;
+	}
+    }
+    strcpy(user, argv[i + 1]);
+    if ((arg = strchr(user, ':')) != NULL) {
+	fprintf(stderr, "%s: username contains illegal character '%c'\n",
+		argv[0], *arg);
+	return ERR_BADUSER;
+    }
+    if (noninteractive) {
+	if (strlen(argv[i + 2]) > (sizeof(password) - 1)) {
+	    fprintf(stderr, "%s: password too long (>%lu)\n", argv[0],
+		    (unsigned long)(sizeof(password) - 1));
+	    return ERR_OVERFLOW;
+	}
+	strcpy(password, argv[i + 2]);
+    }
+
+#ifdef WIN32
+    if (alg == ALG_CRYPT) {
+	alg = ALG_APMD5;
+	fprintf(stderr, "Automatically using MD5 format on Windows.\n");
+    }
+#elif defined(TPF) || defined(NETWARE)
+    if (alg == ALG_CRYPT) {
+        alg = ALG_APMD5;
+        fprintf(stderr, "Automatically using MD5 format.\n");
+     }
+#endif
+
+#if (!(defined(WIN32) || defined(TPF) || defined(NETWARE)))
+    if (alg == ALG_PLAIN) {
+	fprintf(stderr,"Warning: storing passwords as plain text might "
+		"just not work on this platform.\n");
+    }
+#endif
+    if (! nofile) {
+	/*
+	 * Only do the file checks if we're supposed to frob it.
+	 *
+	 * Verify that the file exists if -c was omitted.  We give a special
+	 * message if it doesn't.
+	 */
+	if ((! newfile) && (! exists(pwfilename))) {
+	    fprintf(stderr,
+		    "%s: cannot modify file %s; use '-c' to create it\n",
+		    argv[0], pwfilename);
+	    perror("fopen");
+	    exit(ERR_FILEPERM);
+	}
+	/*
+	 * Verify that we can read the existing file in the case of an update
+	 * to it (rather than creation of a new one).
+	 */
+	if ((! newfile) && (! readable(pwfilename))) {
+	    fprintf(stderr, "%s: cannot open file %s for read access\n",
+		    argv[0], pwfilename);
+	    perror("fopen");
+	    exit(ERR_FILEPERM);
+	}
+	/*
+	 * Now check to see if we can preserve an existing file in case
+	 * of password verification errors on a -c operation.
+	 */
+	if (newfile && exists(pwfilename) && (! readable(pwfilename))) {
+	    fprintf(stderr, "%s: cannot open file %s for read access\n"
+		    "%s: existing auth data would be lost on "
+		    "password mismatch",
+		    argv[0], pwfilename, argv[0]);
+	    perror("fopen");
+	    exit(ERR_FILEPERM);
+	}
+	/*
+	 * Now verify that the file is writable!
+	 */
+	if (! writable(pwfilename)) {
+	    fprintf(stderr, "%s: cannot open file %s for write access\n",
+		    argv[0], pwfilename);
+	    perror("fopen");
+	    exit(ERR_FILEPERM);
+	}
+    }
+
+    /*
+     * All the file access checks (if any) have been made.  Time to go to work;
+     * try to create the record for the username in question.  If that
+     * fails, there's no need to waste any time on file manipulations.
+     * Any error message text is returned in the record buffer, since
+     * the mkrecord() routine doesn't have access to argv[].
+     */
+    i = mkrecord(user, record, sizeof(record) - 1,
+		 noninteractive ? password : NULL,
+		 alg);
+    if (i != 0) {
+	fprintf(stderr, "%s: %s\n", argv[0], record);
+	exit(i);
+    }
+    if (nofile) {
+	printf("%s\n", record);
+	exit(0);
+    }
+
+    /*
+     * We can access the files the right way, and we have a record
+     * to add or update.  Let's do it..
+     */
+    errno = 0;
+    tempfilename = tmpnam(tname_buf);
+    if ((tempfilename == NULL) || (*tempfilename == '\0')) {
+	fprintf(stderr, "%s: unable to generate temporary filename\n",
+		argv[0]);
+	if (errno == 0) {
+	    errno = ENOENT;
+	}
+	perror("tmpnam");
+	exit(ERR_FILEPERM);
+    }
+    ftemp = fopen(tempfilename, "w+");
+    if (ftemp == NULL) {
+	fprintf(stderr, "%s: unable to create temporary file '%s'\n", argv[0],
+		tempfilename);
+	perror("fopen");
+	exit(ERR_FILEPERM);
+    }
+    /*
+     * If we're not creating a new file, copy records from the existing
+     * one to the temporary file until we find the specified user.
+     */
+    if (! newfile) {
+	char scratch[MAX_STRING_LEN];
+
+	fpw = fopen(pwfilename, "r");
+	while (! (getline(line, sizeof(line), fpw))) {
+	    char *colon;
+
+	    if ((line[0] == '#') || (line[0] == '\0')) {
+		putline(ftemp, line);
+		continue;
+	    }
+	    strcpy(scratch, line);
+	    /*
+	     * See if this is our user.
+	     */
+	    colon = strchr(scratch, ':');
+	    if (colon != NULL) {
+		*colon = '\0';
+	    }
+	    if (strcmp(user, scratch) != 0) {
+		putline(ftemp, line);
+		continue;
+	    }
+	    strcpy(scratch, line);		/* make a clean copy of line */
+	    colon = strchr(scratch, ':');	/* skip the username */
+	    colon = strchr(colon+1, ':');	/* skip the password */
+	    if (colon != NULL) {		/* if != NULL there are extrafields */
+		strcpy(extrafields,colon);	/* copy them */
+	    } else {
+		extrafields[0] = '\0';		/* if not be sure that it is empty! */
+	    }
+	    found++;
+	    break;
+	}
+    }
+    if (found) {
+	fprintf(stderr, "Updating ");
+    }
+    else {
+	fprintf(stderr, "Adding ");
+    }
+    fprintf(stderr, "password for user %s\n", user);
+    /*
+     * Now add the user record we created.
+     */
+    if (strlen(extrafields) > 0) {
+	strcat(record,extrafields);
+    }
+    putline(ftemp, record);
+    /*
+     * If we're updating an existing file, there may be additional
+     * records beyond the one we're updating, so copy them.
+     */
+    if (! newfile) {
+	copy_file(ftemp, fpw);
+	fclose(fpw);
+    }
+    /*
+     * The temporary file now contains the information that should be
+     * in the actual password file.  Close the open files, re-open them
+     * in the appropriate mode, and copy them file to the real one.
+     */
+    fclose(ftemp);
+    fpw = fopen(pwfilename, "w+");
+    ftemp = fopen(tempfilename, "r");
+    copy_file(fpw, ftemp);
+    fclose(fpw);
+    fclose(ftemp);
+    unlink(tempfilename);
+    return 0;
+}
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/httpd.8 apache_1.3.33/src/support/httpd.8
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/httpd.8	Fri Feb 20 23:40:51 2004
+++ apache_1.3.33/src/support/httpd.8	Mon Jul 18 15:22:19 2005
@@ -22,6 +22,8 @@
 [
 .B \-X
 ] [
+.BI \-F
+] [
 .BI \-R " libexecdir"
 ] [
 .BI \-d " serverroot"
@@ -136,6 +138,9 @@
 Same as option 
 .B \-t
 but does not check the configured document roots. 
+.TP
+.B \-F
+Run the main process in foreground, for process supervisors.
 .TP
 .B \-X
 Run in single-process mode, for internal debugging purposes only; the daemon
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/httpd.8.orig apache_1.3.33/src/support/httpd.8.orig
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/httpd.8.orig	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/support/httpd.8.orig	Fri Feb 20 23:40:51 2004
@@ -0,0 +1,173 @@
+.TH httpd 8 "February 2004"
+.\" Copyright (c) 1995-1997 David Robinson. All rights reserved.
+.\" ====================================================================
+.\" Copyright 1999-2004 The Apache Software Foundation
+.\"
+.\" Licensed under the Apache License, Version 2.0 (the "License");
+.\" you may not use this file except in compliance with the License.
+.\" You may obtain a copy of the License at
+.\"
+.\"     http://www.apache.org/licenses/LICENSE-2.0
+.\"
+.\" Unless required by applicable law or agreed to in writing, software
+.\" distributed under the License is distributed on an "AS IS" BASIS,
+.\" WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+.\" See the License for the specific language governing permissions and
+.\" limitations under the License.
+.\"
+.SH NAME
+httpd \- Apache hypertext transfer protocol server
+.SH SYNOPSIS
+.B httpd 
+[
+.B \-X
+] [
+.BI \-R " libexecdir"
+] [
+.BI \-d " serverroot"
+] [
+.BI \-f " config"
+] [
+.BI \-C " directive"
+] [
+.BI \-c " directive"
+] [
+.BI \-D " parameter"
+]
+
+.B httpd 
+[
+.B \-h
+] 
+[
+.B \-l
+] 
+[
+.B \-L
+] 
+[
+.B \-v
+] 
+[
+.B \-V
+] 
+[
+.B \-S
+] 
+[
+.B \-t
+] 
+[
+.B \-T
+]
+
+.SH DESCRIPTION
+.B httpd
+is the Apache HyperText Transfer Protocol (HTTP) server program. It is
+designed to be run as a stand-alone daemon process. When used like this
+it will create a pool of child processes to handle requests. To stop
+it, send a TERM signal to the initial (parent) process. The PID of
+this process is written to a file as given in the configuration file.
+Alternatively 
+.B httpd 
+may be invoked by the Internet daemon inetd(8) each
+time a connection to the HTTP service is made.
+.PP
+This manual page only lists the command line arguments. For details
+of the directives necessary to configure 
+.B httpd
+see the Apache manual,
+which is part of the Apache distribution or can be found at
+http://httpd.apache.org/. Paths in this manual may not reflect those
+compiled into 
+.B httpd.
+.SH OPTIONS
+.TP 12
+.BI \-R " libexecdir"
+This option is only available if Apache was built with
+the 
+.I SHARED_CORE
+rule enabled which forces the Apache core code to be
+placed into a dynamic shared object (DSO) file. This file
+is searched in a hardcoded path under ServerRoot per default. Use this
+option if you want to override it.
+.TP 12
+.BI \-d " serverroot"
+Set the initial value for the ServerRoot directive to \fIserverroot\fP. This
+can be overridden by the ServerRoot command in the configuration file. The
+default is \fB/usr/local/apache\fP.
+.TP
+.BI \-f " config"
+Execute the commands in the file \fIconfig\fP on startup. If \fIconfig\fP
+does not begin with a /, then it is taken to be a path relative to
+the ServerRoot. The default is \fBconf/httpd.conf\fP.
+.TP
+.BI \-C " directive"
+Process the configuration \fIdirective\fP before reading config files.
+.TP
+.BI \-c " directive"
+Process the configuration \fIdirective\fP after reading config files.
+.TP
+.BI \-D " parameter"
+Sets a configuration \fIparameter\fP which can be used with
+<IfDefine>...</IfDefine> sections in the configuration files
+to conditionally skip or process commands.
+.TP
+.B \-h
+Output a short summary of available command line options.
+.TP
+.B \-l
+Output a list of modules compiled into the server.
+.TP
+.B \-L
+Output a list of directives together with expected arguments and
+places where the directive is valid.
+.TP
+.B \-S
+Show the settings as parsed from the config file (currently only shows the
+virtualhost settings).
+.TP
+.B \-t
+Run syntax tests for configuration files only. The program immediately exits
+after these syntax parsing with either a return code of 0 (Syntax OK) or
+return code not equal to 0 (Syntax Error).
+.TP
+.B \-T
+Same as option 
+.B \-t
+but does not check the configured document roots. 
+.TP
+.B \-X
+Run in single-process mode, for internal debugging purposes only; the daemon
+does not detach from the terminal or fork any children. Do NOT use this mode
+to provide ordinary web service.
+.TP
+.B \-v
+Print the version of 
+.B httpd
+, and then exit.
+.TP
+.B \-V
+Print the version and build parameters of 
+.B httpd
+, and then exit.
+.SH FILES
+.PD 0
+.B /usr/local/apache/conf/httpd.conf
+.br
+.B /usr/local/apache/conf/srm.conf
+.br
+.B /usr/local/apache/conf/access.conf
+.br
+.B /usr/local/apache/conf/mime.types
+.br
+.B /usr/local/apache/conf/magic
+.br
+.B /usr/local/apache/logs/error_log
+.br
+.B /usr/local/apache/logs/access_log
+.br
+.B /usr/local/apache/logs/httpd.pid
+.PD
+.SH SEE ALSO
+.BR inetd (8).
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/httpd.exp apache_1.3.33/src/support/httpd.exp
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/httpd.exp	Thu Apr 15 17:51:52 2004
+++ apache_1.3.33/src/support/httpd.exp	Mon Jul 18 15:22:25 2005
@@ -431,3 +431,59 @@
 XML_SetUnparsedEntityDeclHandler
 XML_SetUserData
 XML_UseParserAsHandlerArg
+ap_add_config_define
+ap_make_shared_sub_pool
+ap_global_ctx
+ap_ctx_new
+ap_ctx_get
+ap_ctx_set
+ap_hook_init
+ap_hook_kill
+ap_hook_configure
+ap_hook_register_I
+ap_hook_unregister_I
+ap_hook_status
+ap_hook_use
+ap_hook_call
+ap_mm_useable
+ap_MM_create
+ap_MM_permission
+ap_MM_destroy
+ap_MM_lock
+ap_MM_unlock
+ap_MM_malloc
+ap_MM_realloc
+ap_MM_free
+ap_MM_calloc
+ap_MM_strdup
+ap_MM_sizeof
+ap_MM_maxsize
+ap_MM_available
+ap_MM_error
+ap_mm_create
+ap_mm_permission
+ap_mm_destroy
+ap_mm_lock
+ap_mm_unlock
+ap_mm_malloc
+ap_mm_realloc
+ap_mm_free
+ap_mm_calloc
+ap_mm_strdup
+ap_mm_sizeof
+ap_mm_maxsize
+ap_mm_available
+ap_mm_error
+ap_mm_display_info
+ap_mm_core_create
+ap_mm_core_permission
+ap_mm_core_delete
+ap_mm_core_size
+ap_mm_core_lock
+ap_mm_core_unlock
+ap_mm_core_maxsegsize
+ap_mm_core_align2page
+ap_mm_core_align2word
+ap_mm_lib_error_set
+ap_mm_lib_error_get
+ap_mm_lib_version
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/log_server_status apache_1.3.33/src/support/log_server_status
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/log_server_status	Fri Feb 20 23:02:24 2004
+++ apache_1.3.33/src/support/log_server_status	Mon Jul 18 15:22:19 2005
@@ -1,4 +1,4 @@
-#!/usr/local/bin/perl
+#!/usr/bin/perl
 #
 # Copyright 1999-2004 The Apache Software Foundation
 #
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/phf_abuse_log.cgi apache_1.3.33/src/support/phf_abuse_log.cgi
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/phf_abuse_log.cgi	Fri Feb 20 23:02:24 2004
+++ apache_1.3.33/src/support/phf_abuse_log.cgi	Mon Jul 18 15:22:19 2005
@@ -1,4 +1,4 @@
-#!/usr/local/bin/perl
+#!/usr/bin/perl
 #
 # Copyright 1999-2004 The Apache Software Foundation
 #
@@ -22,7 +22,7 @@
 #
 # The format logged to is "[date] remote_addr remote_host [date] referrer user_agent".
 
-$LOG = "/var/log/phf_log";
+$LOG = "/var/log/phf.log";
 
 require "ctime.pl";
 $when = &ctime(time);
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/phf_abuse_log.cgi.orig apache_1.3.33/src/support/phf_abuse_log.cgi.orig
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/phf_abuse_log.cgi.orig	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/support/phf_abuse_log.cgi.orig	Fri Feb 20 23:02:24 2004
@@ -0,0 +1,36 @@
+#!/usr/local/bin/perl
+#
+# Copyright 1999-2004 The Apache Software Foundation
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
+#
+# This script can be used to detect people trying to abuse the security hole which
+# existed in A CGI script direstributed with Apache 1.0.3 and earlier versions.
+# You can redirect them to here using the "<Location /cgi-bin/phf*>" suggestion in
+# httpd.conf.  
+#
+# The format logged to is "[date] remote_addr remote_host [date] referrer user_agent".
+
+$LOG = "/var/log/phf_log";
+
+require "ctime.pl";
+$when = &ctime(time);
+$when =~ s/\n//go;
+$ENV{HTTP_USER_AGENT} .= " via $ENV{HTTP_VIA}" if($ENV{HTTP_VIA});
+
+open(LOG, ">>$LOG") || die "boo hoo, phf_log $!";
+print LOG "[$when] $ENV{REMOTE_ADDR} $ENV{REMOTE_HOST} $ENV{$HTTP_REFERER} $ENV{HTTP_USER_AGENT}\n";
+close(LOG);
+
+print "Content-type: text/html\r\n\r\n<BLINK>Smile, you're on Candid Camera.</BLINK>\n";
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/suexec.c apache_1.3.33/src/support/suexec.c
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/suexec.c	Fri Feb 20 23:02:24 2004
+++ apache_1.3.33/src/support/suexec.c	Mon Jul 18 15:22:19 2005
@@ -47,6 +47,11 @@
 #include <sys/types.h>
 
 #include <stdarg.h>
+#include <strings.h>
+
+/* for fcntl(fileno(log), F_SETFD, FD_CLOEXEC); */
+#include <unistd.h>
+#include <fcntl.h>
 
 #include "suexec.h"
 
@@ -131,6 +136,9 @@
     "UNIQUE_ID=",
     "USER_NAME=",
     "TZ=",
+    "HTTPS=",
+    "REDIRECT_HTTPS=",
+    "SSL=",
     NULL
 };
 
@@ -147,6 +155,8 @@
 	    perror("fopen");
 	    exit(1);
 	}
+	/* Set the close-on-exec flag -- Liyang HU <liyang@nerv.cx> */
+	fcntl(fileno(log), F_SETFD, FD_CLOEXEC);
     }
 
     time(&timevar);
@@ -219,6 +229,244 @@
     environ = cleanenv;
 }
 
+#define MY_STATE_NORMAL 0
+#define MY_STATE_SPACE 1
+#define MY_STATE_QUOTES 2
+#define MY_STATE_APOSTROPHES 3
+#define MY_STATE_END 4
+
+char** param_separate(char* params, int addl_slots) {
+    int state, actpos, actarg_start, actarg_len, argnum;
+    char **res=0;
+    char backslash=0;
+    
+    if (params==0) return(0);
+    
+    if (*params==0) {
+       res=(char**)malloc(sizeof(char*)*(1+addl_slots));
+       for (actpos=0;actpos<addl_slots+1;++actpos) res[actpos]=0;
+       return(res);
+    }
+    actpos=0;backslash=0;argnum=0;state=MY_STATE_SPACE;
+    while (state!=MY_STATE_END) {
+       switch (state) {
+       
+          case MY_STATE_SPACE: 
+              switch (params[actpos]) {
+                 case 0 : 
+                          state=MY_STATE_END;
+                          break;
+                          
+                 case ' ' :
+                 case '\t':
+                          break;              
+       
+                 case '\'':
+                          state=MY_STATE_APOSTROPHES;
+                          actarg_start=actpos+1;
+                          break;
+                 case '"':
+                          state=MY_STATE_QUOTES;
+                          actarg_start=actpos+1;
+                          break;
+                 default: 
+                          state=MY_STATE_NORMAL;
+                          actarg_start=actpos;
+              }
+              break;
+                          
+          case MY_STATE_NORMAL:
+              
+              switch (params[actpos]) {
+                 case 0 : 
+                          state=MY_STATE_END;
+                          ++argnum;
+                          actarg_len=actpos-actarg_start;
+                          break;
+                          
+                 case ' ':
+                 case '\t':
+                          state=MY_STATE_SPACE;
+                          ++argnum;
+                          actarg_len=actpos-actarg_start;
+                          break; 
+              }
+              break;
+
+          case MY_STATE_APOSTROPHES:
+              
+              switch (params[actpos]) {
+                 case 0 : 
+                          state=MY_STATE_END;
+                          ++argnum;
+                          actarg_len=actpos-actarg_start;
+                          break;
+                 
+                 case '\\':
+                          backslash=1-backslash;        
+                          break;        
+                          
+                 case '\'':
+                          if (! backslash) {
+                             state=MY_STATE_SPACE;
+                             ++argnum;
+                             actarg_len=actpos-actarg_start;
+                          }
+                          break; 
+              }
+              if (params[actpos]!='\\') backslash=0;
+              break;
+          
+          case MY_STATE_QUOTES:
+              
+              switch (params[actpos]) {
+                 case 0 : 
+                          state=MY_STATE_END;
+                          ++argnum;
+                          actarg_len=actpos-actarg_start;
+                          break;
+                 
+                 case '\\':
+                          backslash=1-backslash;        
+                          break;        
+                          
+                 case '"':
+                          if (! backslash) {
+                             state=MY_STATE_SPACE;
+                             ++argnum;
+                             actarg_len=actpos-actarg_start;
+                          }
+                          break; 
+              }
+              if (params[actpos]!='\\') backslash=0;
+              break;
+       }
+       actpos++;
+    }
+    
+    res=(char**)malloc(sizeof(char*)*(argnum+1+addl_slots));
+    for (actpos=0;actpos<argnum+addl_slots+1;++actpos) res[actpos]=0;
+    
+
+    actpos=0;backslash=0;argnum=0;state=MY_STATE_SPACE;
+    while (state!=MY_STATE_END) {
+       switch (state) {
+       
+          case MY_STATE_SPACE: 
+              switch (params[actpos]) {
+                 case 0 : 
+                          state=MY_STATE_END;
+                          break;
+                          
+                 case ' ' :
+                 case '\t':
+                          break;              
+       
+                 case '\'':
+                          state=MY_STATE_APOSTROPHES;
+                          actarg_start=actpos+1;
+                          break;
+                 case '"':
+                          state=MY_STATE_QUOTES;
+                          actarg_start=actpos+1;
+                          break;
+                 default: 
+                          state=MY_STATE_NORMAL;
+                          actarg_start=actpos;
+              }
+              break;
+                          
+          case MY_STATE_NORMAL:
+              
+              switch (params[actpos]) {
+                 case 0 : 
+                          state=MY_STATE_END;
+                          actarg_len=actpos-actarg_start;
+                          res[argnum]=(char*)malloc(actarg_len+1);
+                          strncpy(res[argnum],&params[actarg_start],actarg_len);
+                          res[argnum][actarg_len]=0;
+                          ++argnum;
+                          break;
+                          
+                 case ' ':
+                 case '\t':
+                          state=MY_STATE_SPACE;
+                          actarg_len=actpos-actarg_start;
+                          res[argnum]=(char*)malloc(actarg_len+1);
+                          strncpy(res[argnum],&params[actarg_start],actarg_len);
+                          res[argnum][actarg_len]=0;
+                          ++argnum;
+                          break; 
+              }
+              break;
+
+          case MY_STATE_APOSTROPHES:
+              
+              switch (params[actpos]) {
+                 case 0 : 
+                          state=MY_STATE_END;
+                          actarg_len=actpos-actarg_start;
+                          res[argnum]=(char*)malloc(actarg_len+1);
+                          strncpy(res[argnum],&params[actarg_start],actarg_len);
+                          res[argnum][actarg_len]=0;
+                          ++argnum;
+                          break;
+                 
+                 case '\\':
+                          backslash=1-backslash;        
+                          break;        
+                          
+                 case '\'':
+                          if (! backslash) {
+                             state=MY_STATE_SPACE;
+                             actarg_len=actpos-actarg_start;
+                             res[argnum]=(char*)malloc(actarg_len+1);
+                             strncpy(res[argnum],&params[actarg_start],actarg_len);
+                             res[argnum][actarg_len]=0;
+                             ++argnum;
+                          }
+                          break; 
+              }
+              if (params[actpos]!='\\') backslash=0;
+              break;
+          
+          case MY_STATE_QUOTES:
+              
+              switch (params[actpos]) {
+                 case 0 : 
+                          state=MY_STATE_END;
+                          actarg_len=actpos-actarg_start;
+                          res[argnum]=(char*)malloc(actarg_len+1);
+                          strncpy(res[argnum],&params[actarg_start],actarg_len);
+                          res[argnum][actarg_len]=0;
+                          ++argnum;
+                          break;
+                 
+                 case '\\':
+                          backslash=1-backslash;        
+                          break;        
+                          
+                 case '"':
+                          if (! backslash) {
+                             state=MY_STATE_SPACE;
+                             actarg_len=actpos-actarg_start;
+                             res[argnum]=(char*)malloc(actarg_len+1);
+                             strncpy(res[argnum],&params[actarg_start],actarg_len);
+                             res[argnum][actarg_len]=0;
+                             ++argnum;
+                          }
+                          break; 
+              }
+              if (params[actpos]!='\\') backslash=0;
+              break;
+       }
+       actpos++;
+    }
+
+    return(res);
+}    
+
+
 int main(int argc, char *argv[])
 {
     int userdir = 0;		/* ~userdir flag             */
@@ -231,6 +479,10 @@
     char *actual_gname;		/* actual group name         */
     char *prog;			/* name of this program      */
     char *cmd;			/* command to be executed    */
+
+    int ind, ind2;    
+    char **passedargv = 0;
+    
     char cwd[AP_MAXPATH];	/* current working directory */
     char dwd[AP_MAXPATH];	/* docroot working directory */
     struct passwd *pw;		/* password entry holder     */
@@ -510,8 +762,18 @@
     /*
      * Error out if we cannot stat the program.
      */
-    if (((lstat(cmd, &prg_info)) != 0) || (S_ISLNK(prg_info.st_mode))) {
-	log_err("error: cannot stat program: (%s)\n", cmd);
+    passedargv=param_separate(cmd,argc-4);
+    for (ind=0; passedargv[ind]; ++ind);
+    for (ind2=4;ind2<argc;++ind2,++ind) {
+        if (argv[ind2]!=0) if (argv[ind2][0]!=0) passedargv[ind]=strdup(argv[ind2]);
+        if (passedargv[ind]==0) {
+            passedargv[ind]=malloc(1);
+            passedargv[ind][0]=0;
+        }
+    }
+    
+    if (((lstat(passedargv[0], &prg_info)) != 0) || (S_ISLNK(prg_info.st_mode))) {
+	log_err("error: cannot stat program: (%s)\n", passedargv[0]);
 	exit(117);
     }
 
@@ -519,7 +781,7 @@
      * Error out if the program is writable by others.
      */
     if ((prg_info.st_mode & S_IWOTH) || (prg_info.st_mode & S_IWGRP)) {
-	log_err("error: file is writable by others: (%s/%s)\n", cwd, cmd);
+	log_err("error: file is writable by others: (%s/%s)\n", cwd, passedargv[0]);
 	exit(118);
     }
 
@@ -527,7 +789,7 @@
      * Error out if the file is setuid or setgid.
      */
     if ((prg_info.st_mode & S_ISUID) || (prg_info.st_mode & S_ISGID)) {
-	log_err("error: file is either setuid or setgid: (%s/%s)\n", cwd, cmd);
+	log_err("error: file is either setuid or setgid: (%s/%s)\n", cwd, passedargv[0]);
 	exit(119);
     }
 
@@ -552,7 +814,7 @@
      * "[error] Premature end of script headers: ..."
      */
     if (!(prg_info.st_mode & S_IXUSR)) {
-	log_err("error: file has no execute permission: (%s/%s)\n", cwd, cmd);
+	log_err("error: file has no execute permission: (%s/%s)\n", cwd, passedargv[0]);
 	exit(121);
     }
 
@@ -567,23 +829,11 @@
     umask(SUEXEC_UMASK);
 #endif /* SUEXEC_UMASK */
 
-    /* 
-     * Be sure to close the log file so the CGI can't
-     * mess with it.  If the exec fails, it will be reopened 
-     * automatically when log_err is called.  Note that the log
-     * might not actually be open if LOG_EXEC isn't defined.
-     * However, the "log" cell isn't ifdef'd so let's be defensive
-     * and assume someone might have done something with it
-     * outside an ifdef'd LOG_EXEC block.
-     */
-    if (log != NULL) {
-	fclose(log);
-	log = NULL;
-    }
-
     /*
      * Execute the command, replacing our image with its own.
      */
+    execv(passedargv[0], passedargv);
+#if 0
 #ifdef NEED_HASHBANG_EMUL
     /* We need the #! emulation when we want to execute scripts */
     {
@@ -594,7 +844,7 @@
 #else /*NEED_HASHBANG_EMUL*/
     execv(cmd, &argv[3]);
 #endif /*NEED_HASHBANG_EMUL*/
-
+#endif
     /*
      * (I can't help myself...sorry.)
      *
@@ -604,5 +854,10 @@
      * Oh well, log the failure and error out.
      */
     log_err("emerg: (%d)%s: exec failed (%s)\n", errno, strerror(errno), cmd);
+
+    for (ind=0;passedargv[ind];++ind) free(passedargv[ind]);
+    free(passedargv);
+    passedargv=0;
+
     exit(255);
 }
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/suexec.c.orig apache_1.3.33/src/support/suexec.c.orig
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/suexec.c.orig	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/support/suexec.c.orig	Fri Feb 20 23:02:24 2004
@@ -0,0 +1,608 @@
+/* Copyright 1999-2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * suexec.c -- "Wrapper" support program for suEXEC behaviour for Apache
+ *
+ ***********************************************************************
+ *
+ * NOTE! : DO NOT edit this code!!!  Unless you know what you are doing,
+ *         editing this code might open up your system in unexpected 
+ *         ways to would-be crackers.  Every precaution has been taken 
+ *         to make this code as safe as possible; alter it at your own
+ *         risk.
+ *
+ ***********************************************************************
+ *
+ *
+ * Error messages in the suexec logfile are prefixed with severity values
+ * similar to those used by the main server:
+ *
+ *  Sev     Meaning
+ * emerg:  Failure of some basic system function
+ * alert:  Bug in the way Apache is communicating with suexec
+ * crit:   Basic information is missing, invalid, or incorrect
+ * error:  Script permission/configuration error
+ * warn:   
+ * notice: Some issue of which the sysadmin/webmaster ought to be aware
+ * info:   Normal activity message
+ * debug:  Self-explanatory
+ */
+
+#include "ap_config.h"
+#include <sys/param.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+
+#include <stdarg.h>
+
+#include "suexec.h"
+
+/*
+ ***********************************************************************
+ * There is no initgroups() in QNX, so I believe this is safe :-)
+ * Use cc -osuexec -3 -O -mf -DQNX suexec.c to compile.
+ *
+ * May 17, 1997.
+ * Igor N. Kovalenko -- infoh@mail.wplus.net
+ ***********************************************************************
+ */
+
+#if defined(NEED_INITGROUPS)
+int initgroups(const char *name, gid_t basegid)
+{
+/* QNX and MPE do not appear to support supplementary groups. */
+    return 0;
+}
+#endif
+
+#if defined(NEED_STRERROR)
+extern char *sys_errlist[];
+#define strerror(x) sys_errlist[(x)]
+#endif
+
+#if defined(PATH_MAX)
+#define AP_MAXPATH PATH_MAX
+#elif defined(MAXPATHLEN)
+#define AP_MAXPATH MAXPATHLEN
+#else
+#define AP_MAXPATH 8192
+#endif
+
+#define AP_ENVBUF 256
+
+extern char **environ;
+static FILE *log = NULL;
+
+char *safe_env_lst[] =
+{
+    /* variable name starts with */
+    "HTTP_",
+
+    /* variable name is */
+    "AUTH_TYPE=",
+    "CONTENT_LENGTH=",
+    "CONTENT_TYPE=",
+    "DATE_GMT=",
+    "DATE_LOCAL=",
+    "DOCUMENT_NAME=",
+    "DOCUMENT_PATH_INFO=",
+    "DOCUMENT_ROOT=",
+    "DOCUMENT_URI=",
+    "FILEPATH_INFO=",
+    "GATEWAY_INTERFACE=",
+    "LAST_MODIFIED=",
+    "PATH_INFO=",
+    "PATH_TRANSLATED=",
+    "QUERY_STRING=",
+    "QUERY_STRING_UNESCAPED=",
+    "REMOTE_ADDR=",
+    "REMOTE_HOST=",
+    "REMOTE_IDENT=",
+    "REMOTE_PORT=",
+    "REMOTE_USER=",
+    "REDIRECT_QUERY_STRING=",
+    "REDIRECT_STATUS=",
+    "REDIRECT_URL=",
+    "REQUEST_METHOD=",
+    "REQUEST_URI=",
+    "SCRIPT_FILENAME=",
+    "SCRIPT_NAME=",
+    "SCRIPT_URI=",
+    "SCRIPT_URL=",
+    "SERVER_ADMIN=",
+    "SERVER_NAME=",
+    "SERVER_ADDR=",
+    "SERVER_PORT=",
+    "SERVER_PROTOCOL=",
+    "SERVER_SOFTWARE=",
+    "UNIQUE_ID=",
+    "USER_NAME=",
+    "TZ=",
+    NULL
+};
+
+
+static void err_output(const char *fmt, va_list ap)
+{
+#ifdef LOG_EXEC
+    time_t timevar;
+    struct tm *lt;
+
+    if (!log) {
+	if ((log = fopen(LOG_EXEC, "a")) == NULL) {
+	    fprintf(stderr, "failed to open log file\n");
+	    perror("fopen");
+	    exit(1);
+	}
+    }
+
+    time(&timevar);
+    lt = localtime(&timevar);
+
+    fprintf(log, "[%d-%.2d-%.2d %.2d:%.2d:%.2d]: ",
+	    lt->tm_year + 1900, lt->tm_mon + 1, lt->tm_mday,
+	    lt->tm_hour, lt->tm_min, lt->tm_sec);
+
+    vfprintf(log, fmt, ap);
+
+    fflush(log);
+#endif /* LOG_EXEC */
+    return;
+}
+
+static void log_err(const char *fmt,...)
+{
+#ifdef LOG_EXEC
+    va_list ap;
+
+    va_start(ap, fmt);
+    err_output(fmt, ap);
+    va_end(ap);
+#endif /* LOG_EXEC */
+    return;
+}
+
+static void clean_env(void)
+{
+    char pathbuf[512];
+    char **cleanenv;
+    char **ep;
+    int cidx = 0;
+    int idx;
+
+    /* While cleaning the environment, the environment should be clean.
+     * (e.g. malloc() may get the name of a file for writing debugging info.
+     * Bad news if MALLOC_DEBUG_FILE is set to /etc/passwd.  Sprintf() may be
+     * susceptible to bad locale settings....)
+     * (from PR 2790)
+     */
+    char **envp = environ;
+    char *empty_ptr = NULL;
+
+    environ = &empty_ptr; /* VERY safe environment */
+
+    if ((cleanenv = (char **) calloc(AP_ENVBUF, sizeof(char *))) == NULL) {
+        log_err("emerg: failed to malloc memory for environment\n");
+	exit(120);
+    }
+
+    sprintf(pathbuf, "PATH=%s", SAFE_PATH);
+    cleanenv[cidx] = strdup(pathbuf);
+    cidx++;
+
+    for (ep = envp; *ep && cidx < AP_ENVBUF-1; ep++) {
+        for (idx = 0; safe_env_lst[idx]; idx++) {
+            if (!strncmp(*ep, safe_env_lst[idx],
+                         strlen(safe_env_lst[idx]))) {
+		cleanenv[cidx] = *ep;
+		cidx++;
+                break;
+            }
+        }
+    }
+
+    cleanenv[cidx] = NULL;
+
+    environ = cleanenv;
+}
+
+int main(int argc, char *argv[])
+{
+    int userdir = 0;		/* ~userdir flag             */
+    uid_t uid;			/* user information          */
+    gid_t gid;			/* target group placeholder  */
+    char *target_uname;		/* target user name          */
+    char *target_gname;		/* target group name         */
+    char *target_homedir;	/* target home directory     */
+    char *actual_uname;		/* actual user name          */
+    char *actual_gname;		/* actual group name         */
+    char *prog;			/* name of this program      */
+    char *cmd;			/* command to be executed    */
+    char cwd[AP_MAXPATH];	/* current working directory */
+    char dwd[AP_MAXPATH];	/* docroot working directory */
+    struct passwd *pw;		/* password entry holder     */
+    struct group *gr;		/* group entry holder        */
+    struct stat dir_info;	/* directory info holder     */
+    struct stat prg_info;	/* program info holder       */
+
+    /*
+     * Start with a "clean" environment
+     */
+    clean_env();
+
+    prog = argv[0];
+    /*
+     * Check existence/validity of the UID of the user
+     * running this program.  Error out if invalid.
+     */
+    uid = getuid();
+    if ((pw = getpwuid(uid)) == NULL) {
+	log_err("crit: invalid uid: (%ld)\n", uid);
+	exit(102);
+    }
+    /*
+     * See if this is a 'how were you compiled' request, and
+     * comply if so.
+     */
+    if ((argc > 1)
+        && (! strcmp(argv[1], "-V"))
+        && ((uid == 0)
+#ifdef _OSD_POSIX
+        /* User name comparisons are case insensitive on BS2000/OSD */
+            || (! strcasecmp(HTTPD_USER, pw->pw_name)))
+#else  /* _OSD_POSIX */
+            || (! strcmp(HTTPD_USER, pw->pw_name)))
+#endif /* _OSD_POSIX */
+        ) {
+#ifdef DOC_ROOT
+        fprintf(stderr, " -D DOC_ROOT=\"%s\"\n", DOC_ROOT);
+#endif
+#ifdef GID_MIN
+        fprintf(stderr, " -D GID_MIN=%d\n", GID_MIN);
+#endif
+#ifdef HTTPD_USER
+        fprintf(stderr, " -D HTTPD_USER=\"%s\"\n", HTTPD_USER);
+#endif
+#ifdef LOG_EXEC
+        fprintf(stderr, " -D LOG_EXEC=\"%s\"\n", LOG_EXEC);
+#endif
+#ifdef SAFE_PATH
+        fprintf(stderr, " -D SAFE_PATH=\"%s\"\n", SAFE_PATH);
+#endif
+#ifdef SUEXEC_UMASK
+        fprintf(stderr, " -D SUEXEC_UMASK=%03o\n", SUEXEC_UMASK);
+#endif
+#ifdef UID_MIN
+        fprintf(stderr, " -D UID_MIN=%d\n", UID_MIN);
+#endif
+#ifdef USERDIR_SUFFIX
+        fprintf(stderr, " -D USERDIR_SUFFIX=\"%s\"\n", USERDIR_SUFFIX);
+#endif
+        exit(0);
+    }
+    /*
+     * If there are a proper number of arguments, set
+     * all of them to variables.  Otherwise, error out.
+     */
+    if (argc < 4) {
+	log_err("alert: too few arguments\n");
+	exit(101);
+    }
+    target_uname = argv[1];
+    target_gname = argv[2];
+    cmd = argv[3];
+
+    /*
+     * Check to see if the user running this program
+     * is the user allowed to do so as defined in
+     * suexec.h.  If not the allowed user, error out.
+     */
+#ifdef _OSD_POSIX
+    /* User name comparisons are case insensitive on BS2000/OSD */
+    if (strcasecmp(HTTPD_USER, pw->pw_name)) {
+        log_err("crit: calling user mismatch (%s instead of %s)\n",
+		pw->pw_name, HTTPD_USER);
+	exit(103);
+    }
+#else  /* _OSD_POSIX */
+    if (strcmp(HTTPD_USER, pw->pw_name)) {
+        log_err("crit: calling user mismatch (%s instead of %s)\n",
+		pw->pw_name, HTTPD_USER);
+	exit(103);
+    }
+#endif /* _OSD_POSIX */
+
+    /*
+     * Check for a leading '/' (absolute path) in the command to be executed,
+     * or attempts to back up out of the current directory,
+     * to protect against attacks.  If any are
+     * found, error out.  Naughty naughty crackers.
+     */
+    if ((cmd[0] == '/') || (!strncmp(cmd, "../", 3))
+	|| (strstr(cmd, "/../") != NULL)) {
+        log_err("error: invalid command (%s)\n", cmd);
+	exit(104);
+    }
+
+    /*
+     * Check to see if this is a ~userdir request.  If
+     * so, set the flag, and remove the '~' from the
+     * target username.
+     */
+    if (!strncmp("~", target_uname, 1)) {
+	target_uname++;
+	userdir = 1;
+    }
+
+    /*
+     * Error out if the target username is invalid.
+     */
+    if ((pw = getpwnam(target_uname)) == NULL) {
+	log_err("crit: invalid target user name: (%s)\n", target_uname);
+	exit(105);
+    }
+
+    /*
+     * Error out if the target group name is invalid.
+     */
+    if (strspn(target_gname, "1234567890") != strlen(target_gname)) {
+	if ((gr = getgrnam(target_gname)) == NULL) {
+	    log_err("crit: invalid target group name: (%s)\n", target_gname);
+	    exit(106);
+	}
+	gid = gr->gr_gid;
+	actual_gname = strdup(gr->gr_name);
+    }
+    else {
+	gid = atoi(target_gname);
+	actual_gname = strdup(target_gname);
+    }
+
+#ifdef _OSD_POSIX
+    /*
+     * Initialize BS2000 user environment
+     */
+    {
+	pid_t pid, reaped;
+	int status;
+
+	switch (pid = ufork(target_uname))
+	{
+	case -1:	/* Error */
+	    log_err("emerg: failed to setup bs2000 environment for user "
+		    "%s: %s\n",
+		    target_uname, strerror(errno));
+	    exit(150);
+	case 0:	/* Child */
+	    break;
+	default:	/* Father */
+	    while (pid != (reaped = waitpid(pid, &status, 0))
+		   && (reaped != -1 || errno != ECHILD))
+		;
+	    /* @@@ FIXME: should we deal with STOP signals as well? */
+	    if (WIFSIGNALED(status)) {
+		kill (getpid(), WTERMSIG(status));
+	    }
+	    exit(WEXITSTATUS(status));
+	}
+    }
+#endif /* _OSD_POSIX */
+
+    /*
+     * Save these for later since initgroups will hose the struct
+     */
+    uid = pw->pw_uid;
+    actual_uname = strdup(pw->pw_name);
+    target_homedir = strdup(pw->pw_dir);
+
+    /*
+     * Log the transaction here to be sure we have an open log 
+     * before we setuid().
+     */
+    log_err("info: (target/actual) uid: (%s/%s) gid: (%s/%s) cmd: %s\n",
+	    target_uname, actual_uname,
+	    target_gname, actual_gname,
+	    cmd);
+
+    /*
+     * Error out if attempt is made to execute as root or as
+     * a UID less than UID_MIN.  Tsk tsk.
+     */
+    if ((uid == 0) || (uid < UID_MIN)) {
+	log_err("crit: cannot run as forbidden uid (%d/%s)\n", uid, cmd);
+	exit(107);
+    }
+
+    /*
+     * Error out if attempt is made to execute as root group
+     * or as a GID less than GID_MIN.  Tsk tsk.
+     */
+    if ((gid == 0) || (gid < GID_MIN)) {
+	log_err("crit: cannot run as forbidden gid (%d/%s)\n", gid, cmd);
+	exit(108);
+    }
+
+    /*
+     * Change UID/GID here so that the following tests work over NFS.
+     *
+     * Initialize the group access list for the target user,
+     * and setgid() to the target group. If unsuccessful, error out.
+     */
+    if (((setgid(gid)) != 0) || (initgroups(actual_uname, gid) != 0)) {
+	log_err("emerg: failed to setgid (%ld: %s)\n", gid, cmd);
+	exit(109);
+    }
+
+    /*
+     * setuid() to the target user.  Error out on fail.
+     */
+    if ((setuid(uid)) != 0) {
+	log_err("emerg: failed to setuid (%ld: %s)\n", uid, cmd);
+	exit(110);
+    }
+
+    /*
+     * Get the current working directory, as well as the proper
+     * document root (dependant upon whether or not it is a
+     * ~userdir request).  Error out if we cannot get either one,
+     * or if the current working directory is not in the docroot.
+     * Use chdir()s and getcwd()s to avoid problems with symlinked
+     * directories.  Yuck.
+     */
+    if (getcwd(cwd, AP_MAXPATH) == NULL) {
+	log_err("emerg: cannot get current working directory\n");
+	exit(111);
+    }
+
+    if (userdir) {
+	if (((chdir(target_homedir)) != 0) ||
+	    ((chdir(USERDIR_SUFFIX)) != 0) ||
+	    ((getcwd(dwd, AP_MAXPATH)) == NULL) ||
+	    ((chdir(cwd)) != 0)) {
+	    log_err("emerg: cannot get docroot information (%s)\n",
+		    target_homedir);
+	    exit(112);
+	}
+    }
+    else {
+	if (((chdir(DOC_ROOT)) != 0) ||
+	    ((getcwd(dwd, AP_MAXPATH)) == NULL) ||
+	    ((chdir(cwd)) != 0)) {
+	    log_err("emerg: cannot get docroot information (%s)\n", DOC_ROOT);
+	    exit(113);
+	}
+    }
+
+    if ((strncmp(cwd, dwd, strlen(dwd))) != 0) {
+	log_err("error: command not in docroot (%s/%s)\n", cwd, cmd);
+	exit(114);
+    }
+
+    /*
+     * Stat the cwd and verify it is a directory, or error out.
+     */
+    if (((lstat(cwd, &dir_info)) != 0) || !(S_ISDIR(dir_info.st_mode))) {
+	log_err("error: cannot stat directory: (%s)\n", cwd);
+	exit(115);
+    }
+
+    /*
+     * Error out if cwd is writable by others.
+     */
+    if ((dir_info.st_mode & S_IWOTH) || (dir_info.st_mode & S_IWGRP)) {
+	log_err("error: directory is writable by others: (%s)\n", cwd);
+	exit(116);
+    }
+
+    /*
+     * Error out if we cannot stat the program.
+     */
+    if (((lstat(cmd, &prg_info)) != 0) || (S_ISLNK(prg_info.st_mode))) {
+	log_err("error: cannot stat program: (%s)\n", cmd);
+	exit(117);
+    }
+
+    /*
+     * Error out if the program is writable by others.
+     */
+    if ((prg_info.st_mode & S_IWOTH) || (prg_info.st_mode & S_IWGRP)) {
+	log_err("error: file is writable by others: (%s/%s)\n", cwd, cmd);
+	exit(118);
+    }
+
+    /*
+     * Error out if the file is setuid or setgid.
+     */
+    if ((prg_info.st_mode & S_ISUID) || (prg_info.st_mode & S_ISGID)) {
+	log_err("error: file is either setuid or setgid: (%s/%s)\n", cwd, cmd);
+	exit(119);
+    }
+
+    /*
+     * Error out if the target name/group is different from
+     * the name/group of the cwd or the program.
+     */
+    if ((uid != dir_info.st_uid) ||
+	(gid != dir_info.st_gid) ||
+	(uid != prg_info.st_uid) ||
+	(gid != prg_info.st_gid)) {
+	log_err("error: target uid/gid (%ld/%ld) mismatch "
+		"with directory (%ld/%ld) or program (%ld/%ld)\n",
+		uid, gid,
+		dir_info.st_uid, dir_info.st_gid,
+		prg_info.st_uid, prg_info.st_gid);
+	exit(120);
+    }
+    /*
+     * Error out if the program is not executable for the user.
+     * Otherwise, she won't find any error in the logs except for
+     * "[error] Premature end of script headers: ..."
+     */
+    if (!(prg_info.st_mode & S_IXUSR)) {
+	log_err("error: file has no execute permission: (%s/%s)\n", cwd, cmd);
+	exit(121);
+    }
+
+#ifdef SUEXEC_UMASK
+    /*
+     * umask() uses inverse logic; bits are CLEAR for allowed access.
+     */
+    if ((~SUEXEC_UMASK) & 0022) {
+	log_err("notice: SUEXEC_UMASK of %03o allows "
+		"write permission to group and/or other\n", SUEXEC_UMASK);
+    }
+    umask(SUEXEC_UMASK);
+#endif /* SUEXEC_UMASK */
+
+    /* 
+     * Be sure to close the log file so the CGI can't
+     * mess with it.  If the exec fails, it will be reopened 
+     * automatically when log_err is called.  Note that the log
+     * might not actually be open if LOG_EXEC isn't defined.
+     * However, the "log" cell isn't ifdef'd so let's be defensive
+     * and assume someone might have done something with it
+     * outside an ifdef'd LOG_EXEC block.
+     */
+    if (log != NULL) {
+	fclose(log);
+	log = NULL;
+    }
+
+    /*
+     * Execute the command, replacing our image with its own.
+     */
+#ifdef NEED_HASHBANG_EMUL
+    /* We need the #! emulation when we want to execute scripts */
+    {
+	extern char **environ;
+
+	ap_execve(cmd, &argv[3], environ);
+    }
+#else /*NEED_HASHBANG_EMUL*/
+    execv(cmd, &argv[3]);
+#endif /*NEED_HASHBANG_EMUL*/
+
+    /*
+     * (I can't help myself...sorry.)
+     *
+     * Uh oh.  Still here.  Where's the kaboom?  There was supposed to be an
+     * EARTH-shattering kaboom!
+     *
+     * Oh well, log the failure and error out.
+     */
+    log_err("emerg: (%d)%s: exec failed (%s)\n", errno, strerror(errno), cmd);
+    exit(255);
+}
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/suexec.h apache_1.3.33/src/support/suexec.h
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/suexec.h	Fri Feb 20 23:02:24 2004
+++ apache_1.3.33/src/support/suexec.h	Mon Jul 18 15:22:19 2005
@@ -36,7 +36,7 @@
  *            for suEXEC.  For most systems, 500 or 100 is common.
  */
 #ifndef UID_MIN
-#define UID_MIN 100
+#define UID_MIN 1000
 #endif
 
 /*
diff -Naur /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/suexec.h.orig apache_1.3.33/src/support/suexec.h.orig
--- /tmp/apache-1.3.33/upstream/tarballs/apache_1.3.33/src/support/suexec.h.orig	Thu Jan  1 01:00:00 1970
+++ apache_1.3.33/src/support/suexec.h.orig	Fri Feb 20 23:02:24 2004
@@ -0,0 +1,101 @@
+/* Copyright 1999-2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * suexec.h -- user-definable variables for the suexec wrapper code.
+ *             (See README.configure on how to customize these variables.)
+ */
+
+
+#ifndef _SUEXEC_H
+#define _SUEXEC_H
+
+/*
+ * HTTPD_USER -- Define as the username under which Apache normally
+ *               runs.  This is the only user allowed to execute
+ *               this program.
+ */
+#ifndef HTTPD_USER
+#define HTTPD_USER "www"
+#endif
+
+/*
+ * UID_MIN -- Define this as the lowest UID allowed to be a target user
+ *            for suEXEC.  For most systems, 500 or 100 is common.
+ */
+#ifndef UID_MIN
+#define UID_MIN 100
+#endif
+
+/*
+ * GID_MIN -- Define this as the lowest GID allowed to be a target group
+ *            for suEXEC.  For most systems, 100 is common.
+ */
+#ifndef GID_MIN
+#define GID_MIN 100
+#endif
+
+/*
+ * USERDIR_SUFFIX -- Define to be the subdirectory under users' 
+ *                   home directories where suEXEC access should
+ *                   be allowed.  All executables under this directory
+ *                   will be executable by suEXEC as the user so 
+ *                   they should be "safe" programs.  If you are 
+ *                   using a "simple" UserDir directive (ie. one 
+ *                   without a "*" in it) this should be set to 
+ *                   the same value.  suEXEC will not work properly
+ *                   in cases where the UserDir directive points to 
+ *                   a location that is not the same as the user's
+ *                   home directory as referenced in the passwd file.
+ *
+ *                   If you have VirtualHosts with a different
+ *                   UserDir for each, you will need to define them to
+ *                   all reside in one parent directory; then name that
+ *                   parent directory here.  IF THIS IS NOT DEFINED
+ *                   PROPERLY, ~USERDIR CGI REQUESTS WILL NOT WORK!
+ *                   See the suEXEC documentation for more detailed
+ *                   information.
+ */
+#ifndef USERDIR_SUFFIX
+#define USERDIR_SUFFIX "public_html"
+#endif
+
+/*
+ * LOG_EXEC -- Define this as a filename if you want all suEXEC
+ *             transactions and errors logged for auditing and
+ *             debugging purposes.
+ */
+#ifndef LOG_EXEC
+#define LOG_EXEC "/usr/local/apache/logs/cgi.log"	/* Need me? */
+#endif
+
+/*
+ * DOC_ROOT -- Define as the DocumentRoot set for Apache.  This
+ *             will be the only hierarchy (aside from UserDirs)
+ *             that can be used for suEXEC behavior.
+ */
+#ifndef DOC_ROOT
+#define DOC_ROOT "/usr/local/apache/htdocs"
+#endif
+
+/*
+ * SAFE_PATH -- Define a safe PATH environment to pass to CGI executables.
+ *
+ */
+#ifndef SAFE_PATH
+#define SAFE_PATH "/usr/local/bin:/usr/bin:/bin"
+#endif
+
+#endif /* _SUEXEC_H */
